From ae117ec080e7f484a26349d7c8b8deffe6d156d7 Mon Sep 17 00:00:00 2001
From: Hung Tran <hung.tran.jy@renesas.com>
Date: Wed, 15 Aug 2018 18:38:53 +0700
Subject: [PATCH] waylandsink: Support Wayland KMS to improve performance

This commit adds support for wayland-kms.
With this update, if wayland-kms is available,
waylandsink will always use it instead of SHM.
Note that dmabuf mode is unaffected.

By creating buffers from wayland-kms, wayland
buffers are ensured to be contiguous and thus
can be used by hardare elements like vspmfilter.
This improve performance when using with those elements.
(Before this, waylandsink needs to copy data to
SHM buffers, thus the performance is low).

A sameple pipeline where performance improve is:
gst-launch-1.0 filesrc location=videos/RenesasElectronics_1920x1080_60fps.mp4 ! qtdemux ! h264parse ! omxh264dec  ! vspmfilter outbuf-alloc=false ! video/x-raw,format=BGRA  ! waylandsink

Signed-off-by: Hung Tran <hung.tran.jy@renesas.com>
---
 configure.ac                 |   7 +
 ext/wayland/Makefile.am      |  15 ++
 ext/wayland/gstwaylandsink.c |  73 ++++++-
 ext/wayland/waylandkmspool.c | 471 +++++++++++++++++++++++++++++++++++++++++++
 ext/wayland/waylandkmspool.h |  87 ++++++++
 ext/wayland/waylandpool.c    | 262 ++++++++++++++++++++++++
 ext/wayland/waylandpool.h    |  64 ++++++
 ext/wayland/wldisplay.c      |  59 ++++++
 ext/wayland/wldisplay.h      |   6 +
 ext/wayland/wlvideoformat.c  |  79 ++++++++
 ext/wayland/wlvideoformat.h  |   4 +
 11 files changed, 1121 insertions(+), 6 deletions(-)
 create mode 100644 ext/wayland/waylandkmspool.c
 create mode 100644 ext/wayland/waylandkmspool.h
 create mode 100644 ext/wayland/waylandpool.c
 create mode 100644 ext/wayland/waylandpool.h

diff --git a/configure.ac b/configure.ac
index e9a64e9..d2cdb4a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2280,6 +2280,13 @@ AG_GST_CHECK_FEATURE(WAYLAND, [wayland sink], wayland , [
     ],
     [ HAVE_WAYLAND="no"
   ])
+  PKG_CHECK_MODULES(WAYLAND_KMS, libdrm libkms wayland-kms gstreamer-allocators-1.0,
+    [HAVE_WAYLAND="yes"
+        AC_DEFINE(HAVE_WAYLAND_KMS, 1, [Define if wayland KMS protocol is available])],
+       [HAVE_WAYLAND_KMS="no"])
+  PKG_CHECK_MODULES(WAYLAND_PROTOCOLS, [wayland-protocols],
+      [ac_wayland_protocols_pkgdatadir=`$PKG_CONFIG --variable=pkgdatadir wayland-protocols`])
+  AC_SUBST(WAYLAND_PROTOCOLS_DATADIR, $PKG_CONFIG_SYSROOT_DIR$ac_wayland_protocols_pkgdatadir)
 ])
 
 dnl **** WebP ****
diff --git a/ext/wayland/Makefile.am b/ext/wayland/Makefile.am
index 8442dbd..afbe619 100644
--- a/ext/wayland/Makefile.am
+++ b/ext/wayland/Makefile.am
@@ -15,6 +15,10 @@ libgstwaylandsink_la_SOURCES =  \
 	wlvideoformat.c \
 	wllinuxdmabuf.c
 
+libgstwaylandsink_la_SOURCES += \
+	waylandpool.c \
+	waylandkmspool.c
+
 nodist_libgstwaylandsink_la_SOURCES = \
 	viewporter-protocol.c \
 	linux-dmabuf-unstable-v1-protocol.c
@@ -24,12 +28,19 @@ libgstwaylandsink_la_CFLAGS = \
 	$(GST_PLUGINS_BASE_CFLAGS) \
 	$(GST_CFLAGS) \
 	$(WAYLAND_CFLAGS)
+
+libgstwaylandsink_la_CFLAGS += \
+	$(WAYLAND_KMS_CFLAGS)
+
 libgstwaylandsink_la_LIBADD = \
 	$(top_builddir)/gst-libs/gst/wayland/libgstwayland-$(GST_API_VERSION).la \
 	$(GST_PLUGINS_BASE_LIBS) \
 	-lgstvideo-$(GST_API_VERSION) \
 	-lgstallocators-$(GST_API_VERSION) \
 	$(WAYLAND_LIBS)
+
+libgstwaylandsink_la_LIBADD += $(WAYLAND_KMS_LIBS)
+
 libgstwaylandsink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstwaylandsink_la_LIBTOOLFLAGS = $(GST_PLUGIN_LIBTOOLFLAGS)
 
@@ -42,6 +53,10 @@ noinst_HEADERS = \
 	wlvideoformat.h \
 	wllinuxdmabuf.h
 
+noinst_HEADERS += \
+	waylandpool.h \
+	waylandkmspool.h
+
 CLEANFILES = $(BUILT_SOURCES)
 
 .SECONDEXPANSION:
diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 77f38f3..b3cbe3d 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -51,6 +51,9 @@
 #include <gst/wayland/wayland.h>
 #include <gst/video/videooverlay.h>
 
+#include "waylandpool.h"
+#include "waylandkmspool.h"
+
 /* signals */
 enum
 {
@@ -392,6 +395,13 @@ gst_wayland_sink_find_display (GstWaylandSink * sink)
           g_error_free (error);
           ret = FALSE;
         }
+        else {
+          /* inform the world about the new display */
+          context =
+              gst_wayland_display_handle_context_new (sink->display->display);
+          msg = gst_message_new_have_context (GST_OBJECT_CAST (sink), context);
+          gst_element_post_message (GST_ELEMENT_CAST (sink), msg);
+        }
       }
     }
   }
@@ -515,14 +525,30 @@ gst_wayland_sink_get_caps (GstBaseSink * bsink, GstCaps * filter)
     GArray *formats;
     gint i;
     guint fmt;
+#ifdef HAVE_WAYLAND_KMS
+    GValue kms_list = G_VALUE_INIT;
+#endif
 
     g_value_init (&shm_list, GST_TYPE_LIST);
     g_value_init (&dmabuf_list, GST_TYPE_LIST);
+    g_value_init (&value, G_TYPE_STRING);
+#ifdef HAVE_WAYLAND_KMS
+    g_value_init (&kms_list, GST_TYPE_LIST);
+
+    /* Add corresponding KMS formats, not use shm if KMS is available */
+    formats = sink->display->kms_formats;
+    for (i = 0; i < formats->len; i++) {
+      fmt = g_array_index (formats, uint32_t, i);
+      g_value_set_static_string (&value, gst_wl_kms_format_to_string (fmt));
+      gst_value_list_append_and_take_value (&kms_list, &value);
+    }
 
+    gst_structure_take_value (gst_caps_get_structure (caps, 0), "format",
+        &kms_list);
+#else
     /* Add corresponding shm formats */
     formats = sink->display->shm_formats;
     for (i = 0; i < formats->len; i++) {
-      g_value_init (&value, G_TYPE_STRING);
       fmt = g_array_index (formats, uint32_t, i);
       g_value_set_static_string (&value, gst_wl_shm_format_to_string (fmt));
       gst_value_list_append_and_take_value (&shm_list, &value);
@@ -530,11 +556,11 @@ gst_wayland_sink_get_caps (GstBaseSink * bsink, GstCaps * filter)
 
     gst_structure_take_value (gst_caps_get_structure (caps, 0), "format",
         &shm_list);
+#endif
 
     /* Add corresponding dmabuf formats */
     formats = sink->display->dmabuf_formats;
     for (i = 0; i < formats->len; i++) {
-      g_value_init (&value, G_TYPE_STRING);
       fmt = g_array_index (formats, uint32_t, i);
       g_value_set_static_string (&value, gst_wl_dmabuf_format_to_string (fmt));
       gst_value_list_append_and_take_value (&dmabuf_list, &value);
@@ -568,18 +594,21 @@ gst_wayland_create_pool (GstWaylandSink * sink, GstCaps * caps)
   gsize size = sink->video_info.size;
   GstAllocator *alloc;
 
-  pool = gst_video_buffer_pool_new ();
+  pool = gst_wayland_buffer_pool_new(sink->display);
 
   structure = gst_buffer_pool_get_config (pool);
   gst_buffer_pool_config_set_params (structure, caps, size, 2, 0);
 
+#ifndef HAVE_WAYLAND_KMS
   alloc = gst_wl_shm_allocator_get ();
   gst_buffer_pool_config_set_allocator (structure, alloc, NULL);
+  g_object_unref (alloc);
+#endif
+
   if (!gst_buffer_pool_set_config (pool, structure)) {
     g_object_unref (pool);
     pool = NULL;
   }
-  g_object_unref (alloc);
 
   return pool;
 }
@@ -621,9 +650,16 @@ gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
   if (use_dmabuf) {
     if (!gst_wl_display_check_format_for_dmabuf (sink->display, format))
       goto unsupported_format;
-  } else if (!gst_wl_display_check_format_for_shm (sink->display, format)) {
+  }
+#ifdef HAVE_WAYLAND_KMS
+  else if (!gst_wl_display_check_format_for_kms (sink->display, format)) {
+    goto unsupported_format;
+  }
+#else
+  else if (!gst_wl_display_check_format_for_shm (sink->display, format)) {
     goto unsupported_format;
   }
+#endif
 # endif
 
   sink->use_dmabuf = use_dmabuf;
@@ -654,6 +690,7 @@ gst_wayland_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)
   GstBufferPool *pool = NULL;
   gboolean need_pool;
   GstAllocator *alloc;
+  GstStructure *config;
 
   gst_query_parse_allocation (query, &caps, &need_pool);
 
@@ -662,9 +699,26 @@ gst_wayland_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)
 
   if (pool) {
     gst_query_add_allocation_pool (query, pool, sink->video_info.size, 2, 0);
+
+    config = gst_buffer_pool_get_config (pool);
+    gst_buffer_pool_config_set_params (config, caps, sink->video_info.size,
+        GST_WAYLAND_BUFFER_POOL_NUM, GST_WAYLAND_BUFFER_POOL_NUM);
+
+    /*
+     * Add the default allocator for the plugins that can't use dmabuf
+     * descriptors.
+     */
+    gst_query_add_allocation_param (query, gst_allocator_find (NULL), NULL);
+
     g_object_unref (pool);
   }
-  alloc = gst_wl_shm_allocator_get ();
+
+#ifdef HAVE_WAYLAND_KMS
+    alloc = gst_dmabuf_allocator_new ();
+#else
+    alloc = gst_wl_shm_allocator_get ();
+#endif
+
   gst_query_add_allocation_param (query, alloc, NULL);
   gst_query_add_allocation_meta (query, GST_VIDEO_META_API_TYPE, NULL);
   g_object_unref (alloc);
@@ -801,11 +855,18 @@ gst_wayland_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
           &sink->video_info, sink->enable_interlace);
   }
 
+#ifdef HAVE_WAYLAND_KMS
+  /* Reuse below code of SHM for KMS */
+  if (!wbuf) {
+    {
+#else
   if (!wbuf && gst_wl_display_check_format_for_shm (sink->display, format)) {
+
     if (gst_is_fd_memory (mem)) {
       wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
           &sink->video_info);
     } else {
+#endif
       GstVideoFrame src, dst;
       GstVideoInfo src_info = sink->video_info;
 
diff --git a/ext/wayland/waylandkmspool.c b/ext/wayland/waylandkmspool.c
new file mode 100644
index 0000000..9239591
--- /dev/null
+++ b/ext/wayland/waylandkmspool.c
@@ -0,0 +1,471 @@
+/* GStreamer
+ * Copyright (C) 2012 Intel Corporation
+ * Copyright (C) 2012 Sreerenj Balachandran <sreerenj.balachandran@intel.com>
+ * Copyright (C) 2014 Collabora Ltd.
+ * Copyright (C) 2015 Renesas Electronics Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "waylandpool.h"
+#include "waylandkmspool.h"
+#include "wldisplay.h"
+#include "wlvideoformat.h"
+#include "wlbuffer.h"
+
+#include <fcntl.h>              /* O_CLOEXEC */
+#include "xf86drm.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+
+GST_DEBUG_CATEGORY_EXTERN (gstwayland_debug);
+#define GST_CAT_DEFAULT gstwayland_debug
+
+#define GST_WAYLAND_BUFFER_POOL_NUM  3
+
+/* wl metadata */
+GType
+gst_wl_kms_meta_api_get_type (void)
+{
+  static volatile GType type;
+  static const gchar *tags[] =
+      { "memory", "size", "colorspace", "orientation", NULL };
+
+  if (g_once_init_enter (&type)) {
+    GType _type = gst_meta_api_type_register ("GstWlKmsMetaAPI", tags);
+    g_once_init_leave (&type, _type);
+  }
+  return type;
+}
+
+static void
+gst_wl_kms_meta_free (GstWlKmsMeta * meta, GstBuffer * buffer)
+{
+  GstMemory *mem;
+  gboolean is_dmabuf;
+  guint n_mem;
+  struct kms_bo *kms_bo;
+  guint i;
+
+  if (meta->kms_bo_array) {
+    n_mem = gst_buffer_n_memory (buffer);
+    for (i = 0; i < n_mem; i++) {
+      mem = gst_buffer_get_memory (buffer, i);
+
+      kms_bo = (struct kms_bo *) g_ptr_array_index (meta->kms_bo_array, i);
+
+      is_dmabuf = gst_is_dmabuf_memory (mem);
+      if (!is_dmabuf)
+        kms_bo_unmap (kms_bo);
+      else
+        close (gst_dmabuf_memory_get_fd (mem));
+      kms_bo_destroy (&kms_bo);
+
+      gst_memory_unref (mem);
+    }
+    g_ptr_array_unref (meta->kms_bo_array);
+  }
+
+  g_object_unref (meta->display);
+}
+
+const GstMetaInfo *
+gst_wl_kms_meta_get_info (void)
+{
+  static const GstMetaInfo *wl_meta_info = NULL;
+
+  if (g_once_init_enter (&wl_meta_info)) {
+    const GstMetaInfo *meta =
+        gst_meta_register (GST_WL_KMS_META_API_TYPE, "GstWlKmsMeta",
+        sizeof (GstWlKmsMeta), (GstMetaInitFunction) NULL,
+        (GstMetaFreeFunction) gst_wl_kms_meta_free,
+        (GstMetaTransformFunction) NULL);
+    g_once_init_leave (&wl_meta_info, meta);
+  }
+  return wl_meta_info;
+}
+
+
+/* bufferpool */
+static void gst_wayland_kms_buffer_pool_finalize (GObject * object);
+static gboolean gst_wayland_kms_buffer_pool_stop (GstBufferPool * pool);
+static gboolean gst_wayland_kms_buffer_pool_start (GstBufferPool * pool);
+static GstFlowReturn gst_wayland_kms_buffer_pool_alloc (GstBufferPool * pool,
+    GstBuffer ** buffer, GstBufferPoolAcquireParams * params);
+static gboolean gst_wayland_kms_buffer_pool_set_config (GstBufferPool * pool,
+    GstStructure * config);
+
+#define gst_wayland_kms_buffer_pool_parent_class parent_class
+G_DEFINE_TYPE (GstWaylandKmsBufferPool, gst_wayland_kms_buffer_pool,
+    GST_TYPE_WAYLAND_BUFFER_POOL);
+
+static void
+gst_wayland_kms_buffer_pool_class_init (GstWaylandKmsBufferPoolClass * klass)
+{
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+  GstBufferPoolClass *gstbufferpool_class = (GstBufferPoolClass *) klass;
+
+  gobject_class->finalize = gst_wayland_kms_buffer_pool_finalize;
+
+  gstbufferpool_class->stop = gst_wayland_kms_buffer_pool_stop;
+  gstbufferpool_class->start = gst_wayland_kms_buffer_pool_start;
+  gstbufferpool_class->alloc_buffer = gst_wayland_kms_buffer_pool_alloc;
+  gstbufferpool_class->set_config = gst_wayland_kms_buffer_pool_set_config;
+}
+
+static void
+gst_wayland_kms_buffer_pool_init (GstWaylandKmsBufferPool * self)
+{
+  self->kms_drv = NULL;
+  self->allocator = NULL;
+}
+
+static void
+gst_wayland_kms_buffer_pool_finalize (GObject * object)
+{
+  GstWaylandKmsBufferPool *self = GST_WAYLAND_KMS_BUFFER_POOL_CAST (object);
+
+  if (self->allocator)
+    gst_object_unref (self->allocator);
+  self->allocator = NULL;
+
+  G_OBJECT_CLASS (gst_wayland_kms_buffer_pool_parent_class)->finalize (object);
+}
+
+static gboolean
+gst_wayland_buffer_pool_video_meta_map (GstVideoMeta * meta, guint plane,
+    GstMapInfo * info, gpointer * data, gint * stride, GstMapFlags flags)
+{
+  GstBuffer *buffer = meta->buffer;
+  GstMemory *mem;
+  gint n_mem;
+
+  n_mem = gst_buffer_n_memory (buffer);
+  if (n_mem <= plane) {
+    GST_ERROR ("plane is out of range (plane:%d)", plane);
+    return FALSE;
+  }
+
+  mem = gst_buffer_get_memory (buffer, plane);
+  if (!gst_memory_map (mem, info, flags)) {
+    GST_ERROR ("failed to map memory (plane:%d)", plane);
+    return FALSE;
+  }
+
+  *data = info->data;
+  *stride = meta->stride[plane];
+
+  return TRUE;
+}
+
+static gboolean
+gst_wayland_buffer_pool_video_meta_unmap (GstVideoMeta * meta, guint plane,
+    GstMapInfo * info)
+{
+  GstBuffer *buffer = meta->buffer;
+  GstMemory *mem;
+  gint n_mem;
+
+  n_mem = gst_buffer_n_memory (buffer);
+  if (n_mem <= plane) {
+    GST_ERROR ("plane is out of range (plane:%d)", plane);
+    return FALSE;
+  }
+
+  mem = gst_buffer_peek_memory (buffer, plane);
+
+  gst_memory_unmap (mem, info);
+  gst_memory_unref (mem);
+
+  return TRUE;
+}
+
+static gboolean
+gst_wayland_kms_buffer_pool_set_config (GstBufferPool * pool,
+    GstStructure * config)
+{
+  GstWaylandKmsBufferPool *self = GST_WAYLAND_KMS_BUFFER_POOL (pool);
+  GstAllocationParams params;
+  GstCaps *caps;
+  guint size;
+
+  if (self->allocator)
+    gst_object_unref (self->allocator);
+  self->allocator = NULL;
+
+/* Always set the buffer pool min/max buffers to the defined value */
+  if (gst_buffer_pool_config_get_params (config, &caps, &size, NULL, NULL)) {
+    gst_buffer_pool_config_set_params (config, caps, size,
+        GST_WAYLAND_BUFFER_POOL_NUM, GST_WAYLAND_BUFFER_POOL_NUM);
+  }
+
+  if (!gst_buffer_pool_config_get_allocator (config, &self->allocator, &params)) {
+    GST_WARNING_OBJECT (self, "failed to get allocator");
+    return FALSE;
+  }
+
+  if (self->allocator)
+    gst_object_ref (self->allocator);
+
+  return GST_BUFFER_POOL_CLASS (parent_class)->set_config (pool, config);
+}
+
+static gboolean
+gst_wayland_kms_buffer_pool_start (GstBufferPool * pool)
+{
+  GstWaylandKmsBufferPool *self = GST_WAYLAND_KMS_BUFFER_POOL (pool);
+
+  if (kms_create (self->base.display->drm_fd, &self->kms_drv)) {
+    GST_ERROR_OBJECT (self, "kms_create failed");
+    return FALSE;
+  }
+/* need the BASE class, not the WaylandBufferPool class here */
+  return
+      GST_BUFFER_POOL_CLASS (g_type_class_peek_parent (parent_class))->start
+      (pool);
+}
+
+static gboolean
+gst_wayland_kms_buffer_pool_stop (GstBufferPool * pool)
+{
+  GstWaylandKmsBufferPool *self = GST_WAYLAND_KMS_BUFFER_POOL (pool);
+
+  GST_DEBUG_OBJECT (self, "Stopping wayland buffer pool");
+
+  if (self->kms_drv)
+    kms_destroy (&self->kms_drv);
+
+  return
+      GST_BUFFER_POOL_CLASS (g_type_class_peek_parent (parent_class))->stop
+      (pool);
+}
+
+static gboolean
+gst_wayland_buffer_pool_create_mp_buffer (GstWaylandBufferPool * wpool,
+    GstBuffer * buffer, gint dmabuf[GST_VIDEO_MAX_PLANES],
+    GstAllocator * allocator, gint width, gint height,
+    void *data[GST_VIDEO_MAX_PLANES], gint in_stride[GST_VIDEO_MAX_PLANES],
+    gsize offset[GST_VIDEO_MAX_PLANES], GstVideoFormat format, gint n_planes)
+{
+  struct wl_buffer *wbuffer;
+  GstWlKmsMeta *meta;
+  GstVideoMeta *vmeta;
+  size_t size, maxsize;
+  gboolean is_dmabuf;
+  gint i;
+
+  is_dmabuf = (allocator &&
+      g_strcmp0 (allocator->mem_type, GST_ALLOCATOR_DMABUF) == 0);
+  if (!is_dmabuf && data == NULL) {
+    GST_WARNING_OBJECT (wpool, "couldn't get data pointer");
+    return FALSE;
+  }
+
+  meta = (GstWlKmsMeta *) gst_buffer_add_meta
+      (buffer, GST_WL_KMS_META_INFO, NULL);
+
+  meta->kms_bo_array = NULL;
+
+  /*
+   * Wayland protocal APIs require that all (even unused) file descriptors be
+   * valid. Instead of sending random dummy values, copy the valid fds from
+   * the other planes.
+   */
+  if (n_planes == 1)
+    dmabuf[1] = dmabuf[2] = dmabuf[0];
+  else if (n_planes == 2)
+    dmabuf[2] = dmabuf[0];
+
+  wbuffer =
+      wl_kms_create_mp_buffer (wpool->display->kms, width, height,
+      gst_video_format_to_wl_kms_format (format), dmabuf[0], in_stride[0],
+      dmabuf[1], in_stride[1], dmabuf[2], in_stride[2]);
+
+  for (i = 0; i < n_planes; i++) {
+    size = GST_VIDEO_INFO_COMP_STRIDE (&wpool->info, i) *
+        GST_VIDEO_INFO_COMP_HEIGHT (&wpool->info, i);
+
+    if (is_dmabuf) {
+      gst_buffer_append_memory (buffer,
+          gst_dmabuf_allocator_alloc (allocator, dmabuf[i], size));
+    } else {
+      maxsize = in_stride[i] * height;
+
+      gst_buffer_append_memory (buffer,
+          gst_memory_new_wrapped (GST_MEMORY_FLAG_NO_SHARE, data[i],
+              maxsize, 0, size, NULL, NULL));
+    }
+  }
+
+  gst_buffer_add_wl_buffer (buffer, wbuffer, wpool->display);
+
+  vmeta = gst_buffer_add_video_meta_full (buffer, GST_VIDEO_FRAME_FLAG_NONE,
+      format, width, height, n_planes, offset, in_stride);
+  vmeta->map = gst_wayland_buffer_pool_video_meta_map;
+  vmeta->unmap = gst_wayland_buffer_pool_video_meta_unmap;
+
+  return TRUE;
+}
+
+GstBuffer *
+gst_wayland_buffer_pool_create_buffer_from_dmabuf (GstWaylandBufferPool * wpool,
+    gint dmabuf[GST_VIDEO_MAX_PLANES], GstAllocator * allocator, gint width,
+    gint height, gint in_stride[GST_VIDEO_MAX_PLANES], GstVideoFormat format,
+    gint n_planes)
+{
+  GstBuffer *buffer;
+  GstWlKmsMeta *wmeta;
+  gsize offset[GST_VIDEO_MAX_PLANES] = { 0 };
+
+  buffer = gst_buffer_new ();
+
+  if (!gst_wayland_buffer_pool_create_mp_buffer (wpool, buffer, dmabuf,
+          allocator, width, height, NULL, in_stride, offset, format,
+          n_planes)) {
+    GST_WARNING_OBJECT (wpool, "failed to create_mp_buffer");
+    gst_buffer_unref (buffer);
+    return NULL;
+  }
+
+  wmeta = gst_buffer_get_wl_kms_meta (buffer);
+
+  wmeta->kms_bo_array = NULL;
+  wmeta->display = g_object_ref (wpool->display);
+
+  /* To avoid deattaching meta data when a buffer returns to the buffer pool */
+  GST_META_FLAG_SET (wmeta, GST_META_FLAG_POOLED);
+
+  return buffer;
+}
+
+static GstFlowReturn
+gst_wayland_kms_buffer_pool_alloc (GstBufferPool * pool, GstBuffer ** buffer,
+    GstBufferPoolAcquireParams * params)
+{
+  GstWaylandBufferPool *self = GST_WAYLAND_BUFFER_POOL_CAST (pool);
+  GstWaylandKmsBufferPool *kms_self = GST_WAYLAND_KMS_BUFFER_POOL_CAST (pool);
+  GstWlKmsMeta *meta;
+  gint width, height;
+  enum wl_kms_format format;
+  gsize offset[GST_VIDEO_MAX_PLANES] = { 0 };
+  gint stride[GST_VIDEO_MAX_PLANES] = { 0 };
+  gint err;
+  void *data[GST_VIDEO_MAX_PLANES] = { NULL };
+  guint32 handle;
+  gint dmabuf_fd[GST_VIDEO_MAX_PLANES];
+  struct kms_bo *kms_bo[GST_VIDEO_MAX_PLANES];
+  guint n_planes;
+  guint i;
+  unsigned attr[] = {
+    KMS_BO_TYPE, KMS_BO_TYPE_SCANOUT_X8R8G8B8,
+    KMS_WIDTH, 0,
+    KMS_HEIGHT, 0,
+    KMS_TERMINATE_PROP_LIST
+  };
+
+  width = GST_VIDEO_INFO_WIDTH (&self->info);
+  height = GST_VIDEO_INFO_HEIGHT (&self->info);
+  format =
+      gst_video_format_to_wl_kms_format (GST_VIDEO_INFO_FORMAT (&self->info));
+
+  *buffer = gst_buffer_new ();
+
+  n_planes = GST_VIDEO_INFO_N_PLANES (&self->info);
+  for (i = 0; i < n_planes; i++) {
+    /* dumb BOs are treated with 32bpp format as hard-coded in libkms,
+     * so a pixel stride we actually desire should be divided by 4 and
+     * specified as a KMS BO width, which has been implemented
+     * as a macro definition.
+     */
+    attr[3] = gst_wl_get_kms_bo_width (&self->info, i);
+    attr[5] = GST_VIDEO_INFO_COMP_HEIGHT (&self->info, i);
+
+    err = kms_bo_create (kms_self->kms_drv, attr, &kms_bo[i]);
+    if (err) {
+      GST_ERROR ("Failed to create kms bo");
+      return GST_FLOW_ERROR;
+    }
+
+    kms_bo_get_prop (kms_bo[i], KMS_PITCH, (guint *) & stride[i]);
+
+    kms_bo_get_prop (kms_bo[i], KMS_HANDLE, &handle);
+
+    err = drmPrimeHandleToFD (self->display->drm_fd, handle, DRM_CLOEXEC,
+        &dmabuf_fd[i]);
+    if (err) {
+      GST_ERROR_OBJECT (self, "drmPrimeHandleToFD failed. %s\n",
+          strerror (errno));
+      gst_buffer_unref (*buffer);
+      return GST_FLOW_ERROR;
+    }
+
+    if (kms_self->allocator == NULL ||
+        g_strcmp0 (kms_self->allocator->mem_type, GST_ALLOCATOR_DMABUF) != 0) {
+      err = kms_bo_map (kms_bo[i], &data[i]);
+      if (err) {
+        GST_ERROR ("Failed to map kms bo");
+        return GST_FLOW_ERROR;
+      }
+    }
+  }
+
+
+  if (!gst_wayland_buffer_pool_create_mp_buffer (self, *buffer, dmabuf_fd,
+          kms_self->allocator, width, height, data, stride, offset,
+          GST_VIDEO_INFO_FORMAT (&self->info), n_planes)) {
+    GST_WARNING_OBJECT (self, "failed to create_mp_buffer");
+    return GST_FLOW_ERROR;
+  }
+
+
+  meta = gst_buffer_get_wl_kms_meta (*buffer);
+
+  meta->kms_bo_array = g_ptr_array_new ();
+  for (i = 0; i < n_planes; i++)
+    g_ptr_array_add (meta->kms_bo_array, (gpointer) kms_bo[i]);
+
+  GST_DEBUG_OBJECT (self, "Allocating wl_kms buffer of size %" G_GSSIZE_FORMAT
+      " (%d x %d), format %s", GST_VIDEO_INFO_SIZE (&self->info), width, height,
+      gst_wl_kms_format_to_string (format));
+
+  meta->display = g_object_ref (self->display);
+
+  return GST_FLOW_OK;
+}
+
+#if 0
+GstBufferPool *
+gst_wayland_buffer_pool_new (GstWlDisplay * display)
+{
+  GstWaylandBufferPool *pool;
+
+  g_return_val_if_fail (GST_IS_WL_DISPLAY (display), NULL);
+  pool = g_object_new (GST_TYPE_WAYLAND_BUFFER_POOL, NULL);
+  pool->display = g_object_ref (display);
+
+  return GST_BUFFER_POOL_CAST (pool);
+}
+#endif
diff --git a/ext/wayland/waylandkmspool.h b/ext/wayland/waylandkmspool.h
new file mode 100644
index 0000000..cdcf725
--- /dev/null
+++ b/ext/wayland/waylandkmspool.h
@@ -0,0 +1,87 @@
+/* GStreamer Wayland buffer pool
+ * Copyright (C) 2012 Intel Corporation
+ * Copyright (C) 2012 Sreerenj Balachandran <sreerenj.balachandran@intel.com>
+ * Copyright (C) 2014 Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_WAYLAND_KMS_BUFFER_POOL_H__
+#define __GST_WAYLAND_KMS_BUFFER_POOL_H__
+
+#include <gst/video/video.h>
+#include <gst/video/gstvideometa.h>
+
+#include <gst/allocators/gstdmabuf.h>
+
+#include "wldisplay.h"
+
+#include "libkms.h"
+
+G_BEGIN_DECLS
+#define GST_ALLOCATOR_KMS "KMS"
+#define GST_TYPE_WAYLAND_KMS_BUFFER_POOL \
+     (gst_wayland_kms_buffer_pool_get_type())
+#define GST_IS_WAYLAND_KMS_BUFFER_POOL(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WAYLAND_KMS_BUFFER_POOL))
+#define GST_WAYLAND_KMS_BUFFER_POOL(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WAYLAND_KMS_BUFFER_POOL, GstWaylandKmsBufferPool))
+#define GST_WAYLAND_KMS_BUFFER_POOL_CAST(obj) ((GstWaylandKmsBufferPool*)(obj))
+typedef struct _GstWaylandKmsBufferPool GstWaylandKmsBufferPool;
+typedef struct _GstWaylandKmsBufferPoolClass GstWaylandKmsBufferPoolClass;
+
+/* buffer meta */
+typedef struct _GstWlKmsMeta GstWlKmsMeta;
+
+GType gst_wl_kms_meta_api_get_type (void);
+#define GST_WL_KMS_META_API_TYPE  (gst_wl_kms_meta_api_get_type())
+
+const GstMetaInfo *gst_wl_kms_meta_get_info (void);
+#define GST_WL_KMS_META_INFO  (gst_wl_kms_meta_get_info())
+
+#define gst_buffer_get_wl_kms_meta(b) ((GstWlKmsMeta*)gst_buffer_get_meta((b),GST_WL_KMS_META_API_TYPE))
+
+#define gst_wl_get_kms_bo_width(i, p) \
+    ((((GST_VIDEO_INFO_PLANE_STRIDE (i, p) + 3) / 4 + 31) >> 5) << 5)
+
+struct _GstWlKmsMeta
+{
+  GstMeta meta;
+  GPtrArray *kms_bo_array;
+  GstWlDisplay *display;
+};
+
+/* buffer pool */
+struct _GstWaylandKmsBufferPool
+{
+  GstWaylandBufferPool base;
+  struct kms_driver *kms_drv;
+  GstAllocator *allocator;
+};
+
+struct _GstWaylandKmsBufferPoolClass
+{
+  GstWaylandBufferPoolClass parent_class;
+  GstBufferPoolClass *grandparent_class;
+};
+
+GType gst_wayland_kms_buffer_pool_get_type (void);
+GstBuffer
+    *gst_wayland_buffer_pool_create_buffer_from_dmabuf (GstWaylandBufferPool *
+    wpool, gint dmabuf[GST_VIDEO_MAX_PLANES], GstAllocator * allocator,
+    gint width, gint height, gint in_stride[GST_VIDEO_MAX_PLANES],
+    GstVideoFormat format, gint n_planes);
+
+G_END_DECLS
+#endif /*__GST_WAYLAND_KMS_BUFFER_POOL_H__*/
diff --git a/ext/wayland/waylandpool.c b/ext/wayland/waylandpool.c
new file mode 100644
index 0000000..67b9a87
--- /dev/null
+++ b/ext/wayland/waylandpool.c
@@ -0,0 +1,262 @@
+/* GStreamer
+ * Copyright (C) 2012 Intel Corporation
+ * Copyright (C) 2012 Sreerenj Balachandran <sreerenj.balachandran@intel.com>
+ * Copyright (C) 2014 Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "waylandpool.h"
+#include "wldisplay.h"
+#include "wlvideoformat.h"
+#include "waylandkmspool.h"
+#include "wlbuffer.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+
+GST_DEBUG_CATEGORY_EXTERN (gstwayland_debug);
+#define GST_CAT_DEFAULT gstwayland_debug
+
+/* bufferpool */
+static void gst_wayland_buffer_pool_finalize (GObject * object);
+static gboolean gst_wayland_buffer_pool_set_config (GstBufferPool * pool,
+    GstStructure * config);
+static gboolean gst_wayland_buffer_pool_start (GstBufferPool * pool);
+static gboolean gst_wayland_buffer_pool_stop (GstBufferPool * pool);
+static GstFlowReturn gst_wayland_buffer_pool_alloc (GstBufferPool * pool,
+    GstBuffer ** buffer, GstBufferPoolAcquireParams * params);
+
+#define gst_wayland_buffer_pool_parent_class parent_class
+G_DEFINE_TYPE (GstWaylandBufferPool, gst_wayland_buffer_pool,
+    GST_TYPE_BUFFER_POOL);
+
+static void
+gst_wayland_buffer_pool_class_init (GstWaylandBufferPoolClass * klass)
+{
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+  GstBufferPoolClass *gstbufferpool_class = (GstBufferPoolClass *) klass;
+
+  gobject_class->finalize = gst_wayland_buffer_pool_finalize;
+
+  gstbufferpool_class->set_config = gst_wayland_buffer_pool_set_config;
+  gstbufferpool_class->start = gst_wayland_buffer_pool_start;
+  gstbufferpool_class->stop = gst_wayland_buffer_pool_stop;
+  gstbufferpool_class->alloc_buffer = gst_wayland_buffer_pool_alloc;
+}
+
+static void
+gst_wayland_buffer_pool_init (GstWaylandBufferPool * self)
+{
+  gst_video_info_init (&self->info);
+}
+
+static void
+gst_wayland_buffer_pool_finalize (GObject * object)
+{
+  GstWaylandBufferPool *pool = GST_WAYLAND_BUFFER_POOL_CAST (object);
+
+  if (pool->wl_pool)
+    gst_wayland_buffer_pool_stop (GST_BUFFER_POOL (pool));
+
+  g_object_unref (pool->display);
+
+  G_OBJECT_CLASS (gst_wayland_buffer_pool_parent_class)->finalize (object);
+}
+
+static gboolean
+gst_wayland_buffer_pool_set_config (GstBufferPool * pool, GstStructure * config)
+{
+  GstWaylandBufferPool *self = GST_WAYLAND_BUFFER_POOL_CAST (pool);
+  GstCaps *caps;
+
+  if (!gst_buffer_pool_config_get_params (config, &caps, NULL, NULL, NULL))
+    goto wrong_config;
+
+  if (caps == NULL)
+    goto no_caps;
+
+  /* now parse the caps from the config */
+  if (!gst_video_info_from_caps (&self->info, caps))
+    goto wrong_caps;
+
+  GST_LOG_OBJECT (pool, "%dx%d, caps %" GST_PTR_FORMAT,
+      GST_VIDEO_INFO_WIDTH (&self->info), GST_VIDEO_INFO_HEIGHT (&self->info),
+      caps);
+
+  /*Fixme: Enable metadata checking handling based on the config of pool */
+
+  return GST_BUFFER_POOL_CLASS (parent_class)->set_config (pool, config);
+  /* ERRORS */
+wrong_config:
+  {
+    GST_WARNING_OBJECT (pool, "invalid config");
+    return FALSE;
+  }
+no_caps:
+  {
+    GST_WARNING_OBJECT (pool, "no caps in config");
+    return FALSE;
+  }
+wrong_caps:
+  {
+    GST_WARNING_OBJECT (pool,
+        "failed getting geometry from caps %" GST_PTR_FORMAT, caps);
+    return FALSE;
+  }
+}
+
+static gboolean
+gst_wayland_buffer_pool_start (GstBufferPool * pool)
+{
+  GstWaylandBufferPool *self = GST_WAYLAND_BUFFER_POOL (pool);
+  guint size = 0;
+  int fd;
+  char filename[1024];
+  static int init = 0;
+
+  GST_DEBUG_OBJECT (self, "Initializing wayland buffer pool");
+
+  /* configure */
+  size = GST_VIDEO_INFO_SIZE (&self->info) * 15;
+
+  /* allocate shm pool */
+  snprintf (filename, 1024, "%s/%s-%d-%s", g_get_user_runtime_dir (),
+      "wayland-shm", init++, "XXXXXX");
+
+  fd = mkstemp (filename);
+  if (fd < 0) {
+    GST_ERROR_OBJECT (pool, "opening temp file %s failed: %s", filename,
+        strerror (errno));
+    return FALSE;
+  }
+  if (ftruncate (fd, size) < 0) {
+    GST_ERROR_OBJECT (pool, "ftruncate failed: %s", strerror (errno));
+    close (fd);
+    return FALSE;
+  }
+
+  self->data = mmap (NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+  if (self->data == MAP_FAILED) {
+    GST_ERROR_OBJECT (pool, "mmap failed: %s", strerror (errno));
+    close (fd);
+    return FALSE;
+  }
+
+  self->wl_pool = wl_shm_create_pool (self->display->shm, fd, size);
+  unlink (filename);
+  close (fd);
+
+  self->size = size;
+  self->used = 0;
+
+  return GST_BUFFER_POOL_CLASS (parent_class)->start (pool);
+}
+
+static gboolean
+gst_wayland_buffer_pool_stop (GstBufferPool * pool)
+{
+  GstWaylandBufferPool *self = GST_WAYLAND_BUFFER_POOL (pool);
+
+  GST_DEBUG_OBJECT (self, "Stopping wayland buffer pool");
+
+  munmap (self->data, self->size);
+  wl_shm_pool_destroy (self->wl_pool);
+
+  self->wl_pool = NULL;
+  self->size = 0;
+  self->used = 0;
+
+  return GST_BUFFER_POOL_CLASS (parent_class)->stop (pool);
+}
+
+static GstFlowReturn
+gst_wayland_buffer_pool_alloc (GstBufferPool * pool, GstBuffer ** buffer,
+    GstBufferPoolAcquireParams * params)
+{
+  GstWaylandBufferPool *self = GST_WAYLAND_BUFFER_POOL_CAST (pool);
+  gint width, height, stride;
+  gsize size;
+  enum wl_shm_format format;
+  gint offset;
+  void *data;
+  struct wl_buffer *wbuffer;
+
+  width = GST_VIDEO_INFO_WIDTH (&self->info);
+  height = GST_VIDEO_INFO_HEIGHT (&self->info);
+  stride = GST_VIDEO_INFO_PLANE_STRIDE (&self->info, 0);
+  size = GST_VIDEO_INFO_SIZE (&self->info);
+  format =
+      gst_video_format_to_wl_kms_format (GST_VIDEO_INFO_FORMAT (&self->info));
+
+  GST_DEBUG_OBJECT (self, "Allocating buffer of size %" G_GSSIZE_FORMAT
+      " (%d x %d, stride %d), format %s", size, width, height, stride,
+      gst_wl_kms_format_to_string (format));
+
+  /* try to reserve another memory block from the shm pool */
+  if (self->used + size > self->size)
+    goto no_buffer;
+
+  offset = self->used;
+  self->used += size;
+  data = ((gchar *) self->data) + offset;
+
+  *buffer = gst_buffer_new ();
+
+  /* add the allocated memory on the GstBuffer */
+  gst_buffer_append_memory (*buffer,
+      gst_memory_new_wrapped (GST_MEMORY_FLAG_NO_SHARE, data,
+          size, 0, size, NULL, NULL));
+
+  /* create wl_buffer and attach it on the GstBuffer via GstWlBuffer */
+  wbuffer = wl_shm_pool_create_buffer (self->wl_pool, offset, width, height,
+      stride, format);
+  gst_buffer_add_wl_buffer (*buffer, wbuffer, self->display);
+
+  return GST_FLOW_OK;
+
+  /* ERROR */
+no_buffer:
+  {
+    GST_WARNING_OBJECT (pool, "can't create buffer");
+    return GST_FLOW_ERROR;
+  }
+}
+
+GstBufferPool *
+gst_wayland_buffer_pool_new (GstWlDisplay * display)
+{
+  GstWaylandBufferPool *pool;
+
+  g_return_val_if_fail (GST_IS_WL_DISPLAY (display), NULL);
+#ifdef HAVE_WAYLAND_KMS
+  pool = g_object_new (GST_TYPE_WAYLAND_KMS_BUFFER_POOL, NULL);
+#else
+  pool = g_object_new (GST_TYPE_WAYLAND_BUFFER_POOL, NULL);
+#endif
+  pool->display = g_object_ref (display);
+
+  return GST_BUFFER_POOL_CAST (pool);
+}
diff --git a/ext/wayland/waylandpool.h b/ext/wayland/waylandpool.h
new file mode 100644
index 0000000..d4cc419
--- /dev/null
+++ b/ext/wayland/waylandpool.h
@@ -0,0 +1,64 @@
+/* GStreamer Wayland buffer pool
+ * Copyright (C) 2012 Intel Corporation
+ * Copyright (C) 2012 Sreerenj Balachandran <sreerenj.balachandran@intel.com>
+ * Copyright (C) 2014 Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_WAYLAND_BUFFER_POOL_H__
+#define __GST_WAYLAND_BUFFER_POOL_H__
+
+#include <gst/video/video.h>
+
+#include "wldisplay.h"
+
+G_BEGIN_DECLS
+#define GST_TYPE_WAYLAND_BUFFER_POOL      (gst_wayland_buffer_pool_get_type())
+#define GST_IS_WAYLAND_BUFFER_POOL(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WAYLAND_BUFFER_POOL))
+#define GST_WAYLAND_BUFFER_POOL(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WAYLAND_BUFFER_POOL, GstWaylandBufferPool))
+#define GST_WAYLAND_BUFFER_POOL_CAST(obj) ((GstWaylandBufferPool*)(obj))
+#define GST_WAYLAND_BUFFER_POOL_NUM 3
+typedef struct _GstWaylandBufferPool GstWaylandBufferPool;
+typedef struct _GstWaylandBufferPoolClass GstWaylandBufferPoolClass;
+
+/* buffer pool */
+struct _GstWaylandBufferPool
+{
+  GstBufferPool bufferpool;
+  GstWlDisplay *display;
+
+  /* external configuration */
+  GstVideoInfo info;
+
+  /* allocation data */
+  struct wl_shm_pool *wl_pool;
+  size_t size;
+  size_t used;
+  void *data;
+};
+
+struct _GstWaylandBufferPoolClass
+{
+  GstBufferPoolClass parent_class;
+};
+
+GType gst_wayland_buffer_pool_get_type (void);
+
+GstBufferPool *gst_wayland_buffer_pool_new (GstWlDisplay * display);
+
+G_END_DECLS
+#endif /*__GST_WAYLAND_BUFFER_POOL_H__*/
diff --git a/ext/wayland/wldisplay.c b/ext/wayland/wldisplay.c
index 468c361..76a494b 100644
--- a/ext/wayland/wldisplay.c
+++ b/ext/wayland/wldisplay.c
@@ -29,6 +29,15 @@
 
 #include <errno.h>
 
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include "drm.h"
+#include "xf86drm.h"
+
+#include "wlvideoformat.h"
+
 GST_DEBUG_CATEGORY_EXTERN (gstwayland_debug);
 #define GST_CAT_DEFAULT gstwayland_debug
 
@@ -47,6 +56,7 @@ static void
 gst_wl_display_init (GstWlDisplay * self)
 {
   self->shm_formats = g_array_new (FALSE, FALSE, sizeof (uint32_t));
+  self->kms_formats = g_array_new (FALSE, FALSE, sizeof (uint32_t));
   self->dmabuf_formats = g_array_new (FALSE, FALSE, sizeof (uint32_t));
   self->wl_fd_poll = gst_poll_new (TRUE);
   self->buffers = g_hash_table_new (g_direct_hash, g_direct_equal);
@@ -153,7 +163,53 @@ shm_format (void *data, struct wl_shm *wl_shm, uint32_t format)
 static const struct wl_shm_listener shm_listener = {
   shm_format
 };
+static void
+kms_device (void *data, struct wl_kms *kms, const char *device)
+{
+  GstWlDisplay *self = data;
+  drm_magic_t magic;
+
+  if ((self->drm_fd = open (device, O_RDWR | O_CLOEXEC)) < 0) {
+    GST_ERROR ("%s open failed (%s)", device, strerror (errno));
+    return;
+  }
+
+  drmGetMagic (self->drm_fd, &magic);
+  wl_kms_authenticate (self->kms, magic);
+}
+
+static void
+kms_format (void *data, struct wl_kms *kms, uint32_t format)
+{
+  GstWlDisplay *self = data;
+  GstVideoFormat fmt;
 
+  fmt = gst_wl_kms_format_to_video_format (format);
+  if (fmt == GST_VIDEO_FORMAT_UNKNOWN) {
+    GST_WARNING ("waylandsink doesn't support %" GST_FOURCC_FORMAT,
+        GST_FOURCC_ARGS (format));
+    return;
+  }
+  g_array_append_val (self->kms_formats, format);
+  GST_DEBUG ("%" GST_FOURCC_FORMAT " was added to the supported formats list",
+      GST_FOURCC_ARGS (format));
+}
+
+static void
+kms_handle_authenticated (void *data, struct wl_kms *kms)
+{
+  GstWlDisplay *self = data;
+
+  GST_DEBUG ("wl_kms has been authenticated");
+
+  self->authenticated = TRUE;
+}
+
+static const struct wl_kms_listener kms_listenter = {
+  .device = kms_device,
+  .format = kms_format,
+  .authenticated = kms_handle_authenticated
+};
 static void
 dmabuf_format (void *data, struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf,
     uint32_t format)
@@ -226,6 +282,9 @@ registry_handle_global (void *data, struct wl_registry *registry,
         wl_registry_bind (registry, id, &wl_subcompositor_interface, 1);
   } else if (g_strcmp0 (interface, "wl_shell") == 0) {
     self->shell = wl_registry_bind (registry, id, &wl_shell_interface, 1);
+  } else if (strcmp (interface, "wl_kms") == 0) {
+    self->kms = wl_registry_bind (registry, id, &wl_kms_interface, version);
+    wl_kms_add_listener (self->kms, &kms_listenter, self);
   } else if (g_strcmp0 (interface, "wl_shm") == 0) {
     self->shm = wl_registry_bind (registry, id, &wl_shm_interface, 1);
     wl_shm_add_listener (self->shm, &shm_listener, self);
diff --git a/ext/wayland/wldisplay.h b/ext/wayland/wldisplay.h
index 7c4f17e..7d86e1a 100644
--- a/ext/wayland/wldisplay.h
+++ b/ext/wayland/wldisplay.h
@@ -27,6 +27,7 @@
 #include <wayland-client.h>
 #include "viewporter-client-protocol.h"
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "wayland-kms-client-protocol.h"
 
 G_BEGIN_DECLS
 
@@ -56,9 +57,14 @@ struct _GstWlDisplay
   struct wl_shm *shm;
   struct wp_viewporter *viewporter;
   struct zwp_linux_dmabuf_v1 *dmabuf;
+
   GArray *shm_formats;
   GArray *dmabuf_formats;
+  GArray *kms_formats;
 
+  struct wl_kms *kms;
+  gint drm_fd;
+  gboolean authenticated;
   /* private */
   gboolean own_display;
   GThread *thread;
diff --git a/ext/wayland/wlvideoformat.c b/ext/wayland/wlvideoformat.c
index 77cfac8..46b1ffb 100644
--- a/ext/wayland/wlvideoformat.c
+++ b/ext/wayland/wlvideoformat.c
@@ -26,6 +26,7 @@
 #endif
 
 #include "wlvideoformat.h"
+#include "wayland-kms-client-protocol.h"
 
 GST_DEBUG_CATEGORY_EXTERN (gstwayland_debug);
 #define GST_CAT_DEFAULT gstwayland_debug
@@ -42,6 +43,53 @@ typedef struct
   GstVideoFormat gst_format;
 } wl_DmabufVideoFormat;
 
+typedef struct
+{
+  guint wl_format;
+  GstVideoFormat gst_format;
+} wl_KmsVideoFormat;
+
+static const wl_KmsVideoFormat kms_formats[] = {
+#if G_BYTE_ORDER == G_BIG_ENDIAN
+  {WL_KMS_FORMAT_XRGB8888, GST_VIDEO_FORMAT_xRGB},
+  {WL_KMS_FORMAT_ARGB8888, GST_VIDEO_FORMAT_ARGB},
+  {WL_KMS_FORMAT_XBGR8888, GST_VIDEO_FORMAT_BGRx},
+  {WL_KMS_FORMAT_RGBX8888, GST_VIDEO_FORMAT_RGBx},
+  {WL_KMS_FORMAT_BGRX8888, GST_VIDEO_FORMAT_xBGR},
+  {WL_KMS_FORMAT_ABGR8888, GST_VIDEO_FORMAT_ABGR},
+  {WL_KMS_FORMAT_RGBA8888, GST_VIDEO_FORMAT_RGBA},
+  {WL_KMS_FORMAT_BGRA8888, GST_VIDEO_FORMAT_BGRA},
+#else
+  {WL_KMS_FORMAT_XRGB8888, GST_VIDEO_FORMAT_BGRx},
+  {WL_KMS_FORMAT_ARGB8888, GST_VIDEO_FORMAT_BGRA},
+  {WL_KMS_FORMAT_XBGR8888, GST_VIDEO_FORMAT_xRGB},
+  {WL_KMS_FORMAT_RGBX8888, GST_VIDEO_FORMAT_xBGR},
+  {WL_KMS_FORMAT_BGRX8888, GST_VIDEO_FORMAT_RGBx},
+  {WL_KMS_FORMAT_ABGR8888, GST_VIDEO_FORMAT_RGBA},
+  {WL_KMS_FORMAT_RGBA8888, GST_VIDEO_FORMAT_ABGR},
+  {WL_KMS_FORMAT_BGRA8888, GST_VIDEO_FORMAT_ARGB},
+#endif
+  {WL_KMS_FORMAT_RGB888, GST_VIDEO_FORMAT_RGB},
+  {WL_KMS_FORMAT_BGR888, GST_VIDEO_FORMAT_BGR},
+  {WL_KMS_FORMAT_RGB565, GST_VIDEO_FORMAT_RGB16},
+  {WL_KMS_FORMAT_BGR565, GST_VIDEO_FORMAT_BGR16},
+
+  {WL_KMS_FORMAT_YUYV, GST_VIDEO_FORMAT_YUY2},
+  {WL_KMS_FORMAT_YVYU, GST_VIDEO_FORMAT_YVYU},
+  {WL_KMS_FORMAT_UYVY, GST_VIDEO_FORMAT_UYVY},
+  {WL_KMS_FORMAT_AYUV, GST_VIDEO_FORMAT_AYUV},
+  {WL_KMS_FORMAT_NV12, GST_VIDEO_FORMAT_NV12},
+  {WL_KMS_FORMAT_NV21, GST_VIDEO_FORMAT_NV21},
+  {WL_KMS_FORMAT_NV16, GST_VIDEO_FORMAT_NV16},
+  {WL_KMS_FORMAT_YUV410, GST_VIDEO_FORMAT_YUV9},
+  {WL_KMS_FORMAT_YVU410, GST_VIDEO_FORMAT_YVU9},
+  {WL_KMS_FORMAT_YUV411, GST_VIDEO_FORMAT_Y41B},
+  {WL_KMS_FORMAT_YUV420, GST_VIDEO_FORMAT_I420},
+  {WL_KMS_FORMAT_YVU420, GST_VIDEO_FORMAT_YV12},
+  {WL_KMS_FORMAT_YUV422, GST_VIDEO_FORMAT_Y42B},
+  {WL_KMS_FORMAT_YUV444, GST_VIDEO_FORMAT_v308},
+};
+
 static const wl_ShmVideoFormat shm_formats[] = {
 #if G_BYTE_ORDER == G_BIG_ENDIAN
   {WL_SHM_FORMAT_XRGB8888, GST_VIDEO_FORMAT_xRGB},
@@ -175,3 +223,34 @@ gst_wl_dmabuf_format_to_string (guint wl_format)
   return gst_video_format_to_string
       (gst_wl_dmabuf_format_to_video_format (wl_format));
 }
+
+GstVideoFormat
+gst_wl_kms_format_to_video_format (guint wl_format)
+{
+  guint i;
+
+  for (i = 0; i < G_N_ELEMENTS (kms_formats); i++)
+    if (kms_formats[i].wl_format == wl_format)
+      return kms_formats[i].gst_format;
+
+  GST_WARNING ("gst video format not found");
+  return GST_VIDEO_FORMAT_UNKNOWN;
+}
+
+const gchar *
+gst_wl_kms_format_to_string (guint wl_format)
+{
+  return gst_video_format_to_string
+      (gst_wl_kms_format_to_video_format (wl_format));
+}
+guint
+gst_video_format_to_wl_kms_format (GstVideoFormat format)
+{
+  guint i;
+  for (i = 0; i < G_N_ELEMENTS (kms_formats); i++)
+    if (kms_formats[i].gst_format == format)
+      return kms_formats[i].wl_format;
+
+  GST_WARNING ("wayland video format not found");
+  return -1;
+}
diff --git a/ext/wayland/wlvideoformat.h b/ext/wayland/wlvideoformat.h
index 331f582..a2bb594 100644
--- a/ext/wayland/wlvideoformat.h
+++ b/ext/wayland/wlvideoformat.h
@@ -37,6 +37,10 @@ GstVideoFormat gst_wl_dmabuf_format_to_video_format (guint wl_format);
 const gchar *gst_wl_shm_format_to_string (enum wl_shm_format wl_format);
 const gchar *gst_wl_dmabuf_format_to_string (guint wl_format);
 
+guint gst_video_format_to_wl_kms_format (GstVideoFormat format);
+GstVideoFormat gst_wl_kms_format_to_video_format (guint wl_format);
+const gchar *gst_wl_kms_format_to_string (enum wl_shm_format wl_format);
+
 G_END_DECLS
 
 #endif
-- 
1.9.1

