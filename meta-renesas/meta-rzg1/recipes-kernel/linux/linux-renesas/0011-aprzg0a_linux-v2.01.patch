diff --git a/arch/arm/boot/dts/r8a7745-aprzg0a.dts b/arch/arm/boot/dts/r8a7745-aprzg0a.dts
index ea49e74..be452c7 100644
--- a/arch/arm/boot/dts/r8a7745-aprzg0a.dts
+++ b/arch/arm/boot/dts/r8a7745-aprzg0a.dts
@@ -18,11 +18,15 @@
 // #define LCD_KIT_D01
 // #define LCD_KIT_D02
 
+/* WM-RP */
+#define WMRP_0xS
+// #define WMRP_10
+
 /* USB */
 // #define USB0_HOSTMODE
 
 / {
-	model = "AP-RZG-0A Board (BSP : Ver2.0)";
+	model = "AP-RZG-0A Board (BSP : Ver2.1)";
 	compatible = "ap,aprzg0a", "renesas,r8a7745";
 
 	aliases {
@@ -468,7 +472,7 @@
 	renesas,rx-fifo-size = <256>;
 	renesas,dtdl = <50>;
 	renesas,syncdl = <50>;
-
+#if defined(WMRP_0xS)
 	wmrp0x_spi: wmrp0x_spi@0 {
     		compatible = "apj,wmrp0x_spi";
 		reg = <0>;		
@@ -483,6 +487,23 @@
 
 		status = "okay";
 	};
+#endif
+
+#if defined(WMRP_10)
+	wmrp10_spi: wmrp10_spi@0 {
+    		compatible = "apj,wmrp10_spi";
+		reg = <0>;		
+		spi-max-frequency = <25000000>;
+		/* spi-cpha; */
+		/* spi-cpol; */
+
+		interrupt-parent = <&irqc0>;
+		interrupts = <5 IRQ_TYPE_LEVEL_HIGH>;
+
+		status = "okay";
+	};
+#endif
+
 };
 
 &vin0 {
diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index e06f5b1..47d0954 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -286,5 +286,7 @@ source "drivers/net/wireless/mwifiex/Kconfig"
 source "drivers/net/wireless/cw1200/Kconfig"
 source "drivers/net/wireless/rsi/Kconfig"
 source "drivers/net/wireless/wmrp0xs/Kconfig"
+source "drivers/net/wireless/wmrp10/Kconfig"
+
 
 endif # WLAN
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index 2699d90..46df8f6 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -61,4 +61,6 @@ obj-$(CONFIG_BRCMSMAC)	+= brcm80211/
 obj-$(CONFIG_CW1200)	+= cw1200/
 obj-$(CONFIG_RSI_91X)	+= rsi/
 obj-$(CONFIG_WMRP0X_SPI) += wmrp0xs/
+obj-$(CONFIG_WMRP10_SPI) += wmrp10/
+
 
diff --git a/drivers/net/wireless/wmrp10/Kconfig b/drivers/net/wireless/wmrp10/Kconfig
new file mode 100644
index 0000000..cae981b
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/Kconfig
@@ -0,0 +1,10 @@
+config WMRP10_SPI
+	bool "WM-RP-10"
+	depends on SPI
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	select CFG80211
+	help
+	  Redpine
+
+
diff --git a/drivers/net/wireless/wmrp10/Makefile b/drivers/net/wireless/wmrp10/Makefile
new file mode 100644
index 0000000..7ea0d2a
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/Makefile
@@ -0,0 +1,21 @@
+######################################################################
+#                                                                    #
+#   Makefile                                                         #
+#                                                                    #
+#   2016/09/29 Create(AlphaProject)                                  #
+#                                                                    #
+######################################################################
+
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include
+EXTRA_CFLAGS += -DRSI_HAL
+
+obj-$(CONFIG_WMRP10_SPI) += wmrp10_spi.o wmrp10_apis/ wmrp10_apis/apis/hal/src/ wmrp10_apis/apis/intf/spi/src/ wmrp10_apis/apis/wlan/core/src/  wmrp10_apis/apis/bt/core/src/ wmrp10_apis/apis/ble/core/src/
+
+wmrp10_spi-objs := wmrp10.o wmrp10_ioctl.o
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10.c b/drivers/net/wireless/wmrp10/wmrp10.c
new file mode 100644
index 0000000..776fd77
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10.c
@@ -0,0 +1,3888 @@
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/ieee80211.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/semaphore.h>
+#include <linux/sched.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/version.h>
+#include <net/iw_handler.h>
+#include <net/cfg80211.h>
+
+#ifdef CONFIG_USE_OF
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "wmrp10.h"
+#include "wmrp10_ioctl.h"
+#include "wmrp10_apis/wmrp10_apis.h"
+#include "wmrp10_apis/wmrp10_rsi.h"
+#include "wmrp10_apis/wmrp10_bt_rsi.h"
+
+#define WMRP10_DEBUG 0
+
+struct wmrp10_platform_data
+{
+    int (*get_irq_pin_state)(void);
+    int poll_period;
+};
+
+/* 関数 */
+int16 wmrp10_app_cfg(struct wmrp10_priv *priv);
+int16 wmrp10_app_init(void);
+int16 wmrp10_app_exit(void);
+int16 wmrp10_app_start(unsigned char *macaddr);
+int16 wmrp10_app_wps(void);
+int16 wmrp10_app_rsi_query_net_parms(rsi_qryNetParmsFrameRcv *rsp);
+int16 wmrp10_app_rsi_query_fw_version(rsi_qryFwversionFrameRcv *rsp);
+int16 wmrp10_app_upgrade_fw(uint8 *fw_image, uint32 fw_image_size);
+
+static int16 wmrp10_app_init_InfraMode(unsigned char *macaddr);
+static int16 wmrp10_app_init_ApMode(unsigned char *macaddr);
+static int16 wmrp10_app_init_wfd(unsigned char *macaddr);
+static int16 wmrp10_app_wfd_connect(void);
+static int16 wmrp10_app_connect(void);
+static int16 wmrp10_app_create(void);
+static int16 wmrp10_process(struct wmrp10_priv *priv);
+#if 0  /* コンパイラの警告対応(未使用関数) */
+static int16 wmrp10_app_disconnect(void);
+#endif
+
+/** Global Variables */
+struct spi_device *g_wmrp_spi;
+t_wmrp10_cfg_prm g_wmrp_param;
+unsigned char g_wmrp_macflg;
+
+static unsigned char s_eap_flag=0;
+static t_wmrp10_cfg_prm s_cfg_prm;
+static int s_ch24[14];
+static int s_ch5[4];
+static unsigned char s_mode;
+
+int g_oper_flag = 0;
+int g_prm_flag = WMRP10_PARAM_SET_NONE;
+int g_frame_read_type = WMRP10_WLAN_FRAME;
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_cfg()                                                */
+/*      WLANコンフィグレーション設定                                    */
+/*      input   :  prm   設定パラメータ                               */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_app_cfg(struct wmrp10_priv *priv)
+{
+    /* mode と band の チェック */
+    switch(priv->mode)
+    {
+        case WMRP10_WIFIDIRECT:
+            break;
+        case WMRP10_INFRASTRUCTURE:
+            switch(priv->band)
+            {
+                case RSI_BAND_2P4GHZ:
+                case RSI_BAND_5GHZ:
+                case RSI_DUAL_BAND:
+                    break;
+                default:
+                    return WMRP10_ERR_ABORT;
+            }
+            break;
+        case WMRP10_ACCESS_POINT:
+            switch(priv->band)
+            {
+                case RSI_BAND_2P4GHZ:
+                case RSI_BAND_5GHZ:
+                    break;
+                default:
+                    return WMRP10_ERR_ABORT;
+            }
+            break;
+        default:
+            return WMRP10_ERR_ABORT;
+    }
+
+    /* セキュリティのチェック */
+    switch(priv->mode)
+    {
+        case WMRP10_INFRASTRUCTURE:
+            switch(priv->security_mode)
+            {
+                case WMRP10_SECURITY_OPEN:
+                case WMRP10_SECURITY_WPA:
+                case WMRP10_SECURITY_WPA2:
+                case WMRP10_SECURITY_WEP:
+                case WMRP10_SECURITY_WPAWPA2: 
+                    break;
+                case WMRP10_SECURITY_EAP_WPA:
+                case WMRP10_SECURITY_EAP_WPA2:
+                    s_eap_flag = 1;
+                    break;
+                default:
+                    return WMRP10_ERR_ABORT;
+            }
+            break;
+        case WMRP10_ACCESS_POINT:
+            switch(priv->security_mode)
+            {
+                case WMRP10_SECURITY_OPEN:
+                case WMRP10_SECURITY_WPA:
+                case WMRP10_SECURITY_WPA2:
+                case WMRP10_SECURITY_WEP:
+                case WMRP10_SECURITY_WPA_CCMP:
+                case WMRP10_SECURITY_WPA2_CCMP:
+                    break;
+                default:
+                    return WMRP10_ERR_ABORT;
+            }
+            break;
+        case WMRP10_WIFIDIRECT:
+            break;
+        default:
+            break;
+    }
+    
+    /* チャンネルのチェック */
+    if(((0 >= priv->channel)   && (priv->channel >= 13)) &&
+       ((36 >= priv->channel)  && (priv->channel >= 64))&&
+       ((100 >= priv->channel) && (priv->channel >= 165))
+       )
+    {
+        return WMRP10_ERR_ABORT;
+    }
+    
+    s_cfg_prm.mode = priv->mode;
+    s_cfg_prm.band = priv->band;
+    
+    /* 外部アンテナ使用時 */
+    if(priv->antenna != 0)
+    {
+        s_cfg_prm.antenna_enable = 0x01;  
+        s_cfg_prm.antenna_type = priv->antenna;
+    }
+    /* SSID */
+    memcpy(s_cfg_prm.ssid,priv->essid,sizeof(s_cfg_prm.ssid));
+    /* Security mode */
+    s_cfg_prm.sec = priv->security_mode;
+    
+    /* PSK */
+    memcpy(s_cfg_prm.psk,priv->keys[0],sizeof(priv->keys[0]));
+    
+    /* Region */
+    s_cfg_prm.region_code_infra = priv->region;
+    switch (priv->region)
+    {
+        case 1: /* US */
+            if(priv->band == RSI_BAND_2P4GHZ)
+            {
+                memcpy(s_cfg_prm.region_country_code_ap24,"US ",3);
+                s_cfg_prm.region_channel_info_ap24[0].first_channel = 1;
+                s_cfg_prm.region_channel_info_ap24[0].no_of_channels = 11;
+                s_cfg_prm.region_channel_info_ap24[0].max_tx_power = 27;
+            }
+            else if(priv->band == RSI_BAND_5GHZ)
+            {
+                s_cfg_prm.region_no_of_rules_ap5 = 5;
+                memcpy(s_cfg_prm.region_country_code_ap5,"US ",3);
+                s_cfg_prm.region_channel_info_ap5[0].first_channel = 36;
+                s_cfg_prm.region_channel_info_ap5[0].no_of_channels = 4;
+                s_cfg_prm.region_channel_info_ap5[0].max_tx_power = 16;
+                s_cfg_prm.region_channel_info_ap5[1].first_channel = 52;
+                s_cfg_prm.region_channel_info_ap5[1].no_of_channels = 4;
+                s_cfg_prm.region_channel_info_ap5[1].max_tx_power = 23;
+                s_cfg_prm.region_channel_info_ap5[2].first_channel = 100;
+                s_cfg_prm.region_channel_info_ap5[2].no_of_channels = 5;
+                s_cfg_prm.region_channel_info_ap5[2].max_tx_power = 23;
+                s_cfg_prm.region_channel_info_ap5[3].first_channel = 132;
+                s_cfg_prm.region_channel_info_ap5[3].no_of_channels = 3;
+                s_cfg_prm.region_channel_info_ap5[3].max_tx_power = 23;
+                s_cfg_prm.region_channel_info_ap5[4].first_channel = 149;
+                s_cfg_prm.region_channel_info_ap5[4].no_of_channels = 5;
+                s_cfg_prm.region_channel_info_ap5[4].max_tx_power = 29;
+            }
+            break;
+        case 2: /* EU */
+            if(priv->band == RSI_BAND_2P4GHZ)
+            {
+                memcpy(s_cfg_prm.region_country_code_ap24,"EU ",3);
+                s_cfg_prm.region_channel_info_ap24[0].first_channel = 1;
+                s_cfg_prm.region_channel_info_ap24[0].no_of_channels = 13;
+                s_cfg_prm.region_channel_info_ap24[0].max_tx_power = 20;
+            }
+            else if(priv->band == RSI_BAND_5GHZ)
+            {
+                s_cfg_prm.region_no_of_rules_ap5 = 3;
+                memcpy(s_cfg_prm.region_country_code_ap5,"EU ",3);
+                s_cfg_prm.region_channel_info_ap5[0].first_channel = 36;
+                s_cfg_prm.region_channel_info_ap5[0].no_of_channels = 4;
+                s_cfg_prm.region_channel_info_ap5[0].max_tx_power = 23;
+                s_cfg_prm.region_channel_info_ap5[1].first_channel = 52;
+                s_cfg_prm.region_channel_info_ap5[1].no_of_channels = 4;
+                s_cfg_prm.region_channel_info_ap5[1].max_tx_power = 23;
+                s_cfg_prm.region_channel_info_ap5[2].first_channel = 100;
+                s_cfg_prm.region_channel_info_ap5[2].no_of_channels = 11;
+                s_cfg_prm.region_channel_info_ap5[2].max_tx_power = 30;
+            }
+            break;
+         case 3: /* JP */
+            if(priv->band == RSI_BAND_2P4GHZ)
+            {
+                memcpy(s_cfg_prm.region_country_code_ap24,"JP ",3);
+                s_cfg_prm.region_channel_info_ap24[0].first_channel = 1;
+                s_cfg_prm.region_channel_info_ap24[0].no_of_channels = 13;
+                s_cfg_prm.region_channel_info_ap24[0].max_tx_power = 20;
+            }
+            else if(priv->band == RSI_BAND_5GHZ)
+            {
+                s_cfg_prm.region_no_of_rules_ap5 = 3;
+                memcpy(s_cfg_prm.region_country_code_ap5,"JP ",3);
+                s_cfg_prm.region_channel_info_ap5[0].first_channel = 36;
+                s_cfg_prm.region_channel_info_ap5[0].no_of_channels = 4;
+                s_cfg_prm.region_channel_info_ap5[0].max_tx_power = 20;
+                s_cfg_prm.region_channel_info_ap5[1].first_channel = 52;
+                s_cfg_prm.region_channel_info_ap5[1].no_of_channels = 4;
+                s_cfg_prm.region_channel_info_ap5[1].max_tx_power = 20;
+                s_cfg_prm.region_channel_info_ap5[2].first_channel = 100;
+                s_cfg_prm.region_channel_info_ap5[2].no_of_channels = 11;
+                s_cfg_prm.region_channel_info_ap5[2].max_tx_power = 30;
+            }
+            break;
+        default:
+            break;
+    }
+    s_cfg_prm.region_no_of_rules_ap24 = 1;
+    
+    /* channel */
+    s_cfg_prm.ch = priv->channel;
+    
+    /* tx pow */
+    if(priv->txpower < 10)
+    {
+        s_cfg_prm.power = RSI_POWER_LEVEL_LOW;
+    }
+    else if(priv->txpower < 15)
+    {
+        s_cfg_prm.power = RSI_POWER_LEVEL_MEDIUM;
+    }
+    else if(priv->txpower >= 15)
+    {
+        s_cfg_prm.power = RSI_POWER_LEVEL_HIGH;
+    }
+    
+    /* hide */
+    s_cfg_prm.hidden = priv->hidden;
+
+    /* WPS */
+    s_cfg_prm.wps_mode = priv->wps_mode;
+    strcpy((char *)s_cfg_prm.pin,priv->pin);
+    
+    /* EAP */
+    strcpy((char *)s_cfg_prm.method,priv->eap_method);
+    strcpy((char *)s_cfg_prm.inner,priv->inner);
+    strcpy((char *)s_cfg_prm.username,priv->username); 
+    strcpy((char *)s_cfg_prm.password,priv->password);
+    
+    /* WFD */
+    s_cfg_prm.gointent = priv->gointent;
+    strcpy((char *)s_cfg_prm.devicename,priv->devicename);
+    
+    /* Timeout */
+    s_cfg_prm.timeout_other = 10000;
+    s_cfg_prm.timeout_scan  = 10000;
+    s_cfg_prm.timeout_join  = 10000;
+    s_cfg_prm.timeout_wps_join  = 100000;
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_init()                                               */
+/*      WLANモジュール初期化                                          */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_app_init(void)
+{
+    int16 retval;
+    uint16 err_code;
+    uint8 tri_auto_flg;
+    
+    g_oper_flag = 0;
+    s_mode = 0xFF;
+    
+    /***** WLANモジュール初期化 *****/
+    retval = wmrp10_apis_init();
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        return retval;
+    }
+    
+    /***** Linux　sem 初期化 *****/
+    retval = wmrp10_rsi_sys_init();
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        return retval;
+    }
+    
+    /***** board ready待ち *****/
+    do
+    {
+        retval = wmrp10_rsi_waitfor_boardready();
+        if(retval == WMRP10_ERR_ABORT)
+        {
+            wmrp10_app_exit();
+            return retval;
+        }
+    }while(retval == WMRP10_ERR_NOT_READY);
+    
+    /***** bootup *****/
+    retval = wmrp10_rsi_select_option(RSI_LOAD_IMAGE_I_FW,
+                                      &tri_auto_flg,
+                                      &err_code,
+                                      10000);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_exit();
+        return retval;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_exit()                                               */
+/*      WLANモジュール終了処理                                        */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_app_exit(void)
+{
+    int16 ret;
+    
+    ret = wmrp10_apis_exit();
+    if(ret != WMRP10_ERR_SUCCESS)
+    {
+        return ret;
+    }
+    return ret;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_start()                                              */
+/*      WLANモジュール開始処理                                        */
+/*      input   :  macaddr  WLANモジュールのMACアドレス格納先           */
+/*      return  :  0        成功                                    */
+/*              :  < 0      失敗                                    */
+/*------------------------------------------------------------------*/
+int16 wmrp10_app_start(unsigned char *macaddr)
+{
+    int16 ret;
+    
+    /***** WLAN動作モードごとの処理 *****/
+    switch(s_cfg_prm.mode)
+    {
+        /* インフラストラクチャーモード */
+        case WMRP10_INFRASTRUCTURE:
+            /* インフラストラクチャーモード設定 */
+            ret = wmrp10_app_init_InfraMode(macaddr);
+            if(ret != WMRP10_ERR_SUCCESS)
+            {
+                return ret;
+            }
+            
+            /* アクセスポイントへ接続 */
+            ret = wmrp10_app_connect();
+            if(ret != WMRP10_ERR_SUCCESS)
+            {
+                return ret;
+            }
+            
+            s_mode = WMRP10_INFRASTRUCTURE;
+            break;
+        /* アクセスポイントモード */
+        case WMRP10_ACCESS_POINT:
+            /* アクセスポイントモード設定 */
+            ret = wmrp10_app_init_ApMode(macaddr);
+            if(ret != WMRP10_ERR_SUCCESS)
+            {
+                return ret;
+            }
+            
+            /* アクセスポイント作成 */
+            ret = wmrp10_app_create();
+            if(ret != WMRP10_ERR_SUCCESS)
+            {
+                return ret;
+            }
+            
+            s_mode = WMRP10_ACCESS_POINT;
+            break;
+        /* WiFi Directモード */
+        case WMRP10_WIFIDIRECT:
+            /* WiFi Direct 設定 */
+            ret = wmrp10_app_init_wfd(macaddr);
+            if(ret != WMRP10_ERR_SUCCESS)
+            {
+                return ret;
+            }
+            
+            /* WiFi Direct接続 */
+            ret = wmrp10_app_wfd_connect();
+            if(ret != WMRP10_ERR_SUCCESS)
+            {
+                return ret;
+            }
+            
+            s_mode = WMRP10_WIFIDIRECT;
+            break;
+        default:
+            return WMRP10_ERR_ABORT;
+    }
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_wps()                                               */
+/*      WLANモジュール WPS動作開始                                   */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_app_wps(void)
+{
+    int16 retval;
+    uint16 err_code;
+    uint8 oper_state;
+    rsi_uJoin join = {0};
+    rsi_joinResponse join_rsp = {0};
+    
+    /* インフラストラクチャーモード */
+    if(s_mode == WMRP10_INFRASTRUCTURE)
+    {
+        /***** Join *****/
+        join.joinFrameSnd.powerLevel = s_cfg_prm.power;
+        oper_state = 'C';   /* Client */
+        
+        strcpy((char *)join.joinFrameSnd.ssid, "");
+        join.joinFrameSnd.ssid_len = 0;
+        join.joinFrameSnd.securityType = 0;
+        strcpy((char *)join.joinFrameSnd.psk, "");
+    }
+    /* アクセスポイントモード */
+    else if(s_mode == WMRP10_ACCESS_POINT)
+    {
+        join.joinFrameSnd.powerLevel = s_cfg_prm.power;
+        oper_state = 'G';   /* Group Orner */
+        
+        /* Band設定で処理を変更 */
+        switch(s_cfg_prm.band)
+        {
+            case RSI_BAND_2P4GHZ:
+            case RSI_BAND_5GHZ:
+                strcpy((char *)join.joinFrameSnd.ssid, s_cfg_prm.ssid);
+                join.joinFrameSnd.ssid_len = strlen(s_cfg_prm.ssid);
+                break;
+            default:
+                wmrp10_app_init();
+                return WMRP10_ERR_ABORT;
+        }
+    }
+    
+    retval = wmrp10_rsi_join(&join, &join_rsp, &err_code,
+                             s_cfg_prm.timeout_wps_join);
+#if WMRP10_DEBUG
+    printk("%s: WPS join ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if((retval != WMRP10_ERR_SUCCESS) || (join_rsp.operState != oper_state))
+    {
+        wmrp10_app_init();
+        return -1;
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_rsi_query_net_parms()                                */
+/*      WLANモジュール 接続情報取得                                   */
+/*      input   :  rsp   接続情報の格納先                            */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_app_rsi_query_net_parms(rsi_qryNetParmsFrameRcv *rsp)
+{
+    int16 retval;
+    uint16 err_code;
+    
+    retval = wmrp10_rsi_query_net_parms(rsp, &err_code,
+                                        s_cfg_prm.timeout_other);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_rsi_query_fw_version()                               */
+/*      WLANモジュール FWバージョン取得                                */
+/*      input   :  rsp  バージョン情報の格納先                        */
+/*      return  :  0    成功                                        */
+/*              :  < 0  失敗                                        */
+/*------------------------------------------------------------------*/
+int16 wmrp10_app_rsi_query_fw_version(rsi_qryFwversionFrameRcv *rsp)
+{
+    int16 retval;
+    uint16 err_code;
+    
+    /***** Get Fwversion *****/
+    retval = wmrp10_rsi_query_fw_version(rsp, &err_code,
+                                         s_cfg_prm.timeout_other);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_upgrade_fw()                                         */
+/*      WLANモジュール FWアップデート                                   */
+/*      input   :  fw_image       ファームウェアのアドレス               */
+/*              :  fw_image_size  ファームウェアのサイズ                */
+/*      return  :  0              成功                              */
+/*              :  < 0            失敗                              */
+/*------------------------------------------------------------------*/
+int16 wmrp10_app_upgrade_fw(uint8 *fw_image, uint32 fw_image_size)
+{
+    int16 retval;
+    
+    retval = WMRP10_ERR_SUCCESS;
+    
+    /***** WLANモジュール初期化 *****/
+    retval = wmrp10_apis_init();
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        return retval;
+    }
+    
+    retval = wmrp10_rsi_sys_init();
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        return retval;
+    }
+    
+    /***** board ready待ち *****/
+    do
+    {
+        retval = wmrp10_rsi_waitfor_boardready();
+        if(retval == WMRP10_ERR_ABORT)
+        {
+            return retval;
+        }
+    }while(retval == WMRP10_ERR_NOT_READY);
+
+    /***** Upgrade *****/
+    retval = wmrp10_rsi_upgrade_fw(RSI_UPGRADE_IMAGE_TYPE,
+                                   fw_image, fw_image_size);
+    
+    return retval;
+}
+
+/*-----------------------------------------------------------------*/
+/*  wmrp10_app_init_InfraMode()                                    */
+/*      WLANモジュール初期化(Infrastructure Mode)                    */
+/*      input   :  macaddr  WLANモジュールのMACアドレス格納先          */
+/*      return  :  0        成功                                    */
+/*              :  < 0      失敗                                    */
+/*------------------------------------------------------------------*/
+static int16 wmrp10_app_init_InfraMode(unsigned char *macaddr)
+{
+    int16 retval;
+    uint16 err_code;
+    uint16 coex_mode;
+    rsi_uOperMode oper = {0};
+    rsi_rejoin_params_t rejoin_params = {0};
+    rsi_initResponse init_rsp = {0};
+    rsi_usetregion setregion = {0};
+    rsi_uSetRegionRsp region_rsp = {0};
+    rsi_uPsk psk = {0};
+    rsi_uSetEap eap = {0};
+    rsi_wepkey wep = {0};
+    unsigned long feature_bit_map = 0x00000000;
+    unsigned long custom_feature_bit_map = 0x00000000;
+    unsigned long ext_custom_feature_bit_map = 0x00000000;
+    
+    if(g_oper_flag == 0)
+    {
+        /***** Set Operating Mode *****/
+        if(s_eap_flag == 1)
+        {
+            /* Enterprise mode */
+            rsi_uint32_to_4bytes(oper.operModeFrameSnd.oper_mode,2 | (coex_mode << 16));
+        }
+        else
+        {
+            /* Client mode */
+            rsi_uint32_to_4bytes(oper.operModeFrameSnd.oper_mode,0 | (coex_mode << 16));
+        }
+        
+        if(s_cfg_prm.wps_mode == WMRP10_WPS_DISABLE)
+        {
+            feature_bit_map |= 0x00000083;  /* PSK | Open | WPS Disable */
+        }
+        else
+        {
+            feature_bit_map &= ~0x00000080; /* WPS Enable */
+            feature_bit_map |= 0x00000003;  /* PSK | Open */
+        }
+        
+        rsi_uint32_to_4bytes(oper.operModeFrameSnd.tcp_ip_feature_bit_map,
+                             feature_bit_map | 0x00000001 | TCP_IP_FEAT_ICMP);  /* TCP/IP bypass */
+                             
+        custom_feature_bit_map |= 0x00000100;  /* DFS */
+        
+        /* Antenna */
+        if(s_cfg_prm.antenna_enable == 0x01)
+        {
+            custom_feature_bit_map |= 0x80000001;  /* Ext | DFS | Dual Band Roaming*/
+            ext_custom_feature_bit_map |= 0x00000001;  /* antenna */
+            
+        }
+        
+        /* Hidden */
+        if(s_cfg_prm.hidden != 0x00)
+        {
+           custom_feature_bit_map |= 0x00000020;  /* Hidden SSID */
+        }
+        
+        rsi_uint32_to_4bytes(oper.operModeFrameSnd.custom_feature_bit_map,
+                             custom_feature_bit_map);
+        
+        rsi_uint32_to_4bytes(oper.operModeFrameSnd.ext_custom_feature_bit_map,
+                             ext_custom_feature_bit_map);
+        
+        if(g_prm_flag == WMRP10_PARAM_SET_NONE) 
+        {
+            retval = wmrp10_rsi_oper_mode(&oper, &err_code,
+                                      s_cfg_prm.timeout_other);
+        
+    #if WMRP10_DEBUG
+            printk("%s: CL Operating set ->ErrCode:%x\n", __func__,err_code);
+    #endif
+            if(retval != WMRP10_ERR_SUCCESS)
+            {
+                wmrp10_app_init();
+                return retval;
+            }
+            g_oper_flag = 1;
+        }
+    }
+    else
+    {
+        g_frame_read_type = WMRP10_WLAN_FRAME;
+    }
+    /***** Band *****/
+#if WMRP10_DEBUG
+    printk("%s: CL band\n", __func__);
+#endif
+    retval = wmrp10_rsi_band(s_cfg_prm.band, &err_code,
+                             s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: CL band ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+/***** rejoin params *****/
+/* 設定なし => デフォルトで動作 */
+    rsi_uint32_to_4bytes(rejoin_params.rsi_max_try, 1);
+    rsi_uint32_to_4bytes(rejoin_params.rsi_scan_interval, 100);
+    rsi_uint32_to_4bytes(rejoin_params.rsi_beacon_missed_count, 0);
+    rsi_uint32_to_4bytes(rejoin_params.rsi_first_time_retry_enable, 0);
+    retval = wmrp10_rsi_rejoin_params(&rejoin_params, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: CL rejoin set ->ErrCode:%x\n", __func__, err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    /***** Init *****/
+    retval = wmrp10_rsi_init(&init_rsp, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: CL init ->ErrCode:%x\n", __func__, err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    memcpy(macaddr, init_rsp.macAddress1, sizeof(init_rsp.macAddress1));
+    
+    /***** Antenna Selection *****/
+    if(s_cfg_prm.antenna_enable == 0x01)
+    {
+        retval = wmrp10_rsi_select_antenna(1, /* 外部アンテナ 固定 */
+                                           s_cfg_prm.antenna_gain24,
+                                           s_cfg_prm.antenna_gain5,
+                                           2, /* 外部アンテナ 固定 */
+                                           s_cfg_prm.antenna_type,
+                                           &err_code,
+                                           s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+        printk("%s: CL Antenna select ->ErrCode:%x\n", __func__,err_code);
+#endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+            return retval;
+        }
+    }
+    else if(s_cfg_prm.antenna_enable == 0x00)
+    {
+        retval = wmrp10_rsi_select_antenna(0, /* 内部アンテナ 固定 */
+                                           s_cfg_prm.antenna_gain24,
+                                           s_cfg_prm.antenna_gain5,
+                                           1, /* 外部アンテナ 固定 */
+                                           s_cfg_prm.antenna_type,
+                                           &err_code,
+                                           s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+        printk("%s: CL Antenna select ->ErrCode:%x\n", __func__,err_code);
+#endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+            return retval;
+        }
+    }
+    
+    /***** Set Region *****/
+    setregion.setRegionFrameSnd.setregion_code_from_user_cmd = 1;
+    setregion.setRegionFrameSnd.region_code = s_cfg_prm.region_code_infra;
+    rsi_uint16_to_2bytes(setregion.setRegionFrameSnd.module_type,~(s_cfg_prm.antenna_enable));
+    retval = wmrp10_rsi_set_region(&setregion, &region_rsp, &err_code,
+                                   s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: CL region set%d ->ErrCode:%x\n", __func__, s_cfg_prm.region_code_infra, err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    /* WPS無効時のみ */
+    if(s_cfg_prm.wps_mode == WMRP10_WPS_DISABLE)
+    {
+        /* security => WEP use */
+        if(s_cfg_prm.sec == WMRP10_SECURITY_WEP)
+        {
+            /***** WEP *****/
+            rsi_uint16_to_2bytes(wep.index, 0);
+            strcpy((char *)wep.key[0], s_cfg_prm.psk);
+            retval = wmrp10_rsi_set_wepkey(&wep, &err_code,
+                                           s_cfg_prm.timeout_other);
+            if(retval != WMRP10_ERR_SUCCESS)
+            {
+                wmrp10_app_init();
+                return retval;
+            }
+        }
+        /* security => PSK use */
+        else if(s_cfg_prm.sec != WMRP10_SECURITY_OPEN)
+        {
+            /***** psk *****/
+            if(64 != strlen((char *)s_cfg_prm.psk))
+            {
+                psk.PskFrameSnd.TYPE = 1;
+                strcpy((char *)psk.PskFrameSnd.psk_or_pmk, (const char *)s_cfg_prm.psk);
+            }
+            else
+            {
+                psk.PskFrameSnd.TYPE = 2;
+                memcpy((char *)psk.PskFrameSnd.psk_or_pmk, (const char *)s_cfg_prm.psk,sizeof(s_cfg_prm.psk));
+            }
+            
+            retval = wmrp10_rsi_psk(&psk, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+            printk("%s: CL psk set ->ErrCode:%x\n", __func__,err_code);
+#endif
+            if(retval != WMRP10_ERR_SUCCESS)
+            {
+                wmrp10_app_init();
+                return retval;
+            }
+        }
+        
+        /* EAP設定 */
+        if(s_eap_flag == 1)
+        {
+            strcpy((char *)eap.setEapFrameSnd.eapMethod,    s_cfg_prm.method);
+            strcpy((char *)eap.setEapFrameSnd.innerMethod,  s_cfg_prm.inner);
+            strcpy((char *)eap.setEapFrameSnd.userIdentity, s_cfg_prm.username);
+            strcpy((char *)eap.setEapFrameSnd.password,     s_cfg_prm.password);
+            rsi_uint32_to_4bytes((uint8 *)eap.setEapFrameSnd.okc_enable, 0);
+            strcpy((char *)eap.setEapFrameSnd.private_key_passwd, s_cfg_prm.password);
+            
+            retval = wmrp10_rsi_set_eap(&eap, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+            printk("%s: CL EAP set ->ErrCode:%x\n", __func__,err_code);
+#endif
+            if(retval != WMRP10_ERR_SUCCESS)
+            {
+                wmrp10_app_init();
+                return retval;
+            }
+        }
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_init_ApMode()                                        */
+/*      WLANモジュール初期化(Access Point Mode)                       */
+/*      input   :  macaddr  WLANモジュールのMACアドレス格納先           */
+/*      return  :  0        成功                                    */
+/*              :  < 0      失敗                                    */
+/*------------------------------------------------------------------*/
+static int16 wmrp10_app_init_ApMode(unsigned char *macaddr)
+{
+    int16 retval;
+    uint16 err_code;
+    uint16 coex_mode;
+    uint16 index;
+    rsi_uOperMode oper = {0};
+    rsi_initResponse init_rsp = {0};
+    rsi_usetregion_ap_t setregion_ap = {0};
+    rsi_apconfig ap = {0};
+    rsi_uPsk psk = {0};
+    unsigned short scan_flg;
+    unsigned long feature_bit_map = 0x00000000;
+    unsigned long custom_feature_bit_map = 0x00000000;
+    unsigned long ext_custom_feature_bit_map = 0x00000000;
+    
+    scan_flg = 0;
+    if(g_oper_flag == 0)
+    {
+        /***** Set Operating Mode *****/
+        if(g_prm_flag == WMRP10_PARAM_SET_BT) 
+        {
+            coex_mode = 5;
+        }
+        else if(g_prm_flag == WMRP10_PARAM_SET_BLE)
+        {
+            coex_mode = 13;
+        }
+        
+        rsi_uint32_to_4bytes(oper.operModeFrameSnd.oper_mode,
+                             6 | (coex_mode << 16));  /* AP mode */
+        if(s_cfg_prm.wps_mode == WMRP10_WPS_DISABLE)
+        {
+            feature_bit_map |= 0x00000083;  /* PSK | Open | WPS Disable */
+        }
+        else
+        {
+            feature_bit_map &= ~0x00000080; /* WPS Enable */
+            feature_bit_map |= 0x00000003;  /* PSK | Open */
+        }
+        
+        rsi_uint32_to_4bytes(oper.operModeFrameSnd.tcp_ip_feature_bit_map,
+                             (feature_bit_map | 0x00000001));  /* TCP/IP bypass */
+        
+        custom_feature_bit_map = 0x00000100 | (8 << 13);  /* DFS | 最大接続数8 */
+        if(s_cfg_prm.antenna_enable == 0x01)
+        {
+            custom_feature_bit_map |= 0x80000000; /* Ext */
+            ext_custom_feature_bit_map |= 0x00000001;  /* antenna */
+        }
+        if(s_cfg_prm.hidden != 0x00)
+        {
+           custom_feature_bit_map |= 0x00000020;  /* Hidden SSID */
+        }
+        
+        rsi_uint32_to_4bytes(oper.operModeFrameSnd.custom_feature_bit_map,
+                             custom_feature_bit_map);
+        
+        rsi_uint32_to_4bytes(oper.operModeFrameSnd.ext_custom_feature_bit_map,
+                             ext_custom_feature_bit_map);
+        
+        retval = wmrp10_rsi_oper_mode(&oper, &err_code, s_cfg_prm.timeout_other);
+    #if WMRP10_DEBUG
+        printk("%s: Operating set ->ErrCode:%x\n", __func__,err_code);
+    #endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+            return retval;
+        }
+        
+    }
+    else
+    {
+        g_frame_read_type = WMRP10_WLAN_FRAME;
+    }
+    
+    /***** Band *****/
+    retval = wmrp10_rsi_band(s_cfg_prm.band, &err_code,
+                             s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: Band ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    /***** Init *****/
+    retval = wmrp10_rsi_init(&init_rsp, &err_code,
+                             s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: Init ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    memcpy(macaddr, init_rsp.macAddress1, sizeof(init_rsp.macAddress1));
+    
+    /***** Antenna Selection *****/
+    if(s_cfg_prm.antenna_enable == 0x01)
+    {
+        retval = wmrp10_rsi_select_antenna(1, /* 外部アンテナ 固定 */
+                                           s_cfg_prm.antenna_gain24,
+                                           s_cfg_prm.antenna_gain5,
+                                           2, /* 外部アンテナ 固定 */
+                                           s_cfg_prm.antenna_type,
+                                           &err_code,
+                                           s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+        printk("%s: Antenna select ->ErrCode:%x\n", __func__,err_code);
+#endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+            return retval;
+        }
+    }
+    
+    /***** Antenna Selection *****/
+    psk.PskFrameSnd.TYPE = 3;
+    strcpy((char *)psk.PskFrameSnd.psk_or_pmk,s_cfg_prm.psk);
+    strcpy((char *)psk.PskFrameSnd.ap_ssid, s_cfg_prm.ssid);
+    
+    retval = wmrp10_rsi_psk(&psk, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: psk set ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    /***** Set Region AP *****/
+    setregion_ap.setRegionApFrameSnd.setregion_code_from_user_cmd = 1;
+    switch(s_cfg_prm.band)
+    {
+        case RSI_BAND_2P4GHZ:
+            memcpy(setregion_ap.setRegionApFrameSnd.country_code,
+                   s_cfg_prm.region_country_code_ap24, 3);
+            rsi_uint32_to_4bytes(setregion_ap.setRegionApFrameSnd.no_of_rules,
+                                 s_cfg_prm.region_no_of_rules_ap24);
+            for(index = 0; index < s_cfg_prm.region_no_of_rules_ap24; index++)
+            {
+                setregion_ap.setRegionApFrameSnd.channel_info[index].first_channel =
+                               s_cfg_prm.region_channel_info_ap24[index].first_channel;
+                setregion_ap.setRegionApFrameSnd.channel_info[index].no_of_channels =
+                               s_cfg_prm.region_channel_info_ap24[index].no_of_channels;
+                setregion_ap.setRegionApFrameSnd.channel_info[index].max_tx_power =
+                               s_cfg_prm.region_channel_info_ap24[index].max_tx_power;
+            }
+            break;
+        case RSI_BAND_5GHZ:
+            memcpy(setregion_ap.setRegionApFrameSnd.country_code,
+                   s_cfg_prm.region_country_code_ap5, 3);
+            rsi_uint32_to_4bytes(setregion_ap.setRegionApFrameSnd.no_of_rules,
+                                 s_cfg_prm.region_no_of_rules_ap5);
+            for(index = 0; index < s_cfg_prm.region_no_of_rules_ap5; index++)
+            {
+                setregion_ap.setRegionApFrameSnd.channel_info[index].first_channel =
+                               s_cfg_prm.region_channel_info_ap5[index].first_channel;
+                setregion_ap.setRegionApFrameSnd.channel_info[index].no_of_channels =
+                               s_cfg_prm.region_channel_info_ap5[index].no_of_channels;
+                setregion_ap.setRegionApFrameSnd.channel_info[index].max_tx_power =
+                               s_cfg_prm.region_channel_info_ap5[index].max_tx_power;
+            }
+            break;
+        default:
+            wmrp10_app_init();
+            return WMRP10_ERR_ABORT;
+    }
+    retval = wmrp10_rsi_set_region_ap(&setregion_ap, &err_code,
+                                      s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: Region ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    /***** Configure AP Mode *****/
+    rsi_uint16_to_2bytes(ap.channel_no, s_cfg_prm.ch);
+    rsi_uint16_to_2bytes(ap.beacon_interval, 100);
+    rsi_uint16_to_2bytes(ap.dtim_period, 1);
+    ap.ap_keepalive_type = 0;
+    ap.ap_keepalive_period = 100;
+    rsi_uint16_to_2bytes(ap.max_sta_support, 4);
+    
+    switch(s_cfg_prm.band)
+    {
+        case RSI_BAND_2P4GHZ:
+            strcpy((char *)ap.ssid, s_cfg_prm.ssid);
+            switch(s_cfg_prm.sec)
+            {
+                case WMRP10_SECURITY_OPEN:
+                    ap.security_type = 0;
+                    ap.encryp_mode = 0;
+                    strcpy((char *)ap.psk, "");
+                    break;
+                case WMRP10_SECURITY_WPA:
+                    ap.security_type = 1;
+                    if(s_cfg_prm.wps_mode != WMRP10_WPS_DISABLE)
+                    {
+                        ap.encryp_mode = 2;
+                    }
+                    else
+                    {
+                        ap.encryp_mode = 1;
+                    }
+                    strcpy((char *)ap.psk, s_cfg_prm.psk);
+                    break;
+                case WMRP10_SECURITY_WPA_CCMP:
+                    ap.security_type = 1;
+                    ap.encryp_mode = 2;
+                    strcpy((char *)ap.psk, s_cfg_prm.psk);
+                    break;
+                case WMRP10_SECURITY_WPA2:
+                    ap.security_type = 2;
+                    if(s_cfg_prm.wps_mode != WMRP10_WPS_DISABLE)
+                    {
+                        ap.encryp_mode = 2;
+                    }
+                    else
+                    {
+                        ap.encryp_mode = 1;
+                    }
+                    strcpy((char *)ap.psk, s_cfg_prm.psk);
+                    break;
+                case WMRP10_SECURITY_WPA2_CCMP:
+                    ap.security_type = 2;
+                    ap.encryp_mode = 2;
+                    strcpy((char *)ap.psk, s_cfg_prm.psk);
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case RSI_BAND_5GHZ:
+            strcpy((char *)ap.ssid, s_cfg_prm.ssid);
+            switch(s_cfg_prm.sec)
+            {
+                case WMRP10_SECURITY_OPEN:
+                    ap.security_type = 0;
+                    ap.encryp_mode = 0;
+                    strcpy((char *)ap.psk, "");
+                    break;
+                case WMRP10_SECURITY_WPA:
+                    ap.security_type = 1;
+                    if(s_cfg_prm.wps_mode != WMRP10_WPS_DISABLE)
+                    {
+                        ap.encryp_mode = 2;
+                    }
+                    else
+                    {
+                        ap.encryp_mode = 1;
+                    }
+                    strcpy((char *)ap.psk, s_cfg_prm.psk);
+                    break;
+                case WMRP10_SECURITY_WPA_CCMP:
+                    ap.security_type = 1;
+                    ap.encryp_mode = 2;
+                    strcpy((char *)ap.psk, s_cfg_prm.psk);
+                    break;
+                case WMRP10_SECURITY_WPA2:
+                    ap.security_type = 2;
+                    if(s_cfg_prm.wps_mode != WMRP10_WPS_DISABLE)
+                    {
+                        ap.encryp_mode = 2;
+                    }
+                    else
+                    {
+                        ap.encryp_mode = 1;
+                    }
+                    strcpy((char *)ap.psk, s_cfg_prm.psk);
+                    break;
+                case WMRP10_SECURITY_WPA2_CCMP:
+                    ap.security_type = 2;
+                    ap.encryp_mode = 2;
+                    strcpy((char *)ap.psk, s_cfg_prm.psk);
+                    break;
+                default:
+                    break;
+            }            break;
+        default:
+            wmrp10_app_init();
+            return WMRP10_ERR_ABORT;
+    }
+    retval = wmrp10_rsi_set_ap_config(&ap, &err_code,
+                                      s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: apConfigure ->ErrCode:%x\n", __func__, err_code);
+#endif
+    
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    return retval;
+}
+
+/*-----------------------------------------------------------------*/
+/*  wmrp10_app_init_wfd()                                          */
+/*      WLANモジュール初期化(WiFi Direct)                            */
+/*      input   :  macaddr  WLANモジュールのMACアドレス格納先          */
+/*      return  :  0        成功                                    */
+/*              :  < 0      失敗                                    */
+/*------------------------------------------------------------------*/
+static int16 wmrp10_app_init_wfd(unsigned char *macaddr)
+{
+    int16 retval;
+    uint16 err_code;
+    rsi_uOperMode oper = {0};
+    rsi_uConfigP2p p2p = {0};
+    rsi_initResponse init_rsp = {0};
+    rsi_usetregion setregion = {0};
+    rsi_uSetRegionRsp region_rsp = {0};
+    unsigned long custom_feature_bit_map = 0x00000000;
+    unsigned long ext_custom_feature_bit_map = 0x00000000;
+    
+    /***** Set Operating Mode *****/
+    rsi_uint32_to_4bytes(oper.operModeFrameSnd.oper_mode,
+                         1);  /* WiFi Direct */
+    rsi_uint32_to_4bytes(oper.operModeFrameSnd.feature_bit_map,
+                             0x00000003);  /* PSK | Open */
+    rsi_uint32_to_4bytes(oper.operModeFrameSnd.tcp_ip_feature_bit_map,
+                         0x00000001);  /* TCP/IP bypass */
+    
+    custom_feature_bit_map |= 0x00000100;  /* DFS */
+    
+    if(s_cfg_prm.antenna_enable == 0x01)
+    {
+        custom_feature_bit_map |= 0x80000100;  /* Ext | DFS */
+        ext_custom_feature_bit_map|= 0x00000001;  /* antenna */
+    }
+    
+    if(s_cfg_prm.hidden != 0x00)
+    {
+       custom_feature_bit_map |= 0x00000020;  /* Hidden SSID */
+    }
+    
+    rsi_uint32_to_4bytes(oper.operModeFrameSnd.custom_feature_bit_map,
+                         custom_feature_bit_map);
+    
+    rsi_uint32_to_4bytes(oper.operModeFrameSnd.ext_custom_feature_bit_map,
+                         ext_custom_feature_bit_map);
+    
+#if WMRP10_DEBUG
+    printk("%s: Operating set\n", __func__);
+#endif
+    retval = wmrp10_rsi_oper_mode(&oper, &err_code,
+                                  s_cfg_prm.timeout_other);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    /***** Band *****/
+#if WMRP10_DEBUG
+    printk("%s: Band\n", __func__);
+#endif
+    retval = wmrp10_rsi_band(s_cfg_prm.band, &err_code,
+                             s_cfg_prm.timeout_other);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+#if WMRP10_DEBUG
+    printk("%s: Init\n", __func__);
+#endif
+    
+    /***** Init *****/
+    retval = wmrp10_rsi_init(&init_rsp, &err_code,
+                             s_cfg_prm.timeout_other);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    memcpy(macaddr, init_rsp.macAddress1, sizeof(init_rsp.macAddress1));
+    
+    /***** Antenna Selection *****/
+    if(s_cfg_prm.antenna_enable == 0x01)
+    {
+#if WMRP10_DEBUG
+        printk("%s: Antenna select\n", __func__);
+#endif
+        retval = wmrp10_rsi_select_antenna(1, /* 外部アンテナ 固定 */
+                                           s_cfg_prm.antenna_gain24,
+                                           s_cfg_prm.antenna_gain5,
+                                           2, /* 外部アンテナ 固定 */
+                                           s_cfg_prm.antenna_type,
+                                           &err_code,
+                                           s_cfg_prm.timeout_other);
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+            return retval;
+        }
+    }
+    
+    /***** Set Region *****/
+    setregion.setRegionFrameSnd.setregion_code_from_user_cmd = 1;
+    setregion.setRegionFrameSnd.region_code = s_cfg_prm.region_code_infra;
+    rsi_uint16_to_2bytes(setregion.setRegionFrameSnd.module_type, 0x0001);
+    retval = wmrp10_rsi_set_region(&setregion, &region_rsp, &err_code,
+                                   s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: Region \n", __func__);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    /***** Set P2P config**/
+    if(sizeof(s_cfg_prm.ssid) > sizeof(p2p.configP2pFrameSnd.ssidPostFix))
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    rsi_uint16_to_2bytes(p2p.configP2pFrameSnd.GOIntent, s_cfg_prm.gointent);
+    strcpy((char *)p2p.configP2pFrameSnd.deviceName,  s_cfg_prm.devicename);
+    rsi_uint16_to_2bytes(p2p.configP2pFrameSnd.operChannel,  s_cfg_prm.ch);
+    strcpy((char *)p2p.configP2pFrameSnd.ssidPostFix, s_cfg_prm.ssid);
+    strcpy((char *)p2p.configP2pFrameSnd.psk,         s_cfg_prm.psk);
+    
+    retval = wmrp10_rsi_p2p_config(&p2p, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: P2Pconfig\n", __func__);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_connect()                                            */
+/*      WLAN接続(ScanとJoin)                                        */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+static int16 wmrp10_app_connect(void)
+{
+    int16 retval;
+    uint16 err_code;
+    rsi_uScan scan = {0};
+    rsi_scanResponse scan_rsp = {0};
+    rsi_uJoin join = {0};
+    rsi_joinResponse join_rsp = {0};
+    rsi_uWpsMethod wps = {0};
+    rsi_wpsMethodFrameRcv wps_rsp = {0};
+    rsi_ubgScan bg = {0};
+    rsi_uRoamParams roam = {0};
+    
+    /********* WPS設定 **********/
+    /* wps無効 */
+    if(s_cfg_prm.wps_mode == WMRP10_WPS_DISABLE)
+    {
+        /* 何もしない */
+    }
+    /***** Push Button *******/
+    else if(s_cfg_prm.wps_mode == WMRP10_WPS_PUSH_BUTTON)
+    {
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.wps_method, 0);
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.generate_pin, 0);
+        
+        retval = wmrp10_rsi_wps_method(&wps, &wps_rsp, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+        printk("%s: wps method ->ErrCode:%x\n", __func__,err_code);
+#endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+        }
+        /* WPS Start待機へ */
+        return retval;
+        
+    }
+    /***** WPS PIN (入力)　*****/
+    else if(s_cfg_prm.wps_mode == WMRP10_WPS_PIN)
+    {
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.wps_method, 1);
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.generate_pin, 0);
+        strcpy((char *)wps.wpsMethodFrameSnd.wps_pin, s_cfg_prm.pin);
+        
+        retval = wmrp10_rsi_wps_method(&wps, &wps_rsp, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+        printk("%s: wps method ->ErrCode:%x\n", __func__,err_code);
+#endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+        }
+        /* WPS Start待機へ */
+        return retval;
+    }
+    /***** WPS PIN (生成)　*****/
+    else if(s_cfg_prm.wps_mode == WMRP10_WPS_PIN_GENERATE)
+    {
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.wps_method, 1);
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.generate_pin, 1);
+        retval = wmrp10_rsi_wps_method(&wps, &wps_rsp, &err_code, s_cfg_prm.timeout_other);
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.generate_pin, 0);
+        strcpy((char *)wps.wpsMethodFrameSnd.wps_pin, wps_rsp.wps_pin);
+        
+        retval = wmrp10_rsi_wps_method(&wps, &wps_rsp, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+        printk("%s: wps method ->ErrCode:%x\n", __func__,err_code);
+#endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+        }
+        
+        
+        printk("Generate PIN:%s\n", wps_rsp.wps_pin);
+        /* WPS Start待機へ */
+        return retval;
+    }
+    
+    /* WPS無効 */
+    /***** Scan *****/
+    scan.scanFrameSnd.channel[0] = s_cfg_prm.ch;
+    strcpy((char *)scan.scanFrameSnd.ssid, s_cfg_prm.ssid);
+    rsi_uint16_to_2bytes(scan.scanFrameSnd.channel_bit_map_2_4,
+                         s_cfg_prm.scan_filter24_infra);
+    rsi_uint32_to_4bytes(scan.scanFrameSnd.channel_bit_map_5,
+                         s_cfg_prm.scan_filter5_infra);
+    
+    retval = wmrp10_rsi_scan(&scan, &scan_rsp, &err_code,
+                             s_cfg_prm.timeout_scan);
+#if WMRP10_DEBUG
+    printk("%s: Scan ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    /***** Join *****/
+    join.joinFrameSnd.powerLevel = s_cfg_prm.power;
+    strcpy((char *)join.joinFrameSnd.ssid, s_cfg_prm.ssid);
+    join.joinFrameSnd.ssid_len = strlen(s_cfg_prm.ssid);
+    switch(s_cfg_prm.sec)
+    {
+        case WMRP10_SECURITY_OPEN:
+            join.joinFrameSnd.securityType = 0;
+            break;
+        case WMRP10_SECURITY_WPA:
+            join.joinFrameSnd.securityType = 1;
+            break;
+        case WMRP10_SECURITY_WPA2:
+            join.joinFrameSnd.securityType = 2;
+            break;
+        case WMRP10_SECURITY_WEP:
+            join.joinFrameSnd.securityType = 3;
+            break;
+        case WMRP10_SECURITY_EAP_WPA:
+            join.joinFrameSnd.securityType = 4;
+            break;
+        case WMRP10_SECURITY_EAP_WPA2:
+            join.joinFrameSnd.securityType = 5;
+            break;
+        case WMRP10_SECURITY_WPAWPA2:
+            join.joinFrameSnd.securityType = 6;
+            break;
+        default:
+            wmrp10_app_init();
+            return WMRP10_ERR_ABORT;
+    }
+    strcpy((char *)join.joinFrameSnd.psk, "");
+    retval = wmrp10_rsi_join(&join, &join_rsp, &err_code,
+                             s_cfg_prm.timeout_join);
+#if WMRP10_DEBUG
+    printk("%s: Join ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    /* BGscanを行う場合は有効にする */
+    /* BG scan */
+    rsi_uint16_to_2bytes(bg.bgscanFrameSnd.bgscan_enable, 1);  /*Enable*/
+    rsi_uint16_to_2bytes(bg.bgscanFrameSnd.enable_instant_bgscan, 1);
+    rsi_uint16_to_2bytes(bg.bgscanFrameSnd.bgscan_threshold, 0x40);
+    rsi_uint16_to_2bytes(bg.bgscanFrameSnd.rssi_tolerance_threshold, 10);
+    rsi_uint16_to_2bytes(bg.bgscanFrameSnd.bgscan_periodicity, 4);
+    rsi_uint16_to_2bytes(bg.bgscanFrameSnd.active_scan_duration, 10);
+    rsi_uint16_to_2bytes(bg.bgscanFrameSnd.passive_scan_duration, 15);
+    bg.bgscanFrameSnd.multi_probe = 1; /* Disable */
+    
+    retval = wmrp10_rsi_bg_scan(&bg, &scan_rsp, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: BG scan ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+        return retval;
+    }
+    
+    /* Roaming */
+    rsi_uint32_to_4bytes(roam.roamParamsFrameSnd.roam_enable,1); /* Enable */
+    rsi_uint32_to_4bytes(roam.roamParamsFrameSnd.roam_threshold, 0x40);
+    rsi_uint32_to_4bytes(roam.roamParamsFrameSnd.roam_hysteresis, 10);
+    retval = wmrp10_rsi_roam_params(&roam, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+    printk("%s: Roaming ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_create()                                             */
+/*      WLAN Access Point生成(Join)                                 */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+static int16 wmrp10_app_create(void)
+{
+    int16 retval;
+    uint16 err_code;
+    rsi_uJoin join = {0};
+    rsi_joinResponse join_rsp = {0};
+    rsi_uWpsMethod wps = {0};
+    rsi_wpsMethodFrameRcv wps_rsp = {0};
+    join.joinFrameSnd.powerLevel = s_cfg_prm.power;
+    
+    /********* WPS設定 **********/
+    /* wps無効 */
+    if(s_cfg_prm.wps_mode == WMRP10_WPS_DISABLE)
+    {
+        /* 何もしない */
+    }
+    /***** Push Button *******/
+    else if(s_cfg_prm.wps_mode == WMRP10_WPS_PUSH_BUTTON)
+    {
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.wps_method, 0);
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.generate_pin, 0);
+        
+        retval = wmrp10_rsi_wps_method(&wps, &wps_rsp, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+        printk("%s: wps method ->ErrCode:%x\n", __func__,err_code);
+#endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+        }
+        /* WPS Start待機へ */
+        
+    }
+    /***** WPS PIN (入力)　*****/
+    else if(s_cfg_prm.wps_mode == WMRP10_WPS_PIN)
+    {
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.wps_method, 1);
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.generate_pin, 0);
+        strcpy((char *)wps.wpsMethodFrameSnd.wps_pin, s_cfg_prm.pin);
+        retval = wmrp10_rsi_wps_method(&wps, &wps_rsp, &err_code, s_cfg_prm.timeout_other);
+#if WMRP10_DEBUG
+        printk("%s: wps method ->ErrCode:%x\n", __func__,err_code);
+#endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+        }
+        /* WPS Start待機へ */
+    }
+    /***** WPS PIN (生成)　*****/
+    else if(s_cfg_prm.wps_mode == WMRP10_WPS_PIN_GENERATE)
+    {
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.wps_method, 1);
+        rsi_uint16_to_2bytes(wps.wpsMethodFrameSnd.generate_pin, 1);
+        retval = wmrp10_rsi_wps_method(&wps, &wps_rsp, &err_code, s_cfg_prm.timeout_other);
+        
+#if WMRP10_DEBUG
+        printk("%s: wps method ->ErrCode:%x\n", __func__,err_code);
+#endif
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            wmrp10_app_init();
+        }
+        
+        
+        printk("Generate PIN:%s\n", wps_rsp.wps_pin);
+        /* WPS Start待機へ */
+    }
+    
+    /***** Join *****/
+    switch(s_cfg_prm.band)
+    {
+        case RSI_BAND_2P4GHZ:
+            strcpy((char *)join.joinFrameSnd.ssid, s_cfg_prm.ssid);
+            join.joinFrameSnd.ssid_len = strlen(s_cfg_prm.ssid);
+            switch(s_cfg_prm.sec)
+            {
+                case WMRP10_SECURITY_OPEN:
+                    join.joinFrameSnd.securityType = 0;
+                    break;
+                case WMRP10_SECURITY_WPA:
+                case WMRP10_SECURITY_WPA_CCMP:
+                    join.joinFrameSnd.securityType = 1;
+                    break;
+                case WMRP10_SECURITY_WPA2:
+                case WMRP10_SECURITY_WPA2_CCMP:
+                    join.joinFrameSnd.securityType = 2;
+                    break;
+                default:
+                    wmrp10_app_init();
+                    return WMRP10_ERR_ABORT;
+            }
+            strcpy((char *)join.joinFrameSnd.psk, "");
+            break;
+        case RSI_BAND_5GHZ:
+            strcpy((char *)join.joinFrameSnd.ssid, s_cfg_prm.ssid);
+            join.joinFrameSnd.ssid_len = strlen(s_cfg_prm.ssid);
+            switch(s_cfg_prm.sec)
+            {
+                case WMRP10_SECURITY_OPEN:
+                    join.joinFrameSnd.securityType = 0;
+                    break;
+                case WMRP10_SECURITY_WPA:
+                case WMRP10_SECURITY_WPA_CCMP:
+                    join.joinFrameSnd.securityType = 1;
+                    break;
+                case WMRP10_SECURITY_WPA2:
+                case WMRP10_SECURITY_WPA2_CCMP:
+                    join.joinFrameSnd.securityType = 2;
+                    break;
+                default:
+                    wmrp10_app_init();
+                    return WMRP10_ERR_ABORT;
+            }
+            strcpy((char *)join.joinFrameSnd.psk, "");
+            break;
+        default:
+            wmrp10_app_init();
+            return WMRP10_ERR_ABORT;
+    }
+    retval = wmrp10_rsi_join(&join, &join_rsp, &err_code,
+                             s_cfg_prm.timeout_join);
+#if WMRP10_DEBUG
+    printk("%s: Join ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+    }
+
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_wfd_connect()                                        */
+/*      Wifi Direct接続(Join)                                       */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+static int16 wmrp10_app_wfd_connect(void)
+{
+    int16 retval;
+    uint16 err_code;
+    rsi_uJoin join = {0};
+    rsi_joinResponse join_rsp = {0};
+    T_MYMSG_MSG msg_rsp;
+    
+    /* Wi-Fi Directの非同期レスポンス待ち */
+    retval = wmrp10_rsi_msg(&msg_rsp, 50000);
+    
+    switch (msg_rsp.response_type)
+    {
+        case RSI_RESP_WFD_DEV:
+            strcpy((char *)join.joinFrameSnd.ssid,
+                   (const char *)msg_rsp.msg.wfdDevResponse.strWfdDevInfo[0].devName);
+            join.joinFrameSnd.ssid_len = strlen((const char *)join.joinFrameSnd.ssid);
+            break;
+        case RSI_RSP_P2P_CONNREQ:
+            strcpy((char *)join.joinFrameSnd.ssid,
+                   (const char *)msg_rsp.msg.ConnAcceptRcv.dev_name);
+            join.joinFrameSnd.ssid_len = strlen((const char *)join.joinFrameSnd.ssid);
+            break;
+        default:
+            break;
+    }
+    
+    /***** Join *****/
+    join.joinFrameSnd.powerLevel = s_cfg_prm.power;
+    
+    strcpy((char *)join.joinFrameSnd.psk, "");
+    retval = wmrp10_rsi_join(&join, &join_rsp, &err_code,
+                             /*s_cfg_prm.timeout_join*/100000);
+    
+#if WMRP10_DEBUG
+    printk("%s: Join ->ErrCode:%x\n", __func__,err_code);
+#endif
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+    }
+    
+    return retval;
+}
+
+
+#if 0  /* コンパイラの警告対応(未使用関数) */
+/*------------------------------------------------------------------*/
+/*  wmrp10_app_disconnect()                                         */
+/*      WLAN接続終了                                                */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+static int16 wmrp10_app_disconnect(void)
+{
+    int16 retval;
+    uint16 err_code;
+    rsi_disassoc_t disassoc = {0};
+
+    retval = wmrp10_rsi_disconnect(&disassoc, &err_code,
+                                   s_cfg_prm.timeout_other);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_app_init();
+    }
+
+    return retval;
+}
+#endif
+
+/***** iwconfig rateの有効値 *****/
+static const int wmrp10_bitrates[] = {
+        10, 20, 55, 110,
+        60, 90, 120, 180, 240, 360, 480, 540,
+        65, 130, 195, 260, 390, 520, 585, 650,
+};
+
+/***** iwconfig txpowの有効値 *****/
+static const int wmrp10_txpowers[] = {
+        6, 8, 9, 10, 12, 14, 15, 17
+};
+
+/* iw_handler の get_name */
+static int wmrp10_get_name(struct net_device *ndev,
+                           struct iw_request_info *info,
+                           union iwreq_data *wrqu, char *extra)
+{
+    strcpy(wrqu->name, "IEEE 802.11abgn");
+    
+    return 0;
+}
+
+/* iw_handler の set_mode */
+static int wmrp10_set_mode(struct net_device *ndev,
+                           struct iw_request_info *info,
+                           union iwreq_data *wrqu, char *extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_mode() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    switch(wrqu->mode)
+    {
+        case IW_MODE_AUTO:
+            ret = -EINVAL;
+            break;
+        case IW_MODE_ADHOC:
+#if WMRP10_DEBUG
+            printk("set_mode = IW_MODE_ADHOC\n");
+#endif /* WMRP10_DEBUG */
+            priv->mode = wrqu->mode;
+            break;
+        case IW_MODE_MASTER:
+#if WMRP10_DEBUG
+            printk("set_mode = IW_MODE_MASTER\n");
+#endif /* WMRP10_DEBUG */
+            priv->mode = wrqu->mode;
+            break;
+        case IW_MODE_INFRA:
+#if WMRP10_DEBUG
+            printk("set_mode = IW_MODE_INFRA\n");
+#endif /* WMRP10_DEBUG */
+            priv->mode = wrqu->mode;
+            break;
+        default:
+            ret = -EINVAL;
+            break;
+    }
+    
+    return ret;
+}
+
+/* iw_handler の get_mode */
+static int wmrp10_get_mode(struct net_device *ndev,
+                           struct iw_request_info *info,
+                           union iwreq_data *wrqu, char *extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_mode() *****\n");
+#endif /* WMRP10_DEBUG */
+    wrqu->mode = priv->mode;
+    return 0;
+}
+
+/* iw_handler の set_freq */
+static int wmrp10_set_freq(struct net_device *ndev,
+                           struct iw_request_info *info,
+                           union iwreq_data *wrqu, char *extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    struct iw_freq *freq = &wrqu->freq;
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_freq() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if(freq->m == 0)
+    {
+        /* auto = DUAL BAND */
+#if WMRP10_DEBUG
+        printk("set_freq = auto\n");
+#endif /* WMRP10_DEBUG */
+        priv->channel = freq->m;
+        priv->band = RSI_DUAL_BAND; 
+    }
+    else if((freq->m >= 1) && (freq->m <= 13))
+    {
+#if WMRP10_DEBUG
+        printk("set_freq(2.4GHz) = %d\n", freq->m);
+#endif /* WMRP10_DEBUG */
+        priv->channel = freq->m;
+        priv->band = RSI_BAND_2P4GHZ;
+    }
+    else if((freq->m == 36)  || (freq->m == 40)  ||
+            (freq->m == 44)  || (freq->m == 48)  ||
+            (freq->m == 52)  || (freq->m == 56)  ||
+            (freq->m == 60)  || (freq->m == 64)  ||
+            (freq->m == 100) || (freq->m == 104) ||
+            (freq->m == 108) || (freq->m == 112) ||
+            (freq->m == 116) || (freq->m == 120) ||
+            (freq->m == 124) || (freq->m == 128) ||
+            (freq->m == 132) || (freq->m == 136) ||
+            (freq->m == 140) || (freq->m == 144) ||
+            (freq->m == 149) || (freq->m == 153) ||
+            (freq->m == 157) || (freq->m == 161) ||
+            (freq->m == 165) )
+    {
+#if WMRP10_DEBUG
+        printk("set_freq(5GHz) = %d\n", freq->m);
+#endif /* WMRP10_DEBUG */
+        priv->channel = freq->m;
+        priv->band = RSI_BAND_5GHZ;
+    }
+    else
+    {
+        ret = -EINVAL;
+    }
+    return ret;
+}
+
+/* iw_handler の get_freq */
+static int wmrp10_get_freq(struct net_device *ndev,
+                           struct iw_request_info *info,
+                           union iwreq_data *wrqu, char *extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    struct iw_freq *freq = &wrqu->freq;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_freq() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    freq->e = 0;
+    freq->m = priv->channel;
+    
+    return 0;
+}
+
+/* iw_handler の set_range */
+static int wmrp10_get_range(struct net_device *ndev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+    struct iw_point *point = &wrqu->data;
+    struct iw_range *range = (struct iw_range *)extra;
+    int i;
+    
+    point->length = sizeof (struct iw_range);
+    memset(range, 0, sizeof (struct iw_range));
+    range->we_version_compiled = WIRELESS_EXT;
+    range->we_version_source = WIRELESS_EXT;
+    range->scan_capa =
+            IW_SCAN_CAPA_ESSID |
+            IW_SCAN_CAPA_BSSID |
+            IW_SCAN_CAPA_CHANNEL;
+    
+    IW_EVENT_CAPA_SET_KERNEL(range->event_capa);
+    IW_EVENT_CAPA_SET(range->event_capa, SIOCGIWSCAN);
+    
+    range->txpower_capa = IW_TXPOW_DBM | IW_TXPOW_RANGE;
+    range->num_txpower = ARRAY_SIZE(wmrp10_txpowers);
+    
+    for (i = 0; i < range->num_txpower; i++)
+            range->txpower[i] = wmrp10_txpowers[i];
+    
+    range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 | IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_4WAY_HANDSHAKE;
+    range->encoding_size[0] = 5;
+    range->encoding_size[1] = 13;
+    range->encoding_size[2] = 32;
+    range->num_encoding_sizes = 3;
+    
+    for (i = 0; i < 14; i++)
+    {
+        range->freq[i].i = i + 1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+        range->freq[i].m = ieee80211_channel_to_frequency(i + 1, NL80211_BAND_2GHZ) * 100000;
+#else
+        range->freq[i].m = ieee80211_dsss_chan_to_freq(i + 1) * 100000;
+#endif
+        range->freq[i].e = 1;
+    }
+    
+    range->num_channels = i;
+    range->num_frequency = i;
+    
+    for (i = 0; i < ARRAY_SIZE(wmrp10_bitrates); i++)
+    {
+        range->bitrate[i] = wmrp10_bitrates[i] * 100000;
+    }
+    range->num_bitrates = i;
+    
+    return 0;
+}
+
+/* iw_handler の set_auth */
+static int wmrp10_set_auth(struct net_device *netdev,
+                           struct iw_request_info *info,
+                           union iwreq_data *data, char *extra)
+{
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_auth() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    return 0;
+}
+
+/* iw_handler の get_auth */
+static int wmrp10_get_auth(struct net_device *netdev,
+                           struct iw_request_info *info,
+                           union iwreq_data *iwreq, char *extra)
+{
+#if WMRP10_DEBUG
+        printk("***** wmrp10_get_auth() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    return 0;
+}
+
+/* iw_handler の set_essid */
+static int wmrp10_set_essid(struct net_device *ndev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *essid)
+{
+    struct iw_point *data = &wrqu->data;
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_essid() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if(data->length > sizeof(priv->essid))
+    {
+        return -EINVAL;
+    }
+    
+    priv->essid_len = data->length;
+    memset(priv->essid, 0, sizeof (priv->essid));
+    memcpy(priv->essid, essid, priv->essid_len);
+    
+    return 0;
+}
+
+/* iw_handler の get_essid */
+static int wmrp10_get_essid(struct net_device *ndev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *essid)
+{
+    struct iw_point *data = &wrqu->data;
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_essid() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    memcpy(essid, priv->essid, priv->essid_len);
+    data->length = priv->essid_len;
+    data->flags = 1;
+    
+    return 0;
+}
+
+/* iw_handler の set_rate */
+static int wmrp10_set_rate(struct net_device *ndev,
+                           struct iw_request_info *info,
+                           union iwreq_data *wrqu, char *essid)
+{
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_rate() *****\n");
+#endif /* WMRP10_DEBUG */
+    return 0;
+}
+
+/* iw_handler の get_rate */
+static int wmrp10_get_rate(struct net_device *ndev,
+                           struct iw_request_info *info,
+                           union iwreq_data *wrqu, char *essid)
+{
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_rate() *****\n");
+#endif /* WMRP10_DEBUG */
+    return 0;
+}
+
+/* iw_handler の set_txpow */
+static int wmrp10_set_txpow(struct net_device *ndev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    struct iw_param *txpower = &wrqu->txpower;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_txpow() *****\n");
+#endif /* WMRP10_DEBUG */
+    if (txpower->disabled == 1) /* off */
+        return -EINVAL;
+    if (txpower->value == -1) /* auto */
+        priv->txpower = 12;
+    else if (!txpower->fixed)
+        return -EINVAL;
+    else if (txpower->value < 6 || 18 <= txpower->value)
+        return -EINVAL;
+    else
+        priv->txpower = txpower->value;
+    return 0;
+}
+
+/* iw_handler の get_txpow */
+static int wmrp10_get_txpow(struct net_device *ndev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    struct iw_param *txpower = &wrqu->txpower;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_txpow() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    txpower->value = priv->txpower;
+    txpower->fixed = 0;
+    txpower->disabled = 0;
+    txpower->flags = IW_TXPOW_DBM;
+    
+    return 0;
+}
+
+/* iw_handler の set_encode */
+static int wmrp10_set_encode(struct net_device *ndev,
+                             struct iw_request_info *info,
+                             union iwreq_data *wrqu, char *key)
+{
+    struct iw_point *enc = &wrqu->encoding;
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    unsigned long irqflag;
+    int key_index = enc->flags & IW_ENCODE_INDEX, index_specified;
+    __u16 flags = enc->flags & IW_ENCODE_FLAGS;
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_encode() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if(WMRP10_KEY_NUM < key_index)
+    {
+        return -EINVAL;
+    }
+    
+    spin_lock_irqsave(&priv->lock, irqflag);
+    if(key_index)
+    {
+        index_specified = 1;
+        key_index--;
+    }
+    else
+    {
+        index_specified = 0;
+        key_index = priv->current_key;
+    }
+    
+    if(flags & IW_ENCODE_NOKEY)
+    {
+        /* if just IW_ENCODE_NOKEY, change current key index */
+        if(!flags && index_specified)
+        {
+            priv->current_key = key_index;
+            goto done;
+        }
+        if(flags & IW_ENCODE_DISABLED)
+        {
+            if(!index_specified)
+            {
+                /* invalidate all key */
+                priv->key_enabled = 0;
+            }
+            else
+            {
+                clear_bit(key_index, &priv->key_enabled);
+            }
+        }
+    }
+    else
+    {
+        if(IW_ENCODING_TOKEN_MAX < enc->length)
+        {
+            ret = -EINVAL;
+            goto done;
+        }
+        priv->key_lens[key_index] = enc->length;
+        memcpy(priv->keys[key_index], key, enc->length);
+    }
+    
+done:
+    spin_unlock_irqrestore(&priv->lock, irqflag);
+    return ret;
+}
+
+/* iw_handler の get_encode */
+static int wmrp10_get_encode(struct net_device *ndev,
+                             struct iw_request_info *info,
+                             union iwreq_data *data, char *extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    struct iw_point *enc = &data->encoding;
+    unsigned int key_index = enc->flags & IW_ENCODE_INDEX, index_specified;
+    unsigned long irqflag;
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_encode() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if (WMRP10_KEY_NUM < key_index)
+        return -EINVAL;
+    
+    spin_lock_irqsave(&priv->lock, irqflag);
+    if (key_index)
+    {
+        index_specified = 1;
+        key_index--;
+    }
+    else
+    {
+        index_specified = 0;
+        key_index = priv->current_key;
+    }
+    
+    if (test_bit(key_index, &priv->key_enabled))
+    {
+        if (enc->length < priv->key_lens[key_index])
+        {
+            ret = -EINVAL;
+            goto done;
+        }
+        enc->length = priv->key_lens[key_index];
+        memcpy(extra, priv->keys[key_index],
+               priv->key_lens[key_index]);
+    }
+    else
+    {
+        enc->length = 0;
+        enc->flags |= IW_ENCODE_NOKEY;
+    }
+    enc->flags |= key_index + 1;
+done:
+    spin_unlock_irqrestore(&priv->lock, irqflag);
+    return ret;
+}
+
+/* iw_handler の set_encodeext */
+static int wmrp10_set_encodeext(struct net_device *ndev,
+                                struct iw_request_info *info,
+                                union iwreq_data *data, char *extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    struct iw_point *enc = &data->encoding;
+    struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+    __u16 alg;
+    __u16 flags;
+    unsigned long irqflag;
+    int key_index;
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_encodeext() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    flags = enc->flags & IW_ENCODE_FLAGS;
+    alg = ext->alg;
+    key_index = enc->flags & IW_ENCODE_INDEX;
+    
+    if (WMRP10_KEY_NUM < key_index)
+        return -EINVAL;
+    
+    spin_lock_irqsave(&priv->lock, irqflag);
+    
+    if (key_index)
+        key_index--;
+    else
+        key_index = priv->current_key;
+    
+    if (!enc->length && (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY))
+    {
+        /* reques to change default key index */
+        printk("%s: request to change default key to %d\n",
+               __func__, key_index);
+        priv->current_key = key_index;
+        goto done;
+    }
+    
+    if (alg == IW_ENCODE_ALG_NONE || (flags & IW_ENCODE_DISABLED))
+    {
+        printk("%s: alg disabled\n", __func__);
+        priv->wpa_level = IW_AUTH_WPA_VERSION_DISABLED;
+    }
+    else if (alg == IW_ENCODE_ALG_WEP)
+    {
+        printk("%s: WEP requested\n", __func__);
+        if (flags & IW_ENCODE_OPEN)
+        {
+            pr_info("%s: open key mode\n", __func__);
+        }
+        if (flags & IW_ENCODE_RESTRICTED)
+        {
+            pr_info("%s: shared key mode\n", __func__);
+        }
+        if (IW_ENCODING_TOKEN_MAX < ext->key_len)
+        {
+            pr_info("%s: key is too long %d\n", __func__,
+                    ext->key_len);
+            ret = -EINVAL;
+            goto done;
+        }
+        /* OK, update the key */
+        priv->key_lens[key_index] = ext->key_len;
+        memset(priv->keys[key_index], 0, IW_ENCODING_TOKEN_MAX);
+        memcpy(priv->keys[key_index], ext->key, ext->key_len);
+        set_bit(key_index, &priv->key_enabled);
+    }
+    else if (alg == IW_ENCODE_ALG_PMK)
+    {
+        if (ext->key_len != 32/*WPA_PSK_LEN*/)
+        {
+            pr_err("%s: PSK length wrong %d\n", __func__,
+                   ext->key_len);
+            ret = -EINVAL;
+            goto done;
+        }
+        memset(priv->psk, 0, sizeof(priv->psk));
+        memcpy(priv->psk, ext->key, ext->key_len);
+        priv->psk_len = ext->key_len;
+    }
+done:
+    spin_unlock_irqrestore(&priv->lock, irqflag);
+    return ret;
+}
+
+/* iw_handler の get_encodeext */
+static int wmrp10_get_encodeext(struct net_device *ndev,
+                                struct iw_request_info *info,
+                                union iwreq_data *data, char *extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    struct iw_point *enc = &data->encoding;
+    struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+    unsigned long irqflag;
+    int key_index;
+    int ret = 0;
+    int max_key_len;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_encodeext() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    max_key_len = enc->length - sizeof(struct iw_encode_ext);
+    if (max_key_len < 0)
+    {
+        return -EINVAL;
+    }
+    key_index = enc->flags & IW_ENCODE_INDEX;
+    
+    if (WMRP10_KEY_NUM < key_index)
+    {
+        return -EINVAL;
+    }
+    spin_lock_irqsave(&priv->lock, irqflag);
+    
+    if (key_index)
+    {
+        key_index--;
+    }
+    else
+    {
+        key_index = priv->current_key;
+    }
+    memset(ext, 0, sizeof(struct iw_encode_ext));
+    spin_unlock_irqrestore(&priv->lock, irqflag);
+    return ret;
+}
+
+/* iw_handler の set_power */
+static int wmrp10_set_power(struct net_device *ndev,
+                            struct iw_request_info *info,
+                            struct iw_param *power, char *extra)
+{
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_power() *****\n");
+#endif /* WMRP10_DEBUG */
+    return 0;
+}
+
+/* iw_handler の get_power */
+static int wmrp10_get_power(struct net_device *ndev,
+                            struct iw_request_info *info,
+                            union iwreq_data *wrqu, char *key)
+{
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_power() *****\n");
+#endif /* WMRP10_DEBUG */
+    return 0;
+}
+
+#ifndef IW_HANDLER
+#define IW_HANDLER(id, func) [IW_IOCTL_IDX(id)] = func
+#endif
+
+#define IW_IOCTL(n) [(n) - SIOCIWFIRST]
+static const iw_handler wmrp10_iw_handlers[] =
+{
+    IW_HANDLER(SIOCGIWNAME, wmrp10_get_name),
+    IW_HANDLER(SIOCGIWRANGE, wmrp10_get_range),
+    IW_HANDLER(SIOCSIWMODE, wmrp10_set_mode),
+    IW_HANDLER(SIOCGIWMODE, wmrp10_get_mode),
+    IW_HANDLER(SIOCSIWFREQ, wmrp10_set_freq),
+    IW_HANDLER(SIOCGIWFREQ, wmrp10_get_freq),
+    IW_HANDLER(SIOCSIWAUTH, wmrp10_set_auth),
+    IW_HANDLER(SIOCGIWAUTH, wmrp10_get_auth),
+    IW_HANDLER(SIOCSIWESSID, wmrp10_set_essid),
+    IW_HANDLER(SIOCGIWESSID, wmrp10_get_essid),
+    IW_HANDLER(SIOCSIWRATE, wmrp10_set_rate),
+    IW_HANDLER(SIOCGIWRATE, wmrp10_get_rate),
+    IW_HANDLER(SIOCSIWTXPOW, wmrp10_set_txpow),
+    IW_HANDLER(SIOCGIWTXPOW, wmrp10_get_txpow),
+    IW_HANDLER(SIOCSIWENCODE, wmrp10_set_encode),
+    IW_HANDLER(SIOCGIWENCODE, wmrp10_get_encode),
+    IW_HANDLER(SIOCSIWENCODEEXT, wmrp10_set_encodeext),
+    IW_HANDLER(SIOCGIWENCODEEXT, wmrp10_get_encodeext),
+    IW_HANDLER(SIOCSIWPOWER, (iw_handler)wmrp10_set_power),
+    IW_HANDLER(SIOCGIWPOWER, (iw_handler)wmrp10_get_power),
+};
+
+/* バージョン取得 */
+static char* wmrp10_get_version(struct net_device * ndev,
+                              struct iw_request_info * info,
+                              struct iw_point * point,
+                              char * extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    u8 *p;
+    rsi_qryFwversionFrameRcv rsp;
+    int16 retval;
+    uint16 err_code;
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_version() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    retval = wmrp10_rsi_query_fw_version(&rsp, &err_code, 10000);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        if(retval == WMRP10_ERR_CMD)
+        {
+            printk("WM-RP-10: wmrp10_rsi_query_fw_version() err_code 0x%04X\n",
+                   err_code);
+        }
+        else
+        {
+            printk("WM-RP-10: wmrp10_rsi_query_fw_version() failed %d\n",
+                   retval);
+        }
+        
+        ret = -EINVAL;
+    }
+    
+    if(point->length != 20)
+    {
+        ret = -EINVAL;
+    }
+    
+    if(ret == 0)
+    {
+        p = (u8 *)point->pointer;
+        strcpy(p, priv->fwversion);
+    }
+    
+    return p;
+}
+
+
+/* MACアドレス取得 */
+static char* wmrp10_get_macaddr(struct net_device * ndev,
+                              struct iw_request_info * info,
+                              struct iw_point * point,
+                              char * extra)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    int ret = 0;
+    u8 *p;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_macaddr() *****\n");
+#endif /* WMRP10_DEBUG */
+    if(g_wmrp_macflg == 0x00)
+    {
+        ret = -EINVAL;
+    }
+    
+    if(point->length != 6)
+    {
+        ret = -EINVAL;
+    }
+    
+    if(ret == 0)
+    {
+        p = (u8 *)point->pointer;
+        memcpy(p, priv->mac_addr,6);
+    }
+    
+    return p;
+}
+
+/* セキュリティモードの設定 */
+static int wmrp10_set_security_mode(struct net_device * ndev,
+                                    struct iw_request_info * info,
+                                    struct iw_param * rrq,
+                                    char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_security_mode() *****\n");
+#endif /* WMRP10_DEBUG */
+    if((rrq->value >= 0) && (rrq->value < WMRP10_SECURITY_PARAM_MAX))
+    {
+        priv->security_mode = rrq->value;
+    }
+    else
+    {
+        return -1;
+    }
+    
+    return 0;
+}
+
+/* セキュリティモードの取得 */
+static int wmrp10_get_security_mode(struct net_device * ndev,
+                                    struct iw_request_info * info,
+                                    struct iw_param * rrq,
+                                    char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_security_mode() *****\n");
+#endif /* WMRP10_DEBUG */
+
+    rrq->value = priv->security_mode;
+    rrq->fixed = 1;
+    
+    return 0;
+}
+
+/* Regionの設定 */
+static int wmrp10_set_region(struct net_device * ndev,
+                             struct iw_request_info * info,
+                             struct iw_param * rrq,
+                             char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_region() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if((rrq->value >= 0) && (rrq->value < WMRP10_REGION_PARAM_MAX))
+    {
+        priv->region = rrq->value;
+    }
+    else
+    {
+        return -1;
+    }
+    
+    return 0;
+}
+
+/* Regionの取得 */
+static int wmrp10_get_region(struct net_device * ndev,
+                             struct iw_request_info * info,
+                             struct iw_param * rrq,
+                             char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_region() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    rrq->value = priv->region;
+    rrq->fixed = 1;
+    
+    return 0;
+}
+
+/* アンテナの enable / disable 設定 */
+static int wmrp10_set_antenna(struct net_device * ndev,
+                              struct iw_request_info * info,
+                              struct iw_param * rrq,
+                              char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_antenna() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if((rrq->value >= 0) && (rrq->value <= 3))
+    {
+        priv->antenna = rrq->value;
+    }
+    else
+    {
+        return -1;
+    }
+    
+    return 0;
+}
+
+/* アンテナの enable / disable 取得 */
+static int wmrp10_get_antenna(struct net_device * ndev,
+                              struct iw_request_info * info,
+                              struct iw_param * rrq,
+                              char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_antenna() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    rrq->value = priv->antenna;
+    rrq->fixed = 1;
+    
+    return 0;
+}
+
+/* hidden AP機能の enable / disable 設定 */
+static int wmrp10_set_hide(struct net_device * ndev,
+                           struct iw_request_info * info,
+                           struct iw_param * rrq,
+                              char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_hide() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if((rrq->value >= 0) && (rrq->value <= 1))
+    {
+        priv->hidden = rrq->value;
+    }
+    else
+    {
+        return -1;
+    }
+    
+    return 0;
+}
+
+/* hidden AP機能の enable / disable 取得 */
+static int wmrp10_get_hide(struct net_device * ndev,
+                           struct iw_request_info * info,
+                           struct iw_param * rrq,
+                           char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_hide() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    rrq->value = priv->hidden;
+    rrq->fixed = 1;
+    
+    return 0;
+}
+
+/* WPSのモード設定 */
+static int wmrp10_set_wps_mode(struct net_device * ndev,
+                               struct iw_request_info * info,
+                               struct iw_param * rrq,
+                               char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_wps_mode() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if((rrq->value >= 0) && (rrq->value < WMRP10_WPS_MODE_PARAM_MAX))
+    {
+        priv->wps_mode = rrq->value;
+    }
+    else
+    {
+        return -1;
+    }
+    
+    return 0;
+}
+
+/* WPSのモード取得*/
+static int wmrp10_get_wps_mode(struct net_device * ndev,
+                               struct iw_request_info * info,
+                               struct iw_param * rrq,
+                               char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_wps_mode() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    rrq->value = priv->wps_mode;
+    rrq->fixed = 1;
+    
+    return 0;
+}
+
+/* WPSの動作開始 */
+static int wmrp10_wps_start(struct net_device * ndev,
+                               struct iw_request_info * info,
+                               struct iw_param * rrq,
+                               char * extra)
+{
+    int16 retval;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_wps_start() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    retval = wmrp10_app_wps();
+    
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        printk("WPS join Success\n");
+    }
+    else
+    {
+        printk("WPS join Failed\n");
+        retval = 0;
+    }
+    
+    return retval;
+}
+
+/* WPS PINコード設定 */
+static int wmrp10_set_wps_pin(struct net_device * ndev,
+                            struct iw_request_info * info,
+                            struct iw_point * point,
+                            char * extra)
+{
+    u8 *p;
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_wps_pin() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if(point->length > WMRP10_PIN_MAX )
+    {
+        return -1;
+    }
+#if WMRP10_DEBUG
+    printk("[size] point length:%d\n",point->length);
+#endif /* WMRP10_DEBUG */
+    if(ret == 0)
+    {
+        p = (u8 *)point->pointer;
+        strcpy((u8 *)priv->pin,(u8 *)p);
+#if WMRP10_DEBUG
+        printk("wps_pin = %s\n", (u8 *)&priv->pin);
+#endif
+    }
+    
+    return ret;
+}
+
+/* WPS PINコード取得(ポインタ) */
+static char* wmrp10_get_wps_pin(struct net_device * ndev,
+                              struct iw_request_info * info,
+                              struct iw_point * point,
+                              char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    u8 *p;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_wps_pin() *****\n");
+#endif /* WMRP10_DEBUG */
+    p = (u8 *)point->pointer;
+    strcpy(p, priv->pin);
+    
+    return p;
+}
+
+/* EAP method 設定 */
+static int wmrp10_set_eap_method(struct net_device * ndev,
+                            struct iw_request_info * info,
+                            struct iw_point * point,
+                            char * extra)
+{
+    u8 * p;
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_eap_method() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if(point->length > WMRP10_METHOD_MAX)
+    {
+        return -1;
+    }
+    
+    if(ret == 0)
+    {
+        p = (u8 *)point->pointer;
+        memcpy(&priv->eap_method, p, sizeof(priv->eap_method));
+    }
+    
+    return ret;
+}
+
+/* EAP method 取得(ポインタ) */
+static char* wmrp10_get_eap_method(struct net_device * ndev,
+                              struct iw_request_info * info,
+                              struct iw_point * point,
+                              char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    u8 *p;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_eap_method() *****\n");
+#endif /* WMRP10_DEBUG */
+    p = (u8 *)point->pointer;
+    strcpy(p, priv->eap_method);
+    
+    return p;
+}
+
+/* EAP inner 設定 */
+static int wmrp10_set_eap_inner(struct net_device * ndev,
+                                struct iw_request_info * info,
+                                struct iw_point * point,
+                                char * extra)
+{
+    u8 *p;
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_eap_inner() *****\n");
+#endif /* WMRP10_DEBUG */
+    if(point->length > WMRP10_INNER_MAX)
+    {
+        ret = -1;
+    }
+    if(ret == 0)
+    {
+        p = (u8 *)point->pointer;
+        memcpy(&priv->inner, p, sizeof(priv->inner));
+    }
+    
+    return ret;
+}
+
+/* EAP inner 取得(ポインタ) */
+static char* wmrp10_get_eap_inner(struct net_device * ndev,
+                                struct iw_request_info * info,
+                                struct iw_point * point,
+                                char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    u8 *p;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_eap_inner() *****\n");
+#endif /* WMRP10_DEBUG */
+    p = (u8 *)point->pointer;
+    strcpy(p, priv->inner);
+    
+    return p;
+}
+
+/* EAP username 設定 */
+static int wmrp10_set_eap_username(struct net_device * ndev,
+                            struct iw_request_info * info,
+                            struct iw_point * point,
+                            char * extra)
+{
+    u8 * p;
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_eap_username() *****\n");
+#endif /* WMRP10_DEBUG */
+    if(point->length > WMRP10_USERNAME_MAX)
+    {
+        ret = -1;
+    }
+    
+    if(ret == 0)
+    {
+        p = (u8 *)point->pointer;
+        memcpy(&priv->username, p, sizeof(priv->username));
+    }
+    
+    return ret;
+}
+
+/* EAP username 取得(ポインタ) */
+static char* wmrp10_get_eap_username(struct net_device * ndev,
+                              struct iw_request_info * info,
+                              struct iw_point * point,
+                              char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    u8 *p;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_eap_username() *****\n");
+#endif /* WMRP10_DEBUG */
+    p = (u8 *)point->pointer;
+    strcpy(p, priv->username);
+    
+    return p;
+}
+
+/* EAP Passsword 設定 */
+static int wmrp10_set_eap_password(struct net_device * ndev,
+                            struct iw_request_info * info,
+                            struct iw_point * point,
+                            char * extra)
+{
+    u8 *p;
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+        printk("***** wmrp10_set_eap_password() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if(point->length > WMRP10_PASSWORD_MAX)
+    {
+        return -1;
+    }
+    
+    if(ret == 0)
+    {
+        p = (u8 *)point->pointer;
+        memcpy(&priv->password, p, sizeof(priv->password));
+#if WMRP10_DEBUG
+        printk("  eap_password = %s\n", (u8 *)&priv->password);
+#endif
+    }
+    
+    return ret;
+}
+
+/* EAP Passsword 取得(ポインタ) */
+static char* wmrp10_get_eap_password(struct net_device * ndev,
+                              struct iw_request_info * info,
+                              struct iw_point * point,
+                              char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    u8 *p;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_eap_password() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    p = (u8 *)point->pointer;
+    strcpy(p, priv->password);
+    
+    return p;
+}
+
+/* WiFi Direct GOIntent 設定 */
+static int wmrp10_set_wfd_gointent(struct net_device * ndev,
+                                   struct iw_request_info * info,
+                                   struct iw_param * rrq,
+                                   char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_wfd_gointent() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    if((rrq->value >= 0) && (rrq->value <= 16))
+    {
+        priv->gointent = rrq->value;
+    }
+    else
+    {
+        return -1;
+    }
+    
+    return 0;
+}
+
+/* WiFi Direct GOIntent 取得 */
+static int wmrp10_get_wfd_gointent(struct net_device * ndev,
+                               struct iw_request_info * info,
+                               struct iw_param * rrq,
+                               char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_wfd_gointent() *****\n");
+#endif /* WMRP10_DEBUG */
+    rrq->value = priv->gointent;
+    rrq->fixed = 1;
+    
+    return 0;
+}
+
+/* WiFi Direct デバイス名 設定 */
+static int wmrp10_set_wfd_devicename(struct net_device * ndev,
+                            struct iw_request_info * info,
+                            struct iw_point * point,
+                            char * extra)
+{
+    u8 * p;
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    int ret = 0;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_set_wfd_devicename() *****\n");
+#endif /* WMRP10_DEBUG */
+    if(point->length > WMRP10_DEVICENAME_MAX)
+    {
+        ret = -EINVAL;
+    }
+    
+    if(ret == 0)
+    {
+        p = (u8 *)point->pointer;
+        memcpy(&priv->devicename, p, sizeof(priv->devicename));
+    }
+    
+    return ret;
+}
+
+/* WiFi Direct デバイス名 取得(ポインタ) */
+static char* wmrp10_get_wfd_devicename(struct net_device * ndev,
+                              struct iw_request_info * info,
+                              struct iw_point * point,
+                              char * extra)
+{
+    struct wmrp10_priv * priv = netdev_priv(ndev);
+    u8 *p;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_wfd_devicename() *****\n");
+#endif /* WMRP10_DEBUG */
+    p = (u8 *)point->pointer;
+    strcpy(p, priv->devicename);
+    
+    return p;
+}
+
+/******* iwpriv　handleリスト ********/
+static const iw_handler wmrp10_private_handler[] =
+{
+    (iw_handler)NULL,                       /*  */
+    (iw_handler)wmrp10_get_version,         /* WMRP10_GIWVERSION */
+    (iw_handler)NULL,                       /* WMRP10_SIWPARAM */
+    (iw_handler)NULL,                       /*  */
+    (iw_handler)NULL,                       /*  */
+    (iw_handler)wmrp10_get_macaddr,         /* WMRP10_GIWMACADDR */
+    (iw_handler)wmrp10_set_security_mode,   /* WMRP10_SIWSECMODE */
+    (iw_handler)wmrp10_get_security_mode,   /* WMRP10_GIWSECMODE */
+    (iw_handler)wmrp10_set_region,          /* WMRP10_SIWREGION */
+    (iw_handler)wmrp10_get_region,          /* WMRP10_GIWREGION */
+    (iw_handler)wmrp10_set_antenna,         /* WMRP10_SIWANTENNA */
+    (iw_handler)wmrp10_get_antenna,         /* WMRP10_GIWANTENNA */
+    (iw_handler)wmrp10_set_hide,            /* WMRP10_SIWHIDE */
+    (iw_handler)wmrp10_get_hide,            /* WMRP10_GIWHIDE */
+    (iw_handler)wmrp10_set_wps_mode,        /* WMRP10_SIWWPSMODE */
+    (iw_handler)wmrp10_get_wps_mode,        /* WMRP10_GIWWPSMODE */
+    (iw_handler)wmrp10_wps_start,           /* WMRP10_SIWWPSSTART */
+    (iw_handler)wmrp10_set_wps_pin,         /* WMRP10_SIWWPSPIN */
+    (iw_handler)wmrp10_get_wps_pin,         /* WMRP10_GIWWPSPIN */
+    (iw_handler)wmrp10_set_eap_method,      /* WMRP10_SIWEAPMETHOD */
+    (iw_handler)wmrp10_get_eap_method,      /* WMRP10_GIWEAPMETHOD */
+    (iw_handler)wmrp10_set_eap_inner,       /* WMRP10_SIWEAPINNER */
+    (iw_handler)wmrp10_get_eap_inner,       /* WMRP10_GIWEAPINNER */
+    (iw_handler)wmrp10_set_eap_username,    /* WMRP10_SIWEAPUSERNAME */
+    (iw_handler)wmrp10_get_eap_username,    /* WMRP10_GIWEAPUSERNAME */
+    (iw_handler)wmrp10_set_eap_password,    /* WMRP10_SIWEAPPASS */
+    (iw_handler)wmrp10_get_eap_password,    /* WMRP10_GIWEAPPASS */
+    (iw_handler)wmrp10_set_wfd_gointent,    /* WMRP10_SIWGOINTENT */
+    (iw_handler)wmrp10_get_wfd_gointent,    /* WMRP10_GIWGOINTENT */
+    (iw_handler)wmrp10_set_wfd_devicename,  /* WMRP10_SIWDEVICENAME */
+    (iw_handler)wmrp10_get_wfd_devicename,  /* WMRP10_GIWDEVICENAME */
+};
+
+/******* iwpriv コマンド名 引数の設定 *******/
+static const struct iw_priv_args wmrp10_private_args[] =
+{
+    /* FW version */
+    {
+        WMRP10_GIWVERSION,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        "getversion"
+    },
+    {
+        WMRP10_SIWPARAM,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE,
+        "setparam"
+    },
+    
+    /* mac addr */
+    {
+        WMRP10_GIWMACADDR,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        "getmacaddr"
+    },
+    /* security mode */
+    {
+        WMRP10_SIWSECMODE,
+        IW_PRIV_TYPE_INT| IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE ,
+        "setsecuritymode"
+    },
+    {
+        WMRP10_GIWSECMODE,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        "getsecuritymode"
+    },
+    /* Region */
+    {
+        WMRP10_SIWREGION,
+        IW_PRIV_TYPE_INT| IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE ,
+        "setregion"
+    },
+    {
+        WMRP10_GIWREGION,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        "getregion"
+    },
+    /* Antenna */
+    {
+        WMRP10_SIWANTENNA,
+        IW_PRIV_TYPE_INT| IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE ,
+        "setantenna"
+    },
+    {
+        WMRP10_GIWANTENNA,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        "getantenna"
+    },
+    /* AP Hide */
+    {
+        WMRP10_SIWHIDE,
+        IW_PRIV_TYPE_INT| IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE ,
+        "sethidden"
+    },
+    {
+        WMRP10_GIWHIDE,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        "gethidden"
+    },
+    /* WPS mode */
+    {
+        WMRP10_SIWWPSMODE,
+        IW_PRIV_TYPE_INT| IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE ,
+        "setwpsmode"
+    },
+    {
+        WMRP10_GIWWPSMODE,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+        "getwpsmode"
+    },
+    /* WPS start */
+    {
+        WMRP10_SIWWPSSTART,
+        IW_PRIV_TYPE_NONE ,
+        IW_PRIV_TYPE_NONE ,
+        "wps_start"
+    },
+    /* WPS PIN */
+    {
+        WMRP10_SIWWPSPIN,
+        IW_PRIV_TYPE_CHAR | WMRP10_PIN_MAX,
+        IW_PRIV_TYPE_NONE ,
+        "setwpspin"
+    },
+    {
+        WMRP10_GIWWPSPIN,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        "getwpspin"
+    },
+    /* EAP method */
+    {
+        WMRP10_SIWEAPMETHOD,
+        IW_PRIV_TYPE_CHAR | WMRP10_METHOD_MAX,
+        IW_PRIV_TYPE_NONE ,
+        "seteapmethod"
+    },
+    {
+        WMRP10_GIWEAPMETHOD,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        "geteapmethod"
+    },
+    /* EAP Inner */
+    {
+        WMRP10_SIWEAPINNER,
+        IW_PRIV_TYPE_CHAR | WMRP10_INNER_MAX,
+        IW_PRIV_TYPE_NONE ,
+        "seteapinner"
+    },
+    {
+        WMRP10_GIWEAPINNER,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        "geteapinner"
+    },
+    /* EAP username */
+    {
+        WMRP10_SIWEAPUSERNAME,
+        IW_PRIV_TYPE_CHAR | WMRP10_USERNAME_MAX,
+        IW_PRIV_TYPE_NONE ,
+        "setusername"
+    },
+    {
+        WMRP10_GIWEAPUSERNAME,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        "getusername"
+    },
+    /* EAP password */
+    {
+        WMRP10_SIWEAPPASSWORD,
+        IW_PRIV_TYPE_CHAR | WMRP10_PASSWORD_MAX,
+        IW_PRIV_TYPE_NONE ,
+        "setpassword"
+    },
+    {
+        WMRP10_GIWEAPPASSWORD,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        "getpassword"
+    },
+    /* WiFi Direct GOintent */
+    {
+        WMRP10_SIWGOINTENT,
+        IW_PRIV_TYPE_INT| IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE ,
+        "setgointent"
+    },
+    {
+        WMRP10_GIWGOINTENT,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_INT| IW_PRIV_SIZE_FIXED | 1,
+        "getgointent"
+    },
+    /* WiFi Direct devicename */
+    {
+        WMRP10_SIWDEVICENAME,
+        IW_PRIV_TYPE_CHAR | WMRP10_DEVICENAME_MAX,
+        IW_PRIV_TYPE_NONE ,
+        "setdevicename"
+    },
+    {
+        WMRP10_GIWDEVICENAME,
+        IW_PRIV_TYPE_NONE,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        "getdevicename"
+    },
+    /* RS9113 FW Upgrade */
+    {
+        WMRP10_UPGRADE,
+        IW_PRIV_TYPE_ADDR | IW_PRIV_SIZE_FIXED | 1,
+        IW_PRIV_TYPE_NONE,
+        "upgrade"
+    },
+    
+};
+
+/* iw_handler_def構造体 の get_wireless_stats */
+static struct iw_statistics *wmrp10_get_wireless_stats(struct net_device *ndev)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    struct iw_quality *qual = &priv->iwstats.qual;
+    int16 retval;
+    rsi_rssiFrameRcv rssi_rsp;
+    uint16 err_code;
+    u16 rssi;
+    
+    
+    rssi = 0;
+    if((priv->join_flg == true) && (priv->mode == IW_MODE_INFRA))
+    {
+        retval = wmrp10_rsi_query_rssi(&rssi_rsp, &err_code, 10000);
+        if(retval != WMRP10_ERR_SUCCESS)
+        {
+            if(retval == WMRP10_ERR_CMD)
+            {
+                printk("WM-RP-10: wmrp10_rsi_query_rssi() err_code 0x%04X\n", err_code);
+            }
+            else
+            {
+                printk("WM-RP-10: wmrp10_rsi_query_rssi() failed %d\n", retval);
+            }
+            
+            rssi = 0;
+        }
+        else
+        {
+            rssi = rsi_bytes2R_to_uint16(&rssi_rsp.rssiVal);
+        }
+    }
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_get_wireless_stats() rssi = %d(%04X) *****\n",
+           rssi, rssi);
+#endif /* WMRP10_DEBUG */
+    qual->level = rssi;
+    qual->updated = IW_QUAL_DBM | IW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;
+    
+    return &priv->iwstats;
+}
+
+
+static const struct iw_handler_def wmrp10_iw_handler_def =
+{
+    .standard           = wmrp10_iw_handlers,
+    .num_standard       = ARRAY_SIZE(wmrp10_iw_handlers),
+    .num_private        = ARRAY_SIZE(wmrp10_private_handler),
+    .num_private_args   = ARRAY_SIZE(wmrp10_private_args),
+    .private            = wmrp10_private_handler,
+    .private_args       = wmrp10_private_args,
+    .get_wireless_stats = wmrp10_get_wireless_stats,
+};
+
+/* リセット処理 */
+int wmrp10_reset(void)
+{
+    int16 retval;
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_reset() *****\n");
+#endif /* WMRP10_DEBUG */
+    
+    retval = wmrp10_app_init();
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        printk("WM-RP-10: wmrp10_app_init() failed %d\n", retval);
+        
+        return -ENODEV;
+    }
+    
+    return 0;
+}
+
+/* net_device_ops構造体 の ndo_open */
+static int wmrp10_open(struct net_device *ndev)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    int16 ret;
+    unsigned char macaddr[6];
+    
+    ret = wmrp10_app_cfg(priv);
+    if(ret != WMRP10_ERR_SUCCESS)
+    {
+        printk("wmrp10_app_cfg() failed %d\n", ret);
+        wmrp10_reset();
+        
+        return -ENODEV;
+    }
+#if WMRP10_DEBUG
+    printk("wmrp10_app_cfg() complete\n");
+#endif
+    ret = wmrp10_app_start(macaddr);
+    if(ret != WMRP10_ERR_SUCCESS)
+    {
+        printk("wmrp10_app_start() failed %d\n", ret);
+        wmrp10_reset();
+        
+        return -ENODEV;
+    }
+    
+    memcpy(ndev->dev_addr, macaddr, 6);
+    priv->join_flg = true;
+    printk("WM-RP-10: MAC Address = %pM\n", ndev->dev_addr);
+    netif_start_queue(ndev);
+    
+    return 0;
+}
+
+/* net_device_ops構造体 の ndo_stop */
+static int wmrp10_close(struct net_device *ndev)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    
+#if WMRP10_DEBUG
+    printk("***** wmrp10_close() *****\n");
+#endif /* WMRP10_DEBUG */
+    netif_stop_queue(ndev);
+    priv->join_flg = false;
+    
+    return wmrp10_reset();
+}
+
+/* バイパスモード の 送信用処理 */
+static void wmrp10_tx_skb(struct wmrp10_priv *priv, struct sk_buff *skb)
+{
+    struct net_device *ndev = priv->ndev;
+    struct net_device_stats *stats = &priv->stats;
+    char *data, short_pkt[ETH_ZLEN];
+    int len;
+    int send_len;
+    
+    
+    len = skb->len;
+    data = skb->data;
+    if(len < ETH_ZLEN)
+    {
+        memset(short_pkt, 0, sizeof(short_pkt));
+        memcpy(short_pkt, skb->data, skb->len);
+        len = sizeof (short_pkt);
+        data = short_pkt;
+    }
+    
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
+    netif_trans_update(ndev);
+#else
+    ndev->trans_start = jiffies;
+#endif
+
+    stats->tx_packets++;
+    stats->tx_bytes += len;
+    wmrp10_rsi_send_raw_data(data, len, &send_len);
+    dev_kfree_skb(skb);
+}
+
+/* バイパスモード の 送信用処理 */
+static void wmrp10_process_tx(struct wmrp10_priv *priv)
+{
+    struct net_device *ndev = priv->ndev;
+    unsigned long flags;
+    struct sk_buff *skb;
+    
+    spin_lock_irqsave(&priv->lock, flags);
+    
+    while(priv->skb_rp != priv->skb_wp)
+    {
+        skb = priv->skbs[priv->skb_rp];
+        priv->skb_rp = (priv->skb_rp + 1) & (WMRP10_BUFFER_LEN - 1);
+        netif_wake_queue(ndev);
+        spin_unlock_irqrestore(&priv->lock, flags);
+        wmrp10_tx_skb(priv, skb);
+        spin_lock_irqsave(&priv->lock, flags);
+    }
+    
+    spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+/* バイパスモード の 送信用処理 */
+static void wmrp10_tx_work(struct work_struct *work)
+{
+    struct wmrp10_priv *priv = container_of(work, struct wmrp10_priv, tx_work);
+    
+    wmrp10_process_tx(priv);
+}
+
+/* net_device_ops構造体 の ndo_start_xmit */
+static int wmrp10_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    u32 skb_wp;
+    
+    spin_lock(&priv->lock);
+    
+    priv->skbs[priv->skb_wp] = skb;
+    skb_wp = (priv->skb_wp + 1) & (WMRP10_BUFFER_LEN - 1);
+    if(skb_wp == priv->skb_rp)
+    {
+        netif_stop_queue(ndev);
+        spin_unlock(&priv->lock);
+        return NETDEV_TX_BUSY;
+    }
+    priv->skb_wp = skb_wp;
+    spin_unlock(&priv->lock);
+    schedule_work(&priv->tx_work);
+    
+    return NETDEV_TX_OK;
+}
+
+/* net_device_ops構造体 の ndo_tx_timeout */
+static void wmrp10_tx_timeout(struct net_device *ndev)
+{
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    
+    priv->stats.tx_errors++;
+    netif_wake_queue(ndev);
+}
+
+/* net_device_ops構造体 の ndo_get_stats */
+static struct net_device_stats *wmrp10_get_stats(struct net_device *ndev)
+{
+    return &((struct wmrp10_priv *)netdev_priv(ndev))->stats;
+}
+
+static const struct net_device_ops wmrp10_netdev_ops =
+{
+    .ndo_open       = wmrp10_open,
+    .ndo_stop       = wmrp10_close,
+    .ndo_start_xmit = wmrp10_start_xmit,
+    .ndo_tx_timeout = wmrp10_tx_timeout,
+    .ndo_get_stats  = wmrp10_get_stats,
+};
+
+/* wmrp10のデータ受信処理 */
+static int16 wmrp10_process(struct wmrp10_priv *priv)
+{
+    int16 retval;
+    
+    switch(g_frame_read_type)
+    {
+        case WMRP10_WLAN_FRAME:
+            retval = wmrp10_rsi_frame_read();
+            break;
+        case WMRP10_BT_FRAME:
+            retval = wmrp10_rsi_bt_frame_read();
+            break;
+        case WMRP10_BLE_FRAME:
+            retval = wmrp10_rsi_ble_frame_read();
+            break;
+        default:
+            break;
+    }
+    
+    return retval;
+}
+
+static void rsi_work(struct work_struct *work)
+{
+    int16 retval;
+    struct wmrp10_priv *priv = container_of(work, struct wmrp10_priv, work);
+    
+    retval = wmrp10_process(priv);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+#if WMRP10_DEBUG
+        printk("frame_read Error\n");
+#endif
+    }
+    
+    if (priv->ndev->irq)
+    {
+        enable_irq(priv->ndev->irq);
+    }
+}
+
+/* 割り込み処理 */
+static irqreturn_t rsi_interrupt(int irq, void *ptr)
+{
+    struct net_device *ndev;
+    struct wmrp10_priv *priv;
+    
+#if WMRP10_DEBUG
+    printk("********** rsi_interrupt() **********\n");
+#endif
+    disable_irq_nosync(irq);
+    ndev = ptr;
+    priv = netdev_priv(ndev);
+#if WMRP10_DEBUG
+    if (printk_ratelimit())
+    {
+        printk("%s:\n", __func__);
+    }
+#endif
+    
+    schedule_work(&priv->work);
+    return IRQ_HANDLED;
+}
+
+/* コマンド応答 及び バイパスモード受信用のスレッド */
+static int wmrp10_thread(void *ptr)
+{
+    struct net_device *ndev = ptr;
+    struct wmrp10_priv *priv = netdev_priv(ndev);
+    struct wmrp10_platform_data *pdata = priv->pdata;
+    int timeout = 1;
+    int tmo_max = 1 << 8;
+    
+    for(;;)
+    {
+        if(pdata->get_irq_pin_state())
+        {
+            wmrp10_rsi_bt_frame_read();
+            timeout = 1;
+            continue;
+        }
+        if(kthread_should_stop())
+        {
+            break;
+        }
+        
+        msleep(timeout);
+        timeout <<= 1;
+        if(timeout > tmo_max)
+        {
+            timeout = tmo_max;
+        }
+    }
+    
+    return 0;
+}
+
+/* spi_driver構造体 の prove */
+static int wmrp10_spi_probe(struct spi_device *spi)
+{
+    int ret;
+    struct net_device *ndev;
+    struct wmrp10_priv *priv;
+    struct wmrp10_platform_data *pdata = spi->dev.platform_data;
+    int16 retval;
+    rsi_qryFwversionFrameRcv fw_rsp;
+    uint16 err_code;
+    uint8 tri_auto_flg;
+    rsi_uOperMode oper = {0};
+    rsi_initResponse init_rsp = {0};
+    
+    g_wmrp_macflg = 0x00;
+    
+    if(spi->master->flags & SPI_MASTER_HALF_DUPLEX)
+    {
+        return -EINVAL;
+    }
+    
+    spi->mode = SPI_MODE_0;
+    spi->bits_per_word = 8;
+    
+    /* spi初期化 */
+    ret = spi_setup(spi);
+    if(ret != 0)
+    {
+        return ret;
+    }
+    
+    ndev = alloc_etherdev(sizeof (struct wmrp10_priv));
+    strcpy(ndev->name, "wlan%d");
+    ndev->netdev_ops = &wmrp10_netdev_ops;
+    ndev->watchdog_timeo = 5 * HZ;
+    ndev->irq = spi->irq;
+    
+    ndev->wireless_handlers = &wmrp10_iw_handler_def;
+    priv = netdev_priv(ndev);
+    dev_set_drvdata(&spi->dev, priv);
+    g_wmrp_spi = spi;
+    
+    /* WLANモジュール 初期化 */
+    retval = wmrp10_apis_init();
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        printk("WM-RP-10: wmrp10_apis_init() failed %d\n", retval);
+        free_netdev(ndev);
+        
+        return -ENODEV;
+    }
+    /* sytem init */
+    INIT_WORK(&priv->work, rsi_work);
+    /* Linux sem 初期化 */
+    retval = wmrp10_rsi_sys_init();
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        printk("WM-RP-10: wmrp10_rsi_sys_init() failed %d\n", retval);
+        free_netdev(ndev);
+        
+        return -ENODEV;
+    }
+    /* wait for board ready */
+    do
+    {
+        retval = wmrp10_rsi_waitfor_boardready();
+        if((retval != WMRP10_ERR_SUCCESS) && (retval != WMRP10_ERR_NOT_READY))
+        {
+            printk("WM-RP-10: wmrp10_rsi_waitfor_boardready() failed %d\n", retval);
+            free_netdev(ndev);
+            dev_set_drvdata(&spi->dev, NULL);
+            return -ENODEV;
+        }
+    }while(retval == WMRP10_ERR_NOT_READY);
+    
+    ret = register_netdev(ndev);
+    if(ret != 0)
+    {
+        free_netdev(ndev);
+        dev_set_drvdata(&spi->dev, NULL);
+        
+        return ret;
+    }
+    
+    priv->ndev = ndev;
+    priv->pdata = pdata;
+    INIT_WORK(&priv->tx_work, wmrp10_tx_work);
+    
+    if(ndev->irq == NO_IRQ)
+    {
+        kthread_run(wmrp10_thread, ndev, "wmrp10_thread");
+    }
+    else
+    {
+        if ((ret = request_irq( ndev->irq, rsi_interrupt, 
+             IRQF_TRIGGER_HIGH, ndev->name, ndev)))
+        {
+            printk("request_irq(%d) failed %d\n",
+                    ndev->irq, ret);
+                    
+            return ret;
+        }
+    }
+    /* rsi_select_option() */
+    retval = wmrp10_rsi_select_option(RSI_HOST_BOOTUP_OPTION, &tri_auto_flg,
+                                      &err_code, 10000);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        if(retval == WMRP10_ERR_CMD)
+        {
+            printk("WM-RP-10: wmrp10_rsi_select_option() err_code 0x%04X\n",
+                    err_code);
+        }
+        else
+        {
+            printk("WM-RP-10: wmrp10_rsi_select_option() failed %d\n", retval);
+        }
+        
+        flush_scheduled_work();
+        unregister_netdev(priv->ndev);
+        free_netdev(priv->ndev);
+        dev_set_drvdata(&spi->dev, NULL);
+        
+        return -ENODEV;
+    }
+    
+    /* rsi_query_fw_version() */
+    retval = wmrp10_rsi_query_fw_version(&fw_rsp, &err_code, 10000);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        if(retval == WMRP10_ERR_CMD)
+        {
+            printk("WM-RP-10: wmrp10_rsi_query_fw_version() err_code 0x%04X\n",
+                    err_code);
+        }
+        else
+        {
+            printk("WM-RP-10: wmrp10_rsi_query_fw_version() failed %d\n",
+                    retval);
+        }
+        
+        flush_scheduled_work();
+        unregister_netdev(priv->ndev);
+        free_netdev(priv->ndev);
+        dev_set_drvdata(&spi->dev, NULL);
+        
+        return -ENODEV;
+    }
+    memcpy(priv->fwversion,&fw_rsp.fwversion,sizeof(priv->fwversion));
+    
+    /* rsi_oper_mode() */
+    rsi_uint32_to_4bytes(oper.operModeFrameSnd.oper_mode, 0);  /* Client mode */
+    rsi_uint32_to_4bytes(oper.operModeFrameSnd.feature_bit_map,
+                         0x00000083);  /* PSK | Open | WPS Disable */
+    rsi_uint32_to_4bytes(oper.operModeFrameSnd.tcp_ip_feature_bit_map,
+                         0x00000001);  /* TCP/IP bypass */
+    rsi_uint32_to_4bytes(oper.operModeFrameSnd.custom_feature_bit_map,
+                         0x00000100);  /* DFS */
+    
+    retval = wmrp10_rsi_oper_mode(&oper, &err_code, 10000);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        if(retval == WMRP10_ERR_CMD)
+        {
+            printk("WM-RP-10: wmrp10_rsi_oper_mode() err_code 0x%04X\n",
+                    err_code);
+        }
+        else
+        {
+            printk("WM-RP-10: wmrp10_rsi_oper_mode() failed %d\n",retval);
+        }
+        
+        flush_scheduled_work();
+        unregister_netdev(priv->ndev);
+        free_netdev(priv->ndev);
+        dev_set_drvdata(&spi->dev, NULL);
+        
+        return -ENODEV;
+    }
+    
+    /* rsi_band() */
+    retval = wmrp10_rsi_band(RSI_BAND_2P4GHZ, &err_code, 10000);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        if(retval == WMRP10_ERR_CMD)
+        {
+            printk("WM-RP-10: wmrp10_rsi_band() err_code 0x%04X\n", err_code);
+        }
+        else
+        {
+            printk("WM-RP-10: wmrp10_rsi_band() failed %d\n", retval);
+        }
+        
+        flush_scheduled_work();
+        unregister_netdev(priv->ndev);
+        free_netdev(priv->ndev);
+        dev_set_drvdata(&spi->dev, NULL);
+        
+        return -ENODEV;
+    }
+    
+    /* rsi_init() */
+    retval = wmrp10_rsi_init(&init_rsp, &err_code, 10000);
+    if(retval != WMRP10_ERR_SUCCESS)
+    {
+        if(retval == WMRP10_ERR_CMD)
+        {
+            printk("WM-RP-10: wmrp10_rsi_init() err_code 0x%04X\n", err_code);
+        }
+        else
+        {
+            printk("WM-RP-10: wmrp10_rsi_init() failed %d\n", retval);
+        }
+        
+        flush_scheduled_work();
+        unregister_netdev(priv->ndev);
+        free_netdev(priv->ndev);
+        dev_set_drvdata(&spi->dev, NULL);
+        
+        return -ENODEV;
+    }
+    
+    memcpy(priv->mac_addr, init_rsp.macAddress1,
+    sizeof(init_rsp.macAddress1));
+    g_wmrp_macflg = 0x01;
+    
+    /* WLANモジュールのリセット */
+    ret = wmrp10_reset();
+    if(ret != 0)
+    {
+        flush_scheduled_work();
+        unregister_netdev(priv->ndev);
+        free_netdev(priv->ndev);
+        dev_set_drvdata(&spi->dev, NULL);
+        
+        return -ENODEV;
+    }
+    printk("WM-RP-10: Initialization ok\n");
+    printk("WM-RP-10: ver = %s\n", priv->fwversion);
+    printk("WM-RP-10: mac = %02X:%02X:%02X:%02X:%02X:%02X\n",
+            priv->mac_addr[0], priv->mac_addr[1], priv->mac_addr[2],
+            priv->mac_addr[3], priv->mac_addr[4], priv->mac_addr[5]);
+            
+    priv->mode = IW_MODE_INFRA;   /* Infrastructure */
+    priv->channel = 0;            /* ch 0 */
+    priv->band = 0;               /* 2.4GHz */
+    priv->join_flg = false;
+    
+    return 0;
+}
+
+/* spi_driver構造体 の remove */
+ static int /* __devexit */ wmrp10_spi_remove(struct spi_device *spi)
+{
+    struct wmrp10_priv *priv = dev_get_drvdata(&spi->dev);
+    
+    flush_scheduled_work();
+    unregister_netdev(priv->ndev);
+    free_netdev(priv->ndev);
+    dev_set_drvdata(&spi->dev, NULL);
+    
+    return 0;
+}
+
+
+static const struct spi_device_id wmrp10_spi_idtable[] = 
+{
+    { "WMRP10_SPI", 0},
+    {}
+};
+
+static const struct of_device_id wmrp10_spi_of_match[] = 
+{
+    { .compatible = "apj,wmrp10_spi" },
+    {},
+};
+
+MODULE_DEVICE_TABLE(spi, wmrp10_spi_idtable);
+
+/* spi driverの定義 */
+static struct spi_driver wmrp10_spi_driver =
+{
+    .driver =
+    {
+        .name  = "wmrp10_spi",
+        .bus   = &spi_bus_type,
+        .owner = THIS_MODULE,
+        .of_match_table = of_match_ptr( wmrp10_spi_of_match )
+    },
+    .probe     = wmrp10_spi_probe,
+    .remove    = /* __devexit_p */ (wmrp10_spi_remove),
+};
+
+/* 初期化 */
+static int __init wmrp10_init(void)
+{
+    int retval;
+    
+    retval = spi_register_driver(&wmrp10_spi_driver);
+    wmrp10_driver_init();
+    
+    return retval;
+}
+
+/* 終了処理 */
+static void __exit wmrp10_exit(void)
+{
+    spi_unregister_driver(&wmrp10_spi_driver);
+    
+    wmrp10_driver_exit();
+}
+
+
+module_init(wmrp10_init);
+module_exit(wmrp10_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("ALPHAPROJECT");
+MODULE_ALIAS("spi:wmrp10_spi");
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10.h b/drivers/net/wireless/wmrp10/wmrp10.h
new file mode 100644
index 0000000..e835079
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10.h
@@ -0,0 +1,259 @@
+#ifndef _WMRP10_H_
+#define _WMRP10_H_
+
+#include "wmrp10_rsi.h"
+
+#define WMRP10_SIWVERSION  (SIOCIWFIRSTPRIV)
+#define WMRP10_GIWVERSION  (SIOCIWFIRSTPRIV + 1)
+#define WMRP10_SIWPARAM    (SIOCIWFIRSTPRIV + 2)
+#define WMRP10_GIWPARAM    (SIOCIWFIRSTPRIV + 3)
+#define WMRP10_SIWMACADDR  (SIOCIWFIRSTPRIV + 4)
+#define WMRP10_GIWMACADDR  (SIOCIWFIRSTPRIV + 5)
+#define WMRP10_SIWSECMODE  (SIOCIWFIRSTPRIV + 6)
+#define WMRP10_GIWSECMODE  (SIOCIWFIRSTPRIV + 7)
+#define WMRP10_SIWREGION   (SIOCIWFIRSTPRIV + 8)
+#define WMRP10_GIWREGION   (SIOCIWFIRSTPRIV + 9)
+#define WMRP10_SIWANTENNA  (SIOCIWFIRSTPRIV + 10)
+#define WMRP10_GIWANTENNA  (SIOCIWFIRSTPRIV + 11)
+#define WMRP10_SIWHIDE     (SIOCIWFIRSTPRIV + 12)
+#define WMRP10_GIWHIDE     (SIOCIWFIRSTPRIV + 13)
+#define WMRP10_SIWWPSMODE  (SIOCIWFIRSTPRIV + 14)
+#define WMRP10_GIWWPSMODE  (SIOCIWFIRSTPRIV + 15)
+#define WMRP10_SIWWPSSTART (SIOCIWFIRSTPRIV + 16)
+#define WMRP10_SIWWPSPIN      (SIOCIWFIRSTPRIV + 17)
+#define WMRP10_GIWWPSPIN      (SIOCIWFIRSTPRIV + 18)
+#define WMRP10_SIWEAPMETHOD   (SIOCIWFIRSTPRIV + 19)
+#define WMRP10_GIWEAPMETHOD   (SIOCIWFIRSTPRIV + 20)
+#define WMRP10_SIWEAPINNER    (SIOCIWFIRSTPRIV + 21)
+#define WMRP10_GIWEAPINNER    (SIOCIWFIRSTPRIV + 22)
+#define WMRP10_SIWEAPUSERNAME (SIOCIWFIRSTPRIV + 23)
+#define WMRP10_GIWEAPUSERNAME (SIOCIWFIRSTPRIV + 24)
+#define WMRP10_SIWEAPPASSWORD (SIOCIWFIRSTPRIV + 25)
+#define WMRP10_GIWEAPPASSWORD (SIOCIWFIRSTPRIV + 26)
+#define WMRP10_SIWGOINTENT    (SIOCIWFIRSTPRIV + 27)
+#define WMRP10_GIWGOINTENT    (SIOCIWFIRSTPRIV + 28)
+#define WMRP10_SIWDEVICENAME  (SIOCIWFIRSTPRIV + 29)
+#define WMRP10_GIWDEVICENAME  (SIOCIWFIRSTPRIV + 30)
+#define WMRP10_UPGRADE        (SIOCIWFIRSTPRIV + 31)
+
+#define WMRP10_BUFFER_LEN (1 << 8)
+#define WMRP10_KEY_NUM 4
+#define WMRP10_PIN_MAX        63
+#define WMRP10_METHOD_MAX     16
+#define WMRP10_INNER_MAX      32
+#define WMRP10_USERNAME_MAX   32
+#define WMRP10_PASSWORD_MAX   32
+#define WMRP10_DEVICENAME_MAX 32
+#define WMRP10_SSID_MAX       32
+#define WMRP10_PSK_MAX        63
+#define WMRP10_DEVICENAME_MAX 32
+#define WMRP10_POSTFIX_MAX    26
+#define WMRP10_MAX_POSSIBLE_CHANNEL  24
+
+#define WMRP10_PARAM_SET_NONE   0
+#define WMRP10_PARAM_SET_BT     1
+#define WMRP10_PARAM_SET_BLE    2
+
+#define WMRP10_WLAN_FRAME       0
+#define WMRP10_BT_FRAME         1
+#define WMRP10_BLE_FRAME        2
+
+/* WLAN 接続モード */
+enum
+{
+    WMRP10_AUTO           = 0x00,
+    WMRP10_WIFIDIRECT,
+    WMRP10_INFRASTRUCTURE,
+    WMRP10_ACCESS_POINT,
+};
+
+enum
+{
+    WMRP10_SECURITY_OPEN = 0x00,
+    WMRP10_SECURITY_WPA,
+    WMRP10_SECURITY_WPA2,
+    WMRP10_SECURITY_WEP,
+    WMRP10_SECURITY_EAP_WPA,
+    WMRP10_SECURITY_EAP_WPA2,
+    WMRP10_SECURITY_WPAWPA2,    
+    WMRP10_SECURITY_WPA_CCMP,
+    WMRP10_SECURITY_WPA2_CCMP,
+
+    /* max */
+    WMRP10_SECURITY_PARAM_MAX,
+};
+
+enum
+{
+    WMRP10_REGION_DEFAULT = 0x00,
+    WMRP10_REGION_US,
+    WMRP10_REGION_EU,
+    WMRP10_REGION_JP,
+    //WMRP10_REGION_WORLD,  /* RedPine no support */
+
+    /* max */
+    WMRP10_REGION_PARAM_MAX,
+};
+
+enum
+{
+    WMRP10_WPS_DISABLE = 0X00,
+    WMRP10_WPS_PUSH_BUTTON,
+    WMRP10_WPS_PIN,
+    WMRP10_WPS_PIN_GENERATE,
+    /* max */
+    WMRP10_WPS_MODE_PARAM_MAX,
+};
+
+/* WLAN Power Level */
+enum
+{
+    WMRP10_POWER_LOW = 0x00,
+    WMRP10_POWER_MID,
+    WMRP10_POWER_HIGH,
+};
+
+#pragma pack(1)
+
+
+typedef struct _tag_wmrp10_cfg_prm
+{
+    /* 共通 */
+    unsigned char mode;
+    unsigned char band;  /* INFRASTRUCTUREモード用 */
+    unsigned char power;
+    unsigned char antenna_enable;
+    unsigned char antenna_type;  /* 0x00:アンテナ制御OFF, 0x01:アンテナ制御ON */
+    unsigned char antenna_val;     /* 0x00:Internal, 0x01:uFL */
+    unsigned char antenna_gain24;  /* AntennaGain : 0 ～ 10 */
+    unsigned char antenna_gain5;   /* AntennaGain : 0 ～ 10 */
+    unsigned char ch;
+    unsigned char wps_mode;     /* WPS 動作モード */
+    unsigned char pin[WMRP10_PIN_MAX]; /* WPS PIN code */
+    long timeout_scan;           /* タイムアウト値(ミリ秒) -scan用- */
+    long timeout_join;           /* タイムアウト値(ミリ秒) -join用- */
+    long timeout_wps_join;       /* タイムアウト値(ミリ秒) -WPS用- */
+    long timeout_other;          /* タイムアウト値(ミリ秒) -上記以外- */
+    
+    /* INFRASTRUCTUREモードの設定値 */
+    char ssid[WMRP10_SSID_MAX + 1];
+    unsigned char sec;
+    unsigned char psk_type;       /* 0x01:PSK, 0x02:PMK */
+    char psk[WMRP10_PSK_MAX + 1];
+    unsigned char region_code_infra;    /* 0x00/0x01:US, 0x02:Europe, 0x03:Japan */
+    unsigned short scan_filter24_infra; /* BIT0 : 1ch ... BIT13 : 14ch */
+    unsigned long scan_filter5_infra;   /* BIT0 : 36ch ... BIT23 : 165ch */
+    unsigned long rejoin_max_try;                   /* 0: 無制限 */
+    unsigned long rejoin_scan_interval;             /* 単位は、秒 */
+    unsigned long rejoin_beacon_missed_count;
+    unsigned long rejoin_first_time_retry_enable;
+    
+    /* ACCESS_POINT(2.4GHz)モードの設定値 */
+    unsigned char hidden;
+    unsigned char region_country_code_ap24[3];  /* "US ", "EU ", "JP " */
+    unsigned long region_no_of_rules_ap24;
+    struct
+    {
+        unsigned char first_channel;
+        unsigned char no_of_channels;
+        unsigned char max_tx_power;
+
+    }region_channel_info_ap24[WMRP10_MAX_POSSIBLE_CHANNEL];
+    unsigned char region_code_ap24;  /* 0x00/0x01:US, 0x02:Europe, 0x03:Japan */
+    unsigned short scan_filter24_ap24; /* BIT0 : 1ch ... BIT13 : 14ch */
+    
+    /* ACCESS_POINT(5GHz)モードの設定値 */
+    char ssid_ap5[WMRP10_SSID_MAX + 1];
+    unsigned char sec_ap5;
+    char psk_ap5[WMRP10_PSK_MAX + 1];
+    unsigned char region_country_code_ap5[3];  /* "US ", "EU ", "JP " */
+    unsigned long region_no_of_rules_ap5;
+    struct
+    {
+        unsigned char first_channel;
+        unsigned char no_of_channels;
+        unsigned char max_tx_power;
+    }region_channel_info_ap5[WMRP10_MAX_POSSIBLE_CHANNEL];
+    unsigned char region_code_ap5;  /* 0x00/0x01:US, 0x02:Europe, 0x03:Japan */
+    unsigned long scan_filter5_ap5;   /* BIT0 : 36ch ... BIT23 : 165ch */
+    
+    /* EAP */
+    char method[WMRP10_METHOD_MAX];
+    char inner[WMRP10_INNER_MAX];
+    char username[WMRP10_USERNAME_MAX];
+    char password[WMRP10_PASSWORD_MAX];
+    
+    /* WiFi Direct */
+    int gointent;
+    char devicename[WMRP10_DEVICENAME_MAX];
+    char wfd_ssid[WMRP10_SSID_MAX];
+}t_wmrp10_cfg_prm;
+
+struct wmrp10_priv
+{
+    struct net_device_stats stats;
+    struct spi_device *spi;
+    struct net_device *ndev;
+    spinlock_t lock;
+    struct work_struct work;
+    struct work_struct tx_work;
+    struct sk_buff *skbs[WMRP10_BUFFER_LEN];
+    u32 skb_rp, skb_wp;
+    struct wmrp10_platform_data *pdata;
+    
+    /* wireless */
+    struct iw_statistics iwstats;
+    u32 mode;
+    int security_mode;
+    int wpa_level;
+    int band;
+    int region;
+    int channel;
+    int txpower;
+    int bitrate;
+    int antenna;
+    int hidden;
+    int wps_mode;
+    u8 pin[WMRP10_PIN_MAX];
+    u8 eap_method[WMRP10_METHOD_MAX];
+    u8 inner[WMRP10_INNER_MAX];
+    u8 username[WMRP10_USERNAME_MAX];
+    u8 password[WMRP10_PASSWORD_MAX];
+    int gointent;
+    u8 devicename[WMRP10_DEVICENAME_MAX];
+    u8 essid[IW_ESSID_MAX_SIZE];
+    int essid_len;
+    u8 psk[IW_ENCODING_TOKEN_MAX];
+    int psk_len;
+    u8 keys[WMRP10_KEY_NUM][IW_ENCODING_TOKEN_MAX];
+    unsigned long key_enabled;
+    unsigned int key_lens[WMRP10_KEY_NUM];
+    unsigned int current_key;
+    wait_queue_head_t init_waitq;
+    wait_queue_head_t scan_waitq;
+    wait_queue_head_t join_waitq;
+    u8 fwversion[20];
+    u8 mac_addr[6];
+    bool join_flg;
+    int type;
+    int irq;
+    int gpio_reset;
+    int gpio_power;
+    
+    /* ieee80211 */
+    struct ieee80211_hw *hw;
+};
+
+#pragma pack(8)
+
+
+int16 wmrp10_app_cfg(struct wmrp10_priv *priv);
+int16 wmrp10_app_init(void);
+int16 wmrp10_app_exit(void);
+int16 wmrp10_app_start(unsigned char *macaddr);
+int wmrp10_reset(void);
+
+extern int g_frame_read_type;
+
+#endif  /* _WMRP10_H_ */
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/Makefile b/drivers/net/wireless/wmrp10/wmrp10_apis/Makefile
new file mode 100644
index 0000000..830d494
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/Makefile
@@ -0,0 +1,22 @@
+######################################################################
+#                                                                    #
+#   Makefile                                                         #
+#                                                                    #
+#   2019/06/28 Create(AlphaProject)                                  #
+#                                                                    #
+######################################################################
+
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include
+
+
+obj-$(CONFIG_WMRP10_SPI) += wmrp10_apis_all.o
+
+wmrp10_apis_all-objs := wmrp10_apis.o wmrp10_os.o wmrp10_rsi.o wmrp10_bt_os.o wmrp10_bt_rsi.o wmrp10_ble_os.o wmrp10_ble_rsi.o
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include/rsi_ble_api.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include/rsi_ble_api.h
new file mode 100755
index 0000000..58a4f68
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include/rsi_ble_api.h
@@ -0,0 +1,262 @@
+/**
+ * @file     rsi_ble_api.h
+ * @version  1.0
+ * @date     2014-Aug-21
+ *
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER: API specific Defines
+ *
+ * @section Description
+ * This file contains the function prototypes of the APIs defined in library. 
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ */
+
+#ifndef _BLEAPI_H_
+#define _BLEPI_H_
+
+/**
+ * Include Files
+ */
+#include "rsi_ble_global.h"
+#include "rsi_bt_generic.h"
+
+
+#define  BLEPI_H_EXTERN  extern
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+
+#define  MAX_NBR_OF_REMOET_DEVS    5
+#define  SIZE_OF_BDADDR            6
+BLEPI_H_EXTERN  UINT08  remote_dev_list[MAX_NBR_OF_REMOET_DEVS][SIZE_OF_BDADDR];
+BLEPI_H_EXTERN  UINT08  remote_dev_count;
+
+BLEPI_H_EXTERN  UINT08  connected_dev_list[MAX_NBR_OF_REMOET_DEVS][SIZE_OF_BDADDR];
+BLEPI_H_EXTERN  UINT08  connected_dev_count;
+
+
+/* Core commands */
+#define  RSI_BLE_REQ_ADVERTISE                            0x0075
+#define  RSI_BLE_REQ_SCAN                                 0x0076                               
+#define  RSI_BLE_REQ_CONNECT                              0x0077                       
+#define  RSI_BLE_REQ_DISCONNECT                           0x0078                 
+#define  RSI_BLE_REQ_QUERY_DEVICE_STATE                   0x0079               
+
+/* SMP commands */
+#define  RSI_BLE_REQ_START_ENCRYPTION                     0x007B             
+#define  RSI_BLE_REQ_SMP_PAIR_REQUEST                     0x007C       
+#define  RSI_BLE_REQ_SMP_RESPONSE                         0x007D                         
+#define  RSI_BLE_REQ_SMP_PASSKEY                          0x007E                                   
+
+/* GATT commands */
+#define  RSI_BLE_REQ_QUERY_PROFILES_LIST                  0x007F                 
+#define  RSI_BLE_REQ_QUERY_PROFILE                        0x0080                       
+#define  RSI_BLE_REQ_QUERY_CHARACTERISTIC_SERVICES        0x0081                          
+#define  RSI_BLE_REQ_QUERY_INCLUDE_SERVICES               0x0082                   
+#define  RSI_BLE_REQ_READ_CHAR_VALUE_BY_UUID              0x0083                   
+#define  RSI_BLE_REQ_QUERY_ATT_DESC                       0x0084                     
+#define  RSI_BLE_REQ_QUERY_ATT_VALUE                      0x0085                     
+#define  RSI_BLE_REQ_QUERY_MULTIPLE_ATT_VALUES            0x0086                 
+#define  RSI_BLE_REQ_QUERY_LONG_ATT_VALUE                 0x0087                       
+#define  RSI_BLE_REQ_SET_ATT_VALUE                        0x0088                   
+#define  RSI_BLE_REQ_SET_ATT_VALUE_NO_ACK                 0x0089                               
+#define  RSI_BLE_REQ_SET_LONG_ATT_VALUE                   0x008A                                   
+#define  RSI_BLE_REQ_SET_PREPARE_LONG_ATT_VALUE           0x008B                     
+#define  RSI_BLE_REQ_EXECUTE_LONG_ATT_VALUE_WRITE         0x008C              
+#define  RSI_BLE_REQ_ANTENNA_SELECT                       0x008F
+#define  RSI_BLE_REQ_CONFIG_ENABLE                        0x0090
+//#define  RSI_BLE_REQ_LINKKEY_REPLY                        0x0091
+#define  RSI_BLE_REQ_ADD_SERVICE                          0x0092
+#define  RSI_BLE_REQ_ADD_ATTRIBUTE                        0x0093
+#define  RSI_BLE_REQ_SET_LOCAL_ATT_VALUE                  0x0094
+#define  RSI_BLE_REQ_GET_LOCAL_ATT_VALUE                  0x0095
+
+#define  RSI_BLE_REQ_ADD_LINKLOSS_SERVICE                 0x0150
+#define  RSI_BLE_REQ_ADD_LINKLOSS_ATT1                    0x0151
+#define  RSI_BLE_REQ_ADD_LINKLOSS_ATT2                    0x0152
+#define  RSI_BLE_REQ_ADD_LINKLOSS_ATT3                    0x0153
+
+#define  RSI_BLE_REQ_ADD_IMMEDIATE_SERVICE		 	          0x0154
+#define  RSI_BLE_REQ_ADD_IMMEDIATE_ATT1                   0x0155
+#define  RSI_BLE_REQ_ADD_IMMEDIATE_ATT2                   0x0156
+
+#define  RSI_BLE_REQ_SET_LOCAL_ATT_VALUE_ID               0x0157
+#define  RSI_BLE_REQ_GET_LOCAL_ATT_VALUE_ID               0x0158
+
+#define  RSI_BLE_REQ_SET_ADVERTISE_DATA                   0x0159
+#define  RSI_BLE_REQ_SET_LE_PING_TIMEOUT                  0x015A
+#define  RSI_BLE_REQ_GET_LE_PING_TIMEOUT                  0x015B
+#define  RSI_BLE_REQ_SET_RANDOM_ADDRESS                   0x015C
+#define  RSI_BLE_SET_ANTENNA_TX_POWER_LEVEL               0x015D
+
+#define  RSI_BLE_REQ_ADD_RSI_SERVICE                      0x0160
+#define  RSI_BLE_REQ_ADD_RSI_ATT1                         0x0161
+#define  RSI_BLE_REQ_ADD_RSI_ATT2                         0x0162
+#define  RSI_BLE_REQ_ADD_RSI_ATT3                         0x0163
+#define  RSI_BLE_REQ_ADD_RSI_ATT4                         0x0164
+#define  RSI_BLE_REQ_ADD_RSI_ATT5                         0x0165
+
+#define  RSI_BLE_REQ_GET_RSI_ATT4                         0x0166
+#define  RSI_BLE_REQ_SET_RSI_ATT4                         0x0167
+
+#define  RSI_BLE_ADD_WHITELIST                            0x0168 
+#define  RSI_BLE_DELETE_WHITELIST                         0x0169
+#define  RSI_BLE_CLEARALL_WHITELIST                       0x016A
+#define  RSI_BLE_LTK_REQ_REPLY                            0x016B
+#define  RSI_BLE_SMP_REJECT_REPLY                         0x016C
+
+
+//! BLE Response Frame Codes
+#define  RSI_BLE_RSP_ADVERTISE                            0x0075 
+#define  RSI_BLE_RSP_SCAN                                 0x0076                               
+#define  RSI_BLE_RSP_CONNECT                              0x0077                       
+#define  RSI_BLE_RSP_DISCONNECT                           0x0078                 
+#define  RSI_BLE_RSP_QUERY_DEVICE_STATE                   0x0079               
+#define  RSI_BLE_RSP_START_ENCRYPTION                     0x007B             
+#define  RSI_BLE_RSP_SMP_PAIR_REQUEST                     0x007C       
+#define  RSI_BLE_RSP_SMP_RESPONSE                         0x007D                         
+#define  RSI_BLE_RSP_SMP_PASSKEY                          0x007E                                   
+#define  RSI_BLE_RSP_QUERY_PROFILES_LIST                  0x007F                 
+#define  RSI_BLE_RSP_QUERY_PROFILE                        0x0080                       
+#define  RSI_BLE_RSP_QUERY_CHARACTERISTIC_SERVICES        0x0081                          
+#define  RSI_BLE_RSP_QUERY_INCLUDE_SERVICES               0x0082                   
+#define  RSI_BLE_RSP_READ_CHAR_VALUE_BY_UUID              0x0083                   
+#define  RSI_BLE_RSP_QUERY_ATT_DESC                       0x0084                     
+#define  RSI_BLE_RSP_QUERY_ATT_VALUE                      0x0085                     
+#define  RSI_BLE_RSP_QUERY_MULTIPLE_ATT_VALUES            0x0086                 
+#define  RSI_BLE_RSP_QUERY_LONG_ATT_VALUE                 0x0087                       
+#define  RSI_BLE_RSP_SET_ATT_VALUE                        0x0088                   
+#define  RSI_BLE_RSP_SET_ATT_VALUE_NO_ACK                 0x0089                               
+#define  RSI_BLE_RSP_SET_LONG_ATT_VALUE                   0x008A                                   
+#define  RSI_BLE_RSP_SET_PREPARE_LONG_ATT_VALUE           0x008B                     
+#define  RSI_BLE_RSP_EXECUTE_LONG_ATT_VALUE_WRITE         0x008C     
+#define  RSI_BLE_RSP_ANTENNA_SELECT                       0x008F
+#define  RSI_BLE_RSP_CONFIG_ENABLE                        0x0090
+#define  RSI_BLE_RSP_LINKKEY_REPLY                        0x0091
+#define  RSI_BLE_RSP_ADD_SERVICE                          0x0092
+#define  RSI_BLE_RSP_ADD_ATTRIBUTE                        0x0093
+#define  RSI_BLE_RSP_SET_LOCAL_ATT_VALUE                  0x0094
+#define  RSI_BLE_RSP_GET_LOCAL_ATT_VALUE                  0x0095
+
+#define  RSI_BLE_RSP_SET_ADVERTISE_DATA                   0x009C
+#define  RSI_BLE_RSP_GET_LE_PING_TIMEOUT                  0x00A1
+#define  RSI_BLE_RSP_SET_LE_PING_TIMEOUT                  0x00A2
+#define  RSI_BLE_RSP_ANTENNA_TX_POWER_LEVEL               0x00A7
+#define  RSI_BLE_RSP_WHITE_LIST                           0x00AA
+#define  RSI_BLE_RSP_LE_LTK_REQ_REPLY                     0x00BA
+#define  RSI_BLE_RSP_SMP_REQ_REJECT                       0x00F0
+
+//! BLE Event Frames
+#define  RSI_BLE_EVENT_ADVERTISE_REPORT                   0x150E
+#define  RSI_BLE_EVENT_CONNECTION_STATUS                  0x150F
+
+#define  RSI_BLE_EVENT_SMP_REQUEST                        0x1510
+#define  RSI_BLE_EVENT_SMP_RESPONSE                       0x1511
+#define  RSI_BLE_EVENT_SMP_PASSKEY                        0x1512
+#define  RSI_BLE_EVENT_SMP_FAILED                         0x1513
+
+//! BLE GATT Profile Event Frames
+#define  RSI_BLE_EVENT_GATT_NOTIFICATION                  0x1514
+#define  RSI_BLE_EVENT_GATT_INDICATION                    0x1515
+
+#define  RSI_BLE_EVENT_ENCRYPT_ENABLED                    0x1516
+#define  RSI_BLE_EVENT_GATT_WRITE_VALUE                   0x1517
+#define  RSI_BLE_EVENT_MTU_SIZE_VALUE                     0x151C
+#define  RSI_BLE_EVENT_SMP_PASSKEY_DISPLAY                0x151D
+#define  RSI_BLE_EVENT_LE_LTK_REQUEST                     0x152A
+
+//! BLE Proximity Profile Event Frames
+#define  RSI_BLE_EVENT_PXPR_LINK_LOSS_ALERT               0x1520
+#define  RSI_BLE_EVENT_PXPR_IMMEDIATE_ALERT               0x1521
+#define  RSI_BLE_EVENT_PXPR_LINK_IS_LOST                  0x1522
+#define BLE_CLEARALL_ENTRYS_FROM_WHITELIST         0x00 
+#define BLE_ADD_ENTRY_TO_WHITE_LIST                0x01
+#define BLE_DELETE_ENTRY_FROM_WHITE_LIST           0x02
+/* IOCapability for SMP*/
+#define DISPLAY_ONLY                     0
+#define KEYBOARD_AND_DISPLAY             1
+
+/* Rejecting SMP Request from the remote device */
+#define BLE_SMP_REQ_REJECT_REPLY         0x05
+
+
+/*
+ * BLE Core Function Prototype Definitions
+ */
+
+INT16 rsi_ble_advertise(RSI_BLE_CMD_ADVERTISE *LEAdv);
+INT16 rsi_ble_scan(RSI_BLE_CMD_SCAN *LEScan);
+INT16 rsi_ble_connect(RSI_BLE_CMD_CONNECT *LEConn);
+INT16 rsi_ble_disconnect(RSI_BLE_CMD_DISCONNECT  *uLEDisconnect);
+INT16 rsi_ble_query_device_state(void);
+INT16 rsi_ble_start_encryption(RSI_BLE_CMD_ENCRYPTTION  *uLEEncrypt);
+INT16 rsi_ble_smp_pair_request(RSI_BLE_CMD_SMP_PAIR_REQUEST *SMPPairReq);
+INT16 rsi_ble_smp_response(RSI_BLE_CMD_SMP_RESPONSE *SMPResp);
+INT16 rsi_ble_smp_passkey(RSI_BLE_CMD_SMP_PASSKEY *SMPPasskey);
+
+INT16 rsi_ble_set_advertise_data(RSI_BLE_CMD_SET_ADVERTISE_DATA *uSetadvertisedata);
+INT16 rsi_ble_set_ping_timeout(RSI_BLE_CMD_SET_PING_TIMEOUT *uSetLePingTimeout);
+INT16 rsi_ble_get_ping_timeout(void);
+
+INT16 rsi_ble_set_random_address(RSI_BLE_CMD_SET_RANDOM_ADDRESS *uSetRandAdd);                            
+INT16 rsi_ble_set_antenna_tx_power_value(RSI_BLE_CMD_SET_ANTENNA_TX_POWER_VLAUE * uSetAntennaTxPower);
+INT16 rsi_ble_white_list(RSI_BLE_CMD_WHITE_LIST *uBleWhiteList);
+INT16 rsi_ble_ltk_req_reply(RSI_BLE_CMD_LE_LTKREQREPLY *uBleLtkReqReply);
+INT16 rsi_ble_smp_pairing_rejection(RSI_BLE_CMD_SMP_REJECT_REPLY *uBLESMPRejectResp);
+
+
+/*
+ * BLE GATT Profile Function Prototype Definitions
+ */
+
+INT16 rsi_ble_query_profiles_list(RSI_BLE_CMD_PROFILE_LIST  *uGetProfileList);
+INT16 rsi_ble_query_profile(RSI_BLE_CMD_QUERY_PROFILE *GetProf);
+INT16 rsi_ble_query_characteristic_services(RSI_BLE_CMD_QUERY_CHARACTERISTIC_SERVICES *GetCharServ);
+INT16 rsi_ble_query_include_service(RSI_BLE_CMD_QUERY_INCLUDE_SERVICES *GetIncludeServ);
+INT16 rsi_ble_read_char_value_by_UUID(RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID *ReadCharValByUUID);
+INT16 rsi_ble_query_att(RSI_BLE_CMD_QUERY_ATT_DESC *GetAtt);
+INT16 rsi_ble_query_att_value(RSI_BLE_CMD_QUERY_ATT_VALUE *GetAttVal);
+INT16 rsi_ble_query_multi_att_values(RSI_BLE_CMD_QUERY_MULTIPLE_ATT_VALUES *GetMulAttVal);
+INT16 rsi_ble_query_long_att_value(RSI_BLE_CMD_QUERY_LONG_ATT_VALUE *GetLongAttVal);
+INT16 rsi_ble_set_att_value(RSI_BLE_CMD_SET_ATT_VALUE *SetAttVal);
+INT16 rsi_ble_set_att_value_no_ack(RSI_BLE_CMD_SET_ATT_VALUE_NO_ACK *SetAttValNoAck);
+INT16 rsi_ble_set_long_att_value(RSI_BLE_CMD_SET_LONG_ATT_VALUE *SetLongAttVal);
+INT16 rsi_ble_set_prep_long_att_value(RSI_BLE_CMD_SET_PREPARE_LONG_ATT_VALUE *SetPrepLongAttVal);
+INT16 rsi_ble_execute_long_att_value(RSI_BLE_CMD_EXECUTE_LONG_ATT_VALUE_WRITE *ExeLongAttVal);
+
+/*
+ * BT Generic commands
+ */
+INT16 rsi_bt_device_init(void);
+INT16 rsi_bt_device_deinit(void);
+INT16 rsi_bt_antenna_select(RSI_BT_CMD_ANTENNA_SELECT *uAntennaSelect);
+INT16 rsi_ble_device_AddService(RSI_BLE_CMD_ADD_GATT_SERVICE *uLEAddService);
+INT16 rsi_ble_device_AddServiceAttribute(RSI_BLE_CMD_ADD_GATT_ATTRIBUTE *uLEAddAttribute);
+INT16 rsi_ble_device_ChangeLocalAttValue(RSI_BLE_CMD_SET_LOCAL_ATT_VALUE *uLEChangeAttVal);
+INT16 rsi_ble_device_GetLocalAttValue(RSI_BLE_CMD_GET_LOCAL_ATT_VALUE *uLEGetAttVal);
+
+
+void  clear_scan_resp (void);
+void  update_scan_resp (UINT08  *p_resp_buf, UINT16   resp_len);
+void  update_connected_devices (UINT08  *p_resp_buf, UINT16   resp_len);
+void  remove_connected_devices (UINT08  *p_resp_buf, UINT16   resp_len);
+INT08 GetScanDevIndex (void);
+INT08 GetConnectedDevIndex (void);
+
+INT16 ble_main(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include/rsi_ble_global.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include/rsi_ble_global.h
new file mode 100755
index 0000000..931505a
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include/rsi_ble_global.h
@@ -0,0 +1,1428 @@
+/**
+ * @file     rsi_ble_global.h
+ * @version  1.0
+ * @date     2014-Aug-23
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER, GLOBAL, Global Header file, the things that must be almost everywhere 
+ *
+ * @section Description
+ * This is the top level global.h file for data/functions that need to be in every module
+ *
+ * @section Improvements
+ * None
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _RSIBLEGLOBAL_H_
+#define _RSIBLEGLOBAL_H_
+
+#include "rsi_bt_generic.h"
+
+/*****************************************************************************************/
+/*                               Bluetooth Low energy                                    */
+/*****************************************************************************************/
+
+
+/*
+Advertise Local Device
+----------------------
+
+Command Index: 0x75
+
+Arguments:
+1. Status (1B)
+2. Advertise Type (1B)
+3. Filter Type (1B)
+4. DirectAddrType (1B)
+5. DirectAddr (6B)
+6. adv_int_min (2B)
+7. adv_int_max (2B)
+8. own_add_type (1B)
+9. adv_channel_map (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  Status;
+    UINT08  AdvertiseType;
+    UINT08  FilterType;
+    UINT08  DirectAddrType;
+    UINT08  DirectAddr[RSI_BT_BD_ADDR_LEN];
+    UINT16  adv_int_min;
+    UINT16  adv_int_max;
+    UINT08  own_add_type;
+    UINT08  adv_channel_map;
+  }AdvFrameSnd  ;
+
+  UINT08 uAdvBuf[RSI_BT_BD_ADDR_LEN + 10];
+
+} RSI_BLE_CMD_ADVERTISE  ;
+
+
+/*
+Scan Devices
+------------
+
+Command Index: 0x76
+
+Arguments:
+1. Status (1B)
+2. Scan type (1B)
+3. Filter Type (1B)
+4. own_add_type (1B)
+5. scan_int (2B)
+6. scan_win (2B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  Status;
+    UINT08  Scantype;
+    UINT08  FilterType;
+   // UINT08  Reserved;
+    UINT08  own_add_type;
+    UINT16  scan_int;
+    UINT16  scan_win;
+  }ScanFrameSnd  ;
+
+  UINT08 uScanBuf[8];
+
+} RSI_BLE_CMD_SCAN  ;
+
+
+/*
+LE Connection
+-------------
+
+Command Index: 0x77
+
+Arguments:
+1. Address Type (1B)
+2. BD Address (6B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  AddressType;
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  Reserved;
+    UINT16  LeScanInterval;
+    UINT16  LeScanWindow;
+    UINT16  ConnIntervalMin;
+    UINT16  ConnIntervalMax;
+    UINT16  ConnLatency;
+    UINT16  SupervisionTimeout;
+  }ConnectFrameSnd  ;
+
+  UINT08 uConnectBuf[RSI_BT_BD_ADDR_LEN + 14];
+
+} RSI_BLE_CMD_CONNECT  ;
+
+
+/*
+LE Disconnect
+-------------
+
+Command INdex: 0x78
+
+Arguments:
+1. BDAddress (6B)
+*/
+
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }DisconnectFrameSnd;
+
+  UINT08 uDisconnectReqbuf[RSI_BT_BD_ADDR_LEN];
+
+} RSI_BLE_CMD_DISCONNECT;
+
+
+/*
+Set LE Random Address
+-------------
+
+Command INdex: 0xA3
+
+Arguments:
+1. BDAddress (6B)
+*/
+
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }SetRandAddFrameSnd;
+
+  UINT08 uSetRandAddbuf[RSI_BT_BD_ADDR_LEN];
+
+} RSI_BLE_CMD_SET_RANDOM_ADDRESS;
+
+/*
+Set Tx power value
+-------------
+
+Command INdex: 0xA7
+
+Arguments:
+1. Tx power value
+*/
+
+typedef union {
+  
+  struct {
+    UINT08  ProtocolMode;
+    UINT08  AntennaTxPower;
+  }SetAntennaTxPower;
+
+  UINT08 uSetAntennaTxPowerbuf[2];
+
+} RSI_BLE_CMD_SET_ANTENNA_TX_POWER_VLAUE;
+
+/* Command INdex: 0xF0
+
+Arguments:
+Arguments:
+1. BDAddress (6B)
+2. Address type (1B)
+3. Reason code (1B) 
+   
+   
+*/
+typedef union {
+  
+  struct {
+
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  Reserved[2];
+    UINT08  ReasonCode;
+  }BleSmpRejectResp;
+
+  UINT08 uBLESMPRejectResp[RSI_BT_BD_ADDR_LEN + 3];
+
+} RSI_BLE_CMD_SMP_REJECT_REPLY;
+
+
+/*
+Set Tx power value
+-------------
+
+Command INdex: 0xAA
+
+Arguments:
+Arguments:
+1. BDAddress (6B)
+2. Address type (1B)
+3. Clear/Add device to white list (1B)  //  0 - Clear white list
+                                        //  1 - Add to white list
+                                        //  2 - Delete from white list *
+*/
+typedef union {
+  
+  struct {
+
+    UINT08  AddOrDelete;
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  BDAddresstype;
+  }BleWhiteList;
+
+  UINT08 uBLEWhiteList[RSI_BT_BD_ADDR_LEN + 2];
+
+} RSI_BLE_CMD_WHITE_LIST;
+
+/*
+Le Ltk Req reply
+-------------
+
+Command INdex: 0xBA
+
+Arguments:
+1. BDAddress (6B)
+2. Reply type (1B)
+2. LTK (16B)
+*/
+typedef union {
+  
+  struct {
+
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08	ReplyType;
+    UINT08	LocalLTK[16];
+  }BleLtkReqReply;
+
+  UINT08 uBLELtkReqReply[RSI_BT_BD_ADDR_LEN + 17];
+
+} RSI_BLE_CMD_LE_LTKREQREPLY;
+
+/*
+Query Device State (Resp)
+-----------------------
+
+Command Index: 0x79 
+
+Arguments:
+1. State (1B)
+*/
+typedef struct rsi_ble_resp_query_device_state {
+    UINT08  DeviceState;    
+} RSI_BLE_RESP_QUERY_DEVICE_STATE  ;
+
+
+/*
+Start Encryption
+----------------
+
+Command Index: 0x7b
+
+Arguments:
+1. BDAddress    (6B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }SmpEncriptionFrameSnd  ;
+
+  UINT08 uSmpEncryptReqbuf[RSI_BT_BD_ADDR_LEN];
+
+} RSI_BLE_CMD_ENCRYPTTION;
+
+
+/*
+Start SMP Pair Request
+----------------------
+
+Command Index: 0x7c
+
+Arguments:
+1. BDAddress (6B)
+2. IOCapability (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  IOCapability;   
+  }SmpPairReqFrameSnd  ;
+
+  UINT08 uSmpPairReqbuf[RSI_BT_BD_ADDR_LEN + 1];
+
+} RSI_BLE_CMD_SMP_PAIR_REQUEST  ;
+
+
+/*
+SMP Response
+------------
+
+Command Index: 0x7d
+
+Arguments:
+1. BDAddress (6B)
+2. IOCapability (1B)
+*/
+
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  IOCapability;    
+  }SmpRespFrameSnd  ;
+
+  UINT08 uSmpRespBuf[RSI_BT_BD_ADDR_LEN + 1];
+
+} RSI_BLE_CMD_SMP_RESPONSE  ;
+
+
+/*
+SMP Passkey 
+-----------
+
+Command Index:  0x7e
+
+Arguments:
+1. BDAddress (6B)
+2. Passkey (4B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  Reserved[2];
+    UINT08  Passkey[4];
+  }SmpPasskeyFrameSnd  ;
+
+  UINT08 uSmpPasskeyBuf[RSI_BT_BD_ADDR_LEN + 6];
+
+} RSI_BLE_CMD_SMP_PASSKEY  ;
+
+/*
+Set advertise data 
+-----------
+
+Command Index:  0x7e
+
+Arguments:
+1. Data (31B)
+2. Data Length (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  DataLen;
+    UINT08  Data[31];
+  }SetAdvertiseDataFrameSnd  ;
+
+  UINT08 uSetAdvertiseDataBuf[32];
+
+} RSI_BLE_CMD_SET_ADVERTISE_DATA  ;
+
+
+/*
+Set le ping timeout 
+-----------
+
+Command Index:  0x7e
+
+Arguments:
+1. BDAddress (6B)
+2. timeout (2B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT16  Timeout;
+  }SetLePingTimeoutFrameSnd  ;
+
+  UINT08 uSetLePingTimeoutBuf[RSI_BT_BD_ADDR_LEN + 2];
+
+} RSI_BLE_CMD_SET_PING_TIMEOUT  ;
+
+/*
+Get le ping timeout 
+-----------
+
+Command Index:  0x7e
+
+Arguments:
+1. timeout (2B)
+*/
+  
+typedef struct  rsi_ble_resp_get_ping_timeout{
+    UINT16  Timeout;
+} RSI_BLE_RESP_GET_PING_TIMEOUT  ;
+
+
+
+/*****************************************************************************************/
+/*                               Bluetooth Low energy (GATT)                             */
+/*****************************************************************************************/
+
+
+/*
+Query All Profile List (Resp)
+---------------------------
+
+Command Index: 0x7f
+
+Arguments:
+1. BD Address
+2. start handle
+3. end handle
+
+
+Arguments:
+1. Number of Profiles (1B)
+2. Profile Descriptors List (6B)
+2.1. Start Handle (2B)
+2.2. End Handle (2B)
+2.3. Profile UUID (2B)
+*/
+#define  BLE_MAX_RESP_LIST   5
+typedef union {
+  
+  struct {
+    UINT08     BDAddress[6];
+    UINT16     StartHandle;
+    UINT16     EndHandle;
+  }ProfileReqFrameSnd;
+
+  UINT08 uProfileReqBuf[10];
+
+} RSI_BLE_CMD_PROFILE_LIST;
+
+typedef struct profile_descriptor{
+    UINT08  StartHandle[2];
+    UINT08  EndHandle[2];
+    UUID_T    ProfileUUID;
+}PROFILE_DESCRIPTOR  ;
+
+typedef struct rsi_ble_resp_query_profiles_list {
+    UINT08  NumberOfProfiles;
+    UINT08  Reserved[3];
+    PROFILE_DESCRIPTOR ProfileDescriptor[BLE_MAX_RESP_LIST];
+} RSI_BLE_RESP_QUERY_PROFILES_LIST  ;
+
+
+/*
+Query Single Profile Descriptor (Cmd, Resp)
+-----------------------------------------
+
+Command Index: 0x80
+
+Arguments:
+1. UUID Size (1B)
+2. Profile UUID (16B Max)
+
+1. BDAddress (6B)
+2. ProfileDescriptor
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[6];
+	  UINT08  Reserved[2];
+    UUID_T    ProfileUUID;
+  }QueryProfileDescFrameSnd  ;
+
+  UINT08 uQueryProfileDescBuf[28];
+
+} RSI_BLE_CMD_QUERY_PROFILE  ;
+
+typedef struct rsi_ble_resp_query_profile_descriptor {
+    PROFILE_DESCRIPTOR  ProfileDescriptor;
+} RSI_BLE_RESP_QUERY_PROFILE_DESCRIPTOR  ;
+
+/*
+Query all Characteristic Services (Cmd, Resp)
+-------------------------------------------
+
+Command Index: 0x81
+
+Arguents:
+1. BDAddress
+2. Start Handle (2B)
+3. End Handle (2B)
+
+1. Handle (2B)
+2. Character Property (1B)
+3. Character Handle (2B)
+4. Character UUID (16B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  StartHandle[2];
+    UINT08  EndHandle[2];
+  }QueryCharSerFrameSnd  ;
+  
+  UINT08 uQueryCharSerBuf[10];
+
+} RSI_BLE_CMD_QUERY_CHARACTERISTIC_SERVICES  ;
+
+typedef struct bt_le_char_serv {
+		UINT08  CharacterProperty;
+		UINT08  Reserved;
+		UINT16  CharacterHandle;
+		UUID_T    CharacterUUID;
+} BT_LE_CHAR_SERV;
+
+typedef struct characteristic_service {
+    UINT16   Handle;
+    UINT08   Reserved[2];
+    BT_LE_CHAR_SERV  CharServ;
+}CHARACTERISTIC_SERVICE  ;
+
+typedef struct rsi_ble_resp_query_characteristic_services {
+    UINT08                  NumberOfCharServices;
+    UINT08                  Reserved[3];
+    CHARACTERISTIC_SERVICE  CharacteristicService[BLE_MAX_RESP_LIST];
+} RSI_BLE_RESP_QUERY_CHARACTERISTIC_SERVICES  ; 
+
+
+/*
+Query Include Services (Cmd, Resp)
+--------------------------------
+
+Command Index: 0x82
+
+Arguments:
+1. BDAddress    (6B)
+2. Start Handle (2B)
+3. End Handle   (2B)
+
+1. Handle (2B)
+2. Include Start Handle (2B)
+3. Include End Handle (2B)
+4. Include UUID (16B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  StartHandle[2];
+    UINT08  EndHandle[2];
+  }QueryIncludeServFrameSnd  ;
+
+  UINT08 uQueryIncludeServBuf[10];
+
+} RSI_BLE_CMD_QUERY_INCLUDE_SERVICES  ;
+
+
+typedef struct bt_le_inc_serv {
+	UINT16  IncludeStartHandle;
+	UINT16  IncludeEndHandle;
+    UUID_T    IncludeUUID;
+} BT_LE_INC_SERV;
+typedef struct include_service {
+    UINT16          Handle;
+	UINT08          Reserved[2];
+    BT_LE_INC_SERV  IncServ;
+}INCLUDE_SERVICE  ;
+
+typedef struct rsi_ble_resp_query_include_service {
+    UINT08           NumberOfIncludeServices;
+	UINT08           Reserved[3];
+    INCLUDE_SERVICE  IncludeServices[BLE_MAX_RESP_LIST];    
+} RSI_BLE_RESP_QUERY_INCLUDE_SERVICE  ;
+
+
+/*
+Read Characteristic Value By UUID (Cmd, Resp)
+---------------------------------------------
+
+Command Index: 0x83 
+
+Arguments:
+1. BDAddress (6B)
+2. Start Handle (2B)
+3. End Handle (2B)
+4. UUID Size (1B)
+5. UUID (16B)
+
+1. Number of values (1B)
+2. Character values[30] (30B)
+
+*/
+typedef union {
+
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  StartHandle[2];
+    UINT08  EndHandle[2];
+	  UINT08  Reserved[2];
+    UUID_T    CharacterUUID;   
+  }ReadCharValByUuidFrameSnd  ;
+
+  UINT08 uReadCharValByUuidBuf[12 + sizeof(UUID_T)];
+
+} RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID  ;
+
+typedef struct rsi_ble_resp_read_char_value_by_uuid {
+    UINT16  NumberOfValues;
+    UINT08  CharacterValue[30];
+} RSI_BLE_RESP_READ_CHAR_VALUE_BY_UUID  ;
+
+
+/*
+Query Attributes (Cmd, Resp)
+----------------------------
+
+Command Index: 0x84
+
+Arguments:
+1. BDAddress
+2. Start Handle (2B)
+3. End Handle (2B)
+
+1. Handle (2B)
+2, Attribute Type(2B)
+*/
+typedef union {
+
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  StartHandle[2];
+    UINT08  EndHandle[2];
+  }QueryAttFrameSnd  ;
+
+  UINT08 uQueryAttBuf[10];
+
+} RSI_BLE_CMD_QUERY_ATT_DESC  ;
+
+typedef struct attribute_descriptor {
+    UINT08  Handle[2];
+	UINT08  Reserved[2];
+    UUID_T    AttributeTypeUUID;
+} ATTRIBUTE_DESCRIPTOR  ;
+
+typedef struct rsi_ble_resp_query_att_desc {
+    UINT08                NumberOfAttributes;
+	UINT08                Reserved[3];
+    ATTRIBUTE_DESCRIPTOR  AttributeDescriptor[BLE_MAX_RESP_LIST];
+} RSI_BLE_RESP_QUERY_ATT_DESC  ;
+
+
+/*
+Query Attribute Value (Cmd, Resp)
+--------------------------------
+
+Command Index: 0x85
+
+Arguments:
+1. BDAddress (6B)
+2. Handle (2B)
+
+1. Number of Values (1B)
+2. Attribute Values[30] (30B Max)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  Handle[2];
+  }QueryAttValFrameSnd  ;
+
+  UINT08 uQueryAttValBuf[8];
+
+} RSI_BLE_CMD_QUERY_ATT_VALUE  ;
+
+typedef struct rsi_ble_resp_query_att_value {
+    UINT08  NumberOfValues;
+    UINT08  AttributeValues[30];
+} RSI_BLE_RESP_QUERY_ATT_VALUE  ;
+
+
+
+/*
+Query Multiple Attribute Values (Cmd, Resp)
+------------------------------------
+
+Command Index: 0x0087
+
+Arguments:
+1. BD Address        (6B)
+1. Number Of Handles (2B)
+2. Handles[5] (2B each)
+
+1. Number of Values (1B)
+2. Attribute values[30] (30B)
+*/
+typedef union {
+
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  NumberOfHandles;
+	  UINT08  Reserved;
+    UINT16  Handles[5];    
+  }QueryMulAttValFrameSnd  ;
+
+  UINT08 uQueryMulAttValBUF[18];
+
+} RSI_BLE_CMD_QUERY_MULTIPLE_ATT_VALUES  ;
+
+typedef struct rsi_ble_resp_query_multiple_att_values {
+    UINT16  NumberOfValues;
+    UINT08  AttributeValues[30];
+} RSI_BLE_RESP_QUERY_MULTIPLE_ATT_VALUES  ;
+
+
+/*
+Query Long Attribute Values (Cmd, Resp)
+--------------------------------------
+
+Command Index:0x0088
+
+Arguments:
+1. BDAddress(6B);
+2. Handle (2B)
+3. Offset (2B)
+
+1. Number of Values (1B)
+2. Long Attribute Values[50] (50B) 
+*/
+typedef union {
+  struct {
+    UINT08  BDAddress[6];
+    UINT16  Handle;
+    UINT16  Offset;   
+  }QueryLongAttValFrameSnd  ;
+
+  UINT08 QueryLongAttValBuf[10];
+
+} RSI_BLE_CMD_QUERY_LONG_ATT_VALUE  ;
+
+typedef struct rsi_ble_resp_query_long_att_value {
+    UINT08  NumberOfValues;
+    UINT08  LongAttValue[50];    
+} RSI_BLE_RESP_QUERY_LONG_ATT_VALUE  ;
+
+
+/*
+Set Attribute Value 
+--------------------
+
+Command Index:  0x88
+
+Arguments:
+1. BDAddress(6B);
+2. Handle (2B)
+3. Length (1B)
+4. Value[25] (1B each)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  Handle[2];
+    UINT08  Length;
+    UINT08  Value[25];
+  }SetAttValFrameSnd  ;
+
+  UINT08 uSetAttValBuf[34];
+
+} RSI_BLE_CMD_SET_ATT_VALUE  ;
+
+
+/*
+Set Attribute Value with no response from remote device
+-------------------------------------------------------
+
+Command Index: 0x89
+
+Arguments:
+1. BDAddress(6B);
+2. Handle (2B)
+3. Length (1B)
+4. Value[25] (1B each) 
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  Handle[2];
+    UINT08  Length;
+    UINT08  Value[25];
+  }SetAttValNoAckFrameSnd  ;
+
+  UINT08 uSetAttValNoAckbuf[34];
+
+} RSI_BLE_CMD_SET_ATT_VALUE_NO_ACK  ;
+
+
+/*
+Set Long Attribute Value 
+-------------------------
+
+Command Index:  0x8a
+
+Arguments:
+1. BDAddress(6B);
+2. Handle (2B)
+3. Offset (2B)
+4. Length (1B)
+5. Value[40] (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  Handle[2];
+    UINT08  Offset[2];
+    UINT08  Length;
+    UINT08  Value[40];
+  }SetLongAttValFrameSnd;
+
+  UINT08 uSetLongAttValBuf[51];
+
+}RSI_BLE_CMD_SET_LONG_ATT_VALUE;
+
+
+/*
+Set Prepare Long Attribute Value(Prepare write)
+------------------------------------------------
+
+Command Index:  0x8b
+
+Arguments:
+1. BDAddress(6B);
+2. Handle (2B)
+3. Offset (2B)
+4. Length (1B)
+5. Value[40] (1B each)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  Handle[2];
+    UINT08  Offset[2];
+    UINT08  Length;
+    UINT08  Value[40];
+  }SetPreLongAttValFrameSnd;
+
+  UINT08 uSetPreLongAttValBuf[51];
+
+}RSI_BLE_CMD_SET_PREPARE_LONG_ATT_VALUE;
+
+
+/*
+Execute Long Attribute value Write
+-----------------------------------
+
+Command Index: 0x8c
+
+Arguments:
+1. BDAddress(6B);
+1. Flag (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[6];
+    UINT08  Flag;
+  }ExeLongAttValWrFrameSnd  ;
+
+  UINT08 uExeLongAttValWrbuf;
+
+} RSI_BLE_CMD_EXECUTE_LONG_ATT_VALUE_WRITE  ;
+
+/*
+Add GATT Service
+-----------------------------------
+
+Command Index: 0x92
+
+Arguments:
+1. ServiceUUID(20B);
+2. NbrOfAttributes(2B);
+3. MaxDataSize(2B);
+
+1. ServiceHndlerPtr (4B)
+2. StartHndl        (2B)
+*/
+typedef union {
+  
+  struct  {
+      UUID_T        ServiceUUID;
+      UINT16      NbrAttributes;
+      UINT16      MaxAttDataSize;
+  } AddServiceRecord;
+
+  UINT08 uAddServiceRecord[24];
+
+} RSI_BLE_CMD_ADD_GATT_SERVICE;
+
+
+typedef struct rsi_ble_resp_add_gatt_service {
+    void     *ServiceHndlerPtr;
+    UINT16    StartHndl;
+} RSI_BLE_RESP_ADD_GATT_SERVICE;
+
+/*
+Add Attibute to GATT Service
+-----------------------------------
+
+Command Index: 0x93
+
+Arguments:
+1. ServiceHndlerPtr(4B);
+2. attribute handle(2B);
+3. Reserved(2B);
+4. attribute uuid(20B);
+5. property of attribute value (read/write)(1B);
+6. data (maximum of 31 bytes).
+7. data length(2B).
+*/
+typedef union {
+    
+    struct  {
+        void       *ServiceHndlerPtr;
+        UINT16      Hndl;
+        UINT16      Reserved;
+        UUID_T        AttUUID;
+        UINT08      Prop;
+        UINT08      Data[31];
+        UINT16      DataLen;
+    } AddAttRecord;
+
+  UINT08 uAddAttRecord[62];
+
+} RSI_BLE_CMD_ADD_GATT_ATTRIBUTE;
+
+
+/*
+Set or change the LOCAL Attribute Value
+-----------------------------------
+
+Command Index: 0x94
+
+Arguments:
+1. Hndl(2B);
+2. DataLen handle(2B);
+3. Data(31B);
+*/
+typedef struct  {
+    UINT16             Hndl;
+    UINT16             DataLen;
+    UINT08             Data[31];
+} RSI_BLE_CMD_SET_LOCAL_ATT_VALUE;
+
+/*
+Get the Local Attribute Value
+-----------------------------------
+Command Index: 0x95
+
+Arguments:
+1. Hndl(2B);
+
+1. Hndl(2B);
+2. DataLen handle(2B);
+3. Data(31B);
+*/
+typedef struct  {
+    UINT16             Hndl;
+} RSI_BLE_CMD_GET_LOCAL_ATT_VALUE;
+
+//Get the attribute value from GATT service(RESP), cmd_ix = 0x95;
+typedef struct  {
+    UINT16             Hndl;
+    UINT16             DataLen;
+    UINT08             Data[31];
+} RSI_BLE_RESP_GET_LOCAL_ATT_VALUE;
+
+
+
+/*****************************************************************************************/
+/*                                     LE Events                                         */
+/*****************************************************************************************/
+
+/*
+LE Advertise Report
+-------------------
+
+Event Index: RSI_BLE_EVENT_GAP_SCAN_RESP
+
+Arguments:
+1. BD Address Type (1B)
+2. BD Address (6B)
+3. Remote Device Name (50B)
+*/
+typedef struct rsi_ble_event_advertise_report {
+  UINT08  BDAddresstype;
+  UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  UINT08  Adv_data_len;
+  UINT08  Adv_data[31];
+  UINT08  RSSI;
+} RSI_BLE_EVENT_RESP_ADVERTISE_REPORT  ;
+
+
+/*
+Connection Status Event
+-----------------------
+
+Event Index: RSI_BLE_EVENT_GAP_CONN_STATUS
+
+Arguments:
+1. BD Address Type (1B)
+2. BD Address (6B)
+3. Status (1B) 
+*/
+typedef struct rsi_ble_event_connection_status {
+    UINT08  BDAddresstype;
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  Status;
+} RSI_BLE_EVENT_RESP_CONNECTION_STATUS  ;
+
+/*
+Disconnection Status Event
+-----------------------
+
+Event Index: RSI_BLE_EVENT_GAP_CONN_STATUS
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef struct rsi_ble_event_disconnection_status {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  Type;
+} RSI_BLE_EVENT_DISCONNECTION_STATUS  ;
+
+/*
+MTU Size Event
+-----------------------
+
+Event Index: RSI_BLE_EVENT_MTU_SIZE
+
+Arguments:
+1. BD Address (6B)
+2. MTU Size   (2B)
+*/
+typedef struct rsi_ble_event_mtu_size {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  MTU_size[2];
+} RSI_BLE_EVENT_MTU_SIZE  ;
+
+/*
+Encryption Enabled
+------------------------------------
+
+Event Index: RSI_BLE_EVENT_ENCRYPT_ENABLED
+
+Arguments:
+1. BD Address
+2. Enabled (1B)
+3. EDIV (2B)
+4. Rand[8] (8B)
+5. LTK[16] (16B)
+*/
+typedef struct rsi_ble_event_encryption_enabled {
+    UINT08  BDAddress[6];                                 /* BD address of the remote device  (6  Bytes) */
+    UINT08  Enabled;
+    UINT08  Reserved;
+    UINT16  LocalEDIV;                                 
+    UINT08  LocalRand[8];                              
+    UINT08  LocalLTK[16];                              
+} RSI_BT_EVENT_ENCRYPTION_ENABLED;
+
+/*
+LE LTK Req Event
+--------------------------------------
+
+Event Index: RSI_BLE_EVENT_LE_LTK_REQUEST
+
+Arguments:
+1. BD Address
+2. EDIV (2B)
+3. Rand[8] (8B)
+*/
+
+typedef struct rsi_bt_event_le_ltk_request {
+    UINT08  BDAddress[6];                                 /* BD address of the remote device  (6  Bytes) */
+    UINT16  LocalEDIV;
+    UINT08  LocalRand[8];                              
+} RSI_BT_EVENT_LE_LTK_REQUEST;
+
+/*
+SMP Request
+-----------
+
+Event Index: RSI_BLE_EVENT_SMP_REQUEST
+
+Arguments:
+1. BD Address.
+*/
+
+typedef struct rsi_bt_event_smp_req {
+    UINT08  BDAddress[6];
+} RSI_BT_EVENT_SMP_REQ;
+
+
+
+/*
+SMP Response
+------------
+
+Event Index: RSI_BLE_EVENT_SMP_RESPONSE
+
+Arguments:
+1. BD Address.
+*/
+
+typedef struct rsi_bt_event_smp_resp {
+    UINT08  BDAddress[6];
+} RSI_BT_EVENT_SMP_RESP;
+
+
+/*
+SMP Passkey
+-----------
+
+Event Index: RSI_BLE_EVENT_SMP_PASSKEY
+
+Arguments:
+1. BD Address.
+*/
+
+typedef struct rsi_bt_event_smp_passkey {
+    UINT08  BDAddress[6];
+} RSI_BT_EVENT_SMP_PASSKEY;
+
+
+/*
+SMP Passkey
+-----------
+
+Event Index: RSI_BT_EVENT_SMP_PASSKEY_DISPLAY
+
+Arguments:
+1. BD Address(6B)
+2. Reserved(2B)
+3. Passkey(4B)
+*/
+typedef struct rsi_bt_event_smp_passkey_display {
+    UINT08  BDAddress[6];                                 /* BD address of the remote device  (6  Bytes) */
+    UINT08  PasskeyStr[6];                                /* SMP passkey to be displayed */
+} RSI_BT_EVENT_SMP_PASSKEY_DISPLAY;
+
+
+/*
+SMP Failed
+----------
+
+Event Index: RSI_BLE_EVENT_SMP_FAILED
+
+Arguments:
+1. BD Address.
+*/
+
+typedef struct rsi_bt_event_smp_failed {
+    UINT08  BDAddress[6];
+} RSI_BT_EVENT_SMP_FAILED;
+
+
+
+/*
+GATT Characteristic Value Notification
+--------------------------------------
+
+Event Index: RSI_BLE_EVENT_GATT_NOTIFICATION
+
+Arguments:
+1. BD Address
+2. Handle (2B)
+3. Length (1B)
+4. Value[50] (1B)
+*/
+typedef struct rsi_ble_event_gatt_char_value_notifications {
+    UINT08  BDAddress[6];
+    UINT08  Handle[2];
+    UINT08  Length;
+    UINT08  Value[50];
+} RSI_BLE_EVENT_GATT_CHAR_VALUE_NOTIFICATIONS  ;
+
+
+/*
+GATT Characteristic Value Indication
+------------------------------------
+
+Event Index: RSI_BLE_EVENT_GATT_INDICATION
+
+Arguments:
+1. BDAddress (6B)
+2. Handle (2B)
+3. Length (1B)
+4. Value[50] (1B each)
+*/
+typedef struct rsi_ble_event_gatt_char_value_indication {
+    UINT08  BDAddress[6];
+    UINT08  Handle[2];
+    UINT08  Length;
+    UINT08  Value[50];
+} RSI_BLE_EVENT_GATT_CHAR_VALUE_INDICATION  ;
+
+
+/*
+GATT Characteristic Value write event
+--------------------------------------
+
+Event Index: RSI_BLE_EVENT_GATT_WRITE_VALUE
+
+Arguments:
+1. BD Address
+2. Handle (2B)
+3. Length (1B)
+4. Value[50] (1B)
+*/
+typedef struct rsi_ble_event_gatt_write {
+    UINT08  BDAddress[6];
+    UINT08  Handle[2];
+    UINT08  Length;
+    UINT08  Value[50];
+} RSI_BLE_EVENT_GATT_WRITE  ;
+
+/*
+PXP link loss service alert level
+------------------------------------
+
+Event Index: RSI_BLE_EVENT_PXPR_LINK_LOSS_ALERT
+
+Arguments:
+1. Link Loss Alert Level(1B)
+*/
+typedef struct rsi_ble_event_pxp_linkloss {
+    UINT08  LinkLossAlert;
+} RSI_BLE_EVENT_PXP_LINKLOSS  ;
+
+/*
+PXP Immediate alert level
+------------------------------------
+
+Event Index: RSI_BLE_EVENT_PXPR_IMMEDIATE_ALERT
+
+Arguments:
+1. Immediate Alert Level(1B)
+*/
+typedef struct rsi_ble_event_pxp_imm_alert {
+    UINT08  ImmAlert;
+} RSI_BLE_EVENT_PXP_IMM_ALERT  ;
+
+/*
+PXP Link loss alert event
+------------------------------------
+
+Event Index: RSI_BLE_EVENT_PXPR_LINK_IS_LOST
+
+Arguments:
+No Arguments.
+*/
+
+
+typedef union{
+
+  RSI_BT_CMD_SET_LOCAL_NAME                uSetLocalName;
+  RSI_BT_CMD_SET_LOCAL_COD                 uSetLocalCOD; 
+  RSI_BT_CMD_QUERY_RSSI                    uQryRssi;
+  RSI_BT_CMD_QUERY_LINK_QUALITY            uQryLinkQuality;             
+  RSI_BT_CMD_ANTENNA_SELECT                uAntennaSelect;
+
+
+  RSI_BLE_CMD_ADVERTISE                    uLeAdvertise;
+  RSI_BLE_CMD_SCAN                         uLeScan;
+  RSI_BLE_CMD_CONNECT                      uLeConnect;
+  RSI_BLE_CMD_DISCONNECT                   uLeDisConnect;
+
+  RSI_BLE_CMD_ENCRYPTTION                  uLeSmpEncrypt;
+  RSI_BLE_CMD_SMP_PAIR_REQUEST             uLeSmpReq;
+  RSI_BLE_CMD_SMP_RESPONSE                 uLeSmpResp;
+  RSI_BLE_CMD_SMP_PASSKEY                  uLeSmppasskey;
+  RSI_BLE_CMD_SET_PING_TIMEOUT             uLeSetPingTimeout;
+  RSI_BLE_CMD_SET_ADVERTISE_DATA           uLeSetAdvertiseData;
+  
+  RSI_BLE_CMD_PROFILE_LIST                   uLeAllServ;
+  RSI_BLE_CMD_QUERY_PROFILE                  uLeSev;
+  RSI_BLE_CMD_QUERY_CHARACTERISTIC_SERVICES  uLeCharServ;
+  RSI_BLE_CMD_QUERY_INCLUDE_SERVICES         uLeIncServ;
+  RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID        uLeCharVal;
+  RSI_BLE_CMD_QUERY_ATT_DESC                 uLeAttDesc;
+  RSI_BLE_CMD_QUERY_ATT_VALUE                uLeAttVal;
+  RSI_BLE_CMD_QUERY_MULTIPLE_ATT_VALUES      uLeMulAttVals;
+  RSI_BLE_CMD_QUERY_LONG_ATT_VALUE           uLeLongAttVal;
+  RSI_BLE_CMD_SET_ATT_VALUE                  uLeSetAttVal;
+  RSI_BLE_CMD_SET_ATT_VALUE_NO_ACK           uLeSetCmdAttVal;
+  RSI_BLE_CMD_SET_LONG_ATT_VALUE             uLeSetLongAttVal;
+  RSI_BLE_CMD_SET_PREPARE_LONG_ATT_VALUE     uLePrepareAttVal;
+  RSI_BLE_CMD_EXECUTE_LONG_ATT_VALUE_WRITE   uLeExecuteWrite;
+  RSI_BLE_CMD_ADD_GATT_SERVICE               uLeAddService;
+  RSI_BLE_CMD_ADD_GATT_ATTRIBUTE             uLeAddAttribute;
+  RSI_BLE_CMD_SET_LOCAL_ATT_VALUE            uLeSetLocalAttValue;
+  RSI_BLE_CMD_GET_LOCAL_ATT_VALUE            uLeGetLocalAttValue;
+  RSI_BLE_CMD_SET_RANDOM_ADDRESS             uLeRandAdd;
+  RSI_BLE_CMD_SET_ANTENNA_TX_POWER_VLAUE     uLeAntennaTxPower;
+  RSI_BLE_CMD_WHITE_LIST                     uLeWhiteList;
+  RSI_BLE_CMD_LE_LTKREQREPLY                 uLeLtkReqReply;
+  RSI_BLE_CMD_SMP_REJECT_REPLY               uLeSMPRejectReply; 
+
+}RSI_BLE_API;
+
+typedef struct rsi_ble_response{
+  UINT08   ResponseCode[2];
+  UINT08   Status[2];                 
+  union {
+
+    RSI_BT_RESP_QUERY_LOCAL_NAME                uQryLocalName;
+    RSI_BT_RESP_QUERY_LOCAL_COD                 uQryLocalCOD;       
+    RSI_BT_RESP_QUERY_RSSI                      uQryRssi;           
+    RSI_BT_RESP_QUERY_LINK_QUALITY              uQryLinkQuality;    
+    RSI_BT_RESP_QUERY_LOCAL_BD_ADDRESS          uQryLocalBDAddr;    
+
+
+    RSI_BLE_RESP_QUERY_DEVICE_STATE             uQryDevState;
+    RSI_BLE_RESP_QUERY_PROFILES_LIST            uQryProfList;
+    RSI_BLE_RESP_QUERY_PROFILE_DESCRIPTOR       uQryProf;
+    RSI_BLE_RESP_QUERY_CHARACTERISTIC_SERVICES  uQryCharServ;
+    RSI_BLE_RESP_QUERY_INCLUDE_SERVICE          uQryIncServ;
+    RSI_BLE_RESP_READ_CHAR_VALUE_BY_UUID        uQryCharVal;
+    RSI_BLE_RESP_QUERY_ATT_DESC                 uQryDescList;
+    RSI_BLE_RESP_QUERY_ATT_VALUE                uQryAttVal;
+    RSI_BLE_RESP_QUERY_MULTIPLE_ATT_VALUES      uQryAttVals;
+    RSI_BLE_RESP_QUERY_LONG_ATT_VALUE           uQryLongAttVal;
+    RSI_BLE_RESP_ADD_GATT_SERVICE               uQryAddService;
+
+	RSI_BLE_EVENT_RESP_ADVERTISE_REPORT		    uAdvReport;
+	RSI_BLE_EVENT_RESP_CONNECTION_STATUS		uConnStatus;
+	RSI_BLE_EVENT_MTU_SIZE	                 	uMTUSize;
+	RSI_BLE_EVENT_GATT_CHAR_VALUE_NOTIFICATIONS	uNotifications;
+	RSI_BLE_EVENT_GATT_CHAR_VALUE_INDICATION	uIndication;
+	//RSI_BLE_EVENT_PXP_LINKLOSS					uLinkLoss;
+	//RSI_BLE_EVENT_PXP_IMM_ALERT					uImmAlert;
+    RSI_BLE_RESP_GET_PING_TIMEOUT               uGetPingTimeout;
+    UINT08                                      uCmdRspBuf[RSI_BT_FRAME_CMD_RSP_LEN + RSI_BT_MAX_PAYLOAD_SIZE + 100];
+  }uCmdRspPayLoad;
+
+} RSI_BLE_RESPONSE;
+
+extern const UINT08  rsi_frameCmdLEAdv[RSI_BYTES_4];                
+extern const UINT08  rsi_frameCmdLEScan[RSI_BYTES_4];               
+extern const UINT08  rsi_frameCmdLEConn[RSI_BYTES_4];               
+extern const UINT08  rsi_frameCmdLEDisconn[RSI_BYTES_4];             
+extern const UINT08  rsi_frameCmdQryDevstate[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdHciParams[RSI_BYTES_4];            
+extern const UINT08  rsi_frameCmdStartEnc[RSI_BYTES_4];             
+extern const UINT08  rsi_frameCmdSMPPairReq[RSI_BYTES_4];           
+extern const UINT08  rsi_frameCmdSMPResp[RSI_BYTES_4];              
+extern const UINT08  rsi_frameCmdSMPPasskey[RSI_BYTES_4];           
+
+extern const UINT08  rsi_frameCmdSetPingTimeout[RSI_BYTES_4];       
+extern const UINT08  rsi_frameCmdGetPingTimeout[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdSetAdvertiseData[RSI_BYTES_4];
+
+extern const UINT08  rsi_frameCmdQryProfList[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdQryProfDesc[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdQryCharServ[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdQryIncludeServ[RSI_BYTES_4];       
+extern const UINT08  rsi_frameCmdReadCharValByUUID[RSI_BYTES_4];    
+extern const UINT08  rsi_frameCmdQryAtt[RSI_BYTES_4];               
+extern const UINT08  rsi_frameCmdQryAttVal[RSI_BYTES_4];            
+extern const UINT08  rsi_frameCmdQryMulAttVal[RSI_BYTES_4];         
+extern const UINT08  rsi_frameCmdQryLongAttVal[RSI_BYTES_4];        
+extern const UINT08  rsi_frameCmdSetAttVal[RSI_BYTES_4];            
+extern const UINT08  rsi_frameCmdSetAttValNoAck[RSI_BYTES_4];       
+extern const UINT08  rsi_frameCmdSetLongAttVal[RSI_BYTES_4];        
+extern const UINT08  rsi_frameCmdSetPrepLongAttVal[RSI_BYTES_4];    
+extern const UINT08  rsi_frameCmdExeLongAttVal[RSI_BYTES_4];        
+
+
+extern const UINT08  rsi_frameCmdBTAntennaSelect[RSI_BYTES_4];
+
+//extern const UINT08  rsi_frameCmdBTLinkkeyReply[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdBleAddService[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdBleAddAttribute[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdBleSetLocalAttValue[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdBleGetLocalAttValue[RSI_BYTES_4];
+
+
+extern const UINT08  rsi_frameCmdSetRandAdd[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdSetTxPowerValue[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdBleWhiteList[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdBleLtkReqReply[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdBleSMPPairingRejectReply[RSI_BYTES_4];
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/Makefile b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/Makefile
new file mode 100755
index 0000000..6ef51ef
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/Makefile
@@ -0,0 +1,20 @@
+######################################################################
+#                                                                    #
+#   Makefile                                                         #
+#                                                                    #
+#   2019/07/02 Create(AlphaProject)                                  #
+#                                                                    #
+######################################################################
+
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include
+EXTRA_CFLAGS += -DRSI_HAL
+
+obj-$(CONFIG_WMRP10_SPI) += rsi_ble_all.o
+
+rsi_ble_all-objs := rsi_ble_api.o  rsi_ble_core.o  rsi_ble_gatt.o
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/rsi_ble_api.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/rsi_ble_api.c
new file mode 100755
index 0000000..f9a2565
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/rsi_ble_api.c
@@ -0,0 +1,110 @@
+/**
+ * @file     rsi_ble_api.c
+ * @version  1.0
+ * @date     2014-08-23
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief API: Definitions of various data structures and variables
+ * 
+ * @section Description
+ * This file contains definition of different commands variables.
+ * These definitions are used to construct frames. 
+ *
+ * @section Improvements
+ * None
+ */
+/* 2019/05/15 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_ble_global.h"
+#include "rsi_ble_api.h"
+
+#include "rsi_bt_global.h"
+
+/**
+ * Global Variables
+ */
+
+/* In the 4 bytes,  
+ * BYTE0[0:7],BYTE1[0:3] together represent length of the payload for the frame command
+ * BYTE1[4:7], indicates queue number 0000 - Management,0001 - Data
+ * BYTE2[0:8], BYTE3[0:7] together represent the Frame command type. 
+ */
+//#ifdef BLE_ENABLE /* APJ modify */
+#if 1
+#if 0 /* rsi_bt_api.cの定義との重複回避 */ /* APJ modify */
+const UINT08  rsi_frameCmdSetLocalName[RSI_BYTES_4]         = {sizeof(RSI_BT_CMD_SET_LOCAL_NAME), 0x00, 0x01, 0x00};
+const UINT08  rsi_frameCmdQryLocalName[RSI_BYTES_4]         = {0x00, 0x00, 0x02, 0x00};      
+const UINT08  rsi_frameCmdSetLocalCOD[RSI_BYTES_4]          = {0x04, 0x00, 0x03, 0x00}; 
+const UINT08  rsi_frameCmdQryLocalCOD[RSI_BYTES_4]          = {0x00, 0x00, 0x04, 0x00}; 
+const UINT08  rsi_frameCmdQryRSSI[RSI_BYTES_4]              = {0x06, 0x00, 0x05, 0x00};    
+const UINT08  rsi_frameCmdQryLinkQuality[RSI_BYTES_4]       = {0x06, 0x00, 0x06, 0x00};        
+const UINT08  rsi_frameCmdQryLocalBDAddr[RSI_BYTES_4]       = {0x00, 0x00, 0x07, 0x00};       
+#endif
+
+const UINT08  rsi_frameCmdLEAdv[RSI_BYTES_4]                = {sizeof(RSI_BLE_CMD_ADVERTISE), 0x00, 0x75, 0x00}; 
+const UINT08  rsi_frameCmdLEScan[RSI_BYTES_4]               = {sizeof(RSI_BLE_CMD_SCAN), 0x00, 0x76, 0x00}; 
+const UINT08  rsi_frameCmdLEConn[RSI_BYTES_4]               = {sizeof (RSI_BLE_CMD_CONNECT), 0x00, 0x77, 0x00}; 
+const UINT08  rsi_frameCmdLEDisconn[RSI_BYTES_4]            = {0x06, 0x00, 0x78, 0x00};  
+const UINT08  rsi_frameCmdQryDevstate[RSI_BYTES_4]          = {0x00, 0x00, 0x79, 0x00};        
+const UINT08  rsi_frameCmdHciParams[RSI_BYTES_4]            = {0x00, 0x00, 0x7A, 0x00};     
+const UINT08  rsi_frameCmdStartEnc[RSI_BYTES_4]             = {0x06, 0x00, 0x7B, 0x00};    
+const UINT08  rsi_frameCmdSMPPairReq[RSI_BYTES_4]           = {0x07, 0x00, 0x7C, 0x00};      
+const UINT08  rsi_frameCmdSMPResp[RSI_BYTES_4]              = {0x07, 0x00, 0x7D, 0x00}; 
+const UINT08  rsi_frameCmdSMPPasskey[RSI_BYTES_4]           = {sizeof(RSI_BLE_CMD_SMP_PASSKEY), 0x00, 0x7E, 0x00};     
+      
+const UINT08  rsi_frameCmdQryProfList[RSI_BYTES_4]          = {0x0A, 0x00, 0x7F, 0x00};          
+const UINT08  rsi_frameCmdQryProfDesc[RSI_BYTES_4]          = {0x1C, 0x00, 0x80, 0x00};    
+const UINT08  rsi_frameCmdQryCharServ[RSI_BYTES_4]          = {0x0A, 0x00, 0x81, 0x00};     
+const UINT08  rsi_frameCmdQryIncludeServ[RSI_BYTES_4]       = {0x0A, 0x00, 0x82, 0x00};        
+const UINT08  rsi_frameCmdReadCharValByUUID[RSI_BYTES_4]    = {0x20, 0x00, 0x83, 0x00};          
+const UINT08  rsi_frameCmdQryAtt[RSI_BYTES_4]               = {0x0A, 0x00, 0x84, 0x00};  
+const UINT08  rsi_frameCmdQryAttVal[RSI_BYTES_4]            = {0x08, 0x00, 0x85, 0x00};  
+const UINT08  rsi_frameCmdQryMulAttVal[RSI_BYTES_4]         = {0x12, 0x00, 0x86, 0x00};        
+const UINT08  rsi_frameCmdQryLongAttVal[RSI_BYTES_4]        = {0x0A, 0x00, 0x87, 0x00};        
+const UINT08  rsi_frameCmdSetAttVal[RSI_BYTES_4]            = {0x22, 0x00, 0x88, 0x00};     
+const UINT08  rsi_frameCmdSetAttValNoAck[RSI_BYTES_4]       = {0x22, 0x00, 0x89, 0x00};          
+const UINT08  rsi_frameCmdSetLongAttVal[RSI_BYTES_4]        = {0x33, 0x00, 0x8A, 0x00};
+const UINT08  rsi_frameCmdSetPrepLongAttVal[RSI_BYTES_4]    = {0x33, 0x00, 0x8B, 0x00};
+const UINT08  rsi_frameCmdExeLongAttVal[RSI_BYTES_4]        = {0x07, 0x00, 0x8C, 0x00};
+
+#if 0 /* rsi_bt_api.cの定義との重複回避 */ /* APJ modify */
+const UINT08  rsi_frameCmdBTInit[RSI_BYTES_4]        		    = {0x00, 0x00, 0x8D, 0x00};       
+const UINT08  rsi_frameCmdBTDeinit[RSI_BYTES_4]        	    = {0x00, 0x00, 0x8E, 0x00};       
+
+const UINT08  rsi_frameCmdBTAntennaSelect[RSI_BYTES_4]      = {0x01, 0x00, 0x8F, 0x00};       
+const UINT08  rsi_frameCmdBTConfigEnable[RSI_BYTES_4]       = {0x01, 0x00, 0x90, 0x00};
+#endif
+const UINT08  rsi_frameCmdBTLinkkeyReply[RSI_BYTES_4]       = {0x17, 0x00, 0x91, 0x00};  //need to fill proper valus
+const UINT08  rsi_frameCmdBleAddService[RSI_BYTES_4]       	= {0x18, 0x00, 0x92, 0x00};
+const UINT08  rsi_frameCmdBleAddAttribute[RSI_BYTES_4]     	= {0x3E, 0x00, 0x93, 0x00};
+const UINT08  rsi_frameCmdBleSetLocalAttValue[RSI_BYTES_4]  = {0x23, 0x00, 0x94, 0x00};
+const UINT08  rsi_frameCmdBleGetLocalAttValue[RSI_BYTES_4]  = {0x02, 0x00, 0x95, 0x00};
+
+#if 0 /* rsi_bt_api.cの定義との重複回避 */ /* APJ modify */
+const UINT08  rsi_frameCmdPerTransmit[RSI_BYTES_4]          = {sizeof (RSI_BT_CMD_PER_TRANSMIT ), 0x00, 0x98, 0x00};
+const UINT08  rsi_frameCmdPerReceive[RSI_BYTES_4]           = {sizeof (RSI_BT_CMD_PER_RECEIVE  ), 0x00, 0x99, 0x00};
+const UINT08  rsi_frameCmdPerBTStats[RSI_BYTES_4]           = {sizeof (RSI_BT_CMD_PER_STATS    ), 0x00, 0x9a, 0x00};
+const UINT08  rsi_frameCmdPerCwMode[RSI_BYTES_4]            = {sizeof (RSI_BT_CMD_PER_CW_MODE   ), 0x00, 0x9b, 0x00};
+#endif
+
+const UINT08  rsi_frameCmdSetAdvertiseData[RSI_BYTES_4]     = {sizeof (RSI_BLE_CMD_SET_ADVERTISE_DATA), 0x00, 0x9C, 0x00};
+const UINT08  rsi_frameCmdGetPingTimeout[RSI_BYTES_4]       = {0x00, 0x00, 0xA1, 0x00}; 
+const UINT08  rsi_frameCmdSetPingTimeout[RSI_BYTES_4]        = {sizeof (RSI_BLE_CMD_SET_PING_TIMEOUT), 0x00, 0xA2, 0x00};
+
+const UINT08  rsi_frameCmdSetRandAdd[RSI_BYTES_4]           = {sizeof (RSI_BLE_CMD_SET_RANDOM_ADDRESS), 0x00, 0xA3, 0x00 };
+const UINT08  rsi_frameCmdSetTxPowerValue[RSI_BYTES_4]      = {sizeof (RSI_BLE_CMD_SET_ANTENNA_TX_POWER_VLAUE), 0x00, 0xA7, 0x00 };
+const UINT08  rsi_frameCmdBleWhiteList[RSI_BYTES_4]         = {sizeof (RSI_BLE_CMD_WHITE_LIST), 0x00, 0xAA, 0x00 };
+const UINT08  rsi_frameCmdBleLtkReqReply[RSI_BYTES_4]         = {sizeof (RSI_BLE_CMD_LE_LTKREQREPLY), 0x00, 0xBA, 0x00 };
+const UINT08  rsi_frameCmdBleSMPPairingRejectReply[RSI_BYTES_4] = {sizeof (RSI_BLE_CMD_SMP_REJECT_REPLY), 0x00, 0xF0, 0x00 };
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/rsi_ble_core.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/rsi_ble_core.c
new file mode 100755
index 0000000..1222d15
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/rsi_ble_core.c
@@ -0,0 +1,761 @@
+/**
+ * @file      rsi_ble_core.c
+ *
+ * @version   1.0
+ * @date      2014-Aug-22
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Contains BLE Core API's.
+ *
+ * @section Description
+ * This file contains a) Advertise function.
+ *  		      b) Scan function.
+ *   		      c) Connect function.
+ *    		      d) Disconnect function.
+ *    		      e) Query Device State function.
+ *    		      f) Start encryption functon.
+ *    		      g) SMP Pair Request function.
+ *    		      h) SMP Response function.
+ *    		      i) SMP passkey function.
+ *    		      j) Set advertise data.
+ *    		      k) LE ping timeout.
+ *                l) Set Random Address.
+ *    		     	     
+ */		      	
+/* 2019/05/15 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_ble_global.h"
+#include "rsi_ble_api.h"
+#include "rsi_bt_api.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *	
+ * @fn          INT16 rsi_ble_advertise(RSI_BLE_CMD_ADVERTISE *LEAdvertise)
+ * @brief       Sends the Advertise command to the BLE module
+ * @param[in]   RSI_BLE_CMD_ADVERTISE *LEAdvertise, Pointer to Set Advertise structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *               0  = SUCCESS
+ * @section description 
+ * This API is used to expose (or) advertise about local device to remote LE devices. 
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_ble_advertise(RSI_BLE_CMD_ADVERTISE *uLEAdvertise)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\nSet Advertise Mode Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdLEAdv, (UINT08 *)uLEAdvertise, sizeof(RSI_BLE_CMD_ADVERTISE));
+  return retval;
+}
+
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_scan(RSI_BLE_CMD_SCAN *LEScan)
+ * @brief       Sends the  Scan command to the BLE module
+ * @param[in]   RSI_BLE_CMD_SCAN *LEScan, Pointer to Scan structure  			
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to scan for remote LE advertise devices. 
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_ble_scan(RSI_BLE_CMD_SCAN *uLEScan)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nScan starts ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdLEScan, (UINT08 *)uLEScan, sizeof(RSI_BLE_CMD_SCAN));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_connect(RSI_BLE_CMD_CONNECT *LEConnect)	
+ * @brief       Sends the connect command to the BLE module
+ * @param[in]   RSI_BLE_CMD_CONNECT *LEConnect,Pointer to connect structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to create connection with remote LE device. .
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_ble_connect(RSI_BLE_CMD_CONNECT *uLEConnect)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Connection start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdLEConn, (UINT08 *)uLEConnect, sizeof(RSI_BLE_CMD_CONNECT));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_disconnect(void)
+ * @brief       Sends the disconnect command to the BLE module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to cancel create connection command or disconnect HCI connection of already connected device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_ble_disconnect(RSI_BLE_CMD_DISCONNECT  *uLEDisconnect)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nDisconnect start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdLEDisconn, (UINT08 *)uLEDisconnect, sizeof (RSI_BLE_CMD_DISCONNECT));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_query_device_state(void)
+ * @brief       Sends the Query Device State command to the BLE module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to get local LE device state.
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_ble_query_device_state(void)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Device State start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryDevstate, NULL, 0);
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_start_encryption(void)
+ * @brief       Sends the start Encryption command to the BLE module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to .
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_ble_start_encryption(RSI_BLE_CMD_ENCRYPTTION  *uLEEncrypt)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nStart Encryption start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdStartEnc, (UINT08 *)uLEEncrypt, sizeof (RSI_BLE_CMD_ENCRYPTTION));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_smp_pair_request(RSI_BLE_CMD_SMP_PAIR_REQUEST *SMPPairRequest)	
+ * @brief       Sends the smp pair request command to the BLE module
+ * @param[in]   RSI_BLE_CMD_SMP_PAIR_REQUEST *SMPPairRequest, Pointer to SMP Pair Request structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send the SMP pair request command to connected remote device.
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_ble_smp_pair_request(RSI_BLE_CMD_SMP_PAIR_REQUEST *uSMPPairRequest)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n SMP Pair Request start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSMPPairReq, (UINT08 *)uSMPPairRequest, sizeof(RSI_BLE_CMD_SMP_PAIR_REQUEST));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_smp_response(RSI_BLE_CMD_SMP_RESPONSE *SMPResponse)
+ * @brief       Sends the smp response command to the BLE module
+ * @param[in]   RSI_BLE_CMD_SMP_RESPONSE *SMPResponse, Pointer to SMP Response structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send SMP response command to the BLE module.
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_ble_smp_response(RSI_BLE_CMD_SMP_RESPONSE *uSMPResponse)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n SMP Response start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSMPResp, (UINT08 *)uSMPResponse, sizeof(RSI_BLE_CMD_SMP_RESPONSE));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_smp_passkey(RSI_BLE_CMD_SMP_PASSKEY *SMPPasskey)                                                                                                                                             													      
+ * @brief       Sends the smp passkey command to the BLE module                                                  													      
+ * @param[in]   RSI_BLE_CMD_SMP_PASSKEY *SMPPasskey, Pointer to SMP Passkey structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to send SMP Pass key command to the module.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */                                                                                                          													      
+ INT16 rsi_ble_smp_passkey(RSI_BLE_CMD_SMP_PASSKEY *uSMPPasskey)                                                                                                            													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n SMP passkey start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSMPPasskey, (UINT08 *)uSMPPasskey, sizeof(RSI_BLE_CMD_SMP_PASSKEY));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_set_advertise_data(RSI_BLE_CMD_SET_ADVERTISE_DATA *uSetadvertisedata)                                                                                                                                             													      
+ * @brief       Sends the advertise data command to the BLE module                                                  													      
+ * @param[in]   RSI_BLE_CMD_SET_ADVERTISE_DATA *uSetAdvertiseData, Pointer to Set advertise data  structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to prepare and send the advertise data command to the module.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */                                                                                                          													      
+ INT16 rsi_ble_set_advertise_data(RSI_BLE_CMD_SET_ADVERTISE_DATA *uSetAdvertiseData)                              
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set advertise data ");                                                            													      
+#endif                                                                                                       													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetAdvertiseData, (UINT08 *)uSetAdvertiseData, sizeof(RSI_BLE_CMD_SET_ADVERTISE_DATA));													      
+  return retval;                                                                                             													      
+}                           
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_set_random_address(RSI_BLE_CMD_SET_RANDOM_ADDRESS *uSetRandAdd)                                                                                                                                             													      
+ * @brief       Sends the set random address command to the BLE module                                                  													      
+ * @param[in]   RSI_BLE_CMD_SET_RANDOM_ADDRESS *uSetRandAdd, Pointer to Set advertise data  structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to set and send the random address command to the module.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */                                                                                                          													      
+INT16 rsi_ble_set_random_address(RSI_BLE_CMD_SET_RANDOM_ADDRESS *uSetRandAdd)                              
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set Random Adsress ");                                                            													      
+#endif                                                                                                       													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetRandAdd, (UINT08 *)uSetRandAdd, sizeof(RSI_BLE_CMD_SET_RANDOM_ADDRESS));													      
+  return retval;                                                                                             													      
+}           
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_set_antenna_tx_power_value(RSI_BLE_CMD_SET_ANTENNA_TX_POWER_VLAUE *uSetAntennaTxPower)                                                                                                                                             													      
+ * @brief       Sends the set Tx power value in BLE                                                  													      
+ * @param[in]   RSI_BLE_CMD_SET_ANTENNA_TX_POWER_VLAUE *uSetAntennaTxPower, Pointer to Set antenna tx power structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to set BLE Tx power to the Antenna.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */                                                                                                          													      
+ INT16 rsi_ble_set_antenna_tx_power_value(RSI_BLE_CMD_SET_ANTENNA_TX_POWER_VLAUE * uSetAntennaTxPower)
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set  BLE Tx power value ");                                                            													      
+#endif                                                                                                       													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetTxPowerValue, (UINT08 *)uSetAntennaTxPower, sizeof(RSI_BLE_CMD_SET_ANTENNA_TX_POWER_VLAUE));													      
+  return retval;                                                                                             													      
+}           
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_smp_pairing_rejection(RSI_BLE_CMD_SMP_REJECT_REPLY *uBLESMPRejectResp)                                                                                                                                             													      
+ * @brief       Rejecting SMP for SMP request                                                  													      
+ * @param[in]   RSI_BLE_CMD_SMP_REJECT_REPLY *uBLESMPRejectResp, Pointer to reject SMP rject reply structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to Rejecting SMP for SMP request      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */                                                                                                          													      
+INT16 rsi_ble_smp_pairing_rejection(RSI_BLE_CMD_SMP_REJECT_REPLY *uBLESMPRejectResp)
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n BLE SMP pairing rejection cmd \n");                                                            													      
+#endif                                                                                                       													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBleSMPPairingRejectReply, (UINT08 *)uBLESMPRejectResp, sizeof(RSI_BLE_CMD_SMP_REJECT_REPLY));													      
+  return retval;                                                                                             													      
+}           
+
+											      
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_white_list(RSI_BLE_CMD_WHITE_LIST *uBleWhiteList)                                                                                                                                             													      
+ * @brief       Add,Delete and clear all white list                                                  													      
+ * @param[in]   RSI_BLE_CMD_WHITE_LIST *uBleWhiteList, Pointer to Add,Delete and clear all white list structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to Add,Delete and clear all white list      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */                                                                                                          													      
+INT16 rsi_ble_white_list(RSI_BLE_CMD_WHITE_LIST *uBleWhiteList)
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n BLE White List cmd \n");                                                            													      
+#endif                                                                                                       													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBleWhiteList, (UINT08 *)uBleWhiteList, sizeof(RSI_BLE_CMD_WHITE_LIST));													      
+  return retval;                                                                                             													      
+}           
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_ltk_req_reply(RSI_BLE_CMD_LE_LTKREQREPLY *uBleLtkReqReply)                                                                                                                                             													      
+ * @brief       Add,Delete and clear all white list                                                  													      
+ * @param[in]   RSI_BLE_CMD_WHITE_LIST *uBleWhiteList, Pointer to Add,Delete and clear all white list structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to Add,Delete and clear all white list      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */                                                                                                          													      
+INT16 rsi_ble_ltk_req_reply(RSI_BLE_CMD_LE_LTKREQREPLY *uBleLtkReqReply)
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n BLE LTK Req reply cmd \n");                                                            													      
+#endif                                                                                                       													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBleLtkReqReply, (UINT08 *)uBleLtkReqReply, sizeof(RSI_BLE_CMD_LE_LTKREQREPLY));													      
+  return retval;                                                                                             													      
+}      
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_set_ping_timeout(RSI_BLE_CMD_SET_PING_TIMEOUT *uSetLePingTimeout)                                                                                                                                             													      
+ * @brief       Sets the BLE ping (Authenticated Payload Timeout) timeout to the BLE module
+ * @param[in]   RSI_BLE_CMD_SET_PING_TIMEOUT *uSetLePingTimeout, Pointer to Set le ping timeout  structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to send the set le ping timeout command to the module.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */                                                                                                          													      
+ INT16 rsi_ble_set_ping_timeout(RSI_BLE_CMD_SET_PING_TIMEOUT *uSetLePingTimeout)                              
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set le ping timeout");                                                            													      
+#endif                                                                                                       				
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetPingTimeout, (UINT08 *)uSetLePingTimeout, sizeof(RSI_BLE_CMD_SET_PING_TIMEOUT));													      
+  return retval;                                                                                             													      
+}           
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn         INT16 rsi_ble_get_ping_timeout(void)                                                                                                                                             													      
+ * @brief      Gets the BLE ping (Authenticated Payload Timeout) timeout from the BLE module
+ * @param[in]  none 	      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to send the get ping timeout command to the module.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */                                                                                                          													      
+ INT16 rsi_ble_get_ping_timeout(void)                              
+
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Get le ping timeout");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdGetPingTimeout,NULL, 0);													      
+  return retval;                                                                                             													      
+}               
+
+
+
+#if 0  /* APJ modify */
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT08 clear_scan_resp(void)
+ * @brief       clear the scaned device list
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      none
+ *
+ * @section description                                                                                      													      
+ * This API is used to cleat the scaned device list.
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+void  clear_scan_resp ()
+{
+    remote_dev_count = 0;
+    memset (remote_dev_list, 0, sizeof (remote_dev_list));
+}
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT08 update_scan_resp(UINT08  *p_resp_buf, UINT16   resp_len)
+ * @brief       update the scaned device list
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      none
+ *
+ * @section description                                                                                      													      
+ * This API is used to update the scaned device list.
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+void  update_scan_resp (UINT08  *p_resp_buf,
+                        UINT16   resp_len)
+{
+    RSI_BLE_EVENT_RESP_ADVERTISE_REPORT  *p_scan_resp;
+    UINT08                                ix;
+    UINT08                                dev_found;
+
+
+    p_scan_resp = (RSI_BLE_EVENT_RESP_ADVERTISE_REPORT *)p_resp_buf;
+
+    dev_found = 0;
+    if (remote_dev_count != 0) {
+        for (ix = 0; ix < remote_dev_count; ix++) {
+            if (!memcmp (remote_dev_list[ix], p_scan_resp->BDAddress, 6)) {
+                dev_found = 1;
+                break;
+            }
+        }
+    }
+
+    if ((dev_found        ==                            0) &&
+        (remote_dev_count  < (MAX_NBR_OF_REMOET_DEVS - 1))) {
+
+        memcpy (remote_dev_list[remote_dev_count], p_scan_resp->BDAddress, 6);
+        remote_dev_count++;
+    }
+
+    return;
+}
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT08 update_connected_devices(UINT08  *p_resp_buf, UINT16   resp_len)
+ * @brief       update the connection device list
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      none
+ * @section description                                                                                      													      
+ * This API is used to update the connected device list.
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+void  update_connected_devices (UINT08  *p_resp_buf,
+                                UINT16   resp_len)
+{
+    RSI_BLE_EVENT_RESP_CONNECTION_STATUS  *p_conn_evnt;
+    UINT08                                 ix;
+    UINT08                                 dev_found;
+
+
+    p_conn_evnt = (RSI_BLE_EVENT_RESP_CONNECTION_STATUS *)p_resp_buf;
+
+    dev_found = 0;
+    if (connected_dev_count != 0) {
+        for (ix = 0; ix < connected_dev_count; ix++) {
+            if (!memcmp (connected_dev_list[ix], p_conn_evnt->BDAddress, 6)) {
+                dev_found = 1;
+                break;
+            }
+        }
+    }
+
+    if ((dev_found        ==                            0) &&
+        (connected_dev_count  < (MAX_NBR_OF_REMOET_DEVS - 1))) {
+
+        memcpy (connected_dev_list[connected_dev_count], p_conn_evnt->BDAddress, 6);
+        connected_dev_count++;
+    }
+
+    return;
+}
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT08 remove_connected_devices(UINT08  *p_resp_buf, UINT16   resp_len)
+ * @brief       removed disconnected device from the list
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      none
+ * @section description                                                                                      													      
+ * This API is used to remove from the connected device list
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+void  remove_connected_devices (UINT08  *p_resp_buf,
+                                UINT16   resp_len)
+{
+    RSI_BLE_EVENT_DISCONNECTION_STATUS  *p_disconn_evnt;
+    UINT08                      ix, ix1;
+    UINT08                      dev_found;
+
+
+    p_disconn_evnt = (RSI_BLE_EVENT_DISCONNECTION_STATUS *)p_resp_buf;
+
+    dev_found = 0;
+    if (connected_dev_count != 0) {
+        for (ix = 0; ix < connected_dev_count; ix++) {
+            if (!memcmp (connected_dev_list[ix], p_disconn_evnt->BDAddress, 6)) {
+                dev_found = 1;
+                break;
+            }
+        }
+    }
+
+    if (dev_found == 1) {
+        for (ix1 = ix; ix1 < (connected_dev_count - 1); ix1++) {
+            memcpy (connected_dev_list[ix1], connected_dev_list[ix1 + 1], 6);
+        }
+        memset (connected_dev_list[ix1], 0, sizeof (connected_dev_list[ix1]));
+        connected_dev_count--;
+    }
+
+    return;
+}
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT08 GetScanDevIndex(void)                                                                                                                                             													      
+ * @brief       get the scan devices index value.
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      device index                                                                                      													      
+ *              -1 = invalid index
+ *              0 to 5 = device index
+ * @section description                                                                                      													      
+ * 
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT08  GetScanDevIndex ()
+{
+    int  ix, ix1;
+
+
+    for (ix = 0; ix < remote_dev_count; ix++) {
+        printf ("%d, ", ix);
+        for (ix1 = 0; ix1 < 6; ix1++) {
+            printf ("%02X", remote_dev_list[ix][5-ix1]);
+            if (ix1 < 5) {
+                printf ("-");
+            }
+        }
+        printf ("\r\n");
+    }
+
+    printf ("enter scan device index: ");
+    scanf ("%d", &ix);
+
+    if ((ix >= 0) && (ix < remote_dev_count)){
+        return ix;
+    }
+
+    return ((UINT08)-1);
+}
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT08 GetRemoteDevIndex(void)                                                                                                                                             													      
+ * @brief       connected BLE Device index                                                  													      
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      device index                                                                                      													      
+ *              -1 = invalid index
+ *              0 to 5 = device index
+ * @section description                                                                                      													      
+ * This API is used to initialise the BLE module.                                                                                      													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT08  GetConnectedDevIndex (void)
+{
+    int  ix, ix1;
+
+
+    for (ix = 0; ix < connected_dev_count; ix++) {
+        printf ("%d, ", ix);
+        for (ix1 = 0; ix1 < 6; ix1++) {
+            printf ("%02X", connected_dev_list[ix][5-ix1]);
+            if (ix1 < 5) {
+                printf ("-");
+            }
+        }
+        printf ("\r\n");
+    }
+
+    printf ("enter device index: ");
+    scanf ("%d", &ix);
+
+    if ((ix >= 0) && (ix < connected_dev_count)){
+        return ix;
+    }
+
+    return ((UINT08)-1);
+}
+#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/rsi_ble_gatt.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/rsi_ble_gatt.c
new file mode 100755
index 0000000..7f261e5
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/src/rsi_ble_gatt.c
@@ -0,0 +1,591 @@
+/**
+ * @file      rsi_ble_gatt.c
+ *
+ * @version   1.0
+ * @date      2014-Aug-22
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Contains BLE GATT API's.
+ *
+ * @section Description
+ * This file contains a) Query profiles list function.
+ *  		         b) Query profile descriptor function.
+ *   		        c) Query characterstic services function.
+ *    		      d) Query include service function.
+ *    		      e) Read cahr value by UUID function.
+ *    		      f) Query descriptor function.
+ *    		      g) Query att value functon.
+ *    		      h) Query multi att value function.
+ *    		      i) Query long att value function.
+ *    		      j) Set att value function.
+ *    		      k) Set att value no ack function.
+ *    		      l) Set long att value function.
+ *    		      m) Set Prep long att value function.
+ *    		      n) Execute long att value function.
+ *
+ *    		     
+ *    		     
+ *    		     	     
+ */		      	
+/* 2019/07/09 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_ble_global.h"
+#include "rsi_bt_api.h"
+#include "platform_specific.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *	
+ * @fn          INT16 rsi_ble_query_profiles_list(void)
+ * @brief       Sends the Query Profiles list command to the BLE module.
+ * @param[in]   None
+ * @param[out]  None
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *               0  = SUCCESS
+ * @section description 
+ * This API is used to get all supported profiles list from remote device.
+ *
+ * @section prerequisite
+ * This API must be used after connecting with the remote device.
+ */
+
+INT16 rsi_ble_query_profiles_list(RSI_BLE_CMD_PROFILE_LIST  *uGetProfileList)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery profile list Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryProfList, (UINT08 *)uGetProfileList, sizeof (RSI_BLE_CMD_PROFILE_LIST));
+  return retval;
+}
+
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_query_profile(RSI_BLE_CMD_QUERY_PROFILE *uGetProfile)
+ * @brief       Sends the Query profile command to the BLE module
+ * @param[in]   RSI_BLE_CMD_QUERY_PROFILE *uGetProfile, Pointer to Get Profile structure  			
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to get information about the given profile in the remote device. 
+ *
+ * @section prerequisite 
+ * This API must be used after connecting with the remote device.
+ */
+
+INT16 rsi_ble_query_profile(RSI_BLE_CMD_QUERY_PROFILE *uGetProfile)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery profile descriptor starts ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryProfDesc, (UINT08 *)uGetProfile, sizeof(RSI_BLE_CMD_QUERY_PROFILE));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_query_characteristic_services(RSI_BLE_CMD_QUERY_CHARACTERISTIC_SERVICES *GetCharacteristicServices);	
+ * @brief       Sends the query characterstic services command to the BLE module.
+ * @param[in]   RSI_BLE_CMD_QUERY_CHARACTERISTIC_SERVICES *GetCharacteristicServices, Pointer to Query characterstic services structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to get all characteristic services list from remote device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_ble_query_characteristic_services(RSI_BLE_CMD_QUERY_CHARACTERISTIC_SERVICES *uGetCharacteristicServices)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Query Characterstic services start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryCharServ, (UINT08 *)uGetCharacteristicServices, sizeof(RSI_BLE_CMD_QUERY_CHARACTERISTIC_SERVICES));
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_query_include_service(RSI_BLE_CMD_QUERY_INCLUDE_SERVICES *GetIncludeService);
+ * @brief       Sends the query include service command to the BLE module
+ * @param[in]   RSI_BLE_CMD_QUERY_INCLUDE_SERVICES *GetIncludeService,Pointer to Query include services structure.
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to get include services list from remote device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_ble_query_include_service(RSI_BLE_CMD_QUERY_INCLUDE_SERVICES *uGetIncludeService)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Include Service start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryIncludeServ, (UINT08 *)uGetIncludeService, sizeof(RSI_BLE_CMD_QUERY_INCLUDE_SERVICES));
+  return retval;
+}
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_read_char_value_by_UUID(RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID *ReadCharValueByUUID)
+ * @brief       Sends the Read Characteristic value by UUID command to the BLE module.
+ * @param[in]   RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID *ReadCharValueByUUID ,Pointer to Read Char Value By UUID structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to read the services of given UUID in the given range from the remote device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_ble_read_char_value_by_UUID(RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID *uReadCharValueByUUID)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Read Char Val By UUID start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdReadCharValByUUID, (UINT08 *)uReadCharValueByUUID, sizeof(RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID));
+  return retval;
+}
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_ble_query_att(RSI_BLE_CMD_QUERY_ATT_DESC *uGetDescriptor)
+ * @brief       Sends the Query descriptor command to the BLE module
+ * @param[in]   RSI_BLE_CMD_QUERY_DESCRIPTOR *GetDescriptor, Pointer to Query Descriptor structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to get descriptors with in the given range from the remote device..
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_ble_query_att(RSI_BLE_CMD_QUERY_ATT_DESC *uGetDescriptor)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Query Descriptor start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryAtt, (UINT08 *)uGetDescriptor, sizeof(RSI_BLE_CMD_QUERY_ATT_DESC));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_query_att_value(RSI_BLE_CMD_QUERY_ATT_VALUE *uGetAttributeValue)                                                                                                                                            													      
+ * @brief       Sends the query Attribute Value command to the BLE module                                                  													      
+ * @param[in]  	RSI_BLE_CMD_QUERY_ATT_VALUE *GetAttributeValue, Pointer to Query Attribute value structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to get the attribute value of the given handle from the remote device.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_query_att_value(RSI_BLE_CMD_QUERY_ATT_VALUE *uGetAttributeValue)                                                                                                            													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Query Attribute Value start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryAttVal, (UINT08 *)uGetAttributeValue, sizeof(RSI_BLE_CMD_QUERY_ATT_VALUE));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+                                                                                                             													      
+
+                                                                                                                                                                                                                                                                                                                                                                                                                                                                      												
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_query_multi_att_values(RSI_BLE_CMD_QUERY_MULTIPLE_ATT_VALUES *GetMultipleAttValues)                                                                                                                                             													      
+ * @brief       Sends the query multi att values command to the BLE module                                                  													      
+ * @param[in]  	RSI_BLE_CMD_QUERY_MULTIPLE_ATT_VALUES *GetMultipleAttValues, Pointer to Query Multi Att Values structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to get the attribute values of the given handle from the remote device.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_query_multi_att_values(RSI_BLE_CMD_QUERY_MULTIPLE_ATT_VALUES *uGetMultipleAttValues)                                                                                   													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Query Multi Att Values start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryMulAttVal, (UINT08 *)uGetMultipleAttValues, sizeof(RSI_BLE_CMD_QUERY_MULTIPLE_ATT_VALUES));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+                                                                                                             													      
+                                                                                                             													      
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_query_long_att_value(RSI_BLE_CMD_QUERY_LONG_ATT_VALUE *GetLongAttValue)                                                                                                                                           													      
+ * @brief       Sends the query long att value command to the BLE module                                                  													      
+ * @param[in]  	RSI_BLE_CMD_QUERY_LONG_ATT_VALUE *uGetLongAttValue, Pointer to Query long att value structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to read attribute value of the given handle from the given offset from the remote device.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_query_long_att_value(RSI_BLE_CMD_QUERY_LONG_ATT_VALUE *uGetLongAttValue)                                                                                      													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Query long att value start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryLongAttVal, (UINT08 *)uGetLongAttValue, sizeof(RSI_BLE_CMD_QUERY_LONG_ATT_VALUE));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+                                                                                                             													      
+                                                                                                             													      
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_set_att_value(RSI_BLE_CMD_SET_ATT_VALUE *SetAttValue)                                                                                                                                           													      
+ * @brief       Sends the Set Att Value command to the BLE module                                                  													      
+ * @param[in]  	RSI_BLE_CMD_SET_ATT_VALUE *SetAttValue, Pointer to Set Att Value structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to .                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_set_att_value(RSI_BLE_CMD_SET_ATT_VALUE *uSetAttValue)                                                                                                        													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set Att Value start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetAttVal, (UINT08 *)uSetAttValue, sizeof(RSI_BLE_CMD_SET_ATT_VALUE));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+                                                                                                             													      
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_set_att_value_no_ack(RSI_BLE_CMD_SET_ATT_VALUE_NO_ACK *SetAttValueNoAck)                                                                                                                                             													      
+ * @brief       Sends the Set att value no ack command to the BLE module                                                  													      
+ * @param[in]  	RSI_BLE_CMD_SET_ATT_VALUE_NO_ACK *uSetAttValueNoAck, Pointer to Set Att Val No Ack structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to .                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_set_att_value_no_ack(RSI_BLE_CMD_SET_ATT_VALUE_NO_ACK *uSetAttValueNoAck)                                                                                                            													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set att value no ack start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetAttValNoAck, (UINT08 *)uSetAttValueNoAck, sizeof(RSI_BLE_CMD_SET_ATT_VALUE_NO_ACK));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+                                                                                                             													      
+                                                                                                             													      
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_set_long_att_value(RSI_BLE_CMD_SET_LONG_ATT_VALUE *SetLongAttValue)                                                                                                                                            													      
+ * @brief       Sends the Set long att value command to the BLE module                                                  													      
+ * @param[in]  	RSI_BLE_CMD_SET_LONG_ATT_VALUE *uSetLongAttValue, Pointer to Set Long Att Value structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to .                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_set_long_att_value(RSI_BLE_CMD_SET_LONG_ATT_VALUE *uSetLongAttValue)                                                                                                           													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set long att value start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetLongAttVal, (UINT08 *)uSetLongAttValue, sizeof(RSI_BLE_CMD_SET_LONG_ATT_VALUE));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+                                                                                                             													      
+                                                                                                             													      
+                                                                                                             													      
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_set_prep_long_att_value(RSI_BLE_CMD_SET_PREPARE_LONG_ATT_VALUE *SetPrepLongAttValue)                                                                                                                                            													      
+ * @brief       Sends the Set prep long att value command to the BLE module                                                  													      
+ * @param[in]  	RSI_BLE_CMD_SET_PREPARE_LONG_ATT_VALUE *uSetPrepLongAttValue, Pointer to Set Prepare Long Att Value structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to .                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+
+INT16 rsi_ble_set_prep_long_att_value(RSI_BLE_CMD_SET_PREPARE_LONG_ATT_VALUE *uSetPrepLongAttValue)                                                                                                         													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set prep Long Att Value start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetPrepLongAttVal, (UINT08 *)uSetPrepLongAttValue, sizeof(RSI_BLE_CMD_SET_PREPARE_LONG_ATT_VALUE));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+                                                                                                             													      
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_execute_long_att_value(RSI_BLE_CMD_EXECUTE_LONG_ATT_VALUE_WRITE *ExecuteLongAttValue)                                                                                                                                             													      
+ * @brief       Sends the Execute long att value command to the BLE module                                                  													      
+ * @param[in]  	RSI_BLE_CMD_EXECUTE_LONG_ATT_VALUE_WRITE *uExecuteLongAttValue, Pointer to execute long att value structure                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to .                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_execute_long_att_value(RSI_BLE_CMD_EXECUTE_LONG_ATT_VALUE_WRITE *uExecuteLongAttValue)                                                                                                           													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n Execute Long Att Value start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdExeLongAttVal, (UINT08 *)uExecuteLongAttValue, sizeof(RSI_BLE_CMD_EXECUTE_LONG_ATT_VALUE_WRITE));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_device_AddService(void)                                                                                                                                             													      
+ * @brief       Sends the BLE Device add service command to the BLE module                                                  													      
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to deregister/deinit the BLE module. To again initialise the module, rsi_ble_device_init()
+ * API has to be called                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_device_AddService(RSI_BLE_CMD_ADD_GATT_SERVICE *uLEAddService)
+{                                                                                                            													      
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n BLE Add Service ");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %-30.25s\n","BLE","Tx","Add srvc req","Adding BLE GAT service");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBleAddService, (UINT08 *)uLEAddService, sizeof (RSI_BLE_CMD_ADD_GATT_SERVICE));
+  return retval;
+}
+                                                                                                             													      
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_device_AddServiceAttribute(void)                                                                                                                                             													      
+ * @brief       Sends the BLE Device add attribute to service command to the BLE module                                                  													      
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to deregister/deinit the BLE module. To again initialise the module, rsi_ble_device_init()
+ * API has to be called                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_device_AddServiceAttribute(RSI_BLE_CMD_ADD_GATT_ATTRIBUTE *uLEAddAttribute)
+{                                                                                                            													      
+  INT16          retval;
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n BLE Add Attribute ");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %-30.25s\n","BLE","Tx","Add attr req","BLE Add GATT Attribute");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBleAddAttribute, (UINT08 *)uLEAddAttribute, sizeof (RSI_BLE_CMD_ADD_GATT_ATTRIBUTE));
+  return retval;
+}
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_device_AddServiceAttribute(void)                                                                                                                                             													      
+ * @brief       Sends the BLE Device add attribute to service command to the BLE module                                                  													      
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to deregister/deinit the BLE module. To again initialise the module, rsi_ble_device_init()
+ * API has to be called                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_device_ChangeLocalAttValue(RSI_BLE_CMD_SET_LOCAL_ATT_VALUE *uLEChangeAttVal)
+{                                                                                                            													      
+  INT16          retval;
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n BLE Change Local Attribute ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBleSetLocalAttValue, (UINT08 *)uLEChangeAttVal, sizeof (RSI_BLE_CMD_SET_LOCAL_ATT_VALUE));
+  return retval;
+}
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_ble_device_AddServiceAttribute(void)                                                                                                                                             													      
+ * @brief       Sends the BLE Device add attribute to service command to the BLE module                                                  													      
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to deregister/deinit the BLE module. To again initialise the module, rsi_ble_device_init()
+ * API has to be called                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_ble_device_GetLocalAttValue(RSI_BLE_CMD_GET_LOCAL_ATT_VALUE *uLEGetAttVal)
+{                                                                                                            													      
+  INT16          retval;
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n BLE Get Local Attribute ");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %-30.25s\n","BLE","Tx","Set Local Attr","Set Local Attributes");
+#endif
+
+/* APJ : modify */
+//  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBleGetLocalAttValue, (UINT08 *)uLEGetAttVal, sizeof (RSI_BLE_CMD_SET_LOCAL_ATT_VALUE));
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBleGetLocalAttValue, (UINT08 *)uLEGetAttVal, sizeof (RSI_BLE_CMD_GET_LOCAL_ATT_VALUE));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include/rsi_bt_api.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include/rsi_bt_api.h
new file mode 100755
index 0000000..82e08d6
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include/rsi_bt_api.h
@@ -0,0 +1,266 @@
+/**
+ * @file     rsi_bt_api.h
+ * @version  1.0
+ * @date     2014-Aug-21
+ *
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER: API specific Defines
+ *
+ * @section Description
+ * This file contains the function prototypes of the APIs defined in library. 
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ */
+
+#ifndef _BTAPI_H_
+#define _BTAPI_H_
+
+/**
+ * Include Files
+ */
+#include "rsi_bt_global.h"
+
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+
+#define  RSI_BT_REQ_SET_LOCAL_NAME                        0x0001
+#define  RSI_BT_REQ_QUERY_LOCAL_NAME                      0x0002
+#define  RSI_BT_REQ_SET_LOCAL_COD                         0x0003
+#define  RSI_BT_REQ_QUERY_LOCAL_COD                       0x0004
+#define  RSI_BT_REQ_QUERY_RSSI                            0x0005
+#define  RSI_BT_REQ_QUERY_LINK_QUALITY                    0x0006
+#define  RSI_BT_REQ_QUERY_LOCAL_BD_ADDRESS                0x0007
+
+#define  RSI_BT_REQ_INIT                                  0x008D
+#define  RSI_BT_REQ_DEINIT                                0x008E
+#define  RSI_BT_REQ_ANTENNA_SELECT                        0x008F
+//#define  RSI_BT_REQ_CONFIG_ENABLE                         0x0090
+#define  RSI_BT_REQ_LINKEKY_REPLY                         0x0091
+
+//! Request Frame Codes
+#define  RSI_BT_REQ_SET_PROFILE_MODE                      0x0008
+#define  RSI_BT_REQ_SET_DISCV_MODE                        0x0009
+#define  RSI_BT_REQ_QUERY_DISCOVERY_MODE                  0x000A
+#define  RSI_BT_REQ_SET_CONNECTABILITY_MODE               0x000B
+#define  RSI_BT_REQ_QUERY_CONNECTABILITY_MODE             0x000C
+#define  RSI_BT_REQ_SET_PAIR_MODE                         0x000D
+#define  RSI_BT_REQ_QUERY_PAIR_MODE                       0x000E
+#define  RSI_BT_REQ_REMOTE_NAME_REQUEST                   0x000F
+#define  RSI_BT_REQ_REMOTE_NAME_REQUEST_CANCEL            0x0010
+#define  RSI_BT_REQ_INQUIRY                               0x0011
+#define  RSI_BT_REQ_INQUIRY_CANCEL                        0x0012
+#define  RSI_BT_REQ_BOND                                  0x0013
+#define  RSI_BT_REQ_BOND_CANCEL                           0x0014
+#define  RSI_BT_REQ_UNBOND                                0x0015
+#define  RSI_BT_REQ_SET_PIN_TYPE                          0x0016
+#define  RSI_BT_REQ_QUERY_PIN_TYPE                        0x0017
+#define  RSI_BT_REQ_USER_CONFIRMATION                     0x0018
+#define  RSI_BT_REQ_PASSKEY_REPLY                         0x0019
+#define  RSI_BT_REQ_PINCODE_REPLY                         0x001A
+#define  RSI_BT_REQ_QUERY_ROLE                            0x001B
+#define  RSI_BT_REQ_SET_ROLE                              0x001C
+#define  RSI_BT_REQ_QUERY_SERVICES                        0x001D
+#define  RSI_BT_REQ_SEARCH_SERVICE                        0x001E
+#define  RSI_BT_REQ_SPP_CONNECT                           0x001F
+#define  RSI_BT_REQ_SPP_DISCONNECT                        0x0020
+#define  RSI_BT_REQ_SPP_TRANSFER                          0x0021
+#define  RSI_BT_SET_ANTENNA_TX_POWER_LEVEL                0x00A7
+#define  RSI_BT_SET_EIR_DATA                              0x00A9
+
+
+#define  RSI_BT_REQ_PER_TX                                0x0098
+#define  RSI_BT_REQ_PER_RX                                0x0099
+#define  RSI_BT_REQ_PER_STATS                             0x009A
+#define  RSI_BT_REQ_CW_MODE                               0x009B
+
+#define  RSI_BT_REQ_START_SNIFF_MODE                      0x009D
+#define  RSI_BT_REQ_STOP_SNIFF_MODE                       0x009E
+#define  RSI_BT_REQ_SNIFF_SUBRATING_MODE                  0x009F
+#define  RSI_BT_REQ_SSP_ENABLE                            0x00A0
+#define  RSI_BT_REQ_FEATURE_BIT_MAP                       0x00A6
+
+//! Response Frame Codes
+#define  RSI_BT_RSP_CARD_READY                            0x0505
+#define  RSI_BT_RSP_SET_LOCAL_NAME                        0x0001
+#define  RSI_BT_RSP_QUERY_LOCAL_NAME                      0x0002
+#define  RSI_BT_RSP_SET_LOCAL_COD                         0x0003
+#define  RSI_BT_RSP_QUERY_LOCAL_COD                       0x0004
+#define  RSI_BT_RSP_QUERY_RSSI                            0x0005
+#define  RSI_BT_RSP_QUERY_LINK_QUALITY                    0x0006
+#define  RSI_BT_RSP_QUERY_LOCAL_BD_ADDRESS                0x0007
+
+#define  RSI_BT_RSP_INIT				 				                  0x008D
+#define  RSI_BT_RSP_DEINIT				  				              0x008E
+#define  RSI_BT_RSP_ANTENNA_SELECT                        0x008F
+//#define  RSI_BT_RSP_CONFIG_ENABLE                         0x0090
+#define  RSI_BT_RSP_LINKKEY_REPLY                         0x0091
+
+#define  RSI_BT_RSP_SET_PROFILE_MODE                      0x0008
+#define  RSI_BT_RSP_SET_DISCV_MODE                        0x0009
+#define  RSI_BT_RSP_QUERY_DISCOVERY_MODE                  0x000A
+#define  RSI_BT_RSP_SET_CONNECTABILITY_MODE               0x000B
+#define  RSI_BT_RSP_QUERY_CONNECTABILITY_MODE             0x000C
+#define  RSI_BT_RSP_SET_PAIR_MODE                         0x000D
+#define  RSI_BT_RSP_QUERY_PAIR_MODE                       0x000E
+#define  RSI_BT_RSP_REMOTE_NAME_REQUEST                   0x000F
+#define  RSI_BT_RSP_REMOTE_NAME_REQUEST_CANCEL            0x0010
+#define  RSI_BT_RSP_INQUIRY                               0x0011
+#define  RSI_BT_RSP_INQUIRY_CANCEL                        0x0012
+#define  RSI_BT_RSP_BOND                                  0x0013
+#define  RSI_BT_RSP_BOND_CANCEL                           0x0014
+#define  RSI_BT_RSP_UNBOND                                0x0015
+#define  RSI_BT_RSP_SET_PIN_TYPE                          0x0016
+#define  RSI_BT_RSP_QUERY_PIN_TYPE                        0x0017
+#define  RSI_BT_RSP_USER_CONFIRMATION                     0x0018
+#define  RSI_BT_RSP_PASSKEY_REPLY                         0x0019
+#define  RSI_BT_RSP_PINCODE_REPLY                         0x001A
+#define  RSI_BT_RSP_QUERY_ROLE                            0x001B
+#define  RSI_BT_RSP_SET_ROLE                              0x001C
+#define  RSI_BT_RSP_QUERY_SERVICES                        0x001D
+#define  RSI_BT_RSP_SEARCH_SERVICE                        0x001E
+#define  RSI_BT_RSP_SPP_CONNECT                           0x001F
+#define  RSI_BT_RSP_SPP_DISCONNECT                        0x0020
+#define  RSI_BT_RSP_SPP_TRANSFER                          0x0021
+
+#define  RSI_BT_RSP_PER_TX                                0x0098
+#define  RSI_BT_RSP_PER_RX                                0x0099
+#define  RSI_BT_RSP_PER_STATS                             0x009A
+#define  RSI_BT_RSP_CW_MODE                               0x009B
+
+#define  RSI_BT_RSP_START_SNIFF_MODE                      0x009D
+#define  RSI_BT_RSP_STOP_SNIFF_MODE                       0x009E
+#define  RSI_BT_RSP_SNIFF_SUBRATING_MODE                  0x009F
+#define  RSI_BT_RSP_SSP_ENABLE                            0x00A0
+#define  RSI_BT_RSP_FEATURE_BIT_MAP                       0x00A6
+#define  RSI_BT_RSP_ANTENNA_TX_POWER_LEVEL                0x00A7
+#define  RSI_BT_RSP_EIR_DATA                              0x00A9
+         
+
+//! Event Frame Codes
+#define  RSI_BT_EVT_ROLE_CHANGE_STATUS                    0x1000
+#define  RSI_BT_EVT_UNBOND_STATUS                         0x1001
+#define  RSI_BT_EVT_BOND_RESPONSE                         0x1002
+#define  RSI_BT_EVT_INQUIRY_RESPONSE                      0x1003
+#define  RSI_BT_EVT_REMOTE_DEVICE_NAME                    0x1004
+#define  RSI_BT_EVT_REMOTE_NAME_REQUEST_CANCEL            0x1005
+#define  RSI_BT_EVT_DISCONNECTED                          0x1006
+#define  RSI_BT_EVT_USER_CONFIRMATION_REQUEST             0x1007
+#define  RSI_BT_EVT_USER_PASKEY_DISPLAY                   0x1008
+#define  RSI_BT_EVT_USER_PINCODE_REQUEST                  0x1009
+#define  RSI_BT_EVT_USER_PASSKEY_REQUEST                  0x100A
+#define  RSI_BT_EVT_INQ_COMPLETE                          0x100B
+#define  RSI_BT_EVT_AUTH_COMPLETE                         0x100C
+#define  RSI_BT_EVT_USER_LINKKEY_REQUEST                  0x100D
+#define  RSI_BT_EVT_USER_LINKKEY_SAVE                     0x100E
+#define  RSI_BT_EVT_SSP_COMPLETE                          0x100F
+#define  RSI_BT_EVT_MODE_CHANGE                           0x1010
+#define  RSI_BT_EVT_SNIFF_SUBRATING_CHANGED               0x1011
+#define  RSI_BT_EVT_USER_PASKEY_NOTIFY                    0x1012
+
+
+#define  RSI_BT_EVT_SPP_RECEIVE                           0x1100
+#define  RSI_BT_EVT_SPP_CONNECTED                         0x1101
+#define  RSI_BT_EVT_SPP_DISCONNECTED                      0x1102
+
+
+
+/*
+ * Function Prototype Definitions
+ */
+
+INT16 rsi_bt_execute_cmd(UINT08 *descparam, UINT08 *payloadparam, UINT16 size_param);
+
+/*
+ * Generic Function Prototype Definitions
+ */
+
+INT16 rsi_bt_set_local_name(RSI_BT_CMD_SET_LOCAL_NAME *SetLocalName);
+INT16 rsi_bt_query_local_name(void);
+INT16 rsi_bt_set_local_cod(RSI_BT_CMD_SET_LOCAL_COD *SetLocalCOD);
+INT16 rsi_bt_query_local_cod(void);
+INT16 rsi_bt_query_rssi(RSI_BT_CMD_QUERY_RSSI *GetRSSI);
+INT16 rsi_bt_query_link_quality(RSI_BT_CMD_QUERY_LINK_QUALITY *GetLinkQuality);
+INT16 rsi_bt_query_local_bd_address(void);
+
+INT16 rsi_bt_device_init(void);
+INT16 rsi_bt_device_deinit(void);
+INT16 rsi_bt_antenna_select(RSI_BT_CMD_ANTENNA_SELECT *uAntennaSelect);
+//INT16 rsi_bt_config_enable(RSI_BT_CMD_CONFIG_ENABLE *uConfigEnable);
+INT16 rsi_bt_per_transmit(RSI_BT_CMD_PER_TRANSMIT *uPerTransmit);
+INT16 rsi_bt_per_receive(RSI_BT_CMD_PER_RECEIVE *uPerReceive);
+INT16 rsi_bt_per_stats(RSI_BT_CMD_PER_STATS *uPerStats);
+INT16 rsi_bt_per_cw_mode(RSI_BT_CMD_PER_CW_MODE *uPerCw);
+INT16 rsi_bt_eir_data_value(RSI_BT_CMD_SET_EIR_DATA *EirData);
+INT16 rsi_bt_set_antenna_tx_power_value (RSI_BT_CMD_SET_ANTENNA_TX_POWER_LEVEL *AntennaTxPowerLevel);
+
+
+/*
+ * BT Classic Core Function Prototype Definitions
+ */
+
+INT16 rsi_bt_set_profile_mode(RSI_BT_CMD_SET_PROFILE_MODE *SetProfMode);
+INT16 rsi_bt_set_discovery_mode(RSI_BT_CMD_SET_DISCV_MODE *SetDiscvMode);
+INT16 rsi_bt_query_discovery_mode(void);
+INT16 rsi_bt_set_connectability_mode(RSI_BT_CMD_SET_CONNECTABILITY_MODE *SetConnMode);
+INT16 rsi_bt_query_connectability_mode(void);
+INT16 rsi_bt_set_pair_mode(RSI_BT_CMD_SET_PAIR_MODE *SetPairMode);
+INT16 rsi_bt_query_pair_mode(void);
+INT16 rsi_bt_remote_name_request(RSI_BT_CMD_REMOTE_NAME_REQUEST *RemNameReq);
+INT16 rsi_bt_remote_name_request_cancel(RSI_BT_CMD_REMOTE_NAME_REQUEST_CANCEL *RemNameReqCancel);
+INT16 rsi_bt_inquiry(RSI_BT_CMD_INQUIRY *Inq);
+INT16 rsi_bt_inquiry_cancel(void);
+INT16 rsi_bt_bond(RSI_BT_CMD_BOND *Bond);
+INT16 rsi_bt_bond_cancel(RSI_BT_CMD_BOND_CANCEL *BondCancel);
+INT16 rsi_bt_unbond(RSI_BT_CMD_UNBOND *Unbond);
+INT16 rsi_bt_set_pin_type(RSI_BT_CMD_SET_PIN_TYPE *SetPinType);
+INT16 rsi_bt_query_pin_type(void);
+INT16 rsi_bt_user_confirmation(RSI_BT_CMD_USER_CONFIRMATION *UserConf);
+INT16 rsi_bt_passkey_request_reply(RSI_BT_CMD_PASSKEY_REPLY *PasskeyReply);
+INT16 rsi_bt_pincode_reply(RSI_BT_CMD_PINCODE_REPLY *PincodeReply);
+INT16 rsi_bt_query_role(RSI_BT_CMD_QUERY_ROLE *GetRole);
+INT16 rsi_bt_set_role(RSI_BT_CMD_SET_ROLE *SetRole);
+INT16 rsi_bt_query_services(RSI_BT_CMD_QUERY_SERVICES *GetServ);
+INT16 rsi_bt_search_service(RSI_BT_CMD_SEARCH_SERVICE *SearchServ);
+INT16 rsi_bt_start_sniff_mode (RSI_BT_CMD_SNIFF_MODE *SniffMode);
+INT16 rsi_bt_exit_sniff_mode (RSI_BT_CMD_SNIFF_EXIT *SniffExit);
+INT16 rsi_bt_sniff_subrating_mode (RSI_BT_CMD_SNIFF_SUBRATING *SniffSubrating);
+INT16 rsi_bt_enable_ssp_mode (RSI_BT_CMD_SSP_MODE *SSPMode);
+INT16 rsi_bt_enable_set_feature_bitmap (RSI_BT_CMD_FEATURE_BIT_MAP *FeatureBitMap);
+
+/*
+ * BT Classic SPP Function Prototype Definitions
+ */
+
+INT16 rsi_bt_spp_connect(RSI_BT_CMD_SPP_CONNECT *SPPConn);
+INT16 rsi_bt_spp_disconnect(RSI_BT_CMD_SPP_DISCONNECT *SPPDisConn);
+INT16 rsi_bt_spp_transfer(RSI_BT_CMD_SPP_TRANSFER *SPPTransfer);
+
+INT16 rsi_bt_linkkey_reply(RSI_BT_CMD_LINKKEY_REPLY *LinkKeyReply);
+
+//INT16 rsi_spi_frame_dsc_wr(RSI_BT_FRAME_DESC *uFrmDscFrame);
+//INT16 rsi_spi_frame_data_wr(UINT16 bufLen, UINT08 *dBuf, UINT16 tbufLen, UINT08 *tBuf);
+INT16 rsi_frame_read(UINT08 *PktBuffer);
+INT16 rsi_bt_register_interrupt_irq(void);
+void rsi_bt_build_frame_descriptor(RSI_BT_FRAME_DESC *uFrameDscFrame, UINT08 *descparam);
+
+
+
+
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include/rsi_bt_generic.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include/rsi_bt_generic.h
new file mode 100755
index 0000000..d5bff71
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include/rsi_bt_generic.h
@@ -0,0 +1,338 @@
+/**
+ * @file     rsi_bt_generic.h
+ * @version  1.0
+ * @date     2014-Aug-23
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER, GLOBAL, Global Header file, the things that must be almost everywhere 
+ *
+ * @section Description
+ * This is the top level global.h file for data/functions that need to be in every module
+ *
+ * @section Improvements
+ * None
+ */
+ 
+ /* 2019/08/19 APJ modify */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#ifndef _RSIBTGENERIC_H_
+#define _RSIBTGENERIC_H_
+
+#define RSI_BT_DEVICE_NAME_LEN 50
+#define RSI_BT_BD_ADDR_LEN  6
+#define RSI_BT_LINK_KEY_LEN 16
+#define RSI_TRUE 1
+#define RSI_FALSE 0
+
+#ifndef NULL
+#define NULL 0
+#endif  
+
+#define RSI_BT_FRAME_CMD_RSP_LEN               56     //@ Length of the command response buffer/frame
+#define RSI_BT_MAX_PAYLOAD_SIZE                200
+//#define RSI_BT_MAX_PAYLOAD_SIZE                296
+#define RSI_BYTES_4                            4 
+
+#define RSI_BT_STATUS_OFFSET         12
+#define RSI_BT_RSP_TYPE_OFFSET       2
+#define RSI_BT_FRAME_DESC_LEN        16     //@ Length of the frame descriptor, for both read and write
+
+/**
+ * @ Type Definitions
+ */
+#if 0 /*FIXME:warnings*/
+typedef unsigned short    UINT16;
+typedef unsigned long	  UINT32;
+typedef short	          INT16;
+typedef long	          INT32;
+ 
+typedef unsigned char	  UINT08;
+typedef signed char       INT08;
+#else
+#include "rsi_common_types.h"
+#endif
+
+typedef struct bt_uuid128 {
+    UINT08      data1[4];
+    UINT08      data2[2];
+    UINT08      data3[2];
+    UINT08      data4[8];
+} UUID128;
+typedef  UINT16      UUID16;
+typedef  UINT32      UUID32;
+
+typedef struct bt_uuid {
+    UINT08      size;
+    UINT08      reserved[3];
+    union bt_uuid_t {
+        UUID128  val128;        
+        UUID32   val32;
+        UUID16   val16;
+    } Val;
+} UUID_T;
+
+/*===================================================*/
+/**
+ * Frame Descriptor
+ */
+
+typedef union {
+    struct {
+        UINT08   FrmLenAndQueue[2];            
+        //@ Bits 15:12=queue, 0000 and 0001 for BT, Bits 11:0 are the length
+        UINT08   RespType[2];                
+        UINT08   Padding[8];                       
+        //@ Unused , set to 0x0
+        UINT08   RespStatus[2];
+        //@ Frame descriptor response status, 0x0000=success, else error
+        UINT08   Padding1[2];
+        //@ Unused , set to 0x0
+    } FrameDesc;
+    UINT08   uFrmDscBuf[RSI_BT_FRAME_DESC_LEN];
+    //@ byte format for spi interface, 16 bytes
+} RSI_BT_FRAME_DESC;
+
+/*===============================================*/
+/**
+ *  Set Local Name
+ *  --------------
+ *  
+ *  Command Index: 0x0001
+ *  
+ *  Arguments:
+ *  1. Name Length (1B)
+ *  2. Name (50B)
+ */
+typedef union {
+
+  struct {
+    UINT08  NameLength;
+    INT08  Name[RSI_BT_DEVICE_NAME_LEN];
+  }SetLocalNameFrameSnd;
+
+  UINT08 uSetLocalNameBuf[RSI_BT_DEVICE_NAME_LEN + 1];
+
+} RSI_BT_CMD_SET_LOCAL_NAME;
+
+/*===============================================*/
+/*
+Query Local Name (Resp)
+---------------------
+
+Command Index: 0x0002
+
+Arguments:
+1. Name Length (1B)
+2. Name (50B)
+*/
+typedef struct rsi_bt_resp_query_local_name {
+    UINT08   NameLength;
+    INT08   Name[RSI_BT_DEVICE_NAME_LEN];
+} RSI_BT_RESP_QUERY_LOCAL_NAME;
+
+/*===============================================*/
+
+/*
+Set Local COD
+-------------
+
+Command Index: 0x0003
+
+Arguments:
+1. Local COD (4B)
+*/
+typedef union {
+
+  struct {
+    UINT32  LocalCOD;
+  }SetLocalCodFrameSnd;
+
+  UINT08 uSetLocalCodBuf[4];
+
+} RSI_BT_CMD_SET_LOCAL_COD;
+
+/*
+Antenna select
+------------------
+
+Command Index: 0x008F
+
+Arguments:
+1. Antenna select (1B)
+*/
+typedef union {
+
+  struct {
+    UINT08 AntennaVal;
+  }AntennaSelectFrameSnd;
+
+  UINT08 uAntennaVal;
+
+} RSI_BT_CMD_ANTENNA_SELECT;
+
+/*
+Configuration enable/disable
+-----------------------------
+
+Command Index: 0x0090
+
+Arguments:
+1. config enable (1B)
+*/
+/*typedef union {
+
+  struct {
+    UINT08 ConfigEnable;
+  }ConfigEnableFrameSnd;
+
+  UINT08 uConfigEnable;
+
+} RSI_BT_CMD_CONFIG_ENABLE;
+*/
+/*
+Query Local COD (Resp)
+--------------------
+
+Command Index: 0x0004
+
+Arguments:
+1. Local COD (4B)
+*/
+typedef struct rsi_bt_resp_query_local_cod {
+    UINT32 LocalCOD;
+} RSI_BT_RESP_QUERY_LOCAL_COD;
+
+
+/*
+Query RSSI (Cmd, Resp)
+--------------------
+
+Command Index: 0x0005
+
+Arguments:
+1. BD Address (6B)
+
+1. RSSI value (1B)
+*/
+typedef union {                                    
+
+  struct {
+    UINT08 BDAddress[RSI_BT_BD_ADDR_LEN];
+  }QueryRssiFrameSnd;
+
+  UINT08 uQueryRSSIBuf[RSI_BT_BD_ADDR_LEN];
+
+} RSI_BT_CMD_QUERY_RSSI;
+
+typedef struct rsi_bt_resp_query_rssi {
+    UINT08 RSSI;
+} RSI_BT_RESP_QUERY_RSSI;
+
+
+/*
+Query Link Quality (Cmd, Resp)
+----------------------------
+
+Command Index: 0x0006
+
+Arguments:
+1. BD Address (6B)
+
+1. Link Quality (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }QueryLinkQualityFrameSnd;
+
+  UINT08 uQueryLinkQualityBuf[RSI_BT_BD_ADDR_LEN];
+
+} RSI_BT_CMD_QUERY_LINK_QUALITY;
+
+typedef struct rsi_bt_resp_query_link_quality {
+    UINT08 LinkQuality;
+} RSI_BT_RESP_QUERY_LINK_QUALITY;
+
+
+/*
+Query Local BD Address (Resp)
+---------------------------
+
+Command Index: 0x0007
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef struct rsi_bt_resp_query_local_bd_address {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_RESP_QUERY_LOCAL_BD_ADDRESS;
+
+extern const UINT08  rsi_frameCmdSetLocalName[RSI_BYTES_4];         
+extern const UINT08  rsi_frameCmdQryLocalName[RSI_BYTES_4];        
+extern const UINT08  rsi_frameCmdSetLocalCOD[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdQryLocalCOD[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdQryRSSI[RSI_BYTES_4];              
+extern const UINT08  rsi_frameCmdQryLinkQuality[RSI_BYTES_4];       
+extern const UINT08  rsi_frameCmdQryLocalBDAddr[RSI_BYTES_4];      
+
+extern const UINT08  rsi_frameCmdBTInit[RSI_BYTES_4];     
+extern const UINT08  rsi_frameCmdBTDeinit[RSI_BYTES_4];       
+extern const UINT08  rsi_frameCmdBTAntennaSelect[RSI_BYTES_4];       
+
+// Set Tx power for BT
+extern const UINT08  rsi_frameCmdAntennaTxPowerLevel[RSI_BYTES_4];       
+extern const UINT08  rsi_frameCmdEIRData[RSI_BYTES_4];
+
+
+//! PER commands
+extern const UINT08  rsi_frameCmdPerTransmit[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdPerReceive[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdPerBTStats[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdPerCwMode[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdFeatureBitMap[RSI_BYTES_4];
+
+#ifndef RSI_HWTIMER 
+//! need to define this macro if h/w timer is available and it should increment spiTimer2, spiTimer1 
+#define RSI_TICKS_PER_SECOND        50000 
+#else
+#define RSI_TICKS_PER_SECOND        10
+#endif 
+/*@ Start token timeout */
+#define RSI_START_TOKEN_TIMEOUT        10 * RSI_TICKS_PER_SECOND
+
+//! Debug Print Levels
+#define RSI_DEBUG_LVL         0x00ff
+//! These bit values may be ored to all different combinations of debug printing
+#define RSI_PL0                0xffff
+#define RSI_PL1                0x0001
+#define RSI_PL2                0x0002
+#define RSI_PL3                0x0004
+#define RSI_PL4                0x0008
+#define RSI_PL5                0x0010
+#define RSI_PL6                0x0020
+#define RSI_PL7                0x0040
+#define RSI_PL8                0x0080
+#define RSI_PL9                0x0100
+#define RSI_PL10               0x0200
+#define RSI_PL11               0x0400
+#define RSI_PL12               0x0800
+#define RSI_PL13               0x1000
+#define RSI_PL14               0x2000
+#define RSI_PL15               0x4000
+#define RSI_PL16               0x8000
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include/rsi_bt_global.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include/rsi_bt_global.h
new file mode 100755
index 0000000..f86bfb3
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include/rsi_bt_global.h
@@ -0,0 +1,1346 @@
+/**
+ * @file     rsi_bt_global.h
+ * @version  1.0
+ * @date     2014-Aug-23
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER, GLOBAL, Global Header file, the things that must be almost everywhere 
+ *
+ * @section Description
+ * This is the top level global.h file for data/functions that need to be in every module
+ *
+ * @section Improvements
+ * None
+ */
+
+/* 2019/08/09 APJ modify */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _RSIBTGLOBAL_H_
+#define _RSIBTGLOBAL_H_
+
+#include "rsi_bt_generic.h"
+
+/*
+Set Profile Mode
+----------------
+
+Command Index: 0x0008
+*/
+
+typedef union {
+  
+  struct {
+    UINT08  ProfileMode;
+  }SetprofileModeFrameSnd;
+
+  UINT08 uSetProfileModeBuf;
+
+} RSI_BT_CMD_SET_PROFILE_MODE;
+
+/*
+Set Discovery Mode
+------------------
+
+Command Index: 0x0009
+
+Arguments:
+1. Mode (1B)
+2. Timeout (4B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  Mode;
+    UINT08 Reserved[3];
+    INT32  Timeout;
+  }SetDiscvModeFrameSnd;
+
+  UINT08 uSetDiscvModeBuf[8];
+
+} RSI_BT_CMD_SET_DISCV_MODE;
+
+
+/*
+Query Discovery Mode (Resp)
+-------------------------
+
+Command Index: 0x000A
+
+Arguments:
+1. Mode (1B)
+*/
+typedef struct rsi_bt_resp_query_discovery_mode {
+    UINT08  DiscoveryMode;
+} RSI_BT_RESP_QUERY_DISCOVERY_MODE;
+
+
+/*
+Set Connectability Mode
+-----------------------
+
+Command Index: 0x000B
+
+Arguments:
+1. Mode (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  ConnectabilityMode;
+  }SetConnectabilityModeFrameSnd;
+
+  UINT08 uSetConnectabilityModeBuf;
+
+}RSI_BT_CMD_SET_CONNECTABILITY_MODE;
+
+
+/*
+Query Connectability Mode (Resp)
+------------------------------
+
+Command Index: 0x000C
+
+Arguments:
+1. Mode (1B)
+*/
+
+typedef struct rsi_bt_resp_query_connectability_mode {
+    UINT08  ConnectabilityMode;
+} RSI_BT_RESP_QUERY_CONNECTABILITY_MODE;
+
+/*
+Set Pair Mode
+-------------
+
+Command Index: 0x000D
+
+Arguments:
+1. Mode (1B)
+*/
+typedef union {
+
+  struct {
+    UINT08  PairMode;
+  }SetPairModeFrameSnd;
+
+  UINT08 uSetPairModeBuf;
+
+}RSI_BT_CMD_SET_PAIR_MODE;
+
+
+/*
+Query Pair Mode (Resp)
+--------------------
+
+Command Index: 0x000E
+
+Arguments:
+1. Mode (1B)
+*/
+typedef struct rsi_bt_resp_query_pair_mode {
+    UINT08  PairMode;
+} RSI_BT_RESP_QUERY_PAIR_MODE;
+
+
+/*
+Remote Name Request
+-------------------
+
+Command Index: 0x000F
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef union {
+
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }RemNameReqFrameSnd;
+
+  UINT08 uRemNameReqBuf[RSI_BT_BD_ADDR_LEN];
+
+}RSI_BT_CMD_REMOTE_NAME_REQUEST;
+
+
+/*
+Remote Name Request Cancel
+--------------------------
+
+Command Index: 0x0010
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }RemNameReqCancelFrameSnd;
+
+  UINT08 uRemNameReqCancelBuf[RSI_BT_BD_ADDR_LEN];
+
+}RSI_BT_CMD_REMOTE_NAME_REQUEST_CANCEL;
+
+
+/*
+Inquiry
+-------
+
+Command Index: 0x0011
+
+Arguments:
+1. Inquiry Type (1B)
+2. Inquiry Duration (4B)
+3. Maximum device to find (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  InquiryType;
+    UINT08  Reserved[3];
+    UINT32  Duration;
+    UINT08  MaximumDevicesToFind;
+    UINT08  Reserved1[3];
+  }InqFrameSnd;
+
+  UINT08 uInqBuf[12];
+
+} RSI_BT_CMD_INQUIRY;
+
+
+/*
+Inquiry Cancel
+--------------
+
+Command Index: 0x0012
+
+Arguments:
+No Arguments.
+*/
+
+
+/*
+Bond
+----
+
+Command Index: 0x0013
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }BondFrameSnd;
+
+  UINT08 uBondBuf[RSI_BT_BD_ADDR_LEN];
+
+}RSI_BT_CMD_BOND;
+
+
+/*
+Bond Cancel
+-----------
+Command Index: 0x0014
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }BondCancelFrameSnd;
+
+  UINT08 uBondCancelBuf[RSI_BT_BD_ADDR_LEN];
+
+}RSI_BT_CMD_BOND_CANCEL;
+
+
+/*
+Un-Bond
+-------
+
+Command Index: 0x0015
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }UnbondFrameSnd;
+
+  UINT08 uUnbondBuf[RSI_BT_BD_ADDR_LEN];
+
+}RSI_BT_CMD_UNBOND;
+
+
+/*
+Set PIN Type
+------------
+
+Command Index: 0x0016
+
+Arguments:
+1. Pin Type (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  PINType;
+  }SetPinTypeFrameSnd;
+
+  UINT08 uSetPinTypeBuf;
+
+}RSI_BT_CMD_SET_PIN_TYPE;
+
+
+/*
+Query PIN Type (Resp)
+-------------------
+
+Command Index: 0x0017
+
+Arguments:
+1. Pin Type (1B)
+*/
+typedef struct rsi_bt_resp_query_pin_type {
+    UINT08  PinType;
+} RSI_BT_RESP_QUERY_PIN_TYPE;
+
+
+/*
+User Confirmation
+-----------------
+
+Command Index: 0x0018
+
+Arguments:
+1. BD Address (6B)
+2. Confirmation (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  Confirmation;
+  }UserConfFrameSnd;
+
+  UINT08 uUserConfBuf[RSI_BT_BD_ADDR_LEN + 1];
+
+} RSI_BT_CMD_USER_CONFIRMATION;
+
+
+/*
+Passkey Request Reply
+---------------------
+
+Command Index: 0x0019
+
+Arguments:
+1. BD Address (6B)
+2. Reply type (1B)
+3. Passkey (4B)
+*/
+typedef union {
+
+  struct {
+    UINT08   BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08   ReplyType;
+  	UINT08   Reserved;
+    UINT32   Passkey;
+  }PasskeyReplyFrameSnd;
+
+  UINT08 uPasskeyReplyBuf[RSI_BT_BD_ADDR_LEN +1 +1 +4];
+
+} RSI_BT_CMD_PASSKEY_REPLY;
+
+
+#define MAX_PINCODE_REPLY_SIZE  17
+/*
+Pincode Request Reply
+---------------------
+
+Command Index: 0x001A
+
+Arguments:
+1. BD Address (6B)
+2. Reply type (1B)
+3. Pin code (16B)
+*/
+typedef union {
+  
+  struct {
+    UINT08   BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08   ReplyType;
+    UINT08   Reserved;
+    UINT08   Pincode[MAX_PINCODE_REPLY_SIZE];
+  }PincodeReplyFrameSnd;
+
+  UINT08 uPincodeReplyBuf[RSI_BT_BD_ADDR_LEN + 1+ 1+ MAX_PINCODE_REPLY_SIZE];
+
+} RSI_BT_CMD_PINCODE_REPLY;
+
+
+/*
+Query Master Slave Role (Cmd, Resp)
+---------------------------------
+
+Command Index: 0x001B
+
+Arguments:
+1. BD Address (6B)
+
+1. Role (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }QueryRoleFrameSnd;
+
+  UINT08 uQueryRoleBuf[RSI_BT_BD_ADDR_LEN];
+
+} RSI_BT_CMD_QUERY_ROLE;
+
+typedef struct rsi_bt_resp_query_role {
+    UINT08  Role;
+} RSI_BT_RESP_QUERY_ROLE;
+
+
+/*
+Set Master-Slave Role
+---------------------
+
+Command Index: 0x001C
+
+Arguments:
+1. BD Address (6B)
+2. Role (1B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  Role;
+  }SetRoleFrameSnd;
+
+  UINT08 uSetRoleBuf[RSI_BT_BD_ADDR_LEN + 1];
+
+} RSI_BT_CMD_SET_ROLE;
+
+
+/*
+Query Services (Cmd, Resp)
+------------------------
+
+Command Index: 0x001D
+
+Arguments:
+1. BDAddress (6B)
+
+1.
+2. 
+*/
+typedef union {
+  
+  struct {
+    UINT08 BDAddress[RSI_BT_BD_ADDR_LEN];
+  }QueryServFrameSnd;
+
+  UINT08 uQueryServBuf[RSI_BT_BD_ADDR_LEN];
+
+} RSI_BT_CMD_QUERY_SERVICES;
+
+typedef struct rsi_bt_resp_query_services {
+      UINT08  NbrServices;
+      UINT08  Reserved[3];
+      UINT32  uuid[32];
+
+} RSI_BT_RESP_QUERY_SERVICES;
+
+
+/*
+Search Service(Cmd, Resp)
+--------------
+
+Command Index: 0x001E
+
+Arguments:
+1. BDAddress (6B)
+2. Service UUID
+
+1. Service Status (1B)
+*/
+
+typedef union {
+  
+  struct {
+    UINT08 BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08 Reserved[2];
+    UINT32   ServiceUUID;
+  }SearchServFrameSnd;
+
+  UINT08 uSearchServBuf[RSI_BT_BD_ADDR_LEN + 2 + 4 ];
+
+} RSI_BT_CMD_SEARCH_SERVICE;
+
+typedef struct rsi_bt_resp_search_service {
+   
+  UINT08 ServiceStatus; 
+
+} RSI_BT_RESP_SEARCH_SERVICE;
+
+/*
+SPP Connect
+-----------
+
+Command Index: 0x001F
+
+Arguments:
+1. BDAddress (6B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }SppConnFrameSnd;
+
+  UINT08 uSppConnBuf[RSI_BT_BD_ADDR_LEN];
+
+} RSI_BT_CMD_SPP_CONNECT;
+
+
+/*
+SPP DisConnect
+--------------
+
+Command Index: 0x0020
+
+Arguments:
+1. BDAddress (6B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+  }SppDisconnFrameSnd;
+
+  UINT08 uSppDisconnBuf[RSI_BT_BD_ADDR_LEN];
+
+} RSI_BT_CMD_SPP_DISCONNECT;
+
+
+/*
+SPP Transfer
+------------
+
+Command Index: 0x0021
+
+Arguments:
+1. Data Length (2B)
+2. Data (1024B)
+*/
+typedef union {
+  
+  struct {
+    UINT08  DataLength[2];
+//    UINT08  Data[296];
+    UINT08  Data[RSI_BT_MAX_PAYLOAD_SIZE];
+  }SppTransferFrameSnd;
+
+  UINT08 uSppTransferBuf[RSI_BT_MAX_PAYLOAD_SIZE + 2];
+
+} RSI_BT_CMD_SPP_TRANSFER;
+
+/*
+PER Transfer
+------------
+
+Command Index: 0x0098
+
+Arguments:
+1. 
+2. 
+*/
+typedef union {
+  
+  struct {
+    UINT08 type;
+    UINT08 enable;
+    UINT08 bt_addr[6];
+    UINT08 pkt_type;       
+    UINT08 pkt_length[2];     
+    UINT08 link_type;
+    UINT08 edr_ind;        
+    UINT08 rx_channel;     
+    UINT08 tx_channel;     
+    UINT08 scrambled_seed ;
+    UINT32 num_pkts;       
+    UINT08 payload_type;   
+    UINT08 protocol_mode;
+    UINT08 le_channel;     
+    UINT08 tx_power_index ;
+    UINT08 tx_mode;        
+    UINT08 frequency_hop;  
+    UINT08 ant_sel;
+  }PerTransmitFrameSnd;
+
+  UINT08 uPerTransmitBuf[27];
+
+} RSI_BT_CMD_PER_TRANSMIT;
+
+/*
+PER Receive
+------------
+
+Command Index: 0x0099
+
+Arguments:
+1. 
+2. 
+*/
+typedef union {
+  
+  struct {
+    UINT08 type;
+    UINT08 enable;
+    UINT08 bt_addr[6];
+    UINT16 pkt_length;     
+    UINT08 pkt_type;       
+    UINT08 link_type;
+    UINT08 edr_ind;        
+    UINT08 rx_channel;     
+    UINT08 tx_channel;     
+    UINT08 scrambled_seed ;
+    UINT08 payload_type;
+    UINT08 protocol_mode;
+    UINT08 le_channel;     
+    UINT08 frequency_hop;  
+    UINT08 ant_sel;
+  }PerReceiveFrameSnd;
+
+  UINT08 uPerReceiveBuf[21];
+
+} RSI_BT_CMD_PER_RECEIVE;
+
+/*
+PER Status
+------------
+
+Command Index: 0x009A
+
+Arguments:
+1. 
+2. 
+*/
+typedef union {
+  
+  struct {
+    UINT08 type;
+    UINT08 enable;
+  }PerStatsFrameSnd;
+
+  UINT08 uPerStatsBuf[2];
+
+} RSI_BT_CMD_PER_STATS;
+
+
+/*
+PER Status
+------------
+
+Command response Index: 0x009A
+
+Arguments:
+1. 
+2. 
+*/
+typedef struct {
+  
+    UINT16 crc_fail;
+    UINT16 crc_pass;
+    UINT16 RSSI;
+    UINT16 Id_pkts;
+
+} RSI_BT_RESP_PER_STATS;
+
+
+/*
+PER CW mode
+------------
+
+Command Index: 0x009B
+
+Arguments:
+1. 
+2. 
+*/
+typedef union {
+  
+  struct {
+    UINT08 type;
+    UINT08 channel;
+    UINT08 cw_mode;
+    UINT08 cw_type;
+    UINT08 ant_sel;
+  }PerCwFrameSnd;
+
+  UINT08 uPerCwBuf[5];
+
+} RSI_BT_CMD_PER_CW_MODE;
+
+/*
+ * Antenna Tx Power Level
+------------
+
+Command Index: 0x00A7
+
+Arguments:
+1.  Protocol mode BT/LE
+2.  Tx Power value
+*/
+typedef union {
+  struct {
+    UINT08 ProtocolMode;
+    UINT08 TxPower;
+  } AntennaTxPowerLevelsnd;
+  
+  UINT08 uAntennaTxPowerLevelBuf[2];
+
+} RSI_BT_CMD_SET_ANTENNA_TX_POWER_LEVEL;
+
+/*
+ * Set EIR Data 
+------------
+Command Index: 0x00A9
+
+Arguments:
+1.  
+2.  Tx Power value
+*/
+typedef union {
+  struct {
+    UINT08 FECRequired;
+    UINT08 DataLength;
+    UINT08 EIRData[200];
+  } EIRDatasnd;
+  
+  UINT08 uEIRDataBuf[2];
+
+} RSI_BT_CMD_SET_EIR_DATA;
+
+/*
+linkkey Request Reply
+---------------------
+
+Command Index: 0x009C
+
+Arguments:
+1. BD Address (6B)
+2. Reply type (1B)
+3. Reserved (1B)
+4. linkkey (16B)
+*/
+typedef union {
+  
+  struct {
+    UINT08   BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08   ReplyType;
+    UINT08   Reserved;
+    UINT08   LinkKey[RSI_BT_LINK_KEY_LEN];
+  }LinkKeyReplyFrameSnd;
+
+  UINT08 uLinkKeyReplyBuf[RSI_BT_BD_ADDR_LEN + 2 + RSI_BT_LINK_KEY_LEN];
+
+} RSI_BT_CMD_LINKKEY_REPLY;
+
+/*
+Start Sniff mode
+---------------------
+
+Command Index: 0x009D
+
+Arguments:
+1. BD Address (6B)
+2. sniff max interval (2B)
+3. sniff min interval (2B)
+4. sniff attempts     (2B)
+5. sniff timeout      (2B)
+*/
+typedef union
+{
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT16  SniffMaxIntr;
+    UINT16  SniffMinIntr;
+    UINT16  SniffAttempt;
+    UINT16  SniffTimeout;
+  } SniffModeFrameSend;
+
+  UINT08 uSniffModeBuf[RSI_BT_BD_ADDR_LEN + 8];
+
+} RSI_BT_CMD_SNIFF_MODE;
+
+/*
+Sniff Exit Mode
+---------------------
+
+Command Index: 0x009E
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef union
+{
+  struct {
+    UINT08   BDAddress[RSI_BT_BD_ADDR_LEN];
+  } SniffExitFrameSend;
+
+  UINT08 uSniffExitBuf[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_CMD_SNIFF_EXIT;
+
+
+/*
+!Sniff Subrating Mode
+---------------------
+
+Command Index: 0x009F
+
+Arguments:
+1. BD Address (6B)
+2. sniff max latency  (2B)
+3. sniff min remote timeout (2B)
+4. sniff min local timeout  (2B)
+*/
+typedef union
+{
+  struct {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT16  MaxLatency;
+    UINT16  MinRemoteTimeout;
+    UINT16  MinLocalTimeout;
+  } SniffSubratingFrameSend;
+
+  UINT08 uSniffSubratingBuf[RSI_BT_BD_ADDR_LEN + 6];
+} RSI_BT_CMD_SNIFF_SUBRATING;
+
+/*
+!Set SSP Mode
+---------------------
+
+Command Index: 0x00A0
+
+Arguments:
+1. Pair mode (enable/disable) (1B)
+2. IO capability  (1B)
+*/
+typedef union
+{
+  struct {
+    UINT08   Enable;
+    UINT08   IO_Capability;
+  } SSPModeFrameSend;
+  UINT08 uSspModeBuf[2];
+} RSI_BT_CMD_SSP_MODE;
+
+/*
+!Set Feature BitMap
+---------------------
+
+Command Index: 0x00A6
+
+Arguments:
+1. Feature_Bitmap (enable/disable) (4B)
+*/
+typedef union
+{
+  struct {
+    UINT32   Feature_BitMap;
+  } BitMapFrameSend;
+  UINT08 uFeatureBitMapBuf[2];
+} RSI_BT_CMD_FEATURE_BIT_MAP;
+
+/*****************************************************************************************/
+/*                               Bluetooth Events                                        */
+/*****************************************************************************************/
+
+/*****************************************************************************************/
+/*                                 BR/EDR Events                                         */
+/*****************************************************************************************/
+
+/*
+Role Change Status
+-------------------
+
+Event Index: 0x1000
+
+Arguments:
+1. BD Address (6B)
+2. Status (1B)
+*/
+typedef struct rsi_bt_event_role_change_status {
+    UINT08 BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08 RoleChangeStatus;
+} RSI_BT_EVENT_ROLE_CHANGE_STATUS;
+
+
+/*
+Unbond Status
+-------------
+
+Event Index: 0x1001
+
+Arguments:
+1. BD Address (6B)
+2. Status (1B)
+*/
+typedef struct rsi_bt_event_unbond_status {
+    UINT08 BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_EVENT_UNBOND_STATUS;
+
+
+/*
+Bond Response
+-------------
+
+Event Index: 0x1002
+
+Arguments:
+1. BD Address (6B)
+2. Bond Status (1B)
+3. Error Status (4B)
+*/
+typedef struct rsi_bt_event_bond_response {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_EVENT_BOND_RESPONSE;
+
+
+/*
+Inquiry Response
+----------------
+
+Event Index: 0x1003
+
+Arguments:
+1. Inquiry Type (1B)
+2. BD Address (6B)
+3. Remote Device Name Length (1B)
+4. Remote Device Name (50B)
+5. COD (4B)
+6. RSSI (1B) (Present only if Inquiry with RSSI)
+*/
+typedef struct rsi_bt_event_inquiry_response {
+    UINT08  InquiryType;
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  NameLength;
+    INT08   RemoteDeviceName[RSI_BT_DEVICE_NAME_LEN];
+    UINT08  COD[3];
+    UINT08  RSSI;
+} RSI_BT_EVENT_INQUIRY_RESPONSE;
+
+
+/*
+Remote Device Name
+------------------
+
+Event Index: 0x1004
+
+Arguments:
+1. BD Address (6B)
+2. Remote Name Length (1B)
+3. Remote Device Name (50B)
+*/
+typedef struct rsi_bt_event_remote_device_name {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  NameLength;
+    INT08   RemoteDeviceName[RSI_BT_DEVICE_NAME_LEN];
+} RSI_BT_EVENT_REMOTE_DEVICE_NAME;
+
+
+/*
+Remote Name Request Cancelled
+-----------------------------
+
+Event Index: 0x1005
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef struct rsi_bt_event_remote_name_request_cancel {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_EVENT_REMOTE_NAME_REQUEST_CANCEL;
+
+
+/*
+Disconnected
+------------
+
+Event Index: 0x1006
+
+Arguments:
+1. Connection Handle (4B)
+2. Disconnection Reason (1B)
+*/
+typedef struct rsi_bt_event_disconnected {
+    UINT08  ConnectionHandle[4];
+    UINT08  DisconnectionReason;
+} RSI_BT_EVENT_DISCONNECTED;
+
+
+/*
+User Confirmation Request
+-------------------------
+
+Event Index: 0x1007
+
+Arguments:
+1. BD Address (6B)
+2. ConfirmationValue (4B)
+*/
+typedef struct rsi_bt_event_user_confirmation_request {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  Reserved[2];
+    UINT08  ConfirmationValue[4];
+} RSI_BT_EVENT_USER_CONFIRMATION_REQUEST;
+
+
+/*
+User Passkey Display
+--------------------
+
+Event Index: 0x1008
+
+Arguments:
+1. BD Address (6B)
+2. Passkey (4B)
+*/
+typedef struct rsi_bt_event_user_passkey_display {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+    UINT08  Reserved[2];
+    UINT08  Passkey[4];
+} RSI_BT_EVENT_USER_PASKEY_DISPLAY;
+
+
+/*
+User Pincode Request
+--------------------
+
+Event Index: 0x1009
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef struct rsi_bt_event_user_pincode_request {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_EVENT_USER_PINCODE_REQUEST;
+
+
+/*
+User Passkey Request
+--------------------
+
+Event Index: 0x100A
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef struct rsi_bt_event_user_passkey_request {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_EVENT_USER_PASSKEY_REQUEST;
+
+/*
+Inquiry Complete
+--------------------
+
+Event Index: 0x100B
+
+Arguments:
+1. BD Address (6B)
+*/
+
+/*
+Auth Complete
+--------------------
+
+Event Index: 0x100C
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef struct rsi_bt_event_auth_complete {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_EVENT_AUTH_COMPLETE;
+
+/*
+User linkkey Request
+--------------------
+
+Event Index: 0x100D
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef struct rsi_bt_event_user_linkkey_request {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_EVENT_USER_LINKKEY_REQUEST;
+
+/*
+User linkkey save
+--------------------
+
+Event Index: 0x100E
+
+Arguments:
+1. BD Address (6B)
+2. linkkey  (16B)
+*/
+typedef struct rsi_bt_event_user_linkkey_save {
+    UINT08  BDAddress[6];
+    UINT08  LinkKey[16];
+} RSI_BT_EVENT_USER_LINKKEY_SAVE;
+
+/*
+BT Mode event
+--------------------
+
+Event Index: 0x1010
+
+Arguments:
+1. BD Address   (6B)
+2. CurrentMode  (1B)
+3. Reserved     (1B)
+4. ModeInterval (2B)
+*/
+typedef struct rsi_bt_event_mode_change
+{
+  UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+	UINT08  CurrentMode;
+  UINT08  Reserved;
+	UINT16  ModeInterval;
+} RSI_BT_EVENT_MODE_CHANGE;
+
+/*
+BT sniff subrating event
+--------------------
+
+Event Index: 0x1011
+
+Arguments:
+1. BD Address       (6B)
+2. MaxTxLatency     (2B)
+3. MinRemoteTimeout (2B)
+4. MinLocalTimeout  (2B)
+*/
+typedef struct rsi_bt_event_sniff_subrating
+{
+  UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+	UINT16  MaxTxLatency;
+	UINT16  MinRemoteTimeout;
+	UINT16  MinLocalTimeout;
+} RSI_BT_EVENT_SNIFF_SUBRATING;
+
+/*
+BT SPP pair complete
+--------------------
+
+Event Index: 0x100F
+
+Arguments:
+1. BD Address (6B)
+2. Status     (1B)
+*/
+typedef struct rsi_bt_event_ssp_complete
+{
+  UINT08   BDAddress[RSI_BT_BD_ADDR_LEN];
+	UINT08   Status;
+} RSI_BT_EVENT_SSP_COMPLETE;
+
+/*
+SPP Receive
+-----------
+Command Index: 0x1100
+
+Arguments:
+1. Data Length (2B)
+2. Data (200B)
+*/
+/* APJ : modify */
+/* Data [200] → [296] */
+typedef struct rsi_bt_event_spp_receive {
+    UINT16  DataLen;
+//    UINT08  Data[200];
+    UINT08  Data[296];
+} RSI_BT_EVENT_SPP_RECEIVE;
+
+
+
+/*
+SPP Connected
+-------------
+
+Event Index: 0x1101
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef struct rsi_bt_event_spp_connected {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_EVENT_SPP_CONNECTED;
+
+
+/*
+SPP DisConnected
+-------------
+
+Event Index: 0x1102
+
+Arguments:
+1. BD Address (6B)
+*/
+typedef struct rsi_bt_event_spp_disconnected {
+    UINT08  BDAddress[RSI_BT_BD_ADDR_LEN];
+} RSI_BT_EVENT_SPP_DISCONNECTED;
+
+
+typedef union rsi_bt_api {
+    
+    RSI_BT_CMD_SET_LOCAL_NAME                uSetLocalName;
+    RSI_BT_CMD_SET_LOCAL_COD                 uSetLocalCOD; 
+    RSI_BT_CMD_QUERY_RSSI                    uQryRssi;
+    RSI_BT_CMD_QUERY_LINK_QUALITY            uQryLinkQuality;              
+    RSI_BT_CMD_ANTENNA_SELECT                uAntennaSelect;
+//    RSI_BT_CMD_CONFIG_ENABLE                 uConfigEnable; 
+    
+    RSI_BT_CMD_SET_PROFILE_MODE              uSetProfMode;               
+    RSI_BT_CMD_SET_DISCV_MODE                uSetDiscvMode;        
+    RSI_BT_CMD_SET_CONNECTABILITY_MODE       uSetConnMode;                   
+    RSI_BT_CMD_SET_PAIR_MODE                 uSetPairMode;                     
+    RSI_BT_CMD_REMOTE_NAME_REQUEST           uRemNameReq;                     
+    RSI_BT_CMD_REMOTE_NAME_REQUEST_CANCEL    uRemNameReqCancel;                     
+    RSI_BT_CMD_INQUIRY                       uInq;               
+    RSI_BT_CMD_BOND                          uBond;        
+    RSI_BT_CMD_BOND_CANCEL                   uBondCancel;                   
+    RSI_BT_CMD_UNBOND                        uUnbond;                     
+    RSI_BT_CMD_SET_PIN_TYPE                  uSetPinType;                    
+    RSI_BT_CMD_USER_CONFIRMATION             uUserConf;          
+    RSI_BT_CMD_PASSKEY_REPLY                 uPasskeyReply;                  
+    RSI_BT_CMD_PINCODE_REPLY                 uPincodeReply;            
+    RSI_BT_CMD_QUERY_ROLE                    uQryRole;               
+    RSI_BT_CMD_SET_ROLE                      uSetRole;             
+    RSI_BT_CMD_QUERY_SERVICES                uQryServ;                       
+    RSI_BT_CMD_SEARCH_SERVICE                uSearchServ;                 
+    RSI_BT_CMD_SPP_CONNECT                   uSPPConn;               
+    RSI_BT_CMD_SPP_DISCONNECT                uSPPDisConn;                
+    RSI_BT_CMD_SPP_TRANSFER                  uSPPTransfer;
+    RSI_BT_CMD_LINKKEY_REPLY                 uLinkKeyReply;
+    RSI_BT_CMD_SNIFF_MODE                    uSniffEnable;
+    RSI_BT_CMD_SNIFF_EXIT                    uSniffDisable;
+    RSI_BT_CMD_SNIFF_SUBRATING               uSniffSubrating;
+    RSI_BT_CMD_SSP_MODE                      uSSPEnable;
+    RSI_BT_CMD_FEATURE_BIT_MAP               uFeatureBitMap;
+    RSI_BT_CMD_PER_TRANSMIT                  uPerTransmit;
+    RSI_BT_CMD_PER_RECEIVE                   uPerReceive;
+    RSI_BT_CMD_PER_STATS                     uPerStats;
+    RSI_BT_CMD_PER_CW_MODE                   uPerCw;
+    RSI_BT_CMD_SET_ANTENNA_TX_POWER_LEVEL    uAntennaTxPowerLevel;
+    RSI_BT_CMD_SET_EIR_DATA                  uSetEIRData;
+}RSI_BT_API;
+
+
+typedef struct rsi_bt_response{
+  UINT08   ResponseCode[2];
+  UINT08   Status[2];                  
+  //@ 0- For Success ,Non-Zero Value is the Error Code return
+  union {
+    //@ response payload    
+    RSI_BT_RESP_QUERY_LOCAL_NAME             uQryLocalName;
+    RSI_BT_RESP_QUERY_LOCAL_COD              uQryLocalCOD;
+    RSI_BT_RESP_QUERY_RSSI                   uQryRssi;
+    RSI_BT_RESP_QUERY_LINK_QUALITY           uQryLinkQuality;
+    RSI_BT_RESP_QUERY_LOCAL_BD_ADDRESS       uQryLocalBDAddr;
+    
+    RSI_BT_RESP_QUERY_DISCOVERY_MODE         uQryDiscvMode;
+    RSI_BT_RESP_QUERY_CONNECTABILITY_MODE    uQryConnMode;
+    RSI_BT_RESP_QUERY_PAIR_MODE              uQryPairMode;
+    RSI_BT_RESP_QUERY_PIN_TYPE               uQryPinType;
+    RSI_BT_RESP_QUERY_ROLE                   uQryRole;
+    RSI_BT_RESP_QUERY_SERVICES               uQryServ;
+
+    RSI_BT_EVENT_ROLE_CHANGE_STATUS          uRoleChangeStatus;  
+    RSI_BT_EVENT_UNBOND_STATUS               uUnbondStatus;
+    RSI_BT_EVENT_BOND_RESPONSE               uBondResp;
+    RSI_BT_EVENT_INQUIRY_RESPONSE            uInqResp;
+    RSI_BT_EVENT_REMOTE_DEVICE_NAME          uRemDevName;
+    RSI_BT_EVENT_REMOTE_NAME_REQUEST_CANCEL  uRemNameReqCancel; 
+    RSI_BT_EVENT_DISCONNECTED                uDisconn;
+    RSI_BT_EVENT_USER_CONFIRMATION_REQUEST   uUserConfReq;
+    RSI_BT_EVENT_USER_PASKEY_DISPLAY         uUserPaskeyDisp;
+    RSI_BT_EVENT_USER_PINCODE_REQUEST        uUserPincodeReq;
+    RSI_BT_EVENT_USER_PASSKEY_REQUEST        uUserPasskeyReq;
+    RSI_BT_EVENT_SPP_CONNECTED               uSppConn;
+    RSI_BT_EVENT_SPP_DISCONNECTED            uSppDisConn;
+    RSI_BT_RESP_PER_STATS                    uPerStats;
+    UINT08                                   uCmdRspBuf[RSI_BT_FRAME_CMD_RSP_LEN + RSI_BT_MAX_PAYLOAD_SIZE + 100];
+    RSI_BT_EVENT_MODE_CHANGE                 uModeChange;  
+  }uCmdRspPayLoad;
+} RSI_BT_RESPONSE;
+
+ 
+extern const UINT08  rsi_frameCmdSetProfMode[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdSetDiscvMode[RSI_BYTES_4];         
+extern const UINT08  rsi_frameCmdQryDiscvMode[RSI_BYTES_4];         
+extern const UINT08  rsi_frameCmdSetConnMode[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdQryConnMode[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdSetPairMode[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdQryPairMode[RSI_BYTES_4];          
+extern const UINT08  rsi_frameCmdRemNameReq[RSI_BYTES_4];           
+extern const UINT08  rsi_frameCmdRemNameReqCancel[RSI_BYTES_4];     
+extern const UINT08  rsi_frameCmdInq[RSI_BYTES_4];                  
+extern const UINT08  rsi_frameCmdInqCancel[RSI_BYTES_4];            
+extern const UINT08  rsi_frameCmdBond[RSI_BYTES_4];                 
+extern const UINT08  rsi_frameCmdBondCancel[RSI_BYTES_4];           
+extern const UINT08  rsi_frameCmdUnbond[RSI_BYTES_4];               
+extern const UINT08  rsi_frameCmdSetPinType[RSI_BYTES_4];           
+extern const UINT08  rsi_frameCmdQryPinType[RSI_BYTES_4];           
+extern const UINT08  rsi_frameCmdUserConf[RSI_BYTES_4];             
+extern const UINT08  rsi_frameCmdPasskeyReply[RSI_BYTES_4];         
+extern const UINT08  rsi_frameCmdPincodeReply[RSI_BYTES_4];         
+extern const UINT08  rsi_frameCmdQryRole[RSI_BYTES_4];              
+extern const UINT08  rsi_frameCmdSetRole[RSI_BYTES_4];              
+extern const UINT08  rsi_frameCmdQryServ[RSI_BYTES_4];              
+extern const UINT08  rsi_frameCmdSearchServ[RSI_BYTES_4];           
+                
+extern const UINT08  rsi_frameCmdSPPConn[RSI_BYTES_4];              
+extern const UINT08  rsi_frameCmdSPPDisConn[RSI_BYTES_4];           
+extern const UINT08  rsi_frameCmdSPPTransfer[RSI_BYTES_4];          
+
+extern const UINT08  rsi_frameCmdLinkKeyReply[RSI_BYTES_4];         
+extern const UINT08  rsi_frameCmdSniffMode[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdSniffExit[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdSniffSubrating[RSI_BYTES_4];
+extern const UINT08  rsi_frameCmdSSPEnable[RSI_BYTES_4];
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/Makefile b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/Makefile
new file mode 100644
index 0000000..7bcd8ea
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/Makefile
@@ -0,0 +1,22 @@
+######################################################################
+#                                                                    #
+#   Makefile                                                         #
+#                                                                    #
+#   2019/07/02 Create(AlphaProject)                                  #
+#                                                                    #
+######################################################################
+
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include
+#EXTRA_CFLAGS += -DRSI_HAL
+
+obj-$(CONFIG_WMRP10_SPI) += rsi_bt_all.o
+
+rsi_bt_all-objs := rsi_bt_build_frame_descriptor.o rsi_bt_register_interrupt_irq.o rsi_bt_api.o  rsi_bt_core.o rsi_bt_spp.o rsi_bt_generic.o rsi_bt_execute_cmd.o
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_api.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_api.c
new file mode 100755
index 0000000..bc99c80
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_api.c
@@ -0,0 +1,100 @@
+/**
+ * @file     rsi_bt_api.c
+ * @version  1.0
+ * @date     2014-08-23
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief API: Definitions of various data structures and variables
+ * 
+ * @section Description
+ * This file contains definition of different commands variables.
+ * These definitions are used to construct frames. 
+ *
+ * @section Improvements
+ * None
+ */
+/* 2019/05/15 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_bt_global.h"
+#include "rsi_bt_generic.h"
+#include "rsi_bt_api.h"
+
+
+/**
+ * Global Variables
+ */
+
+/* In the 4 bytes,  
+ * BYTE0[0:7],BYTE1[0:3] together represent length of the payload for the frame command
+ * BYTE1[4:7], indicates queue number 0000 - Management,0001 - Data
+ * BYTE2[0:8], BYTE3[0:7] together represent the Frame command type. 
+ */
+
+//#ifdef BT_ENABLE /* APJ modify */
+#if 1
+const UINT08  rsi_frameCmdSetLocalName[RSI_BYTES_4]         = {0x33, 0x00, 0x01, 0x00};
+const UINT08  rsi_frameCmdQryLocalName[RSI_BYTES_4]         = {0x00, 0x00, 0x02, 0x00};      
+const UINT08  rsi_frameCmdSetLocalCOD[RSI_BYTES_4]          = {0x04, 0x00, 0x03, 0x00}; 
+const UINT08  rsi_frameCmdQryLocalCOD[RSI_BYTES_4]          = {0x00, 0x00, 0x04, 0x00}; 
+const UINT08  rsi_frameCmdQryRSSI[RSI_BYTES_4]              = {0x06, 0x00, 0x05, 0x00};    
+const UINT08  rsi_frameCmdQryLinkQuality[RSI_BYTES_4]       = {0x06, 0x00, 0x06, 0x00};        
+const UINT08  rsi_frameCmdQryLocalBDAddr[RSI_BYTES_4]       = {0x00, 0x00, 0x07, 0x00};       
+
+const UINT08  rsi_frameCmdSetProfMode[RSI_BYTES_4]          = {0x01, 0x00, 0x08, 0x00};    
+const UINT08  rsi_frameCmdSetDiscvMode[RSI_BYTES_4]         = {0x08, 0x00, 0x09, 0x00};   
+const UINT08  rsi_frameCmdQryDiscvMode[RSI_BYTES_4]         = {0x00, 0x00, 0x0A, 0x00};    
+const UINT08  rsi_frameCmdSetConnMode[RSI_BYTES_4]          = {0x01, 0x00, 0x0B, 0x00};              
+const UINT08  rsi_frameCmdQryConnMode[RSI_BYTES_4]          = {0x00, 0x00, 0x0C, 0x00};     
+const UINT08  rsi_frameCmdSetPairMode[RSI_BYTES_4]          = {0x01, 0x00, 0x0D, 0x00};                
+const UINT08  rsi_frameCmdQryPairMode[RSI_BYTES_4]          = {0x00, 0x00, 0x0E, 0x00};                    
+const UINT08  rsi_frameCmdRemNameReq[RSI_BYTES_4]           = {0x06, 0x00, 0x0F, 0x00};          
+const UINT08  rsi_frameCmdRemNameReqCancel[RSI_BYTES_4]     = {0x06, 0x00, 0x10, 0x00};                       
+const UINT08  rsi_frameCmdInq[RSI_BYTES_4]                  = {0x0C, 0x00, 0x11, 0x00};       
+const UINT08  rsi_frameCmdInqCancel[RSI_BYTES_4]            = {0x00, 0x00, 0x12, 0x00};         
+const UINT08  rsi_frameCmdBond[RSI_BYTES_4]                 = {0x06, 0x00, 0x13, 0x00};        
+const UINT08  rsi_frameCmdBondCancel[RSI_BYTES_4]           = {0x06, 0x00, 0x14, 0x00};           
+const UINT08  rsi_frameCmdUnbond[RSI_BYTES_4]               = {0x06, 0x00, 0x15, 0x00};        
+const UINT08  rsi_frameCmdSetPinType[RSI_BYTES_4]           = {0x01, 0x00, 0x16, 0x00};            
+const UINT08  rsi_frameCmdQryPinType[RSI_BYTES_4]           = {0x00, 0x00, 0x17, 0x00};             
+const UINT08  rsi_frameCmdUserConf[RSI_BYTES_4]             = {0x07, 0x00, 0x18, 0x00};              
+const UINT08  rsi_frameCmdPasskeyReply[RSI_BYTES_4]         = {0x0C, 0x00, 0x19, 0x00};                  
+const UINT08  rsi_frameCmdPincodeReply[RSI_BYTES_4]         = {sizeof(RSI_BT_CMD_PINCODE_REPLY), 0x00, 0x1A, 0x00};         
+const UINT08  rsi_frameCmdQryRole[RSI_BYTES_4]              = {0x06, 0x00, 0x1B, 0x00};      
+const UINT08  rsi_frameCmdSetRole[RSI_BYTES_4]              = {0x07, 0x00, 0x1C, 0x00};     
+const UINT08  rsi_frameCmdQryServ[RSI_BYTES_4]              = {0x06, 0x00, 0x1D, 0x00};         
+const UINT08  rsi_frameCmdSearchServ[RSI_BYTES_4]           = {sizeof (RSI_BT_CMD_SEARCH_SERVICE), 0x00, 0x1E, 0x00};                 
+               
+const UINT08  rsi_frameCmdSPPConn[RSI_BYTES_4]              = {0x06, 0x00, 0x1F, 0x00};  
+const UINT08  rsi_frameCmdSPPDisConn[RSI_BYTES_4]           = {0x06, 0x00, 0x20, 0x00};    
+const UINT08  rsi_frameCmdSPPTransfer[RSI_BYTES_4]          = {sizeof(RSI_BT_CMD_SPP_TRANSFER), 0x00, 0x21, 0x00};     
+
+const UINT08  rsi_frameCmdBTInit[RSI_BYTES_4]        		    = {0x00, 0x00, 0x8D, 0x00};       
+const UINT08  rsi_frameCmdBTDeinit[RSI_BYTES_4]        	    = {0x00, 0x00, 0x8E, 0x00};       
+const UINT08  rsi_frameCmdBTAntennaSelect[RSI_BYTES_4]      = {0x01, 0x00, 0x8F, 0x00};       
+const UINT08  rsi_frameCmdBTConfigEnable[RSI_BYTES_4]       = {0x01, 0x00, 0x90, 0x00};       
+
+const UINT08  rsi_frameCmdLinkKeyReply[RSI_BYTES_4]         = {0x18, 0x00, 0x91, 0x00};         
+
+const UINT08  rsi_frameCmdPerTransmit[RSI_BYTES_4]          = {sizeof (RSI_BT_CMD_PER_TRANSMIT ), 0x00, 0x98, 0x00};
+const UINT08  rsi_frameCmdPerReceive[RSI_BYTES_4]           = {sizeof (RSI_BT_CMD_PER_RECEIVE  ), 0x00, 0x99, 0x00};
+const UINT08  rsi_frameCmdPerBTStats[RSI_BYTES_4]           = {sizeof (RSI_BT_CMD_PER_STATS    ), 0x00, 0x9a, 0x00};
+const UINT08  rsi_frameCmdPerCwMode[RSI_BYTES_4]            = {sizeof (RSI_BT_CMD_PER_CW_MODE   ), 0x00, 0x9b, 0x00};
+
+const UINT08  rsi_frameCmdSniffMode[RSI_BYTES_4]            = {sizeof (RSI_BT_CMD_SNIFF_MODE), 0x00, 0x9D, 0x00};
+const UINT08  rsi_frameCmdSniffExit[RSI_BYTES_4]            = {sizeof (RSI_BT_CMD_SNIFF_EXIT), 0x00, 0x9E, 0x00};
+const UINT08  rsi_frameCmdSniffSubrating[RSI_BYTES_4]       = {sizeof (RSI_BT_CMD_SNIFF_SUBRATING), 0x00, 0x9F, 0x00};
+const UINT08  rsi_frameCmdSSPEnable[RSI_BYTES_4]            = {sizeof (RSI_BT_CMD_SSP_MODE), 0x00, 0xA0, 0x00};
+const UINT08  rsi_frameCmdFeatureBitMap[RSI_BYTES_4]        = {sizeof (RSI_BT_CMD_FEATURE_BIT_MAP), 0x00, 0xA6, 0x00};
+const UINT08  rsi_frameCmdAntennaTxPowerLevel[RSI_BYTES_4]  = {sizeof (RSI_BT_CMD_SET_ANTENNA_TX_POWER_LEVEL), 0x00, 0xA7, 0x00};
+const UINT08  rsi_frameCmdEIRData[RSI_BYTES_4]              = {sizeof (RSI_BT_CMD_SET_EIR_DATA), 0x00, 0xA9, 0x00};
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_build_frame_descriptor.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_build_frame_descriptor.c
new file mode 100755
index 0000000..3c1d9d6
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_build_frame_descriptor.c
@@ -0,0 +1,70 @@
+/**
+ * @file     rsi_bt_build_frame_descriptor.c
+ * @version  1.0
+ * @date     2014-Aug-23
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Function which builds the frame descriptor of BT Packet.
+ *
+ * @section Description
+ * This file contains a function to build the frame descriptor of BT Packet.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_bt_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*==================================================*/
+/**
+ * @fn          void rsi_bt_build_frame_descriptor(RSI_BT_FRAME_DESC *uFrameDescFrame, UINT08 *Cmd)
+ * @brief       Creates a Frame Descriptor
+ * @param[in]   RSI_BT_FRAME_DESC *uFrameDescFrame,Frame Descriptor
+ * @param[in]   UINT08 *Cmd,Indicates type and length of the packet
+ * @param[out]  none
+ * @return      none
+ * 
+ * @section description 
+ * This API is used to build the frame descriptor for the BT packet which is supposed to be 
+ * given to the firmware/module. 
+ *
+ */
+void rsi_bt_build_frame_descriptor(RSI_BT_FRAME_DESC *uFrameDescFrame, UINT08 *Cmd)
+{
+  UINT08        i;  
+  for (i = 0; i < RSI_BT_FRAME_DESC_LEN; i++) 
+  { 
+    uFrameDescFrame->uFrmDscBuf[i] = 0x00; 
+  }  
+  //!zero the frame descriptor buffer
+  
+  /* Cmd0[0:7],Cmd1[0:3] together represent length of the payload for the frame command
+   * Cmd1[4:7], indicates queue number 0000 - Management, 0001 - Data
+   * Cmd2[0:8], Cmd3[0:7] together represent the Frame command type. 
+   */
+  uFrameDescFrame->uFrmDscBuf[0] = Cmd[0];      
+  uFrameDescFrame->uFrmDscBuf[1] = (Cmd[1] | (2 << 4));
+  uFrameDescFrame->uFrmDscBuf[2] = Cmd[2];      
+  uFrameDescFrame->uFrmDscBuf[3] = Cmd[3];      
+
+  return;
+}
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_core.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_core.c
new file mode 100755
index 0000000..73dc1f3
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_core.c
@@ -0,0 +1,965 @@
+/**
+ * @file      rsi_bt_core.c
+ *
+ * @version   1.0
+ * @date      2014-Aug-22
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Contains BT Classic Core API's.
+ *
+ * @section Description
+ * This file contains a) Set Discovery Mode function.
+ *          		      b) Query Discovery Mode function.
+ *   		              c) Set Connectability Mode function.
+ *    		            d) Set Pair Mode function.
+ *    		            e) Query Pair Mode function.
+ *    		            f) Remote Name Request function.
+ *    		            g) Remote Name Requst Cancel functon.
+ *    		            h) Inquiry function.
+ *    		            i) Inquity Cancel function.
+ *    		            j) Bond function.
+ *    		            k) Bond Cancel function.
+ *    		            l) Unbond function.
+ *    		            m) Set Pin Type function.
+ *    		            n) Query Pin Type function.
+ *    		            o) User Confirmation funcion.
+ *    		            p) Passkey Request Reply function.
+ *    		            q) PinCode Reply function.
+ *    		            r) Query Role function.
+ *    		            s) Query Services function.
+ *    		            t) Search Services function.
+ *   		              u) Set Profile Mode function.
+ *   		              v) Query Connectability mode function.
+ *   		              w) set Role function.
+ */		      	
+
+
+/**
+ * Includes
+ */
+#include "rsi_bt_global.h"
+#include "rsi_bt_generic.h"
+#include "rsi_bt_api.h"
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *	
+ * @fn          INT16 rsi_bt_set_discovery_mode(RSI_BT_CMD_SET_DISCV_MODE *uSetDiscoveryMode)
+ * @brief       Sends the Set Discovery Mode command to the BT module
+ * @param[in]   RSI_BT_CMD_SET_DISCV_MODE *uSetDiscoveryMode, Pointer to Set Discovery Mode structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *               0  = SUCCESS
+ * @section description 
+ * This API is used to set the BT Module in any of the 3 discovery modes.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_set_discovery_mode(RSI_BT_CMD_SET_DISCV_MODE *uSetDiscoveryMode)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSet Discovery Mode Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetDiscvMode, (UINT08 *)uSetDiscoveryMode, sizeof(RSI_BT_CMD_SET_DISCV_MODE));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_discovery_mode(void)
+ * @brief       Sends the Query Discovery mode command to the BT module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to get Discovery Mode of the BT module.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_query_discovery_mode(void)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Discovery Mode start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryDiscvMode, NULL, 0);
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn         INT16 rsi_bt_set_connectability_mode(RSI_BT_CMD_SET_CONNECTABILITY_MODE *uSetConnectabilityMode)
+ * @brief       Sends the  Set Connectability Mode command to the BT module
+ * @param[in]   RSI_BT_CMD_SET_CONNECTABILITY_MODE *uSetConnectabilityMode, Pointer to Set Connectability Mode structure  			
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set the BT module in one of the two Connectability modes. 
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_bt_set_connectability_mode(RSI_BT_CMD_SET_CONNECTABILITY_MODE *uSetConnectabilityMode)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSet Connectability Mode starts ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetConnMode,  (UINT08 *)uSetConnectabilityMode, sizeof(RSI_BT_CMD_SET_CONNECTABILITY_MODE));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_connectability_mode(void)
+ * @brief       Sends the Query Connectability mode command to the BT module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to query the connectability mode of the BT module.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_query_connectability_mode(void)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Connectability Mode start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryConnMode, NULL, 0);
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_set_pair_mode(RSI_BT_CMD_SET_PAIR_MODE *uSetPairMode)
+ * @brief       Sends the Set Pair Mode command to the BT module
+ * @param[in]   RSI_BT_CMD_SET_PAIR_MODE *uSetPairMode , Pointer to Set Pair Mode structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to enable or disable the Pairing mode of the BT module. 
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_set_pair_mode(RSI_BT_CMD_SET_PAIR_MODE *uSetPairMode)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSet Pair Mode Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetPairMode, (UINT08 *)uSetPairMode, sizeof(RSI_BT_CMD_SET_PAIR_MODE));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_pair_mode(void)
+ * @brief       Sends the query pair mode command to the BT module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to query current pairing mode of the BT module.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_query_pair_mode(void)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Pair Mode start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryPairMode, NULL, 0);
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_remote_name_request(RSI_BT_CMD_REMOTE_NAME_REQUEST *uRemoteNameRequest)	
+ * @brief       Sends the Remote Name Request command to the BT module
+ * @param[in]   RSI_BT_CMD_REMOTE_NAME_REQUEST *uRemoteNameRequest , Pointer to Remote Name Request structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to know the name of the remote BT device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_remote_name_request(RSI_BT_CMD_REMOTE_NAME_REQUEST *uRemoteNameRequest)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n  Remote Name Request Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdRemNameReq , (UINT08 *)uRemoteNameRequest , sizeof(RSI_BT_CMD_REMOTE_NAME_REQUEST));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_remote_name_request_cancel(RSI_BT_CMD_REMOTE_NAME_REQUEST_CANCEL *uRemoteNameRequestCancel)	
+ * @brief       Sends the Remote Name Request Cancel command to the BT module
+ * @param[in]   RSI_BT_CMD_REMOTE_NAME_REQUEST_CANCEL *uRemoteNameRequestCancel, Pointer to Remote Name Request Cancel structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to cancel the request made by “Remote Name Request” command
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_remote_name_request_cancel(RSI_BT_CMD_REMOTE_NAME_REQUEST_CANCEL *uRemoteNameRequestCancel)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n  Remote Name Request Cancel Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdRemNameReqCancel , (UINT08 *)uRemoteNameRequestCancel , sizeof(RSI_BT_CMD_REMOTE_NAME_REQUEST_CANCEL));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_inquiry(RSI_BT_CMD_INQUIRY *uInquiry)	
+ * @brief       Sends the Inquiry command to the BT module.
+ * @param[in]   RSI_BT_CMD_INQUIRY *uInquiry, Pointer to Inquiry structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to perform an inquiry to find BT devices in the vicinity.
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_bt_inquiry(RSI_BT_CMD_INQUIRY *uInquiry)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n  Inquiry Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdInq , (UINT08 *)uInquiry , sizeof(RSI_BT_CMD_INQUIRY));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_inquiry_cancel(void); 	
+ * @brief       Sends the Inquiry Cancel command to the BT module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to cancel the inquiry which was in progress.
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_bt_inquiry_cancel(void)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n  Inquiry Cancel Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdInqCancel , NULL, 0);
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_bond(RSI_BT_CMD_BOND *uBond)	
+ * @brief       Sends the Bond command to the BT module
+ * @param[in]   RSI_BT_CMD_BOND *uBond, Pointer to Bond structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to establish Bond between BT module and remote BT device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_bond(RSI_BT_CMD_BOND *uBond)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n  Bond Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBond , (UINT08 *)uBond , sizeof(RSI_BT_CMD_BOND));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_bond_cancel(RSI_BT_CMD_BOND_CANCEL *uBondCancel)	
+ * @brief       Sends the Bond Cancel command to the BT module
+ * @param[in]   RSI_BT_CMD_BOND_CANCEL *uBondCancel,pointer to Bond Cancel structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to cancel Bond between BT module and remote BT device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_bond_cancel(RSI_BT_CMD_BOND_CANCEL *uBondCancel)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Bond Cancel Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBondCancel , (UINT08 *)uBondCancel, sizeof(RSI_BT_CMD_BOND_CANCEL));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_unbond(RSI_BT_CMD_UNBOND *uUnbond)
+ * @brief       Sends the UnBond command to the BT module
+ * @param[in]   RSI_BT_CMD_UNBOND *uUnbond, Pointer to UnBond structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to un-bond the device, which was already bonded.
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_bt_unbond(RSI_BT_CMD_UNBOND *uUnbond)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n  UnBond Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdUnbond , (UINT08 *)uUnbond , sizeof(RSI_BT_CMD_UNBOND));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_set_pin_type(RSI_BT_CMD_SET_PIN_TYPE *uSetPinType)
+ * @brief       Sends the Set Pin Type command to the BT module
+ * @param[in]   RSI_BT_CMD_SET_PIN_TYPE *uSetPinType, Pointer to Set Pin Type structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to Set Pin Type of the BT module.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_set_pin_type(RSI_BT_CMD_SET_PIN_TYPE *uSetPinType)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSet Pin Type Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetPinType, (UINT08 *)uSetPinType, sizeof(RSI_BT_CMD_SET_PIN_TYPE));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_pin_type(void)
+ * @brief       Sends the Query Pin Type command to the BT module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to Get Pin Type of the BT module.
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_bt_query_pin_type(void)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Pin Type start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryPinType, NULL, 0);
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_user_confirmation(RSI_BT_CMD_USER_CONFIRMATION *uUserConfirmation)
+ * @brief       Sends the User Confirmation command to the BT module
+ * @param[in]   RSI_BT_CMD_USER_CONFIRMATION *uUserConfirmation, Pointer to  User Confirmation structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give the confirmation for the values sent by remote BT devices at the time of bonding. 
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_bt_user_confirmation(RSI_BT_CMD_USER_CONFIRMATION *uUserConfirmation)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nUser Confirmation Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdUserConf, (UINT08 *)uUserConfirmation, sizeof(RSI_BT_CMD_USER_CONFIRMATION));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_passkey_request_reply(RSI_BT_CMD_PASSKEY_REPLY *uPasskeyReply)
+ * @brief       Sends the Passkey Request reply command to the BT module.
+ * @param[in]   RSI_BT_CMD_PASSKEY_REPLY *uPasskeyReply, Pointer to Passkey Request Reply structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to respond on a passkey entry request.
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_bt_passkey_request_reply(RSI_BT_CMD_PASSKEY_REPLY *uPasskeyReply)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nPasskey Request Reply start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdPasskeyReply, (UINT08 *)uPasskeyReply, sizeof(RSI_BT_CMD_PASSKEY_REPLY));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_pincode_reply(RSI_BT_CMD_PINCODE_REPLY *uPincodeReply)
+ * @brief       Sends the Pincodereply command to the BT module
+ * @param[in]   RSI_BT_CMD_PINCODE_REPLY *uPincodeReply, Pointer to Pin Code Reply structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to respond on a pincode request.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_pincode_reply(RSI_BT_CMD_PINCODE_REPLY *uPincodeReply)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nPinCode Reply start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdPincodeReply, (UINT08 *)uPincodeReply, sizeof(RSI_BT_CMD_PINCODE_REPLY));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_role(RSI_BT_CMD_QUERY_ROLE *uQryRole)
+ * @brief       Sends the query role command to the BT module
+ * @param[in]   RSI_BT_CMD_QUERY_ROLE *uQryRole, Pointer to Query Role structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *               0  = SUCCESS
+ * @section description 
+ * This API is used to Get Role of the BT module when connected with a particular remote BT device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_query_role(RSI_BT_CMD_QUERY_ROLE *uQryRole)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Role Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryRole, (UINT08 *)uQryRole, sizeof(RSI_BT_CMD_QUERY_ROLE));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_set_role(RSI_BT_CMD_SET_ROLE *uSetRole)
+ * @brief       Sends the Set role command to the BT module
+ * @param[in]   RSI_BT_CMD_SET_ROLE *uSetRole, Pointer to Set Role structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to Set Master/Slave Role to the BT module.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_set_role(RSI_BT_CMD_SET_ROLE *uSetRole)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSet Role Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetRole, (UINT08 *)uSetRole, sizeof(RSI_BT_CMD_SET_ROLE));
+  return retval;
+}
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_services(RSI_BT_CMD_QUERY_SERVICES *uGetServ)
+ * @brief       Sends the Query services command to the BT module
+ * @param[in]   RSI_BT_CMD_QUERY_SERVICES *uGetServ, Pointer to query services structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to search for the services supported by the remote BT Device. 
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_bt_query_services(RSI_BT_CMD_QUERY_SERVICES *uGetServ)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Services Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryServ, (UINT08 *)uGetServ, sizeof(RSI_BT_CMD_QUERY_SERVICES));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_search_service(RSI_BT_CMD_SEARCH_SERVICE *uSearchService)
+ * @brief       Sends the Search service command to the BT module
+ * @param[in]   RSI_BT_CMD_SEARCH_SERVICE *uSearchService, Pointer to Search Service Structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to to find whether a particular service is supported by the remote BT device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_search_service(RSI_BT_CMD_SEARCH_SERVICE *uSearchService)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSearch Services Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSearchServ, (UINT08 *)uSearchService, sizeof(RSI_BT_CMD_SEARCH_SERVICE));
+  return retval;
+}
+
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_set_profile_mode(RSI_BT_CMD_SET_PROFILE_MODE *uSetProfileMode)
+ * @brief       Sends the Set Profile Mode command to the BT module
+ * @param[in]   RSI_BT_CMD_SET_PROFILE_MODE *uSetProfileMode , Pointer to Set Profile Mode structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set profile mode of the BT module.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_set_profile_mode(RSI_BT_CMD_SET_PROFILE_MODE *uSetProfileMode)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSet Profile Mode Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetProfMode, (UINT08 *)uSetProfileMode, sizeof(RSI_BT_CMD_SET_PROFILE_MODE));
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_linkkey_reply(RSI_BT_CMD_LINKKEY_REPLY *uLinkKeyReply)
+ * @brief       Sends the LinkKeyreply command to the BT module
+ * @param[in]   RSI_BT_CMD_LINKKEY_REPLY *uLinkKeyReply, Pointer to Link Key Reply structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to respond on a linkkey reply request.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_linkkey_reply(RSI_BT_CMD_LINKKEY_REPLY *uLinkKeyReply)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nLinkKey Reply start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdLinkKeyReply, (UINT08 *)uLinkKeyReply, sizeof(RSI_BT_CMD_LINKKEY_REPLY));
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_start_sniff_mode (RSI_BT_CMD_SNIFF_MODE *SniffMode)
+ * @brief       Sends the start sniff mode command to the BT module
+ * @param[in]   RSI_BT_CMD_SNIFF_MODE *SniffMode, Pointer to sniff enable structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used after connection completed to keep the device in sniff mode.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_start_sniff_mode (RSI_BT_CMD_SNIFF_MODE *SniffMode)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n start sniff mode \r\n");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSniffMode, (UINT08 *)SniffMode, sizeof(RSI_BT_CMD_SNIFF_MODE));
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_exit_sniff_mode (RSI_BT_CMD_SNIFF_EXIT *SniffExit)
+ * @brief       Sends the stop/exit sniff mode command to the BT module
+ * @param[in]   RSI_BT_CMD_SNIFF_EXIT *SniffExit, Pointer to sniff disable structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to get back the device from sniff mode.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_exit_sniff_mode (RSI_BT_CMD_SNIFF_EXIT *SniffExit)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n sniff exit \r\n");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSniffExit, (UINT08 *)SniffExit, sizeof(RSI_BT_CMD_SNIFF_EXIT));
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_sniff_subrating_mode (RSI_BT_CMD_SNIFF_SUBRATING *SniffSubrating)
+ * @brief       Sends the sniff subrating mode command to the BT module
+ * @param[in]   RSI_BT_CMD_SNIFF_SUBRATING *SniffSubrating, Pointer to sniff subrating structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to keep the device in sniff subrating mode.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_sniff_subrating_mode (RSI_BT_CMD_SNIFF_SUBRATING *SniffSubrating)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n sniff subrating mode \r\n");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSniffSubrating, (UINT08 *)SniffSubrating, sizeof(RSI_BT_CMD_SNIFF_SUBRATING));
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          rsi_bt_enable_ssp_mode (RSI_BT_CMD_SSP_MODE *SSPMode)
+ * @brief       Sends the enbale ssp pair mode command to the BT module
+ * @param[in]   RSI_BT_CMD_SSP_MODE *SSPMode, Pointer to SSP mode enable structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is given before enter the connection state. This is used to enable/disable SSP pair mode.
+ * If SSP is disabled, legacy pairing will happen by default
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_enable_ssp_mode (RSI_BT_CMD_SSP_MODE *SSPMode)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n SSP mode \r\n");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSSPEnable, (UINT08 *)SSPMode, sizeof(RSI_BT_CMD_SSP_MODE));
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_enable_set_feature_bitmap (RSI_BT_CMD_FEATURE_BIT_MAP *FeatureBitMap)
+ * @brief       Sends the set features bit map command to the BT module
+ * @param[in]   RSI_BT_CMD_FEATURE_BIT_MAP *FeatureBitMap, Pointer to feature bit map structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is given at initilization time or before connection state.
+ * bit fields:
+ * bit 0 - security mode (1- enable/ 0-disable).
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_enable_set_feature_bitmap (RSI_BT_CMD_FEATURE_BIT_MAP *FeatureBitMap)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n set feature bitmap \r\n");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdFeatureBitMap, (UINT08 *)FeatureBitMap, sizeof(RSI_BT_CMD_FEATURE_BIT_MAP));
+  return retval;
+}
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_set_antenna_tx_power_value(RSI_BT_CMD_SET_ANTENNA_TX_POWER_LEVEL *AntennaTxPowerLevel)
+ * @brief       Sends the BT/BLE Antenna Tx power value based on protocol mode
+ * @param[in]   RSI_BT_CMD_SET_ANTENNA_TX_POWER_LEVEL *AntennaTxPowerLevel, pointer to antenna tx power level structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is given at initilization time or before connection state or after connection time.
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_set_antenna_tx_power_value (RSI_BT_CMD_SET_ANTENNA_TX_POWER_LEVEL *AntennaTxPowerLevel)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n set BT tx power value \r\n");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdAntennaTxPowerLevel, (UINT08 *)AntennaTxPowerLevel, sizeof(RSI_BT_CMD_SET_ANTENNA_TX_POWER_LEVEL));
+  return retval;
+}
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_eir_data_value(RSI_BT_CMD_SET_EIR_DATA *EirData)
+ * @brief       Sends EIR data 
+ * @param[in]   RSI_BT_CMD_SET_EIR_DATA *EirData, pointer to antenna EIR_data structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is given at initilization time or before connection state or after connection time.
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_eir_data_value(RSI_BT_CMD_SET_EIR_DATA *EirData)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n set BT EIR data value \r\n");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdEIRData, (UINT08 *)EirData, sizeof(RSI_BT_CMD_SET_EIR_DATA));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_execute_cmd.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_execute_cmd.c
new file mode 100755
index 0000000..1ff3941
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_execute_cmd.c
@@ -0,0 +1,71 @@
+/**
+ * @file       rsi_bt_execute_cmd.c
+ * @version    1.0
+ * @date       2014-Aug-23
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Implements common functionality for all the BT commands
+ *
+ * @section Description
+ * This file contains common API needed for all the BT commands
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_bt_generic.h"
+#include "rsi_bt_api.h"
+
+
+
+
+/*====================================================*/
+/**
+ * @fn          INT16 rsi_bt_execute_cmd(UINT08 *descparam,UINT08 *payloadparam,UINT16 size_param)
+ * @brief       Common function for all the commands.
+ * @param[in]   UINT08 *descparam, pointer to the frame descriptor parameter structure
+ * @param[in]   UINT08 *payloadparam, pointer to the command payload parameter structure
+ * @param[in]   UINT16 size_param, size of the payload for the command
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *               0  = SUCCESS
+ * @section description 
+ * This is a common function used to process a command to the BT module.
+ */
+INT16 rsi_bt_execute_cmd(UINT08 *descparam, UINT08 *payloadparam, UINT16 size_param)
+{
+  INT16            retval;
+  RSI_BT_FRAME_DESC  uFrameDscFrame;
+  
+  //! 16 bytes, send/receive command descriptor frame
+  //! Create the Command Frame Descriptor  
+  rsi_bt_build_frame_descriptor(&uFrameDscFrame, descparam);
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"Descriptor write");
+#endif
+
+  //! Write descriptor and payload
+  retval = rsi_frame_write((rsi_uFrameDsc*)&uFrameDscFrame, payloadparam, size_param);
+
+  if (retval != 0x00) 
+  {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL4,"Frame write failErr=%02x", (UINT16)retval);
+#endif
+    return retval;
+  }
+  
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_generic.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_generic.c
new file mode 100755
index 0000000..f2c79a9
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_generic.c
@@ -0,0 +1,541 @@
+/**
+ * @file      rsi_bt_generic.c
+ * @version   1.0
+ * @date      2014-Aug-22
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Contains BT Common API's
+ *
+ * @section Description
+ * This file contains a) Set Local Name function.
+ * 		                b) Query Local Name function.		
+ *		                c) Set Local COD function.
+ *		                d) Query Local COD function.
+ *		                e) Query RSSI function.
+ *		                f) Query Link Quality function.
+ *		                g) Query Local BD Address function.
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_bt_generic.h"
+#include "rsi_bt_api.h"
+#include "platform_specific.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_set_local_name(RSI_BT_CMD_SET_LOCAL_NAME *uSetLocalName)
+ * @brief       Sends the Set Local name command to the BT module
+ * @param[in]   RSI_BT_CMD_SET_LOCAL_NAME *uSetLocalName, Pointer to Set Local Name structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to  Set Name to the BT module.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_set_local_name(RSI_BT_CMD_SET_LOCAL_NAME *uSetLocalName)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSet Local Name Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetLocalName, (UINT08 *)uSetLocalName, sizeof(RSI_BT_CMD_SET_LOCAL_NAME));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_local_name(void)
+ * @brief       Sends the Query Local Name command to the BT module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to Get Name of the BT module.
+ *
+ * @section prerequisite 
+ * none
+ */
+
+INT16 rsi_bt_query_local_name(void)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Local Name Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryLocalName, NULL, 0);
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_set_local_cod(RSI_BT_CMD_SET_LOCAL_COD *SetLocalCOD)
+ * @brief       Sends the Set Local code command to the BT module
+ * @param[in]   RSI_BT_CMD_SET_LOCAL_COD *uSetLocalCOD, Pointer to Set Local COD structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set the Class of the BT module.
+ *
+ * @section prerequisite 
+ */
+INT16 rsi_bt_set_local_cod(RSI_BT_CMD_SET_LOCAL_COD *uSetLocalCOD)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSet Local COD Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSetLocalCOD, (UINT08 *)uSetLocalCOD, sizeof(RSI_BT_CMD_SET_LOCAL_COD));
+  return retval;
+}
+
+
+
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_local_cod(void);
+ * @brief       Sends the Query Local code command to the BT module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to query the class of the BT module.
+ *
+ * @section prerequisite 
+ * none
+ */
+
+
+INT16 rsi_bt_query_local_cod(void)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Local Name Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryLocalCOD, NULL, 0);
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_rssi(RSI_BT_CMD_QUERY_RSSI *QueryRSSI)
+ * @brief       Sends the Query rssi command to the BT module
+ * @param[in]   RSI_BT_CMD_QUERY_RSSI *QueryRssi, Pointer to Query RSSI structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to get RSSI of remote BT device.
+ *
+ * @section prerequisite
+ * none
+ */
+
+INT16 rsi_bt_query_rssi(RSI_BT_CMD_QUERY_RSSI *uQueryRSSI)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery RSSI Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryRSSI, (UINT08 *)uQueryRSSI, sizeof(RSI_BT_CMD_QUERY_RSSI));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_link_quality(RSI_BT_CMD_QUERY_LINK_QUALITY *uQueryLinkQuality)
+ * @brief       Sends the Query Link Quality command to the BT module
+ * @param[in]   RSI_BT_CMD_QUERY_LINK_QUALITY *uQueryLinkQuality, Pointer to Query Link Quality structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to Get link quality between BT module and remote BT device.
+ *
+ * @section prerequisite 
+ *
+ */
+
+INT16 rsi_bt_query_link_quality(RSI_BT_CMD_QUERY_LINK_QUALITY *uQueryLinkQuality)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Link Quality Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryLinkQuality, (UINT08 *)uQueryLinkQuality, sizeof(RSI_BT_CMD_QUERY_LINK_QUALITY));
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_query_local_bd_address(void)
+ * @brief       Sends the Query Local BD Address command to the BT module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to Get Local BD Address of the BT module.
+ *
+ * @section prerequisite 
+ * none
+ */
+
+INT16 rsi_bt_query_local_bd_address(void)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Query Local BD Address Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdQryLocalBDAddr, NULL, 0);
+  return retval;
+}
+
+
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_bt_device_init(void)                                                                                                                                             													      
+ * @brief       Sends the BT Device Init command to the BT classic/LE module                                                  													      
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to initialise the BT module.                                                                                      													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_bt_device_init(void)                                                                                                           													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n BT INIT start");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBTInit, NULL, 0);													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+
+
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_bt_device_deinit(void)                                                                                                                                             													      
+ * @brief       Sends the BT Device deinit command to the BT Classic/LE module                                                  													      
+ * @param[in]  	none                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to deregister/deinit the BT module. To again initialise the module, rsi_bt_device_init()
+ * API has to be called                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_bt_device_deinit(void)                                                                                                           													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n BT DEINIT start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBTDeinit, NULL, 0);													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+                                                                                                             													      
+
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_bt_antenna_select(RSI_BT_CMD_ANTENNA_SELECT *uAntennaSelect)                                                                                                                                             													      
+ * @brief       Sends the BT antenna select command to the BT Classic/LE module                                                  													      
+ * @param[in]  	RSI_BT_CMD_ANTENNA_SELECT *uAntennaSelect                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to select internal/external antenna of the BT module. 
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+INT16 rsi_bt_antenna_select(RSI_BT_CMD_ANTENNA_SELECT *uAntennaSelect)                                                                                                           													                                                              													      
+{                                                                                                            													      
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n BT Antenna Select start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBTAntennaSelect, (UINT08 *)uAntennaSelect, sizeof(RSI_BT_CMD_ANTENNA_SELECT));													      
+  return retval;                                                                                             													      
+}                                                                                                            													      
+                                                                                                             													      
+
+
+
+/*===========================================================================
+ *                                                                                                                                                                                                                        													      
+ * @fn          INT16 rsi_bt_config_enable(RSI_BT_CMD_CONFIG_ENABLE *uConfigEnable)                                                                                                                                             													      
+ * @brief       Sends the BT config enable command to the BT Classic/LE module                                                  													      
+ * @param[in]  	RSI_BT_CMD_CONFIG_ENABLE *uConfigEnable                                  													      
+ * @param[out]  none                                                                                         													      
+ * @return      errCode                                                                                      													      
+ *              -2 = Command execution failure                                                               													      
+ *              -1 = Buffer Full                                                                             													      
+ *              0  = SUCCESS                                                                                 													      
+ * @section description                                                                                      													      
+ * This API is used to enable/disable stored configuration in the BT module.                                                                                     													      
+ *                                                                                                           													      
+ * @section prerequisite                                                                                     													      
+ */
+
+/*INT16 rsi_bt_config_enable(RSI_BT_CMD_CONFIG_ENABLE *uConfigEnable)                                                                                                           													                                                              													      
+{                                                                                                            													      
+  INT16          retval;                                                                                     													      
+                                                                                                             													      
+#ifdef RSI_DEBUG_PRINT                                                                                       													      
+  RSI_DPRINT(RSI_PL3,"\r\n\n BT Config Enable/Disable start ");                                                            													      
+#endif                                                                                                       													      
+                                                                                                             													      
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdBTConfigEnable, (UINT08 *)uConfigEnable, sizeof(RSI_BT_CMD_CONFIG_ENABLE));													      
+  return retval;
+}
+*/
+                                                                                                             													      
+
+/*=================================================*/
+/**
+ * @fn          rsi_uCmdRsp *rsi_parse_response(UINT08 *rsp)
+ * @brief       To parse the resposne received from Kernel
+ * @param[in]   UINT08 *rsp, response buffer pointer
+ * @param[out]  none
+ * @return      rsi_uCmdRsp *ptr, response pointer
+ * @section description 
+ * This API is used to parse the recieved response. This returns the 
+ * pointer which points to rsptype, status, response payload in order.
+ */
+RSI_BT_RESPONSE *rsi_bt_parse_response(UINT08 *rsp)
+{
+  RSI_BT_RESPONSE         *temp_uCmdRspPtr = NULL;
+  UINT16                  temp_rspCode;
+  UINT16                  temp_status;
+  UINT08                  *descPtr = rsp ;
+  UINT08                  *payloadPtr = rsp + RSI_BT_FRAME_DESC_LEN;
+
+  /* Retrieve response code from the received packet */
+  temp_status  = rsi_bytes2R_to_uint16(descPtr + RSI_BT_STATUS_OFFSET);
+  temp_rspCode = rsi_bytes2R_to_uint16(descPtr + RSI_BT_RSP_TYPE_OFFSET);
+ 
+  /* Copy the response type and status to payloadPtr-4, payloadPtr-2
+   * locations respectively.
+   */
+  rsi_uint16_to_2bytes((payloadPtr - 2), temp_status);
+  rsi_uint16_to_2bytes((payloadPtr - 4), temp_rspCode);
+
+  temp_uCmdRspPtr = (RSI_BT_RESPONSE *)(payloadPtr - 4);
+
+  return temp_uCmdRspPtr;
+}
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_per_transmit(RSI_BT_CMD_PER_TRANSMIT *uPerTransmit)
+ * @brief       Sends the PER transmit command to the BT module
+ * @param[in]   RSI_BT_CMD_PER_TRANSMIT *uPerTransmit, Pointer to PER Transfer structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send PER transmit command to module. 
+ *
+ * @section prerequisite
+ * none
+ */
+
+INT16 rsi_bt_per_transmit(RSI_BT_CMD_PER_TRANSMIT *uPerTransmit)
+{
+  INT16          retval;
+#ifdef BT_ENABLE
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdPerTransmit, (UINT08 *)uPerTransmit, sizeof(RSI_BT_CMD_PER_TRANSMIT ));
+#endif  
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\n\nPER Transmit Command Sent...\n");
+#endif
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_per_receive(RSI_BT_CMD_PER_RECEIVE *uPerReceive)
+ * @brief       Sends the PER receive command to the BT module
+ * @param[in]   RSI_BT_CMD_PER_RECEIVE *uPerReceive, Pointer to PER Transfer structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send PER receive command to module. 
+ *
+ * @section prerequisite
+ * none
+ */
+
+INT16 rsi_bt_per_receive(RSI_BT_CMD_PER_RECEIVE *uPerReceive)
+{
+  INT16          retval;
+
+#ifdef BT_ENABLE
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdPerReceive, (UINT08 *)uPerReceive, sizeof(RSI_BT_CMD_PER_RECEIVE));
+#endif  
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\n\nPER Receive Command Sent...\n");
+#endif
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_per_stats(RSI_BT_CMD_PER_STATS *uPerStats)
+ * @brief       Sends the PER Stats command to the BT module
+ * @param[in]   RSI_BT_CMD_PER_STATS *uPerStats, Pointer to PER Transfer structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send PER stats command to module. 
+ *
+ * @section prerequisite
+ * none
+ */
+
+INT16 rsi_bt_per_stats(RSI_BT_CMD_PER_STATS *uPerStats)
+{
+  INT16          retval;
+
+#ifdef BT_ENABLE
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdPerBTStats, (UINT08 *)uPerStats, sizeof(RSI_BT_CMD_PER_STATS));
+#endif  
+  return retval;
+}
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_per_cw_mode(RSI_BT_CMD_PER_CW_MODE *uPerCw)
+ * @brief       Sends the PER cw mode command to the BT module
+ * @param[in]   RSI_BT_CMD_PER_CW_MODE *uPerCw, Pointer to PER Transfer structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send PER cw mode command to module. 
+ *
+ * @section prerequisite
+ * none
+ */
+
+INT16 rsi_bt_per_cw_mode(RSI_BT_CMD_PER_CW_MODE *uPerCw)
+{
+  INT16          retval;
+
+#ifdef BT_ENABLE
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdPerCwMode, (UINT08 *)uPerCw, sizeof(RSI_BT_CMD_PER_CW_MODE));
+#endif  
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\n\nContinous Wave Mode Command Sent...\n");
+#endif
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_register_interrupt_irq.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_register_interrupt_irq.c
new file mode 100755
index 0000000..846727c
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_register_interrupt_irq.c
@@ -0,0 +1,63 @@
+/**
+ * @file       rsi_bt_register_interrupt_irq.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief IRQ: Function to register interrupt irq
+ *
+ * @section Description
+ * This file contains the function used to register the interrupt IRQ
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_bt_global.h"
+#include "rsi_bt_generic.h"
+#include "rsi_bt_api.h"
+#include "platform_specific.h"
+ 
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ *@fn           INT16 rsi_bt_register_interrupt_irq(UINT08 mask)
+ * @brief       Sends the register interrupt irq to the Wi-Fi module via SPI
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to register the interrupt irq.
+ */
+INT16 rsi_bt_register_interrupt_irq(void)
+{
+  INT16     retval;
+  /* set unblock interrupt frame */  
+  UINT08      rsi_frameRegisterInterruptIrq[RSI_BYTES_4] = {0x01, 0x00, 0xEE, 0x00};
+
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nunblocking interrupt");
+#endif
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameRegisterInterruptIrq, NULL, 0);
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_spp.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_spp.c
new file mode 100755
index 0000000..4a7db69
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/src/rsi_bt_spp.c
@@ -0,0 +1,209 @@
+/**
+ * @file      rsi_bt_spp.c
+ * @version   1.0
+ * @date      2014-Aug-22
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Contains BT Classic SPP API's
+ *
+ * @section Description
+ * This file contains a) SPP Connect function.
+ * 		      b) SPP Disconnect function.		
+ *		      c) SPP Transfer function.
+ *
+ */
+ 
+ 
+/**
+ * Includes
+ */
+#include "rsi_bt_global.h"
+#include "rsi_bt_generic.h"
+#include "rsi_bt_api.h"
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_spp_connect(RSI_BT_CMD_SPP_CONNECT *SPPConnect)
+ * @brief       Sends the SPP Connect command to the BT module
+ * @param[in]   RSI_BT_CMD_SPP_CONNECT *SPPConnect, Pointer to SPP Connect structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to establish SPP connection with the remote BT device.
+ *
+ * @section prerequisite 
+ */
+
+
+INT16 rsi_bt_spp_connect(RSI_BT_CMD_SPP_CONNECT *uSPPConnect)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSPP Connect Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSPPConn, (UINT08 *)uSPPConnect, sizeof(RSI_BT_CMD_SPP_CONNECT));
+  return retval;
+}
+
+
+
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_spp_disconnect(RSI_BT_CMD_SPP_DISCONNECT *SPPDisConnect)
+ * @brief       Sends the SPP disconnect command to the BT module
+ * @param[in]   RSI_BT_CMD_SPP_DISCONNECT *SPPDisConnect, Pointer to SPP Disconnect structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to disconnect the SPP connection with the remote BT device.
+ *
+ * @section prerequisite 
+ */
+
+INT16 rsi_bt_spp_disconnect(RSI_BT_CMD_SPP_DISCONNECT *uSPPDisConnect)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSPP Disconnect Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSPPDisConn, (UINT08 *)uSPPDisConnect, sizeof(RSI_BT_CMD_SPP_DISCONNECT));
+  return retval;
+}
+
+
+
+
+
+/*===========================================================================
+ *
+ * @fn          INT16 rsi_bt_spp_transfer(RSI_BT_CMD_SPP_TRANSFER *SPPTransfer)
+ * @brief       Sends the SPP transfer command to the BT module
+ * @param[in]   RSI_BT_CMD_SPP_TRANSFER *SPPTransfer, Pointer to SPP Transfer structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send data to the remote BT device using SPP profile. 
+ *
+ * @section prerequisite
+ * none
+ */
+
+
+INT16 rsi_bt_spp_transfer(RSI_BT_CMD_SPP_TRANSFER *uSPPTransfer)
+{
+  INT16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSPP Transfer Start ");
+#endif
+
+  retval = rsi_bt_execute_cmd((UINT08 *)rsi_frameCmdSPPTransfer, (UINT08 *)uSPPTransfer, sizeof(RSI_BT_CMD_SPP_TRANSFER));
+  return retval;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include/platform_specific.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include/platform_specific.h
new file mode 100755
index 0000000..971734b
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include/platform_specific.h
@@ -0,0 +1,26 @@
+/**
+ * @file     platform_specific.h
+ * @version  3.6
+ * @date     2013-May-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER, Global Header file, which contains platform specific information
+ *
+ * @section Description
+ * This is header file contains platform specific information
+ *
+ *
+ */
+
+
+
+/**
+ * Global defines
+ */
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include/rsi_hal.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include/rsi_hal.h
new file mode 100755
index 0000000..cba0be9
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include/rsi_hal.h
@@ -0,0 +1,68 @@
+/**
+ * @file     rsi_hal.h
+ * @version  2.2.0.0
+ * @date     2011-May-30
+ *
+ * Copyright(C) Redpine Signals 2011
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HAL HEADER: Function prototypes for HAL
+ *
+ * @section Description
+ * This file contains the function definition prototypes, defines used in HAL and related functions
+ *
+ *
+ */
+
+
+#ifndef _RSIHAL_H_
+#define _RSIHAL_H_
+
+
+/**
+ * INCLUDES
+ */
+#include "rsi_global.h"
+
+#ifdef SAM9_G20
+#define SPI_INTR_GPIO_PIN AT91_PIN_PB8
+#endif
+#ifdef SAM9_G35
+#define SPI_INTR_GPIO_PIN AT91_PIN_PA13
+#endif
+#ifdef SAM9_G45
+#define SPI_INTR_GPIO_PIN AT91_PIN_PD0
+#endif
+#ifdef X86
+#define SPI_INTR_GPIO_PIN 0
+#endif
+
+/**
+ * DEFINES
+ */
+#define RSI_SPI_SEND_BYTE(A)                           //@ to send 1 byte over SPI interface
+#define RSI_SPI_SEND_4BYTE(A)                          //@ to send 4 bytes over SPI interface 
+#define RSI_SPI_READ_BYTE(B)                           //@ to receive 1 byte over SPI interface
+#define RSI_SPI_READ_4BYTE(B)                          //@ to receive 4 byte over SPI interface
+/**
+ * Function Prototypes
+ */
+void  rsi_interrupt_handler(void);
+void  rsi_irq_start(void);
+void  rsi_irq_enable(void);
+void  rsi_irq_disable(void);
+void  rsi_irq_clear_pending(void);
+uint8 rsi_irq_status(void);
+void  rsi_module_power(uint8 tf);
+int16 rsi_spi_send(uint8 *ptrBuf, uint16 bufLen,uint8 *valBuf,uint8 mode);
+int16 rsi_spi_recv(uint8 *ptrBuf, uint16 bufLen,uint8 mode);
+void  rsi_delay_ms(uint16 delay);
+void  rsi_delay_us(uint16 delay);
+void  rsi_spi_cs_assert(void);
+void  rsi_spi_cs_deassert(void);
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/Makefile b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/Makefile
new file mode 100644
index 0000000..c23a031
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/Makefile
@@ -0,0 +1,20 @@
+######################################################################
+#                                                                    #
+#   Makefile                                                         #
+#                                                                    #
+#   2016/09/29 Create(AlphaProject)                                  #
+#                                                                    #
+######################################################################
+
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include
+EXTRA_CFLAGS += -DRSI_HAL
+
+obj-$(CONFIG_WMRP10_SPI) += rsi_hal_all.o
+
+rsi_hal_all-objs := rsi_hal_mcu_ioports.o rsi_hal_mcu_spi.o rsi_hal_mcu_timers.o
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/rsi_hal_mcu_ioports.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/rsi_hal_mcu_ioports.c
new file mode 100755
index 0000000..37d257a
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/rsi_hal_mcu_ioports.c
@@ -0,0 +1,139 @@
+/**
+ * @file       rsi_hal_mcu_ioports.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Functions to control IO pins of the microcontroller
+ *  
+ * @section Description
+ * This file contains API to control different pins of the microcontroller 
+ * which interface with the module and other components related to the module. 
+ *
+ */
+/* 2019/05/15 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#ifdef RSI_HAL
+#include "rsi_hal.h"
+#endif
+
+/**
+ * Global Variales
+ */
+
+
+
+/*====================================================*/
+/**
+ * @fn    void rsi_module_reset(uint8 tf)
+ * @brief  Sets or clears the reset pin on the wifi module
+ * @param[in]  uint8 tf, true or false, true sets reset, false clears reset
+ * @param[out]  none
+ * @return  none
+ * @description This HAL API is used to set or clear the active-low reset pin of the Wi-Fi module.
+ */
+void rsi_module_reset(uint8 tf)
+{  
+  if (tf == RSI_TRUE) {
+  }
+  else {
+  }
+
+ }
+
+/*====================================================*/
+/**
+ * @fn    void rsi_module_power(uint8 tf)
+ * @brief  Turns on or off the power to the wifi module
+ * @param[in]  uint8 tf, true or false, true turns on power, false turns off power
+ * @param[out]  none
+ * @return  none
+ * @description This HAL API is used to turn on or off the power to the Wi-Fi module.
+ */
+void rsi_module_power(uint8 tf)
+{  
+  if (tf == RSI_TRUE) {
+  }
+  else {
+  }
+
+ }
+
+/*===========================================================*/
+/**
+ * @fn      int16 rsi_module_power_cycle(void)
+ * @brief    MODULE POWER ON, Power cycles the module
+ * @param[in]  none
+ * @param[out]  none
+ * @return    errCode
+ *        -1 = Error
+ *        0  = OK
+ * @description This API is used to power cycle the module. 
+ * This API is valid only if there is a power gate, external to the module, 
+ * which is controlling the power to the module using a GPIO signal of the MCU.
+ */
+int16 rsi_module_power_cycle(void)
+{   
+    return 0;
+}
+
+/*===========================================================*/
+/**
+ * @fn      void config_gpio_output(uint8 value)
+ * @brief    Configures gpio pin in output mode,with a value
+ * @param[in]  uint8 value, value to be configures
+ * @param[out]  none
+ * @return    errCode
+ *        -1 = Error
+ *        0  = OK
+ * @description This API is used to configure host gpio pin in output mode. 
+ */
+void config_gpio_output(uint8 value)
+{
+  /* Sets gpio pin in output mode */
+}
+
+/*===========================================================*/
+/**
+ * @fn      void config_gpio_input(void)
+ * @brief    Configures gpio pin in input mode
+ * @param[in]  none
+ * @param[out]  none
+ * @return    errCode
+ *        -1 = Error
+ *        0  = OK
+ * @description This API is used to configure host gpio pin in input mode. 
+ */
+void config_gpio_input(void)
+{
+  /* Sets gpio pin in input mode */
+}
+
+/*===========================================================*/
+/**
+ * @fn      uint8 get_gpio_value()
+ * @brief    Gets the gpio value
+ * @param[in]   none
+ * @param[out] none
+ * @return    errCode
+ *        -1 = Error
+ *        0  = OK
+ * @description This API is used to gets the host gpio value. 
+ */
+//uint8 get_gpio_value()
+uint8 get_gpio_value(void) /* APJ : modify */
+{
+  /* return gpio value*/
+  return 0;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/rsi_hal_mcu_spi.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/rsi_hal_mcu_spi.c
new file mode 100755
index 0000000..8da55ea
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/rsi_hal_mcu_spi.c
@@ -0,0 +1,99 @@
+/**
+ * @file       rsi_hal_mcu_spi.c
+ * @version    2.3.0.0
+ * @date       2011-May-30
+ *
+ * Copyright(C) Redpine Signals 2011
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief: HAL SPI API
+ *
+ * @Description:
+ * This file Contains all the API's related to HAL 
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include <linux/spi/spi.h>
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+extern struct spi_device *g_wmrp_spi;
+
+static void rsi_spi_txrx2(u8 *din, u8 *dout, int len)
+{
+    struct spi_message msg;
+    struct spi_transfer t;
+
+    spi_message_init(&msg);
+
+    memset(&t, 0, sizeof t);
+
+    spi_message_add_tail(&t, &msg);
+
+    t.tx_buf = din;
+    t.rx_buf = dout;
+    t.len = len;
+    spi_sync(g_wmrp_spi, &msg);
+}
+
+/*==================================================================*/
+/**
+ * @fn         int16 rsi_spi_send(uint8 *ptrBuf,uint16 bufLen,uint8 *valBuf,uint8 mode)
+ * @param[in]  uint8 *ptrBuf, pointer to the buffer with the data to be sent/received
+ * @param[in]  uint16 bufLen, number of bytes to send
+ * @param[in]  uint8 *valBuf, pointer to the buffer where the response is stored
+ * @param[in]  uint8 mode, To indicate mode 8 BIT/32 BIT.
+ * @param[out] None
+ * @return     0, 0=success
+ * @section description  
+ * This API is used to send data to the Wi-Fi module through the SPI interface.
+ */
+int16 rsi_spi_send(uint8 *ptrBuf, uint16 bufLen, uint8 *valBuf, uint8 mode)
+{
+    u8 buf[bufLen];
+
+    rsi_spi_txrx2(ptrBuf, buf, bufLen);
+
+    valBuf[0] = buf[0];
+    valBuf[1] = buf[1];
+
+    return RSI_SUCCESS;
+}
+
+
+/*==================================================================*/
+/**
+ * @fn         int16 rsi_spi_recv(uint8 *ptrBuf,uint16 bufLen,uint8 mode)
+ * @param[in]  uint8 *ptrBuf, pointer to the buffer with the data to be sent/received
+ * @param[in]  uint16 bufLen, number of bytes to send
+ * @param[in]  uint8 mode, To indicate the mode 8 BIT / 32 BIT.
+ * @param[out] None
+ * @return     0, 0=success
+ * @description 
+ * This API is used to receive data from Wi-Fi module through the SPI interface.
+ */
+int16 rsi_spi_recv(uint8 *ptrBuf, uint16 bufLen, uint8 mode)
+{
+    u8 rx_buf[bufLen];
+
+    memset(ptrBuf, 0, bufLen);
+
+    rsi_spi_txrx2(ptrBuf, rx_buf, bufLen);
+
+    memcpy(ptrBuf, rx_buf, bufLen);
+
+    return RSI_SUCCESS;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/rsi_hal_mcu_timers.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/rsi_hal_mcu_timers.c
new file mode 100755
index 0000000..74b2c02
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/src/rsi_hal_mcu_timers.c
@@ -0,0 +1,61 @@
+/**
+ * @file       rsi_hal_mcu_timers.c
+ * @version    2.9
+ * @date       2012-Nov-23
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HAL Timer: Functions related to HAL Timers
+ *
+ * @section Description
+ * This file implements MCU related timer functions.
+ *
+ */
+
+
+/**
+ * Include files
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global define
+ */
+
+
+/*===============================================================*/
+/**
+ * @fn          void rsi_delay_ms (uint16 delay)
+ * @brief       Delays by an integer number of milliseconds
+ * @param[in]   delay Number of milliseconds to delay
+ * @param[out]  none
+ * @return      none
+ * @description This HAL API should contain the code to introduce a delay in milliseconds.
+ */
+void rsi_delay_ms (uint16 delay)
+{
+}
+
+
+/*===============================================================*/
+/**
+ * @fn          void rsi_delay_us(uint16 delay)
+ * @brief       Delays by an integer number of microseconds
+ * @param[in]   uint16 delay, Number of microseconds to delay
+ * @param[out]  none
+ * @return      none
+ * @description This HAL API should contain the code to introduce a delay in microseconds.
+ */
+void rsi_delay_us (uint16 delay)
+{
+}
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include/rsi_spi_cmd.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include/rsi_spi_cmd.h
new file mode 100755
index 0000000..f1eb022
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include/rsi_spi_cmd.h
@@ -0,0 +1,233 @@
+/**
+ * @file     rsi_spi_cmd.h
+ * @version  3.6
+ * @date     2013-May-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SPI HEADER: SPI specific function declarations
+ *
+ * @section Description
+ * This file contains the function prototypes of the api's defined in spi library. 
+ *
+ */
+/* 2016/10/11 APJ modify */
+
+#ifndef _SPICMDAPI_H_
+#define _SPICMDAPI_H_
+
+/**
+ * Include Files
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Defines
+ */
+
+/*=========================================================*/
+//!C1 Register Bit Field Defines
+#define RSI_C1_INIT_CMD     0x15       
+//! sent to spi interface after reset/powerup to init the spi interface
+
+#define RSI_C1_INIT_RESP    0x55       
+//! response from spi interface to successful init
+
+#define RSI_C176_INIT       0b00111111            //@ and
+#define RSI_C176_RW         0b01000000            //@ or
+#define RSI_C15_RD          0b11011111            //@ and
+#define RSI_C15_WR          0b00100000            //@ or
+#define RSI_C14_SPISLV      0b11101111            //@ and 
+#define RSI_C14_AHBBUS      0b00010000            //@ or
+#define RSI_C13_AHBMEM      0b11110111            //@ and
+#define RSI_C13_AHBFRM      0b00001000            //@ or
+#define RSI_C12_02BITXFR    0b11111011            //@ and
+#define RSI_C12_16BITXFR    0b00000100            //@ or
+#define RSI_C110_4BYTESLEN  0b11111100      
+//! and number of C bytes transferred, usually 4
+#define RSI_C110_1BYTESLEN  0b00000001      
+//! or/~and number of C bytes transferred
+#define RSI_C110_2BYTESLEN  0b00000010      
+//! or/~and number of C bytes transferred
+#define RSI_C110_3BYTESLEN  0b00000011      
+//! or number of C bytes transferred
+
+/*=========================================================*/
+//! C2 Register Defines
+#define RSI_C276_08BIT      0b00111111            //@ and
+#define RSI_C276_32BIT      0b01000000            //@ or
+#define RSI_C250_SPIADDR    0b00111111            //@ and
+#define RSI_C250_DATAPACKET 0b00000010            //@ or
+#define RSI_C250_MGMTPACKET 0b00000100            //@ or
+
+//#define RSI_C3_XFERLENLSB  0x00                 //@ set value
+//#define RSI_C4_XFERLENMSB  0x00                 //@ set value
+
+/*==========================================================*/
+//! C1 Register Defines
+//! Internal Read
+#define RSI_C1INTREAD2BYTES            0x42    
+//! (((((0x00 & C176_INT) & C15_RD) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_2BYTESLEN // 01000010
+#define RSI_C1INTREAD1BYTES            0x41
+
+//! Memory ReadWrite (AHB Master Read/Write, Internal Legacy Name)
+//! Memory read/write is normally done using 16-bit transfer length with 4 C bytes transferred
+#define RSI_C1MEMWR16BIT1BYTE           0x75      
+//! (((0x00 | C176_RW | C15_WR | C14_AHBBUS) & C13_AHBMEM) & C12_16BITXFR) | C110_1BYTESLEN // 01110101
+#define RSI_C1MEMRD16BIT1BYTE           0x55      
+//! (((0x00 | C176_RW & C15_RD | C14_AHBBUS) & C13_AHBMEM) & C12_16BITXFR) | C110_1BYTESLEN // 01010101
+
+#define RSI_C1MEMWR16BIT4BYTE           0x74      
+//! (((0x00 | C176_RW | C15_WR | C14_AHBBUS) & C13_AHBMEM) & C12_16BITXFR) & C110_4BYTESLEN // 01110100
+#define RSI_C1MEMRD16BIT4BYTE           0x54      
+//! ((((0x00 | C176_RW & C15_RD) | C14_AHBBUS) & C13_AHBMEM) & C12_16BITXFR) & C110_4BYTESLEN // 01010100
+
+//! Normally, 2-bit transfer length is not used for memory read/write
+#define RSI_C1MEMWR02BIT1BYTE           0x71      
+//! (((0x00 | C176_RW | C15_WR | C14_AHBBUS) & C13_AHBMEM) & C12_02BITXFR) | C110_1BYTESLEN // 01110001
+#define RSI_C1MEMRD02BIT1BYTE           0x51      
+//! (((0x00 | C176_RW & C15_RD | C14_AHBBUS) & C13_AHBMEM) & C12_02BITXFR) | C110_1BYTESLEN // 01010001
+#define RSI_C1MEMWR02BIT4BYTE           0x70      
+//! (((0x00 | C176_RW | C15_WR | C14_AHBBUS) & C13_AHBMEM) & C12_02BITXFR) & C110_4BYTESLEN // 01110000
+#define RSI_C1MEMRD02BIT4BYTE           0x50    
+//! ((((0x00 | C176_RW & C15_RD) | C14_AHBBUS) & C13_AHBMEM) & C12_02BITXFR) & C110_4BYTESLEN // 01010000
+
+
+//! Frame ReadWrite
+//! Frame read/writes normally  use 16-bit transfer length
+#define RSI_C1FRMWR16BIT1BYTE           0x7d      
+//! ((C176_RW | C15_WR | C14_AHBBUS | C13_AHBFRM) & C12_16BITXFR) | C110_1BYTESLEN // 01111101
+#define RSI_C1FRMRD16BIT1BYTE           0x5d      
+//! ((C176_RW & C15_RD | C14_AHBBUS | C13_AHBFRM) & C12_16BITXFR) | C110_1BYTESLEN // 01011101
+
+#define RSI_C1FRMWR16BIT4BYTE           0x7c      
+//! ((C176_RW | C15_WR | C14_AHBBUS | C13_AHBFRM) & C12_16BITXFR) | C110_4BYTESLEN // 01111100
+#define RSI_C1FRMRD16BIT4BYTE           0x5c      
+//! ((C176_RW & C15_RD | C14_AHBBUS | C13_AHBFRM) & C12_16BITXFR) | C110_4BYTESLEN // 01011100
+
+//! Frame read/writes normally do not use 2-bit transfer length
+#define RSI_C1FRMWR02BIT1BYTE           0x79      
+//! ((C176_RW | C15_WR | C14_AHBBUS | C13_AHBFRM) & C12_02BITXFR) | C110_1BYTESLEN // 01111001
+#define RSI_C1FRMRD02BIT1BYTE           0x59      
+//! ((C176_RW & C15_RD | C14_AHBBUS | C13_AHBFRM) & C12_02BITXFR) | C110_1BYTESLEN // 01011001
+
+#define RSI_C1FRMWR02BIT4BYTE           0x78      
+//! ((C176_RW | C15_WR | C14_AHBBUS | C13_AHBFRM) & C12_02BITXFR) | C110_4BYTESLEN // 01111000
+#define RSI_C1FRMRD02BIT4BYTE           0x58      
+//! ((C176_RW & C15_RD | C14_AHBBUS | C13_AHBFRM) & C12_02BITXFR) | C110_4BYTESLEN // 01011000
+
+//! SPI Register ReadWrite
+#define RSI_C1SPIREGWR16BIT4BYTE        0x64      
+//! ((((C176_RW | C15_WR) & C14_SPISLV) & C13_AHBMEM) & C12_16BITXFR) | C110_4BYTESLEN // 01100100
+#define RSI_C1SPIREGRD16BIT4BYTE        0x44      
+//! ((((C176_RW & C15_RD) & C14_SPISLV) & C13_AHBMEM) & C12_16BITXFR) | C110_4BYTESLEN // 01000100
+
+#define RSI_C1SPIREGWR02BIT4BYTE        0x60    
+//! ((((C176_RW | C15_WR) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_4BYTESLEN // 01100000
+#define RSI_C1SPIREGRD02BIT4BYTE        0x40    
+//! ((((C176_RW & C15_RD) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_4BYTESLEN // 01000000
+
+#define RSI_C1SPIREGWR02BIT1BYTE        0x61      
+//! ((((C176_RW | C15_WR) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_1BYTESLEN // 01100001
+#define RSI_C1SPIREGRD02BIT1BYTE        0x41      
+//! ((((C176_RW & C15_RD) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_1BYTESLEN // 01000001
+
+
+
+//!C2 Register Defines 
+#define RSI_C2RDWR4BYTE           0x40            //@ 0x00 | C276_32BIT | C250_DATAPACKET   // 01000010
+#define RSI_C2RDWR4BYTE           0x40            //@ 0x00 | C276_32BIT | C250_MGMTPACKET   // 01000100
+
+#define RSI_C2RDWR1BYTE           0x00            //@ (0x00 & C276_08BIT) | C250_DATAPACKET // 00000010
+#define RSI_C2RDWR1BYTE           0x00            //@ (0x00 & C276_08BIT) | C250_MGMTPACKET
+                                                  //@ 00000100
+#define RSI_C2MGMT                0x04
+#define RSI_C2DATA                0x02
+#define RSI_C2WPS                 0x08
+
+#define RSI_C2SPIADDR1BYTE        0x00            //@(0x00 & C276_08BIT) | C250_SPIADDR   // 00xxxxxx
+#define RSI_C2MEMRDWRNOCARE       0x00            //@0x00 or ANYTHING                     // 00000000
+#define RSI_C2SPIADDR4BYTE        0x40            //@(0x00 | C276_32BIT) | C250_SPIADDR   // 01xxxxxx
+
+#define RSI_C1INTWRITE1BYTES      0x61
+#define RSI_C1INTWRITE2BYTES      0x62
+
+/*====================================================*/
+//! Constant Defines
+//! Sizes
+
+//! SPI Status
+#define RSI_SPI_SUCCESS           0x58
+#define RSI_SPI_BUSY              0x54
+#define RSI_SPI_FAIL              0x52
+
+#define RSI_SUCCESS               0
+#define RSI_BUSY                  -1
+#define RSI_FAIL                  -2
+#define RSI_BUFFER_FULL           -3
+#define RSI_IN_SLEEP              -4
+//! SPI Constants
+#define RSI_SPI_START_TOKEN       0x55           //@ SPI Start Token
+
+
+//!SPI Internal Register Offset
+#define RSI_SPI_INT_REG_ADDR       0x00           //@ register access method
+#define RSI_SPI_MODE_REG_ADDR      0x08           //@ register access method
+//#define RSI_SPI_INT_REG_ADDR      0x08000000    //@ memory access method
+//#define RSI_SPI_MODE_REG_ADDR     0x08000008    //@ memory access method
+
+
+//!SPI Mode Register
+#define RSI_SPI_MODE_LOW           0x00
+#define RSI_SPI_MODE_HIGH          0x01
+
+#ifndef RSI_HWTIMER 
+/*@ approximate ticks for timeout implementation */
+#define RSI_INC_TIMER_2        rsi_spiTimer2++
+#define RSI_INC_TIMER_1        rsi_spiTimer1++
+#define RSI_INC_TIMER_3        rsi_spiTimer3++
+#define RSI_INC_TIMER_4        rsi_spiTimer4++
+#define RSI_RESET_TIMER1       rsi_spiTimer1=0
+#define RSI_RESET_TIMER2       rsi_spiTimer2=0
+#define RSI_RESET_TIMER3       rsi_spiTimer3=0
+#define RSI_RESET_TIMER4       rsi_spiTimer4=0
+#else
+#define RSI_INC_TIMER_3        rsi_spiTimer3
+#define RSI_INC_TIMER_2        rsi_spiTimer2
+#define RSI_INC_TIMER_1        rsi_spiTimer1
+#define RSI_INC_TIMER_4        rsi_spiTimer4
+#define RSI_RESET_TIMER1       rsi_spiTimer1=0
+#define RSI_RESET_TIMER2       rsi_spiTimer2=0
+#define RSI_RESET_TIMER3       rsi_spiTimer3=0
+#define RSI_RESET_TIMER4       rsi_spiTimer4=0
+void rsi_timer_interrupt_handler(void);
+#endif
+
+
+int16 rsi_send_c1c2(uint8 c1, uint8 c2);
+int16 rsi_send_c3c4(uint8 c3, uint8 c4);
+int16 rsi_spi_wait_start_token(uint32 timeout,uint8 mode);
+int16 rsi_clear_interrupt(uint8 interruptClear);
+int16 rsi_mem_wr(uint32 addr, uint16 len, uint8 *dBuf);
+int16 rsi_mem_rd(uint32 addr, uint16 len, uint8 *dBuf);
+int16 rsi_reg_rd(uint8 regAddr, uint8 *dBuf);
+int16 rsi_reg_wr(uint8 regAddr, uint8 *dBuf);
+int16 rsi_pre_dsc_rd(uint8 *dbuf);
+int16 rsi_pkt_rd(uint8 *pkt, uint16 dummy_len, uint16 total_len);
+int16 rsi_set_intr_mask(uint8 interruptMask);
+int16 rsi_spi_iface_init(void);
+void rsi_ulp_wakeup_init(void);
+int16 rsi_device_interrupt_status(uint8 *int_status);
+//int16 rsi_spi_high_speed_enable();
+int16 rsi_spi_high_speed_enable(void); /* APJ : modify */
+int16 rsi_spi_recv(uint8 *ptrBuf, uint16 bufLen, uint8 mode);
+int16 rsi_spi_send(uint8 *ptrBuf, uint16 bufLen,uint8 *valBuf,uint8 mode);
+int16 rsi_spiSend_data(uint8 *ptrBuf, uint16 bufLen,uint8 *valBuf,uint8 mode);
+int spi_write_and_read(UINT8 *txbuf, UINT8 *rxbuf, UINT32 rx_tx_length);
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/Makefile b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/Makefile
new file mode 100644
index 0000000..aa298d4
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/Makefile
@@ -0,0 +1,21 @@
+######################################################################
+#                                                                    #
+#   Makefile                                                         #
+#                                                                    #
+#   2016/09/29 Create(AlphaProject)                                  #
+#                                                                    #
+######################################################################
+
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include
+EXTRA_CFLAGS += -DRSI_HAL
+
+obj-$(CONFIG_WMRP10_SPI) += rsi_intf_spi_all.o
+
+rsi_intf_spi_all-objs := rsi_spi_frame_rd_wr.o rsi_spi_functs.o rsi_spi_iface_init.o rsi_spi_mem_rd_wr.o rsi_spi_reg_rd_wr.o
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_frame_rd_wr.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_frame_rd_wr.c
new file mode 100755
index 0000000..9fbc0cb
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_frame_rd_wr.c
@@ -0,0 +1,394 @@
+/**
+ * @file     rsi_spi_framerdwr.c
+ * @version  3.6
+ * @date     2013-June-12
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SPI Control: Functions used to control SPI frame read/write functions
+ *
+ * @section Description
+ * SPI function to read/write management descriptors frames to/from the Wi-Fi module
+ *
+ * @section Improvements
+ * Function header is modified for frameDscRd() function
+ */
+/* 2016/11/17 APJ modify */
+
+
+/*
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_spi_cmd.h"
+#include "rsi_config.h"
+
+#if (RSI_INTERFACE == RSI_SPI)
+/**
+ * Global Variables
+ */
+
+/*====================================================*/
+/**
+ * @fn          int16 rsi_frame_read(uint8 *pkt_buffer)
+ * @brief This  function is used to read the response from module.
+ * @param[in]   uint8 *pkt_buffer, pointer to the buffer to which packet has to read
+ *              which is used to store the response from the module
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ * @section description 
+ * This is a common function to read response for all the command and data from Wi-Fi module.
+ */
+int16 rsi_frame_read(uint8 *pkt_buffer)
+{
+  int16     retval; 
+  uint8     local_buffer[8];
+#if (1) /* GfBÄႢɑΉ 20161117 */
+ uint16  dummy_len;
+ uint16  total_len;
+#endif
+
+
+  retval = rsi_pre_dsc_rd(&local_buffer[0]);
+  if (retval != 0x00) 
+  {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL4,"DscRd Error=%02x ", (uint16)retval);
+#endif
+    return retval;
+  }
+#if (1) /* GfBÄႢɑΉ 20161117 */
+  total_len = rsi_bytes2R_to_uint16((uint8 *)&local_buffer[0]);
+  dummy_len = rsi_bytes2R_to_uint16((uint8 *)&local_buffer[2]);
+  retval = rsi_pkt_rd(pkt_buffer, (dummy_len-4), (total_len-4));
+#else
+  retval = rsi_pkt_rd(pkt_buffer, ((*(uint16 *)&local_buffer[2])-4),((*(uint16 *)&local_buffer[0])-4));
+#endif
+  if (retval != 0x00) 
+  {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL4,"DscRdError=%02x ", (uint16)retval);
+#endif
+    return retval;
+  }
+
+  return retval;
+}
+
+/*====================================================*/
+/**
+ * @fn          int16 rsi_frame_write(rsi_uFrameDsc *uFrameDscFrame,uint8 *payloadparam,uint16 size_param)
+ * @brief       Common function for all the commands.
+ * @param[in]   uFrameDsc uFrameDscFrame, frame descriptor
+ * @param[in]   uint8 *payloadparam, pointer to the command payload parameter structure
+ * @param[in]   uint16 size_param, size of the payload for the command
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ * @section description 
+ * This is a common function used to process a command to the Wi-Fi module.
+ */
+int16 rsi_frame_write(rsi_uFrameDsc *uFrameDscFrame,uint8 *payloadparam,uint16 size_param)
+{
+  int16      retval;
+
+  //! Write out the Command Frame Descriptor
+  retval = rsi_spi_frame_dsc_wr(uFrameDscFrame);  
+
+  if (retval != 0x00) 
+  {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL4,"Descriptor write failErr=%02x", (uint16)retval);
+#endif
+    return retval;
+  }
+
+  //! Write the Command Frame Data
+  if(size_param)
+  {
+    size_param= (size_param+3)&~3;  
+    retval = rsi_spi_frame_data_wr(size_param, payloadparam, 0, NULL);
+    if (retval != 0x00)
+    {
+#ifdef RSI_DEBUG_PRINT
+      RSI_DPRINT(RSI_PL4,"FramePayload writeErr=%02x", (uint16)retval);
+#endif
+      return retval;
+    }
+  }
+
+  return retval;
+}
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_pre_dsc_rd(uint8 *dbuf)
+ * @brief       Reads a pre frame descriptor
+ * @param[in]   uint8 *dbuf, pointer to the buffer into which pre decriptor has to be read
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ * @section description 
+ * This function performs pre frame decriptor read. 
+ */
+int16 rsi_pre_dsc_rd(uint8 *dbuf)
+{
+  int16     retval;
+  uint8     c1;
+  uint8     c2;
+  uint8     c3;
+  uint8     c4;
+
+
+  c1 = RSI_C1FRMRD16BIT4BYTE;         //! 0x5c
+#ifdef RSI_BIT_32_SUPPORT
+  c2 = RSI_C2SPIADDR4BYTE;            //! 0x40
+#else
+  c2 = RSI_C2MEMRDWRNOCARE;           //! 0x00
+#endif
+  c3 = 0x04;                          //! command frame response descriptor
+  c4 = 0x00;                          //! upper bye of transfer length
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL5," CFrameDscRd=");
+#endif
+  // Send C1/C2
+  retval = rsi_send_c1c2(c1, c2);
+  if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL6," pre desc read - C1C2 Failed");
+#endif
+    return retval;                     //! exit with error if we timed out waiting for the SPI to get ready
+  }
+
+  // Send C3/C4
+  retval = rsi_send_c3c4(c3, c4);
+
+  // Wait for start token
+  retval = rsi_spi_wait_start_token(RSI_START_TOKEN_TIMEOUT,RSI_MODE_32BIT);
+  if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL6," pre desc read - Start token wait Failed");
+#endif
+    return retval;                     //! exit with error if we timed out waiting for the SPI to get ready
+  }
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL6," CFrameDscRd=");
+#endif
+  retval = rsi_spi_recv((uint8 *)dbuf, 0x4, RSI_MODE_32BIT); 
+  //! read the command frame descriptor
+  return retval;                       //! return the control frame length
+}
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_pkt_rd(uint8 *buf, uint16 dummy_len, uint16 total_len)
+ * @brief       Reads frame descriptor and payload
+ * @param[in]   uint8 *dbuf, pointer to the buffer into which  decriptor and payload has to be read
+ * @param[in]   uint16 dummy_len, number of dummy bytes which can be discarded
+ * @param[in]   uint16 total_len, number of bytes to be read
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ * @section description 
+ * This function performs frame decriptor and payload read. 
+ */
+
+int16 rsi_pkt_rd(uint8 *buf, uint16 dummy_len, uint16 total_len)
+{
+  int16     retval;
+  uint8     c1;
+  uint8     c2;
+  uint8     c3;
+  uint8     c4;
+
+
+
+  uint8     dummy_buf[8];
+
+  uint32    aligned_len=0;
+
+  aligned_len = ((total_len) + 3) & ~3;
+  c1 = RSI_C1FRMRD16BIT1BYTE;     //! 0x5d
+#ifdef RSI_BIT_32_SUPPORT
+  c2 = RSI_C2SPIADDR1BYTE;        //! 0x40
+#else
+  c2 = RSI_C2MEMRDWRNOCARE;       //! 0x00
+#endif
+  c3 = aligned_len & 0xff;            //! command frame response descriptor
+  c4 = (aligned_len & 0xff00) >> 8;   //! upper bye of transfer length
+
+  //! Send C1/C2
+  retval = rsi_send_c1c2(c1, c2);
+  if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL6," packet read - C1C2 Failed");
+#endif
+    return retval;            //! exit with error if we timed out waiting for the SPI to get ready
+  }
+
+  //! Send C3/C4
+  retval = rsi_send_c3c4(c3, c4);
+  //! Wait for start token
+  retval = rsi_spi_wait_start_token(RSI_START_TOKEN_TIMEOUT,RSI_MODE_32BIT);
+  if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL6," packet read - Start token wait Failed");
+#endif
+    return retval;               //! exit with error if we timed out waiting for the SPI to get ready
+  }
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL6," packet read=");
+#endif
+
+  if(dummy_len)
+  {
+    //! spi recv for dummy bytes
+    retval = rsi_spi_recv((uint8 *)&dummy_buf[0],dummy_len,RSI_MODE_8BIT); 
+  }
+
+  //! Actual spi read for descriptor and payload
+  if(buf)
+  {
+    retval = rsi_spi_recv(buf, (aligned_len - dummy_len),RSI_MODE_32BIT); //TODO: this support only in 8bit mode need fix it for 32bit mode
+  }
+  // memcpy((uint8 *)buf, local_buf, (total_len));
+  //! read the command frame descriptor
+  return retval;       //! return the control frame length
+}
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_spi_frame_dsc_wr(uFrameDsc *uFrameDscFrame)
+ * @brief       Writes a Frame descriptor
+ * @param[in]   uFrameDsc uFrameDscFrame, frame descriptor
+ * @param[in]   uint8 type, To indicate the type whether it is DATA or MGMT
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ * @section description 
+ * This function performs Frame Decriptor Write. 
+ */
+int16 rsi_spi_frame_dsc_wr(rsi_uFrameDsc *uFrameDscFrame)
+{
+  int16                             retval;
+  uint8                             c1;
+  uint8                             c2;
+  uint8                             c3;
+  uint8                             c4;
+  uint8                             localBuf[16];
+
+
+  c1 = RSI_C1FRMWR16BIT4BYTE;    // 0x7c
+#ifdef RSI_BIT_32_SUPPORT
+  c2 = RSI_C2RDWR4BYTE;         
+#else
+  c2 = RSI_C2RDWR1BYTE;      
+#endif  
+  c3 = RSI_FRAME_DESC_LEN;      //! frame descriptor is 16 bytes long
+  c4 = 0x00;                    //! upper bye of transfer length
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL5,"\r\nCFrmDscWr");
+#endif
+  retval = rsi_send_c1c2(c1, c2);  //! send C1/C2
+
+  if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL6," desc write - C1C2 Failed");
+#endif    
+    return retval;                   //! exit with error if we timed out waiting for the SPI to get ready
+  }
+
+  retval = rsi_send_c3c4(c3, c4);   //! send C3/C4
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL5," CFrameDscWr=");
+#endif
+  retval = rsi_spi_send(&uFrameDscFrame->uFrmDscBuf[0], RSI_FRAME_DESC_LEN,localBuf,RSI_MODE_32BIT);   
+  //! the Management Type byte is in byte 1 (byte 0 is the length)
+  return retval;                
+  //! here we can only return ok
+}
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_spi_frame_data_wr(uint16 bufLen, uint8 *dBuf,uint16 tbufLen,uint8 *tBuf)
+ * @brief       Writes a Control data frame decriptor.
+ * @param[in]   uint16 buflen length of the data buffer to write
+ * @param[in]   uint8 *dBuf, pointer to the buffer of data to write
+ * @param[in]   uint16 tbuflen length of the data fragment to write
+ * @param[in]   uint8 *tBuf, pointer to the buffer of data fragment to write
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS  
+ * @section description 
+ * This function performs Frame Data Write. 
+ */
+int16 rsi_spi_frame_data_wr(uint16 bufLen, uint8 *dBuf,uint16 tbufLen,uint8 *tBuf)
+{
+  int16                     retval;
+  uint8                     c1;
+  uint8                     c2;
+  uint8                     c3;
+  uint8                     c4;
+#ifdef LINUX
+  uint8                     localBuf[1600];
+#else
+  uint8                     localBuf[8];
+#endif
+  uint16                    tempbufLen;
+  tempbufLen = bufLen + tbufLen;
+
+  c1 = RSI_C1FRMWR16BIT4BYTE;         
+#ifdef RSI_BIT_32_SUPPORT
+  c2 = RSI_C2RDWR4BYTE;                
+#else
+  c2 = RSI_C2RDWR1BYTE;         
+#endif  
+  c3 = (uint8)(tempbufLen & 0x00ff);       //! lower byte of transfer length
+  c4 = (uint8)((tempbufLen >> 8) & 0x00FF);//! upper byte of transfer length
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL5,"\r\nFrmDataWr");
+#endif
+  retval = rsi_send_c1c2(c1, c2);        //! send C1/C2
+  if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL6,"\r\n data write - C1C2 Failed");
+#endif 
+    return retval; }                       //!exit with error if we timed out waiting for the SPI to get ready
+
+  retval = rsi_send_c3c4(c3, c4);        //! send C3/C4
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL5," FrameData=");
+#endif
+#if 1
+  retval = rsi_spi_send(dBuf, bufLen,localBuf,RSI_MODE_32BIT);
+  if(tbufLen)
+  {
+    retval = rsi_spi_send(tBuf, tbufLen,localBuf,RSI_MODE_32BIT);   
+  }
+#endif
+
+  return retval;       
+
+}
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_functs.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_functs.c
new file mode 100755
index 0000000..1b63eaf
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_functs.c
@@ -0,0 +1,315 @@
+/**
+ * @file     rsi_spi_functs.c
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Common SPI Functions
+ *
+ * @section Description
+ * SPI bus Layer function used to transfer spi protocol level commands to module.
+ * For more detail refer PRM for spi commands
+ *
+ */
+/* 2016/10/14 APJ modify */
+
+/*
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_spi_cmd.h"
+#include "rsi_config.h"
+
+#if (RSI_INTERFACE == RSI_SPI)
+
+/**
+ * Global Variables
+ */
+
+
+/*==================================================*/
+/**
+ * @fn          int16 rsi_send_c1c2(uint8 c1, uint8 c2)
+ * @brief       Sends the C1 & C2 commands bytes, should check response for C1 command.Incase of busy should retry.
+ * @param[in]   uint8 c1 SPI c1 command.
+ * @param[in]   uint8 c2 SPI c2 command
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ */
+int16 rsi_send_c1c2(uint8 c1, uint8 c2)
+{
+ int16                   retval;
+ uint32                  timeout;            
+ uint8                   txCmd[2];             
+ uint8                   localBuf[8];
+ timeout = 1 * RSI_TICKS_PER_SECOND;     
+ //! reset the timeout timer to 0
+ RSI_RESET_TIMER1;      
+ while (1) {
+   txCmd[0] = c1;    
+   txCmd[1] = c2;               
+   if (RSI_INC_TIMER_1 > timeout) 
+   {           
+     retval = RSI_BUSY;              
+#ifdef RSI_DEBUG_PRINT
+     RSI_DPRINT(RSI_PL8,"\r\n C1C2 command Timeout");
+#endif
+     break;
+   }
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL7," C1C2=");
+#endif
+  //! Send C1 & C2 
+  retval = rsi_spi_send(&txCmd[0], 2,localBuf,RSI_MODE_8BIT);
+  if((localBuf[1] == RSI_SPI_SUCCESS) ||(localBuf[1] == 0x00))  {            
+   //! success, so return now 
+   retval = RSI_SUCCESS;
+   break;
+  }
+  else if (localBuf[1] == RSI_SPI_FAIL) {
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL8,"\r\n C1C2 command Failed");
+#endif
+   retval = RSI_FAIL;
+   break;
+  }
+  else if (localBuf[1] == RSI_SPI_BUSY) {
+   //! Busy, retry once again 
+   retval = RSI_BUSY;
+  }
+ }
+
+ return retval;
+}
+
+
+
+/*==================================================*/
+/**
+ * @fn          int16 rsi_send_c3c4(uint8 c3, uint8 c4)
+ * @brief       Sends the C3/C4 bytes
+ * @param[in]   uint8 c3 SPI c3 command bytes to be sent
+ * @param[in]   uint8 c4 SPI c4 command bytes to be sent
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ * @prerequisite rsi_send_c1c2 should successful before this function.
+ */
+int16 rsi_send_c3c4(uint8 c3, uint8 c4)
+{
+ int16                   retval;
+ uint8                   txCmd[2];  //@ command buffer
+ uint8                   localBuf[8];
+
+ txCmd[0] = c3;
+ txCmd[1] = c4;
+#ifdef RSI_DEBUG_PRINT
+ RSI_DPRINT(RSI_PL15," C3C4=");
+#endif
+ //!command should send only 8 bit mode 
+ retval = rsi_spi_send(txCmd, (uint16)sizeof(txCmd),localBuf,
+   RSI_MODE_8BIT);   
+ return retval;
+}
+
+
+
+/*==================================================*/
+/**
+ * @fn            int16 rsi_spi_wait_start_token(uint32 timeout,uint8 mode)
+ * @brief         Loops reading the SPI until a start token, 0x55, is received
+ * @param[in]     uint32  timeout   Timeout for start token.
+ * @param[in]     uint8   mode      To indicate 8bit/32bit mode.
+ * @param[out]    none
+ * @return        errCode
+ *                 0 = success
+ *                -1 = busy/timeout failure
+ *                -2 = spi failure
+ * @section prerequisite 
+ * should issue read commands before this function.
+ */
+int16 rsi_spi_wait_start_token(uint32 timeout,uint8 mode)
+{
+ int16                   retval;
+#ifdef RSI_BIT_32_SUPPORT
+ uint32                  txChar;       //! char to send/receive data in
+#else
+ uint8                   txChar;
+#endif
+ //! Look for start token
+ //! Send a character, could be any character, and check the response for a start token
+ //! If we don't find it within the timeout time, error out
+ //! Timeout value needs to be passed since context is important
+#ifdef RSI_DEBUG_PRINT
+ RSI_DPRINT(RSI_PL8,"\r\nWaitStartToken=");
+#endif
+ RSI_RESET_TIMER1;       //! reset the timeout timer to 0;
+ while(1) 
+ {
+  if (RSI_INC_TIMER_1 > timeout) 
+  {  
+   retval = RSI_BUSY;             
+   //! timeout 
+   break;                   
+  }
+
+  txChar = 0x00;
+#ifdef RSI_BIT_32_SUPPORT
+  if( mode == RSI_MODE_8BIT)
+#endif
+   retval = rsi_spi_recv((uint8 *)&txChar, 1, mode);
+#ifdef RSI_BIT_32_SUPPORT 
+  else
+   retval = rsi_spi_recv((uint8 *)&txChar, 4, mode);
+#endif    
+  if (txChar == RSI_SPI_START_TOKEN) {      
+   //! found the start token 
+   retval = RSI_SUCCESS;            
+   break;
+  }
+ }
+ return retval;
+}
+
+
+/*==================================================*/
+/**
+ * @fn          int16 rsi_set_intr_mask(uint8 interruptMask)
+ * @brief       Sets the INTERRUPT MASK REGISTER of the Wi-Fi module
+ * @param[in]   uint8 interruptMask, the value to set the mask register to
+ * @param[out]  none
+ * @return      errorcode 
+ *               0 = Success
+ *              -1 = busy/timeout failure
+ *              -2 = spi failure 
+ 
+ */
+int16 rsi_set_intr_mask(uint8 interruptMask)
+{
+ int16                     retval;
+ int16                     i;
+#ifdef RSI_BIT_32_SUPPORT
+    uint8                   dBuf[4]= {0,0,0,0};
+#else
+    uint8                   dBuf[2]= {0,0};
+#endif
+
+
+ //! Create the data to write to the interrupt mask register
+ for (i = 0; i < sizeof(dBuf); i++) { dBuf[i] = 0; }  // zero out dBuf
+ dBuf[0] = interruptMask;
+
+ //!memory write the mask value
+ retval = rsi_mem_wr(RSI_INT_MASK_REG_ADDR, sizeof(dBuf), dBuf); // 0x74, 0x00, 0x22000008, 0x04, interruptMask
+
+ return retval;
+}
+
+
+
+
+/*==================================================*/
+/**
+ * @fn          int16 rsi_clear_interrupt(uint8 interruptClear)
+ * @brief       Clears the interrupt register
+ * @param[in]   uint8 interrutClear, the value to set the interrupt clear register to
+ * @param[out]  none
+ * @return      errorcode 
+ *              -1 = busy/timeout failure
+ *              -2 = spi failure 
+ *               0 = Success
+ */
+int16 rsi_clear_interrupt(uint8 interruptClear)
+{
+ int16                     retval;
+#ifdef RSI_BIT_32_SUPPORT
+    uint8                   dBuf[4]= {0,0,0,0};
+#else
+    uint8                   dBuf[2]= {0,0};
+#endif
+ //! read in the register so we can set bit 5 and write back out
+ //!retval = rsi_memRd(RSI_INT_CLR_REG_ADDR, sizeof(dBuf), dBuf); 
+ //! 0x74, 0x00, 0x22000010
+ //! set bit 5, interrupt clear
+ dBuf[0] |= interruptClear;
+ //! memory write the mask value
+ retval = rsi_mem_wr(RSI_INT_CLR_REG_ADDR, sizeof(dBuf), dBuf);     
+ //! 0x74, 0x00, 0x22000010
+
+ return retval;
+}
+
+
+
+
+/*==================================================*/
+/**
+ * @fn          int16 rsi_device_interrupt_status(uint8 *int_status)
+ * @brief       Returns the value of the Interrupt register
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errorcode
+ *               0 = Success
+ *              -1 = busy/timeout failure
+ *              -2 = spi failure  
+ */
+int16 rsi_device_interrupt_status(uint8 *int_status)
+{
+ int16                   retval;
+ uint32                  timeout; 
+
+ timeout = 1 * RSI_TICKS_PER_SECOND;
+
+ RSI_RESET_TIMER2;
+ while(1) 
+ {
+  if (RSI_INC_TIMER_2 > timeout) {   
+   retval = RSI_BUSY;       //! timeout
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL3,"\r\nError Readng Interrupt Status Register = Timeout");
+#endif
+   break;                   //!retry some more
+  }
+
+  //! read the interrupt register
+  retval = rsi_reg_rd(RSI_SPI_INT_REG_ADDR, int_status);    
+
+  if(retval != RSI_BUSY) 
+    {
+   break;
+  }
+ }
+
+ return retval;
+}
+/*==================================================================*/
+/**
+ * @fn         int16 rsi_spi_high_speed_enable(void)
+ * @param[in]  None
+ * @param[out] None
+ * @return     0, 0=success
+ * @description
+ * This API is program Redpine module SPI in high speed mode
+ */
+
+int16 rsi_spi_high_speed_enable(void) /* APJ : modify */
+{
+    uint8 data=1;
+    int16 return_val; /* APJ : modify */
+    return_val = rsi_reg_wr(0x08,&data);
+    return return_val;
+}
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_iface_init.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_iface_init.c
new file mode 100755
index 0000000..630b116
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_iface_init.c
@@ -0,0 +1,116 @@
+/**
+ * @file     rsi_spi_iface_init.c
+ * @version  2.0.0.0
+ * @date     2011-May-30
+ *
+ * Copyright(C) Redpine Signals 2011
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SPI INIT: Functions which initiaize the SPI hardware interface in the module
+ *
+ * @section Description
+ * This file contains the SPI Initialization function.
+ * This function enables the SPI interface on the Wi-Fi chip.
+ * This function is only run once during startup, after power-on, or reset
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_spi_cmd.h"
+
+
+/**
+ * Global Variables
+ */
+uint32                 rsi_spiTimer1;
+uint32                 rsi_spiTimer2;
+uint32                 rsi_spiTimer3;
+
+
+/*=============================================*/
+/**
+ * @fn                  int16 rsi_spi_iface_init(void)
+ * @brief               Start the SPI interface
+ * @param[in]           none
+ * @param[out]          none
+ * @return              errCode
+ *                      -1 = SPI busy / Timeout
+ *                      -2 = SPI Failure
+ *                      0  = SUCCESS
+ * @section description         
+ * This API initializes the Wi-Fi modules Slave SPI interface.
+ */
+int16 rsi_spi_iface_init(void)
+{ 
+ uint8                   txCmd[2];            
+ int16                   retval = 0;            
+ uint16                  txLen;             
+ uint16                  timeout;            
+ uint8                   localBuf[8];
+
+ txLen   = sizeof(txCmd);    //! number of bytes to send
+ timeout   = 10;             //! 10ms timeout on command, nothing magic, just a reasonable number
+ RSI_RESET_TIMER1;           //! init the timer counter
+ while(1) {
+  if (RSI_INC_TIMER_1 > timeout) {   
+   retval = RSI_BUSY;
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL15,"\r\nspi_iface_init Failure due to timeout");
+#endif
+   break;
+  }
+
+  txCmd[0] = RSI_C1_INIT_CMD;   
+  txCmd[1] = 0x00;        
+
+
+  retval = rsi_spi_send(txCmd, txLen,localBuf,RSI_MODE_8BIT);
+  if (localBuf[1] == RSI_SPI_SUCCESS) {         
+   retval = RSI_SUCCESS;              
+   break;
+  }
+  else {
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL15,"SpiInitErr=%02x ", (uint16)txCmd[1]);
+#endif      
+   retval = RSI_BUSY;
+  }
+  //rsi_delay_ms(20);   //! Not necessary
+ }
+
+ return retval;
+}
+
+/*=============================================*/
+/**
+ * @fn                  int16 rsi_ulp_wakeup_init(void)
+ * @brief               Start the SPI interface
+ * @param[in]           none
+ * @param[out]          none
+ * @return              none
+ * @section description         
+ * This API initializes the Wi-Fi modules Slave SPI interface on ulp wakeup.
+ */
+void rsi_ulp_wakeup_init(void)
+{ 
+  uint8                   txCmd[2];            
+  uint16                  txLen;             
+  uint8                   localBuf[8];
+
+  txLen   = sizeof(txCmd);    //! number of bytes to send
+  txCmd[0] = RSI_C1_INIT_CMD;   
+  txCmd[1] = 0x00;        
+
+  rsi_spi_send(txCmd, txLen,localBuf,RSI_MODE_8BIT);
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_mem_rd_wr.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_mem_rd_wr.c
new file mode 100755
index 0000000..7342e80
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_mem_rd_wr.c
@@ -0,0 +1,184 @@
+/**
+ * @file       rsi_spi_mem_rd_wr.c 
+ * @version    2.0.0.0
+ * @date       2011-May-30
+ *
+ * Copyright(C) Redpine Signals 2011
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SPI MEMRDWR: SPI Memory Read/Write functions, r/w memory on the module via the SPI interface
+ *
+ * @section Description
+ * This file contains the SPI Memory Read/Write functions to the module
+ *
+ *
+ */
+
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_spi_cmd.h"
+
+#if (RSI_INTERFACE == RSI_SPI)
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================*/
+/** 
+ * @fn          int16 rsi_mem_wr(uint32 addr, uint16 len, uint8 *dBuf)
+ * @brief       Performs a memory write to the Wi-Fi module
+ * @param[in]   uint32 addr, address to write to
+ * @param[in]   uint16, len, number of bytes to write
+ * @param[in]   uint8 *dBuf, pointer to the buffer of data to write
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ *
+ * ABH Master Write (Internal Legacy Name)
+ */
+int16 rsi_mem_wr(uint32 addr, uint16 len, uint8 *dBuf)
+{
+   uint8         txCmd[4];
+   int16         retval;
+   uint8         c1;
+   uint8         c2;
+   uint8         c3;
+   uint8         c4;
+   uint8     localBuf[8];
+
+   c1     = RSI_C1MEMWR16BIT4BYTE;
+#ifdef RSI_BIT_32_SUPPORT
+   c2     = RSI_C2SPIADDR4BYTE;             //!0x40
+#else
+   c2     = RSI_C2SPIADDR1BYTE;             //!0x00
+#endif
+   c3     = (int8)(len & 0x00ff);           //! C3, LSB of length
+   c4     = (int8)((len >> 8) & 0x00ff);    //! C4, MSB of length
+
+   rsi_uint32_to_4bytes(txCmd, addr);
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL5,"\r\nMemWr");
+#endif
+   //! Send C1/C2
+   retval = rsi_send_c1c2(c1, c2);
+
+   //! Check for SPI Busy/Error
+   if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+      RSI_DPRINT(RSI_PL6,"\r\nMemWr C1C2 Fail, SPI Busy ");
+#endif
+      return retval;
+   }
+
+   //! Send C3/C4
+   retval = rsi_send_c3c4(c3, c4);
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL5,"\r\nMemWrAddr=");
+#endif
+   //! Send the 4 address bytes
+   retval = rsi_spi_send(txCmd, sizeof(txCmd),localBuf,RSI_MODE_8BIT);
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL5,"\r\n MemWrData=");
+#endif
+   //! Send the Data  
+#ifdef RSI_BIT_32_SUPPORT
+   retval = rsi_spi_send(dBuf, len,localBuf,RSI_MODE_32BIT);
+#else
+   retval = rsi_spi_send(dBuf, len,localBuf,RSI_MODE_8BIT);
+#endif  
+   return retval;
+}
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_mem_rd(uint32 addr, uint16 len, uint8 *dBuf)
+ * @brief       Performs a memory read from the Wi-Fi module
+ * @param[in]   uint32, address to read from
+ * @param[in]   uint16, len, number of bytes to read
+ * @param[in]   uint8 *dBuf, pointer to the buffer to receive the data into
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ *
+ * ABH Master Read (Internal Legacy Name)
+ */
+int16 rsi_mem_rd(uint32 addr, uint16 len, uint8 *dBuf)
+{
+   uint8                            txCmd[4];
+   int16                            retval;
+   uint8                            c1;
+   uint8                            c2;
+   uint8                            c3;
+   uint8                            c4;
+   uint8                            localBuf[8];
+
+   c1            = RSI_C1MEMRD16BIT4BYTE;
+#ifdef RSI_BIT_32_SUPPORT
+   c2            = RSI_C2SPIADDR4BYTE;
+#else
+   c2            = RSI_C2MEMRDWRNOCARE;
+#endif  
+   c3            = len & 0x00ff;                      //! C3, LSB of length
+   c4            = (len >> 8) & 0x00ff;               //! C4, MSB of length
+   //! put the address bytes into the buffer to send
+   txCmd[0]      = addr & 0x000000ff;                 //! A0, Byte 0 of address (LSB)
+   txCmd[1]      = (addr >> 8) & 0x000000ff;          //! A1, Byte 1 of address
+   txCmd[2]      = (addr >> 16) & 0x000000ff;         //! A2, Byte 2 of address
+   txCmd[3]      = (addr >> 24) & 0x000000ff;         //! A3, Byte 3 of address (MSB)
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL15,"\r\nMemoryRd");
+#endif
+   //! Send C1/C2
+   retval = rsi_send_c1c2(c1, c2);
+
+   //! Check for SPI busy
+   if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+      RSI_DPRINT(RSI_PL16,"MemRd, C1C2 Fail, SPI Busy ");
+#endif
+      return retval;
+   }
+
+   //! Send C3/C4
+   retval = rsi_send_c3c4(c3, c4);
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL15," MemRdAddr=");
+#endif
+   //! Send the 4 address bytes
+   retval = rsi_spi_send(txCmd, sizeof(txCmd),localBuf,RSI_MODE_8BIT);
+
+   //! Wait for the start token
+   retval = rsi_spi_wait_start_token(RSI_START_TOKEN_TIMEOUT,RSI_MODE_8BIT);
+   
+   //if (retval != 0) 
+   //{    
+    //! exit with error if we timed out waiting for start token
+   //return retval;
+   //}
+   
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL15," MRdDataRd=");
+#endif
+   //! Read in the memory data
+   retval = rsi_spi_recv(dBuf, len, RSI_MODE_8BIT);
+
+   return retval;
+}
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_reg_rd_wr.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_reg_rd_wr.c
new file mode 100755
index 0000000..37b2095
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/src/rsi_spi_reg_rd_wr.c
@@ -0,0 +1,149 @@
+/**
+ * @file                rsi_spi_reg_rd_wr.c   
+ * @version		2.0.0.0
+ * @date 		2011-May-30
+ *
+ * Copyright(C) Redpine Signals 2011
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SPI REGRDWR: SPI Register Read/Write functions
+ *
+ * @section Description
+ * This file contains the SPI based Register R/W functionss
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_spi_cmd.h"
+#include "rsi_config.h"
+
+#if (RSI_INTERFACE == RSI_SPI)
+
+/**
+ * Global Variables
+ */
+
+
+/**===========================================================================
+ * @fn          int16 rsi_reg_rd_wr(uint8 regAddr, uint8 *dBuf)
+ * @brief       Reads a register in the Wi-Fi module
+ * @param[in]   uint8 regAddr, address of spi register to read, addr is 6-bits, upper 2 bits must be cleared
+ * @param[in]   uint8 *dBuf, pointer to the buffer of data to write, assumed to be at least 2 bytes long
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              0  = SUCCESS
+ * 
+ * @section description 
+ * Reads a spi register with an address specified.
+ *
+ */
+int16 rsi_reg_rd(uint8 regAddr, uint8 *dBuf)
+{
+	int16                   retval;
+	uint8                   c1;
+	uint8                   c2;
+
+	//! set the C1/C2 values
+	c1 = RSI_C1INTREAD1BYTES;
+	c2 = 0x00;																		// and/or the addrss into C2, addr is 6-bits long, upper two bits must be cleared for byte mode
+	c2 |= regAddr;
+#ifdef RSI_DEBUG_PRINT
+	//! send C2/C2
+	RSI_DPRINT(RSI_PL5,"\r\nRegRd");
+#endif
+	retval = rsi_send_c1c2(c1, c2);
+
+
+	//! Check for SPI Busy/Error
+	if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+		RSI_DPRINT(RSI_PL6,"\r\nRegRd C1C2 Fail, SPI Busy ");
+#endif
+		return retval;	//! exit with error if we timed out waiting for the SPI to get ready
+	}
+
+	//! Wait for start token
+	retval = rsi_spi_wait_start_token(RSI_START_TOKEN_TIMEOUT,RSI_MODE_8BIT);
+
+	if (retval != 0) {    
+        //! exit with error if we timed out waiting for start token
+		return retval;
+	}
+
+	//! Start token found now read the two bytes of data
+#ifdef RSI_DEBUG_PRINT
+	RSI_DPRINT(RSI_PL5," RegData=");
+#endif
+	retval = rsi_spi_recv(dBuf, 1,RSI_MODE_8BIT);
+	return retval;	
+    //! we return the error status here
+}
+
+/**===========================================================================
+ * @fn          int16 rsi_reg_wr(uint8 regAddr, uint8 *dBuf)
+ * @brief       writes to a register in the Wi-Fi module
+ * @param[in]   uint8 regAddr, address of spi register to be written
+ * @param[in]   uint8 *dBuf, pointer to the buffer of data to write, assumed to be at least 2 bytes long
+ * @param[out]  none
+ * @return      errCode
+ * @return 	-1 = SPI busy / Timeout
+ * @return      -2 = SPI Failure
+ * @return       0  = SUCCESS
+ * 
+ * @section description 
+ * Writes to a spi register with an address specified.
+ *
+ */
+
+int16 rsi_reg_wr(uint8 regAddr, uint8 *dBuf)
+{
+	int16                   retval;
+	uint8                   c1;
+	uint8                   c2;
+    uint8                   localBuf[8];
+
+	//! set the C1/C2 values
+	c1 = RSI_C1INTWRITE2BYTES;
+	c2 = 0x00;																		
+    //! and/or the addrss into C2, addr is 6-bits long, upper two bits must be cleared for byte mode
+	c2 |= regAddr;
+#ifdef RSI_DEBUG_PRINT
+	//! send C2/C2
+	RSI_DPRINT(RSI_PL5,"\r\nRegWr");
+#endif
+	retval = rsi_send_c1c2(c1, c2);
+
+
+	//! Check for SPI Busy/Error
+	if (retval != 0) {
+#ifdef RSI_DEBUG_PRINT
+		RSI_DPRINT(RSI_PL6,"\r\nRegWr C1C2 Fail, SPI Busy ");
+#endif
+		return retval;		
+		//! exit with error if we timed out waiting for the SPI to get ready
+	}
+        
+  retval = rsi_spi_send(dBuf, 2, localBuf, RSI_MODE_8BIT);
+
+	if (retval != 0) 
+    {   
+		
+    //! exit with error if we timed out waiting for start token
+    return retval;
+	}
+	return retval;
+}
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_api.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_api.h
new file mode 100755
index 0000000..f666844
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_api.h
@@ -0,0 +1,1001 @@
+/**
+ * @file     rsi_api.h
+ * @version  3.6
+ * @date     2013-May-16
+ *
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER: API specific Defines
+ *
+ * @section Description
+ * This file contains the function prototypes of the APIs defined in library, and defines used in API's.
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ */
+
+
+#ifndef _SPIAPI_H_
+#define _SPIAPI_H_
+
+/**
+ * Include Files
+ */
+#include "rsi_global.h"
+#include "rsi_app_util.h"
+/**
+ * Global Defines
+ */
+
+//! Host interfaces
+#define RSI_SPI    0
+#define RSI_UART   1
+#define RSI_USB    2
+
+//! Upgrade Image types
+#define RSI_UPGRADE_IMAGE_I_FW           '2'
+#define RSI_UPGRADE_BL                   '#'
+
+
+//! Firmware Upgradation form host params
+#define FW_UP_PL  0
+#define FW_UP_REQ 1
+#define RSI_RPS_HEADER 32
+#define RSI_FW_UP_SUCCESS 0x0003
+
+//!Load Image types
+#define RSI_LOAD_IMAGE_I_FW                  '1'
+#define RSI_LOAD_IMAGE_I_ACTIVE_LOW_FW       0x71 
+
+//!Select Default image
+#define RSI_SELECT_IMAGE_I_BY_DEFAULT        '5'
+
+// bypass bootup
+#define RSI_ENABLE_BOOT_BYPASS            '7'
+#define RSI_DISABLE_BOOT_BYPASS           '8'
+
+//!load default
+#define RSI_LOAD_DEFAULT                  '9'
+
+//! Check CRC
+#define RSI_CHECK_CRC                     'K'
+
+
+#define HOST_INTF_REG_OUT                 0x4105003C
+#define HOST_INTF_REG_IN                  0x41050034
+#define BOARD_READY                       0xABCD  
+#define REG_READ                          0xD1
+#define REG_WRITE                         0xD2
+#define PONG_WRITE                        0xD4
+#define PING_WRITE                        0xD5
+#define HOST_INTERACT_REG_VALID           (0xAB << 8)
+#define PONG_AVAIL                        'O'
+#define PING_AVAIL                        'I'
+#define PONG_VALID                        'O'   
+#define PING_VALID                        'I'   
+#define LOADING_INITIATED                 '1'
+#define SEND_RPS_FILE                     '2'
+#define FWUP_SUCCESSFUL                   'S'
+#define EOF_REACHED                       'E'
+#define BOOTUP_OPTIONS_LAST_CONFIG_NOT_SAVED 0xF1
+#define BOOTUP_OPTIONS_CHECKSUM_FAIL      0xF2
+#define INVALID_OPTION                    0xF3
+#define CHECKSUM_SUCCESS                  0xAA
+#define CHECKSUM_FAILURE                  0xCC
+#define CHECKSUM_INVALID_ADDRESS          0x4C
+
+#define RSI_SUCCESS                        0
+#define RSI_BUSY                           -1
+#define RSI_FAIL                           -2
+#define RSI_BUFFER_FULL                    -3
+#define RSI_IN_SLEEP                       -4
+
+
+#define RSI_RESET_LOOP_COUNTER(X)              X = 0;
+#define RSI_WHILE_LOOP(X, Y)                   while((X++) < (uint32)Y)
+#define RSI_LOOP_COUNT_UPGRADE_IMAGE           0xFFFF
+#define RSI_LOOP_COUNT_WAKEUP_REQ              0xFFFFFFFF
+#define RSI_LOOP_COUNT_WAKEUP_WAIT             0xFFFFFFFF   
+#define RSI_LOOP_COUNT_UPGRADE_REQ             0xFFFF
+#define RSI_LOOP_COUNT_UPGRADE_CHUNK           0xFFFF
+#define RSI_LOOP_COUNT_UPGRADE_STATUS          0xFFFF
+#define RSI_LOOP_COUNT_SELECT_OPTION           0xFFFF
+#define RSI_CHECK_LOOP_COUNTER(X, Y)           { if(X >= Y)\
+                                                  return -1;}
+
+//!SPI Internal Register Offset
+#define RSI_SPI_INT_REG_ADDR               0x00      //@ register access method
+#define RSI_SPI_MODE_REG_ADDR              0x08      //@ register access method
+
+//!Power Mode Constants
+#define RSI_POWER_MODE_0                   0x0000
+#define RSI_POWER_MODE_1                   0x0001
+#define RSI_POWER_MODE_2                   0x0002
+#define RSI_POWER_MODE_3                   0x0003
+#define RSI_POWER_MODE_8                   0x0008
+#define RSI_POWER_MODE_9                   0x0009
+#define RSI_LP_MODE                        0x0
+#define RSI_ULP_MODE_WITH_RAM_RET          0x1
+#define RSI_ULP_MODE_NO_RAM_RET            0x2
+#define RSI_MAX_PSP                        0x0
+#define RSI_FAST_PSP                       0x1
+#define RSI_UAPSD                          0x2
+//!Tx Power level
+#define RSI_POWER_LEVEL_LOW                0x0000
+#define RSI_POWER_LEVEL_MEDIUM             0x0001
+#define RSI_POWER_LEVEL_HIGH               0x0002
+
+//!Join feature bitmap
+#define RSI_JOIN_FEAT_STA_BG_ONLY_MODE_ENABLE 	BIT(0)
+#define RSI_JOIN_FEAT_LISTEN_INTERVAL_VALID 	BIT(1)
+
+//!Interrupt Defines
+#define RSI_INT_MASK_REG_ADDR              0x41050000      //@ Interrupt mask register
+#define RSI_INT_CLR_REG_ADDR               0x22000010      //@ Interrupt clear register
+//!bit5=1 to clear the interrupt, must use read-modify-write to preserver the other bits
+
+
+/*======================================================*/
+//!Management Request Frame Codes (Type)
+#define RSI_REQ_OPERMODE                   0x10
+#define RSI_REQ_BAND                       0x11
+#define RSI_REQ_INIT                       0x12
+#define RSI_REQ_SCAN                       0x13
+#define RSI_REQ_JOIN                       0x14
+#define RSI_REQ_PWRMODE                    0x15
+#define RSI_REQ_SLEEP_TIMER                0x16
+#define RSI_REQ_SET_MAC_ADDR               0x17
+#define RSI_REQ_QUERY_NETWORK_PARAMS       0x18
+#define RSI_REQ_DISCONNECT                 0x19
+#define RSI_REQ_RSSI_QUERY                 0x3A
+#define RSI_REQ_ANTENNA_SEL                0x1B
+#define RSI_REQ_SET_REG_CODE               0x1D 
+#define RSI_REQ_CFG_SAVE                   0x20
+#define RSI_REQ_CFG_ENABLE                 0x21
+#define RSI_REQ_CFG_GET                    0x22
+#define RSI_REQ_USER_STORE_CFG             0x23
+#define RSI_REQ_APCONFIG                   0x24
+#define RSI_REQ_SET_WEP_KEY                0x25
+#define RSI_REQ_DEBUG_PRINTS               0x26
+#define RSI_REQ_PING_PACKET                0x29
+#define RSI_REQ_MULTICAST_FILTER           0x40
+#define RSI_REQ_HOST_WEBPAGE               0x64
+#define RSI_REQ_BG_SCAN                    0x6a
+#define RSI_REQ_REJOIN_PARAMS              0x6F
+
+//!IPV6 IPCONFIG REQ
+#define RSI_REQ_IPCONF6                    0x90
+
+//!SNMP COMMANDS
+#define RSI_REQ_SNMP_GET                   0x80
+#define RSI_REQ_SNMP_GETNEXT               0x81
+#define RSI_REQ_SNMP_SET                   0x82
+
+#define RSI_REQ_SNMP_ENABLE                0x85
+#define RSI_REQ_SNMP_TRAP                  0x86
+#define RSI_REQ_SNMP_GET_STATS             0x88
+
+#define RSI_REQ_CREATE_JSON                0x9C
+#define RSI_REQ_CLEAR_FILES                0x7F
+#define RSI_REQ_ERASE_FILE                 0x9A
+#define RSI_REQ_ERASE_JSON                 0x9B
+#define RSI_REQ_HOST_PSK                   0xA5
+#define RSI_REQ_MULTICAST                  0xB1
+#define RSI_REQ_SET_REG_AP                 0xBD
+#define RSI_REQ_IPPARAM_CONFIG             0x41
+#define RSI_REQ_SOCKET_CREATE              0x42
+#define RSI_REQ_SOCKET_CLOSE               0x43
+#define RSI_REQ_DNS_QRY                    0x44
+#define RSI_REQ_TCP_CONN_STATUS_QUERY      0x46
+#define RSI_REQ_CONNECTION_STATUS          0x48
+#define RSI_REQ_FWVERSION_QUERY            0x49
+#define RSI_REQ_GET_MAC_ADDR               0x4A
+#define RSI_REQ_CFG_P2P                    0x4B
+#define RSI_REQ_SET_EAP_CFG                0x4C
+#define RSI_REQ_SET_CERT                   0x4D
+#define RSI_REQ_QUERY_GO_PARAMS            0x4E
+#define RSI_REQ_GET_WEBPAGE                0x50
+#define RSI_REQ_HTTP_GET                   0x51
+#define RSI_REQ_HTTP_POST                  0x52
+#define RSI_REQ_DNS_SERVER                 0x55
+#define RSI_REQ_READ                       0x6B
+#define RSI_REQ_HTTP_POST_DATA             0xEB
+
+//!Roaming parameter request
+#define RSI_REQ_ROAM_PARAMS                0x7B
+
+//!HT CAPS request
+#define RSI_REQ_AP_HT_CAPS                 0x6D
+
+
+//!WMM PS request
+#define RSI_REQ_WMM_PS                     0x97
+
+//! Request types
+#define RSI_REQ_FW_UP_REQ                    0x99
+
+//!WPS MEHOD request
+#define RSI_REQ_WPS_METHOD                 0x72
+
+//!PER MODE request
+#define RSI_REQ_PER_PARAMS                 0x7c
+
+//! PER stats request
+#define RSI_REQ_PER_STATS                  0xA2
+
+//!Wireless firmware upgradation 
+#define RSI_FWUP_RSP                       0x59
+
+//! RF Current Mode configuration
+#define RSI_REQ_RF_CURRENT_CONFIG          0xAD
+
+//! socket configuration
+#define RSI_REQ_SOCKET_CONFIG              0xA7
+
+//! FTP client
+#define RSI_REQ_FTP                        0xE2
+
+//! SNTP client
+#define RSI_REQ_SNTP                        0xE4
+
+//! MDNS
+#define RSI_REQ_MDNS                       0xDB
+
+//! SMTP
+#define RSI_REQ_SMTP                       0xE6
+
+//!HTTP_PUT_CLIENT 
+#define RSI_REQ_HTTP_CLIENT_PUT            0x53
+
+
+//! POP3
+#define RSI_REQ_POP3                       0xE7
+
+//! DNS Update
+#define RSI_REQ_DNS_UPDATE                 0xED
+
+//! DHCP USER CLASS
+#define RSI_REQ_DHCP_USER_CLASS                 0xEC
+
+//! OTAF
+#define RSI_REQ_OTA_FW_UP                  0xEF
+
+//!Timeout
+#define RSI_REQ_TIMEOUT                    0xEA 
+
+//! Management Response Frame Codes
+#define RSI_RSP_DATA_RECEIVE               0x00
+#define RSI_RSP_CARD_READY                 0x89
+#define RSI_RSP_OPERMODE                   0x10
+#define RSI_RSP_BAND                       0x11
+#define RSI_RSP_CONFIG		           	     0xC6
+#define RSI_RSP_INIT                       0x12
+#define RSI_RSP_SCAN                       0x13
+#define RSI_RSP_JOIN                       0x14
+#define RSI_RSP_PWRMODE                    0x15
+#define RSI_RSP_SLEEP_TIMER                0x16
+#define RSI_RSP_MACADDRESS_SET             0x17
+#define RSI_RSP_NETWORK_PARAMS             0x18
+#define RSI_RSP_DISCONNECT                 0x19
+#define RSI_RSP_RSSI_QUERY                 0x3A
+#define RSI_RSP_ANTENNA_SEL                0x1B
+#define RSI_RSP_SOFT_RESET                 0x1C
+#define RSI_RSP_SET_REG_CODE               0x1D 
+#define RSI_RSP_FEATSEL                    0x1E
+#define RSI_RSP_SNR                        0x1F
+#define RSI_RSP_CFG_SAVE                   0x20
+#define RSI_RSP_CFG_ENABLE                 0x21
+#define RSI_RSP_CFG_GET                    0x22
+#define RSI_RSP_USER_STORE_CFG             0x23
+#define RSI_RSP_APCONFIG                   0x24
+#define RSI_RSP_SET_WEP_KEY                0x25
+#define RSI_RSP_DEBUG_PRINTS               0x26
+#define RSI_RSP_GPIO_CONF                  0x28
+#define RSI_RSP_PING_PACKET                0x29
+#define RSI_RSP_P2P_CONNREQ                0x30
+#define RSI_RSP_MULTICAST_FILTER           0x40
+#define RSI_RSP_BG_SCAN                    0x6a
+#define RSI_RSP_REJOIN_PARAMS              0x6F
+#define RSI_RSP_MODULE_STATE               0x70
+#define RSI_RSP_ULP_NO_RAM_RET             0xCD
+
+
+//!SNMP RESPONSES
+#define RSI_RSP_SNMP_GET_RSP               0x83
+#define RSI_RSP_SNMP_GETNEXT_RSP           0x84
+#define RSI_RSP_SNMP_ENABLE                0x85
+#define RSI_RSP_SNMP_TRAP                  0x86
+#define RSI_RSP_SNMP_GET_STATS             0x88
+
+//!IPV6 IPCONFIG RSP
+#define RSI_RSP_IPCONF6                    0xa1
+
+//! PER stats RSP
+#define RSI_RSP_PER_STATS                  0xA2
+
+//! UART FLow control
+#define RSI_RSP_UART_FLOW_CONTROL          0xA4
+
+//!IP change ASYNC MSG 
+#define RSI_RSP_IPCHANGE_NOTIFY            0xaa
+#define RSI_RSP_HOST_PSK                   0xA5
+#define RSI_RSP_SET_REG_AP                 0xBD
+#define RSI_FWUP_OK                        0x5a
+
+//! Control Response Frame Codes
+#define RSI_RSP_NULL                       0x00
+#define RSI_RSP_IPPARAM_CONFIG             0x41
+#define RSI_RSP_SOCKET_CREATE              0x42
+#define RSI_RSP_CLOSE                      0x43
+#define RSI_RSP_DNS_QRY                    0x44
+#define RSI_RSP_TCP_CONN_STATUS_QUERY      0x46
+#define RSI_RSP_CONNECTION_STATUS          0x48
+#define RSI_RSP_FWVERSION_QUERY            0x49
+#define RSI_RSP_MAC_QUERY                  0x4A
+#define RSI_RSP_CFG_P2P                    0x4B
+#define RSI_RSP_SET_EAP_CFG                0x4C
+#define RSI_RSP_SET_CERT                   0x4D
+#define RSI_RSP_QUERY_GO_PARAMS            0x4E
+#define RSI_RSP_GET_WEBFIELDS              0x4F  
+#define RSI_RSP_GET_WEBPAGE                0x50
+#define RSI_RSP_HTTP_GET                   0x51
+#define RSI_RSP_HTTP_POST                  0x52
+#define RSI_RSP_SENT_BYTES                 0xB2
+#define RSI_RSP_HTTP_ABORT                 0xB3
+#define RSI_RSP_HTTP_CREDENTIALS           0xB4
+#define RSI_RSP_HTTP_POST_DATA             0xEB
+
+
+//!Roaming parameter response
+#define RSI_RSP_ROAM_PARAMS                0x7B
+
+
+#define RSI_RESP_WFD_DEV                   0x54
+#define RSI_RSP_CONN_ESTABLISH             0x61
+#define RSI_RSP_REMOTE_TERMINATE           0x62
+#define RSI_RSP_DNS_SERVER                 0x55
+#define RSI_RSP_HOST_WEBPAGE               0x56
+ 
+//! HT CAPS response
+#define RSI_RSP_AP_HT_CAPS                 0x6D
+
+//! WMM PS response 
+#define RSI_RSP_WMM_PS                     0x97
+
+//! Response types
+#define RSI_RSP_FW_UP_REQ                    0x99
+
+//!WPS MEHOD response
+#define RSI_RSP_WPS_METHOD                 0x72
+
+//! PER MODE response
+#define RSI_RSP_PER_PARAMS                 0x7c
+#define RSI_RSP_CREATE_JSON                0x9c
+#define RSI_RSP_CLEAR_FILES                0x7f
+#define RSI_RSP_ERASE_FILE                 0x9A
+#define RSI_RSP_ERASE_JSON                 0x9B
+#define RSI_RSP_JSON_UPDATE                0x9D
+#define RSI_RSP_MULTICAST                  0xB1
+
+#define RSI_RSP_SLP                        0xDE
+#define RSI_RSP_WKP                        0xDD
+/* Ack to received data */
+#define RSI_RSP_DATA_PACKET_ACK            0xAC
+
+#define RSI_RSP_CLIENT_CONNECTED           0xC2
+#define RSI_RSP_CLIENT_DISCONNECTED        0xC3
+
+//! RF Current Mode configuration
+#define RSI_RSP_RF_CURRENT_CONFIG          0xAD
+
+//! socket configuration
+#define RSI_RSP_SOCKET_CONFIG              0xA7
+
+//! FTP client
+#define RSI_RSP_FTP                        0xE2
+
+//! SNTP client
+#define RSI_RSP_SNTP                        0xE4
+#define RSI_RSP_SNTP_SERVER                 0xE5
+
+//! MDNS
+#define RSI_RSP_MDNS                       0xDB
+
+//! SMTP
+#define RSI_RSP_SMTP                       0xE6
+
+//! HTTP_PUT_CLIENT 
+#define RSI_RSP_HTTP_CLIENT_PUT            0x53
+
+//! POP3
+#define RSI_RSP_POP3                       0xE7
+#define RSI_RSP_POP3_REMOTE_TERMINATE      0xE8
+
+//! HTTP POST DATA
+#define RSI_HTTP_END_OF_DATA               BIT(0)
+#define RSI_RSP_HTTP_POST_START            BIT(1)
+#define RSI_RSP_HTTP_POST_DATA_SEND        BIT(2)
+#define RSI_RSP_HTTP_POST_DATA_RECV        BIT(3)
+
+
+//! DNS Update
+#define RSI_RSP_DNS_UPDATE                 0xED
+
+//! DHCP USER CLASS
+#define RSI_RSP_DHCP_USER_CLASS                 0xEC
+
+//! OTAF
+#define RSI_RSP_OTA_FW_UP                  0xEF
+
+//!Timeout
+#define RSI_RSP_TIMEOUT                    0xEA 
+
+/*==============================================*/
+//! Band Defines
+#define RSI_BAND_2P4GHZ                    0x00  
+#define RSI_BAND_5GHZ                      0x01  
+#define RSI_DUAL_BAND                      0x02  
+
+//! TCPIP Defines
+#define RSI_STATIC_IP_MODE                 0x00
+#define RSI_DHCP_IP_MODE                   0x01
+#define RSI_FEAT_DHCP_HOST_NAME            0x02
+#define RSI_FEAT_DHCP_FQDN                 0x04
+#define RSI_DNS_MODE_ENABLE                0x01
+#define RSI_DNS_MODE_DISABLE               0x00
+#define RSI_AUTO_IP_CFG                    0x02
+#define RSI_DHCP_UNICAST_OFFER_SUPPORT     0x08
+
+//!CERTIFICATE defines
+#define RSI_EAP_TLS_CERTIFICATE            0x01    //@ WLAN EAP-TLS Client Certificate/Private Key/CA Root
+#define RSI_EAP_FAST_PAC_CERTIFICATE       0x02    //@ WLAN EAP-FAST PAC file
+#define RSI_SSL_CLIENT_CERTIFICATE         0x03    //@ SSL client certificate
+#define RSI_SSL_CLIENT_PRIVATE_KEY         0x04    //@ SSL client private key
+#define RSI_SSL_CA_CERTIFICATE             0x05    //@ SSL CA certificate
+#define RSI_SSL_SERVER_CERTIFICATE         0x06    //@ SSL server certificate
+#define RSI_SSL_SERVER_PRIVATE_KEY         0x07    //@ SSL server private key
+
+//!SOCKET Defines
+#define RSI_SOCKET_TCP_CLIENT              0x0000 
+//#define RSI_SOCKET_UDP_CLIENT              0x0001 
+#define RSI_SOCKET_TCP_SERVER              0x0002 
+#define RSI_SOCKET_LUDP                    0x0004 
+
+#define RSI_AP_VAP_ID                      1
+#define RSI_CLIENT_VAP_ID                  0
+
+//!SEND Defines
+#define RSI_UDP_FRAME_HEADER_LEN           44
+//!UDP Frame header is 42 bytes, padding bytes are extra
+#define RSI_TCP_FRAME_HEADER_LEN           56                                                
+//!TCP Frame header is 54 bytes, padding bytes are extra
+#define RSI_UDP_V6_FRAME_HEADER_LEN        64 
+//!Frame header is 42 bytes, padding bytes are extra
+#define RSI_TCP_V6_FRAME_HEADER_LEN        76
+//!TCP Frame header is 54 bytes, padding bytes are extra
+#define RSI_UDP_SEND_OFFSET                32                                  
+//!Offset of sent UDP payload data
+#define RSI_TCP_SEND_OFFSET                44                                
+//!Offset of sent TCP payload data
+#define RSI_UDP_RECV_OFFSET                26                                
+//!Offset of received UDP payload data
+#define RSI_TCP_RECV_OFFSET                38                                
+//!Offset of received TCP payload data
+
+//!Security types for AP Configuration
+//! SECURITY Type Defines
+#define RSI_SECURITY_NONE                   0                   
+//! Security type NONE and OPEN are alises for each other
+#define RSI_SECURITY_OPEN                   0
+#define RSI_SECURITY_WPA1                   1
+#define RSI_SECURITY_WPA2                   2
+
+//! Encryption type for AP Configuration 
+#define RSI_ENCRYPTION_NONE                 0                   
+#define RSI_ENCRYPTION_TKIP                 1
+#define RSI_ENCRYPTION_AES                  2
+
+//! NETWORK Type
+#define RSI_IBSS_OPEN_MODE                  0
+#define RSI_INFRASTRUCTURE_MODE             1
+#define RSI_IBSS_SEC_MODE                   2
+#define RSI_IBSS_JOINER                     0
+#define RSI_IBSS_CREATOR                    1
+
+// DATA Rates
+#define RSI_DATA_RATE_AUTO                  0
+#define RSI_DATA_RATE_1                     1
+#define RSI_DATA_RATE_2                     2
+#define RSI_DATA_RATE_5P5                   3
+#define RSI_DATA_RATE_11                    4
+#define RSI_DATA_RATE_6                     5
+#define RSI_DATA_RATE_9                     6
+#define RSI_DATA_RATE_12                    7
+#define RSI_DATA_RATE_54                    12
+#define RSI_DATA_RATE_20                    20
+#define RSI_DATA_RATE_18                    18
+
+
+#define RSI_MACADDRLEN                      6
+
+#define RSI_MODE_8BIT                       0
+#define RSI_MODE_32BIT                      1
+
+//!PER mode data rates
+#define RSI_RATE_1                         0x0
+#define RSI_RATE_2                         0x2
+#define RSI_RATE_5_5                       0x4
+#define RSI_RATE_11                        0x6
+#define RSI_RATE_6                         0x8b
+#define RSI_RATE_9                         0x8f
+#define RSI_RATE_12                        0x8a
+#define RSI_RATE_18                        0x8e
+#define RSI_RATE_24                        0x89
+#define RSI_RATE_36                        0x8d
+#define RSI_RATE_48                        0x88
+#define RSI_RATE_54                        0x8c
+#define RSI_RATE_MCS0                      0x100
+#define RSI_RATE_MCS1                      0x101
+#define RSI_RATE_MCS2                      0x102
+#define RSI_RATE_MCS3                      0x103
+#define RSI_RATE_MCS4                      0x104
+#define RSI_RATE_MCS5                      0x105
+#define RSI_RATE_MCS6                      0x106
+#define RSI_RATE_MCS7                      0x107
+#define RSI_RATE_MCS7_SG                   0x307
+
+#define RSI_PER_BURST_MODE               0
+#define RSI_PER_CONTT_MODE               1
+#define RSI_PER_CONT_WAVE_MODE_DC        2
+
+//! WPS
+#define RSI_WPS_PUSH_METHOD              0
+#define RSI_WPS_PIN_METHOD               1
+
+//!Multicast
+#define RSI_MULTICAST_LEAVE              0
+#define RSI_MULTICAST_JOIN               1
+
+//!Multicast filter cmds
+#define RSI_MULTICAST_MAC_ADD_BIT        0
+#define RSI_MULTICAST_MAC_CLEAR_BIT      1
+#define RSI_MULTICAST_MAC_CLEAR_ALL      2
+#define RSI_MULTICAST_MAC_SET_ALL        3
+
+
+//!SNMP
+#define SNMP_ANS1_INTEGER                0x2
+#define SNMP_ANS1_OCTET_STRING           0x4
+#define SNMP_ANS1_OBJECT_ID              0x6
+#define SNMP_ANS1_IP_ADDRESS             0x40
+#define SNMP_ANS1_COUNTER                0x41 
+#define SNMP_ANS1_GAUGE                  0x42
+#define SNMP_ANS1_TIME_TICS              0x43
+#define SNMP_ANS1_IPV6_ADDRESS           0x44
+#define SNMP_ANS1_COUNTER64              0x46
+#define SNMP_ANS1_NO_SUCH_OBJECT         0x80
+#define SNMP_ANS1_NO_SUCH_INSTANCE       0x81
+#define SNMP_ANS1_END_OF_MIB_VIEW        0x82
+
+#define SNMP_VERSION_1                   1
+#define SNMP_VERSION_2                   2
+#define SNMP_VERSION_3                   3
+
+#define IP_VERSION_4                     4                  
+#define IP_VERSION_6                     6
+
+#define SNMP_TRAP_COLD_START             0
+#define SNMP_TRAP_WARM_START             1
+#define SNMP_TRAP_LINK_DOWN              2
+#define SNMP_TRAP_LINK_UP                3
+#define SNMP_TRAP_AUTH_FAILURE           4
+#define SNMP_TRAP_EGP_NEIGHBOURLOSS      5 
+#define SNMP_TRAP_USER_SPECIFIC          6
+ 
+#define BIT(a) ((long int)1 << a)
+//! feature bit map
+#define FEAT_SECURITY_OPEN               BIT(0)
+#define FEAT_SECURITY_PSK                BIT(1)
+#define FEAT_AGGREGATION                 BIT(2)
+#define FEAT_LP_GPIO_BASED_HANDSHAKE     BIT(3)
+#define FEAT_ULP_GPIO_BASED_HANDSHAKE    BIT(4)
+#define FEAT_DEV_TO_HOST_ULP_GPIO_1      BIT(5)
+#define FEAT_RF_SUPPY_VOL_3_3_VOLT       BIT(6)
+
+//! tcp/ip feature bit map
+#define TCP_IP_FEAT_BYPASS               BIT(0)
+#define TCP_IP_FEAT_HTTP_SERVER          BIT(1)
+#define TCP_IP_FEAT_DHCPV4_CLIENT        BIT(2)
+#define TCP_IP_FEAT_DHCPV6_CLIENT        BIT(3)
+#define TCP_IP_FEAT_DHCPV4_SERVER        BIT(4)
+#define TCP_IP_FEAT_DHCPV6_SERVER        BIT(5)
+#define TCP_IP_FEAT_JSON_OBJECTS         BIT(6)
+#define TCP_IP_FEAT_HTTP_CLIENT          BIT(7)
+#define TCP_IP_FEAT_DNS_CLIENT           BIT(8)
+#define TCP_IP_FEAT_SNMP_AGENT           BIT(9)
+#define TCP_IP_FEAT_SSL                  BIT(10)
+#define TCP_IP_FEAT_ICMP                 BIT(11)
+#define TCP_IP_FEAT_HTTPS_SERVER         BIT(12)
+#define TCP_IP_FEAT_FTP_CLIENT           BIT(15)
+#define TCP_IP_FEAT_SNTP_CLIENT          BIT(16)
+
+#define TCP_IP_FEAT_MDNSD		             BIT(19)
+#define TCP_IP_FEAT_SMTP_CLIENT		       BIT(20)
+#define TCP_IP_FEAT_POP3_CLIENT		       BIT(29)
+
+#define TCP_IP_FEAT_SINGLE_SSL_SOCKET		 BIT(25)
+#define TCP_IP_FEAT_LOAD_PUBLIC_PRIVATE_CERTS   BIT(26)
+
+#define TCP_IP_FEAT_EXTENSION_VALID     	     BIT(31)
+
+#define EXT_TCP_FEAT_DHCP_OPT77      BIT(1)
+
+#define EXT_TCP_IP_HTTP_SERVER_BYPASS      BIT(2)
+
+//! Enable this bit will give, both IPV4 and IPV6 addresses in GOPARAMS command response
+#define EXT_TCP_IP_GOPARAMS         BIT(3)
+
+//! Enable this bit, to parse parameters in URL
+#define EXT_TCP_IP_HTTP_URL         BIT(4)
+
+//! Select No of sockets
+
+#define TCP_IP_TOTAL_SOCKETS_1     (1<<21)
+#define TCP_IP_TOTAL_SOCKETS_2     (2<<21) 
+#define TCP_IP_TOTAL_SOCKETS_3     (3<<21)
+#define TCP_IP_TOTAL_SOCKETS_4     (4<<21)
+#define TCP_IP_TOTAL_SOCKETS_5     (5<<21)
+#define TCP_IP_TOTAL_SOCKETS_6     (6<<21)
+#define TCP_IP_TOTAL_SOCKETS_7     (7<<21)
+#define TCP_IP_TOTAL_SOCKETS_8     (8<<21)
+#define TCP_IP_TOTAL_SOCKETS_9     (9<<21)
+#define TCP_IP_TOTAL_SOCKETS_10    (10<<21)
+
+//!Custom feature select bitmap
+#define FEAT_SEL_GATEWAY_SKIP                    BIT(2)	
+#define FEAT_SEL_DISABLE_INTERNAL_WEB_SERVER     BIT(3)
+#define FEAT_SEL_UART_HW_FLOW_CTRL               BIT(4)
+#define FEAT_SEL_HIDDEN_AP                       BIT(5)
+#define FEAT_SEL_INCLUDE_DNS                     BIT(6)
+#define FEAT_SEL_DHCP_UNICAST                    BIT(7)
+#define FEAT_SEL_DFS_CHANNEL_SUPPORT             BIT(8)
+#define FEAT_SEL_LED_SUPPORT                     BIT(9)
+
+#define FEAT_SEL_DISABLE_SUPP_BLACKLIST          BIT(12)   	
+#define FEAT_SEL_ROAM_MODE_WITH_DEAUTH           BIT(13)   	
+ 
+#define FEAT_WAIT_ON_HOST                        BIT(20)
+#define FEAT_EVK_HTTP_SERVER_PKT_SIZE            BIT(21)	
+#define FEAT_HTTP_SERVER_AUTHENTICATION          BIT(23)	
+#define FEAT_HTTP_SERVER_CREDENTIALS             BIT(25) //! Http server credentials details in get configuration command
+#define FEAT_LTCP_ZERO_LISTEN_REQUEST_QUEUE      BIT(26)
+#define FEAT_CUSTOM_FEAT_EXTENTION_VALID         BIT(31)
+
+//! Extended custom feature select bitmap
+#define EXT_FEAT_RSA_KEY_WITH_4096_SUPPORT       BIT(1)
+#define EXT_FEAT_TELEC_SUPPORT                   BIT(2)
+#define EXT_FEAT_SSL_CERT_WITH_4096_KEY_SUPPORT  BIT(3)
+#define EXT_FEAT_AP_BROADCAST_PKT_SND_B4_DTIM    BIT(4)
+#define EXT_FEAT_FCC_LOW_PWR    		             BIT(5)
+#define EXT_FEAT_PUF_PRIVATE_KEY                 BIT(7)
+#define EXT_FEAT_SPECTRAL_MASK_NOKIA             BIT(8)
+#define EXT_HTTP_SKIP_DEFAULT_LEADING_CHARACTER  BIT(9)
+
+
+//! socket feature
+#define RSI_SSL_SUPPORT                  BIT(0)
+#define RSI_WEBS_SUPPORT                 BIT(1)
+#define RSI_SSL_WEBS_SUPPORT             (BIT(0) | BIT(1))
+#define RSI_SSL_TLS_V_1                  BIT(2)
+#define RSI_SSL_TLS_V_1_2                BIT(3)
+#define RSI_SSL_TLS_V_1_1                BIT(4)
+#define RSI_TCP_HIGH_PERFORMANCE         BIT(7)
+
+//! Socket bitmap
+#define RSI_SYNCHRONOUS_DATA_READ       BIT(0)
+#define RSI_LTCP_ACCEPT                 BIT(1)
+#define RSI_ASYNCHRONOUS_DATA_READ      BIT(3)
+#define RSI_TCP_RX_WINDOW               BIT(4)
+
+//! HTTP Feature
+#define RSI_HTTP_NULL_DELIMITER          BIT(1)
+#define RSI_FEAT_HTTP_POST_DATA          BIT(5)
+#define RSI_FEAT_HTTP_V_1_1              BIT(6)
+
+
+//!PMK
+#define RSI_PSK_FROM_HOST               1
+#define RSI_PMK_FROM_HOST               2
+#define RSI_GENERATE_PMK                3
+
+
+//!ANTENNA
+#define RSI_TYPE_RF_OUT_2               0         //! Internal Antenna
+#define RSI_TYPE_RF_OUT_1               1         //! uFL connector
+
+#define RSI_ANTENNA_PATH_INTERNAL       1
+#define RSI_ANTENNA_PATH_EXTERNAL       2
+
+#define RSI_ANTENNA_TYPE_REDPINE        1
+#define RSI_ANTENNA_TYPE_FRACTUS        2
+#define RSI_ANTENNA_TYPE_MOLEX          3
+
+
+//! SMTP feature
+#define RSI_SMTP_MAIL_PRIORITY_LOW       BIT(0)
+#define RSI_SMTP_MAIL_PRIORITY_NORMAL    BIT(1)        
+#define RSI_SMTP_MAIL_PRIORITY_HIGH      BIT(2)        
+#define RSI_FEAT_SMTP_EXTENDED_HEADER    BIT(3)
+#define RSI_SMTP_AUTH_PLAIN              1
+#define RSI_SMTP_AUTH_LOGIN              3 
+#define RSI_SMTP_SSL_AUTH_PLAIN          5
+#define RSI_SMTP_SSL_AUTH_LOGIN          7 
+
+//! SSL
+#define SSL_ALL_CIPHERS 0
+#define BIT_TLS_RSA_WITH_AES_256_CBC_SHA256    (1<<0)
+#define BIT_TLS_RSA_WITH_AES_128_CBC_SHA256    (1<<1)
+#define BIT_TLS_RSA_WITH_AES_256_CBC_SHA       (1<<2)
+#define BIT_TLS_RSA_WITH_AES_128_CBC_SHA       (1<<3)
+#define BIT_TLS_RSA_WITH_AES_128_CCM_8         (1<<4)
+#define BIT_TLS_RSA_WITH_AES_256_CCM_8         (1<<5)
+
+
+//! FTP client commands
+#define FTP_COMMAND_CREATE              1
+#define FTP_COMMAND_CONNECT             2
+#define FTP_COMMAND_DIRECTORY_MAKE      3
+#define FTP_COMMAND_DIRECTORY_DELETE    4
+#define FTP_COMMAND_DIRECTORY_CWD       5
+#define FTP_COMMAND_DIRECTORY_LIST      6
+#define FTP_COMMAND_FILE_READ           7
+#define FTP_COMMAND_FILE_WRITE          8
+#define FTP_COMMAND_FILE_WRITE_CONTENT  9
+#define FTP_COMMAND_FILE_DELETE         10
+#define FTP_COMMAND_FILE_RENAME         11
+#define FTP_COMMAND_DISCONNECT          12
+#define FTP_COMMAND_DESTROY             13
+#define FTP_COMMAND_PASSIVE_MODE        14
+#define FTP_COMMAND_ACTIVE_MODE         15
+
+//! SNTP client commands
+#define SNTP_COMMAND_CREATE             1
+#define SNTP_GET_TIME                   2
+#define SNTP_GET_TIME_DATE              3
+#define SNTP_GET_SERVER_ADDRESS         4
+#define SNTP_DELETE                     5
+#define SNTP_GET_SERVER_INFO            6
+
+#define SNTP_BROADCAST_MODE             1
+#define SNTP_UNICAST_MODE               2
+
+//! MDNS commands 
+#define MDNS_INIT                       1
+#define MDNS_REGISTER_SERVICE           3
+#define MDNS_DEINT                      6
+
+/**
+ * Enumerations
+ */
+enum RSI_INTTYPE { 
+    RSI_IRQ_NONE             = 0x00,
+    RSI_IRQ_BUFFERFULL       = 0x01,
+    RSI_IRQ_BUFFEREMPTY      = 0x02,
+    RSI_IRQ_MGMTPACKET       = 0x04,
+    RSI_IRQ_DATAPACKET       = 0x08,
+    RSI_IRQ_10               = 0x10,
+    RSI_IRQ_PWRMODE          = 0x20,
+    RSI_IRQ_40               = 0x40,
+    RSI_IRQ_80               = 0x80,
+    RSI_IRQ_ANY              = 0xff
+};
+
+//! PS defines 
+#define PS_CONFIRM              0x2
+
+
+/*=====================================================================================*/
+/**
+ *         This is platform dependent operation.Needs to be implemented 
+ *         specific to the platform.This timer is mentioned in the following functions
+ *             Application/TCPDemo/Source/main.c
+ *             WLAN/SPI/Source/spi_functs.c
+ *             WLAN/SPI/Source/spi_iface_init.c
+ *     
+ */
+
+extern uint32            rsi_spiTimer1;
+extern uint32            rsi_spiTimer2;
+extern uint32            rsi_spiTimer3;
+
+extern volatile rsi_powerstate rsi_pwstate;
+/*
+ * Function Prototype Definitions
+ */
+int16 rsi_oper_mode(rsi_uOperMode *uOperMode);
+int16 rsi_band(uint8 band);
+int16 rsi_config(uint16 config_type, uint16 config_value);
+int16 rsi_init(void);
+int16 rsi_scan(rsi_uScan *uScanFrame);
+int16 rsi_join(rsi_uJoin *uJoinFrame);
+int16 rsi_ip_param_set(rsi_uIpparam *uIpparamFrame);
+int16 rsi_ipv6_param_set(rsi_uIPconf6  *uIpconf6Frame);
+int16 rsi_query_rssi(void);
+int16 rsi_query_snr(void);
+int16 rsi_set_mac_addr(uint8 *macAddress);
+int16 rsi_query_mac_address(void);
+int16 rsi_power_mode(uint8 powermode, uint8 ulp_mode_enable, uint8 listen_interval_dtim, uint8 rsi_psp_type, uint16 monitor_interval);
+int16 rsi_socket(rsi_uSocket *uSocketFrame);
+int16 rsi_socket_close(uint16 socketDescriptor, uint16 port_number);
+int16 rsi_query_conn_status(void);
+int16 rsi_query_fw_version(void);
+int16 rsi_query_net_parms(void);
+int16 rsi_select_antenna(uint8 antenna_val,uint8 gain_2g,uint8 gain_5g, uint8 antenna_path, uint8 antenna_type);
+int16 rsi_query_go_parms(void);
+int16 rsi_p2p_config(rsi_uConfigP2p *uConfigP2p);
+int16 rsi_set_eap(rsi_uSetEap *uSetEap);
+int16 rsi_set_certificate(uint8 certificate_type,uint8 *buffer,uint32 certificate_length, struct SET_CHUNK_S *SetChunks);
+int16 rsi_load_web_page(rsi_uWebServer *uWebServer, uint8* webpage_file, uint8* webpage_load_done);
+int16 rsi_send_url_rsp(HostWebpageSnd_t *uUrlRsp, uint8 *webpage_morechunks, uint8 *webpage_file , uint32 file_size, uint8 first_chunk);
+int16 rsi_web_fields(rsi_uWebFields *uWebFields);
+int16 rsi_sleep_timer(rsi_uSleepTimer *uSleepTimer);
+int16 rsi_module_soft_reset(void);
+int16 rsi_set_ap_config(rsi_apconfig *apconf);
+int16 rsi_set_wepkey(rsi_wepkey *wepkey);
+int16 rsi_dns_server(rsi_uDnsServer *uDnsServer);
+int16 rsi_http_get(rsi_uHttpReq *uHttpGetReqFrame);
+int16 rsi_http_post(rsi_uHttpReq *uHttpGetPostFrame);
+int16 rsi_dns_query(rsi_uDnsQry  *uDnsQryFrame);
+int16 rsi_dns_update(rsi_uDnsUpdate  *uDnsUpdateFrame);
+int16 rsi_ltcp_conn_status(uint16 socketDescriptor);
+int16 rsi_ping_request(rsi_ping_request_t *pingReq);
+int16 rsi_disconnect(rsi_disassoc_t *disassoc_Frame);
+int16 rsi_sys_init(void);
+uint8* rsi_fill_parameters(uint32 type, uint8 *buffer);
+int16 rsi_fwup_frm_host(rsi_fw_up_t *ptr_fw_up, uint8 *rps_file,uint32 rps_offset,uint16 length,uint16 type);
+/*Multicast api's*/
+uint8 lmac_crc8_c(uint8 crc8_din, uint8 crc8_state, uint8 end);
+uint8 multicast_mac_hash(uint8 *mac);
+int16 rsi_multicast_mac_filter(uint8 cmd, uint8 MAC[6]);
+int16 rsi_multicast(rsi_uMulticast *uMulticastFrame);
+uint8* rsi_itoa(uint32 val, uint8 *str);
+
+
+
+int16 rsi_rejoin_params(rsi_rejoin_params_t *uRejoinFrame);
+int16 rsi_psk(rsi_uPsk *uPskReqFrame);
+int16 rsi_bg_scan(rsi_ubgScan *ubgScanFrame);
+
+/* For power save */
+int16 rsi_pwrsave_continue(void);
+int16 rsi_pwrsave_hold(void);
+void config_gpio_output(uint8 value);
+void config_gpio_input(void);
+//uint8 get_gpio_value();
+uint8 get_gpio_value(void);
+//uint8 get_spi_intr_gpio_value();
+uint8 get_spi_intr_gpio_value(void);
+int16 rsi_http_abort(void);
+int16 rsi_cfg_enable(uint8 cfg_enable_val);
+int16 rsi_cfg_get(void);
+int16 rsi_cfg_save(void);
+
+int16 rsi_debug_prints(rsi_uDebug *uDebugFrame);
+
+int16 rsi_module_power_cycle(void);
+void  rsi_build_frame_descriptor(rsi_uFrameDsc *uFrameDscFrame, uint8 *cmd);
+int16 rsi_spi_frame_dsc_wr(rsi_uFrameDsc *uFrmDscFrame);
+int16 rsi_spi_frame_data_wr(uint16 bufLen, uint8 *dBuf,uint16 tbufLen,uint8 *tBuf);
+int16 rsi_frame_write(rsi_uFrameDsc *uFrameDscFrame,uint8 *payloadparam,uint16 size_param);
+int16 rsi_execute_cmd(uint8 *descparam,uint8 *payloadparam,uint16 size_param);
+int16 rsi_send_data(uint16 socketDescriptor, uint8 *payload, uint32 payloadLen,uint8 protocol,uint32 *bytes_sent);
+int16 rsi_send_raw_data(uint8 *payload, uint32 payloadLen,uint32 *bytes_sent);
+int16 rsi_send_ludp_data(uint16 socketDescriptor, uint8 *payload,uint32 payloadLen,uint8 protocol, uint8 *destIp, uint16 destPort,uint32 *bytes_sent);
+int16 rsi_frame_read(uint8 *pkt_buffer);
+void  rsi_wakeup_from_host(void);
+int32 rsi_req_wakeup(void);
+int32 rsi_wait4wakeup(void);
+void rsi_allow_sleep(void);
+int16 rsi_wireless_fwupgrade(void);
+
+
+
+/* For SNMP */
+int16 rsi_snmp_enable(uint8 snmpEnable);
+int16 rsi_snmp_get_rsp(rsi_uSnmp *uSnmpGetRsp);
+int16 rsi_snmp_get_next_rsp(rsi_uSnmp *uSnmpGetNextRsp);
+int16 rsi_snmp_trap(rsi_uSnmptrap  *uSnmpTrapFrame, int snmp_len);
+int16 rsi_snmp_get_stats(void);
+
+
+/* For IPV6 ipconfig*/
+int16 rsi_ipconf6(rsi_uIPconf6  *uIpconf6Frame);
+
+/* Bootup configuration APIs*/
+int16 rsi_waitfor_boardready(void);
+int16 rsi_upgrade_fw(uint8 image_type, uint8 *fw_image, uint32 fw_image_size);
+int16 rsi_boot_insn(uint8 type, uint16* data);
+int16 rsi_select_option(uint8 cmd);
+
+
+/* Roaming parameter set API*/
+int16 rsi_roam_params(rsi_uRoamParams *uRoamParamsFrame);
+
+/* HT CAPS parameter wet API*/
+int16 rsi_ht_caps(rsi_uHtCaps *uHtCapsFrame);
+
+/* WMM PS parameter wet API*/
+int16 rsi_wmm_ps(rsi_uWmmPs *uWmmPsFrame);
+
+/* WPS PIN METHOD parameter API*/
+int16 rsi_wps_method(rsi_uWpsMethod *uWpsMethodFrame);
+
+/* PER MODE parameter API*/
+int16 rsi_per_mode(rsi_uPerMode *uPerMode);
+/* PER stats API */
+int16 rsi_per_stats(rsi_uPerStats *uPerStats);
+
+/* JSON & Webpage Related Functionality */
+int16 rsi_json_create(rsi_jsonCreateObject_t* json, uint8* buffer, uint8 *json_load_done);
+int16 rsi_json_erase_file(rsi_tfs_erase_file_t* file);
+int16 rsi_webpage_clear_files(rsi_tfs_clear_files_t* clear);
+int16 rsi_webpage_erase_file(rsi_tfs_erase_file_t* file);
+
+/*set region */
+int16 rsi_set_region(rsi_usetregion *uSetRegionReqFrame);
+/*Set region AP*/
+int16 rsi_set_region_ap(rsi_usetregion_ap_t *uSetRegionApReqFrame);
+int16 rsi_send_websocket_data(uint16 socketDescriptor, uint8 *payload, uint32 payloadLen,uint8 protocol, uint8 opcode, uint32 *total_bytes_sent);
+int16 rsi_user_store_config(rsi_user_store_config_t  *ptr_userstrcfg);
+void rsi_buildHttpExtendedHeader(uint8 *http_header, uint8 mode);
+int16 rsi_bytes_sent_count(uint16 socketDescriptor);
+/* RF Current Configuration */
+int16 rsi_rf_current_config(rsi_rf_current_config_t *rf_config);
+
+int16 rsi_uart_flow_control(uint8 enable);
+/* Socket configuration */
+int16 rsi_socket_config(rsi_socket_config_t *socket_config);
+/* Trigger Auto configuration */
+int16 rsi_trigger_auto_config(void);
+/* HTTP Server Credentials */
+int16 rsi_http_credentials(rsi_uhttpCredentials  *uhttpCredentialsFrame);
+
+//! FTP client
+int16 rsi_ftp_client(uint8 type, rsi_ftp_client_t *ftp_client);
+int16 rsi_ftp_file_write_content(rsi_ftp_file_write_t *ftp_file_write, uint8 *file_content, uint32 file_size, uint8 ip_version);
+
+//! SNTP client
+int16 rsi_sntp_client(uint8 type, rsi_sntp_client_t *sntp_client);
+
+//! MDNS 
+int16 rsi_mdns_req(uint8 type, rsi_mdns_t *mdns);
+uint8 rsi_irq_status(void);
+
+//! SNMP 
+uint16 rsi_build_snmp_buffer(uint8 *snmp_buf, char *obj_string, uint32 data_type, uint32 data_msw, uint32 data_lsw,char *data_string);
+int  rsi_snmp_trap_init(uint8 *buffer);
+
+//! SMTP
+int16 rsi_smtp_client(uint8 type, rsi_smtp_client_t *smtp_client);
+void  rsi_buil_smtp_header(uint8 *smtp_header);
+
+//! POP3 
+int16 rsi_pop3_client(uint8 type, rsi_pop3_client_t *pop3_client);
+
+//! OTAF
+int16 rsi_ota_fw_up(rsi_uOtafReq  *uOtafReqFrame);
+
+//! DNS update
+int16 rsi_dns_update(rsi_uDnsUpdate  *uDnsUpdateFrame);
+
+//! HTTP Client PUT
+int16 rsi_http_client_put(uint8 type, rsi_http_client_put_req_t *http_client_put);
+
+//! RTC time from host
+int16 rsi_host_rtc_time(module_rtc_time_t *rtc_time);
+int16 rsi_dhcp_client_usr_cls(rsi_dhcp_user_class_t *dhcp_usr_cls);
+int16 rsi_timeout(rsi_utimeout *uTimeoutFrame);
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_common_types.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_common_types.h
new file mode 100755
index 0000000..001b028
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_common_types.h
@@ -0,0 +1,91 @@
+/**
+ * @file         rsi_common_types.h
+ * @version      1.0
+ * @date         2015-Feb-17
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER, APP, APPLICATION Header file which contains application specific structures 
+ *
+ * @section Description
+ * This file contains the Application related information.
+ *
+ *
+ */
+/* 2016/10/11 APJ add #if 0 */
+
+/**
+ * Includes
+ * */
+
+#ifndef __RSI_COMMON_TYPES_H
+#define __RSI_COMMON_TYPES_H
+typedef unsigned char	          UINT08;
+typedef signed char             INT08;
+
+#ifndef UINT8
+typedef unsigned char           UINT8;
+#endif
+#ifndef INT8
+typedef signed char             INT8;
+#endif
+#ifndef UINT16
+typedef unsigned short int      UINT16;
+#endif
+#ifndef INT16
+typedef short                   INT16;
+#endif
+#ifndef UINT32
+typedef unsigned int       UINT32;
+#endif
+
+#ifndef INT32
+typedef int       			INT32;
+#endif
+
+typedef long                    SINT32;
+typedef long                    SINT_32;
+typedef unsigned long long int  UINT64;
+typedef long long  int          INT64;
+
+#ifndef WINDOWS
+#if 0 /* APJ : delete */
+typedef unsigned char           BOOL;
+#endif /* APJ */
+#endif
+
+typedef unsigned char           uint8;
+typedef unsigned short          uint16;
+typedef unsigned int            uint32;
+typedef signed char             int8;
+typedef short                   int16;
+typedef long                    int32;
+
+//ZIgb Datatypes
+typedef int sint32, sint_32;
+typedef unsigned long long int uint64;
+typedef long long  int int64;
+typedef unsigned char RSI_ZB_STATUS;
+#if (defined WINDOWS || defined LINUX_PLATFORM)
+typedef unsigned char uint8_t;
+typedef signed char int8_t;
+typedef unsigned short uint16_t;
+typedef short int16_t;
+typedef unsigned int uint32_t;
+typedef int int32_t;
+#endif
+#ifdef LINUX_PLATFORM
+typedef uint16_t profile_id_t;
+typedef uint16_t cluster_id_t;
+typedef uint16_t ProfileID;
+typedef uint16_t ClusterID;
+typedef uint16_t GroupID;
+#endif
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_global.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_global.h
new file mode 100755
index 0000000..5528c92
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_global.h
@@ -0,0 +1,2883 @@
+			/**
+ * @file     rsi_global.h
+ * @version  3.6
+ * @date     2013-May-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER, GLOBAL, Global Header file, the things that must be almost everywhere 
+ *
+ * @section Description
+ * This is the top level global.h file for data/functions that need to be in every module
+ * This file contains all the structures and defines used in the entire application 
+ *
+ * @section Improvements
+ * New structures are added. 
+ * The definition for MACRO "RSI_TXDATA_OFFSET_LUDP" from 28 to 26.
+ * LTCP Conn Establishment Rcv structure is changed. 
+ * rsi_uSleepTimer is changed
+ *
+ */
+
+
+#ifndef _RSIGLOBAL_H_
+#define _RSIGLOBAL_H_
+
+
+/**
+ * Global defines
+ */
+#define RSI_TRUE            1    
+#define RSI_FALSE           0
+#ifndef NULL
+#define NULL                0
+#endif
+
+#define DATA_RX             0
+#define DATA_TX             1
+
+//#define PACKED            1 
+
+#define WLAN_MGMT_TYPE  0x4
+#define WLAN_DATA_TYPE  0x5
+#define ZB_MGMT_TYPE    0x1
+#define ZB_DATA_TYPE    0x1
+#define BT_MGMT_TYPE    0x2
+#define BT_DATA_TYPE    0x2
+
+//!Comment This in case the host MCU is of BIG ENDIAN 
+#define RSI_LITTLE_ENDIAN                       1
+
+//#define RSI_FEATSEL_ENABLE                    0
+
+//!Uncomment this if host has hardware timers
+//#define RSI_HWTIMER
+
+//! Interrupt Mode Selection 
+#define RSI_INTERRUPTS
+
+//! Polled Mode selection
+//#define RSI_POLLED
+
+#include "rsi_common_types.h"
+
+#include "rsi_lib_util.h"
+
+#define ENABLE                      1
+#define DISABLE                     0
+
+
+#ifndef RSI_HWTIMER 
+//! need to define this macro if h/w timer is available and it should increment spiTimer2, spiTimer1 
+#define RSI_TICKS_PER_SECOND        50000 
+#else
+#define RSI_TICKS_PER_SECOND        10
+#endif
+
+
+/*@ firmware upgradation timeout */
+#define RSI_FWUPTIMEOUT                100 * RSI_TICKS_PER_SECOND
+/*@ wireless firmware upgradation timeout */
+#define RSI_WIRELESSFWUPTIMEOUT        500 * RSI_TICKS_PER_SECOND
+/*@ bootloading timeout */
+#define RSI_BLTIMEOUT                  1 * RSI_TICKS_PER_SECOND
+/*@ band timeout */
+#define RSI_BANDTIMEOUT                1 * RSI_TICKS_PER_SECOND
+/*@ Init timeout */
+#define RSI_INITTIMEOUT                1 * RSI_TICKS_PER_SECOND
+/*@ Query firmware version timeout */
+#define RSI_QFWVTIMEOUT                1 * RSI_TICKS_PER_SECOND
+/*@ Set Mac address timeout */
+#define RSI_SMATIMEOUT                 1 * RSI_TICKS_PER_SECOND
+/*@ Scan timeout */
+#define RSI_SCANTIMEOUT                12 * RSI_TICKS_PER_SECOND
+/*@ Sleep timer timeout */
+#define RSI_SLEEPTIMERTIMEOUT          1 * RSI_TICKS_PER_SECOND
+/*@ Wepkeys timeout */
+#define RSI_WEPKEYSTIMEOUT             1 * RSI_TICKS_PER_SECOND
+/*@ Join timeout */
+#define RSI_JOINTIMEOUT                12 * RSI_TICKS_PER_SECOND
+/*@ Disconnect timeout */
+#define RSI_DISCONTIMEOUT              1 * RSI_TICKS_PER_SECOND
+/*@ Query connection status timeout */
+#define RSI_QCSTIMEOUT                 3 * RSI_TICKS_PER_SECOND
+/*@ Query dhcp params timeout */
+#define RSI_QDPTIMEOUT                 3 * RSI_TICKS_PER_SECOND
+/*@ Query network params timeout */
+#define RSI_QNPTIMEOUT                 3 * RSI_TICKS_PER_SECOND
+/*@ Ip configuration timeout */
+#define RSI_IPPTIMEOUT                 6 * RSI_TICKS_PER_SECOND
+/*@ Query RSSI Value timeout */
+#define RSI_RSSITIMEOUT                1 * RSI_TICKS_PER_SECOND
+/*@ recv timeout */
+#define RSI_RECVTIMEOUT                1 * RSI_TICKS_PER_SECOND
+/*@ Socket open timeout */
+#define RSI_SOPTIMEOUT                 6 * RSI_TICKS_PER_SECOND
+/*@ Regread timeout */
+#define RSI_REGREADTIMEOUT             1 * RSI_TICKS_PER_SECOND
+/*@ Query DNS timeout */
+#define RSI_QDNSTIMEOUT                6 * RSI_TICKS_PER_SECOND
+/*@ Start token timeout */
+#define RSI_START_TOKEN_TIMEOUT        10 * RSI_TICKS_PER_SECOND
+/*@ Set Listen interval timeout */
+#define RSI_SLITIMEOUT                 1 * RSI_TICKS_PER_SECOND
+/*@ Config Enable timeout */
+#define RSI_CETIMEOUT                  1 * RSI_TICKS_PER_SECOND
+/*@ Config store timeout */
+#define RSI_CSTIMEOUT                  1 * RSI_TICKS_PER_SECOND
+/*@ Config get timeout */
+#define RSI_CGTIMEOUT                  1 * RSI_TICKS_PER_SECOND
+/*@ Query BSSID/NW TYPE timeout */
+#define RSI_QBSSIDNWTIMEOUT            6 * RSI_TICKS_PER_SECOND
+#define RSI_QMACADDTIMEOUT             6 * RSI_TICKS_PER_SECOND
+/*@ Query MAC ADDR timeout */
+/*@ Get HTTP timeout */
+#define RSI_GETHTTPTIMEOUT             40 * RSI_TICKS_PER_SECOND
+/*@ Post HTTP timeout */
+#define RSI_POSTHTTPTIMEOUT            6 * RSI_TICKS_PER_SECOND
+/*@ Mode select timeout */
+#define RSI_MODESEL_TIMEOUT            1 * RSI_TICKS_PER_SECOND
+/*@ Feature select timeout */
+#define RSI_FEATSEL_TIMEOUT            1 * RSI_TICKS_PER_SECOND
+/*@ WPS RESPONSE timeout */
+#define RSI_WPSRSPTIMEOUT              120 * RSI_TICKS_PER_SECOND
+/*@ Power save timeout*/
+#define RSI_PWSAVE_TIMEOUT             5 * RSI_TICKS_PER_SECOND
+/*@ Command response timeout */
+#define RSI_RESPONSE_TIMEOUT(A)        RSI_RESET_TIMER3;                         \
+                                           while (rsi_checkPktIrq() != RSI_TRUE) \
+                                            {                                    \
+                                              if (RSI_INC_TIMER_3 > A)           \
+                                               {                                 \
+                                                 retval = -1;                    \
+                                                 break;                          \
+                                               }                                 \
+                                            }     
+
+
+
+/*=======================================================================================*/
+/**
+ * Device Parameters
+ */
+#define RSI_MAXSOCKETS                       10     //@ Maximum number of open sockets
+
+/**
+ * Debugging Parameters
+ */
+#define RSI_DEBUG_DEVICE                    "UART_1"
+#define RSI_MAX_PAYLOAD_SIZE                 1600  //@ Maximum data payload size
+#define RSI_WEBSOCKET_MAX_SEND_SIZE          1450
+#define RSI_TCP_MAX_SEND_SIZE                1460
+#define RSI_UDP_MAX_SEND_SIZE                1472
+#define RSI_RAW_DATA_MAX_SEND_SIZE           1514
+#define RSI_AP_SCANNED_MAX                   11    //@ Maximum number of scanned acces points
+#define RSI_MAX_WFD_DEV_CNT                  10    //@ Maximum wifi direct device count
+
+/**
+ * Things that are needed in this .h file
+ */
+#define RSI_FRAME_DESC_LEN                  16     //@ Length of the frame descriptor, for both read and write
+#define RSI_FRAME_CMD_RSP_LEN               56     //@ Length of the command response buffer/frame
+#define RSI_TXDATA_OFFSET_TCP               46     //@ required Tx data offset value for TCP, 46
+#define RSI_TXDATA_OFFSET_UDP               34     //@ required Tx data offset value for UDP, 34
+#define RSI_RXDATA_OFFSET_TCP_V4            26     //@ required Rx data offset value for TCPV4, 26
+#define RSI_RXDATA_OFFSET_TCP_V6            46     //@ required Rx data offset value for TCPV6, 46
+#define RSI_RXDATA_OFFSET_UDP_V4            14     //@ required Rx data offset value for UDP_V4, 14
+#define RSI_RXDATA_OFFSET_UDP_V6            34     //@ required Rx data offset value for UDP_V6, 34
+#define RSI_TXDATA_OFFSET_LUDP              16     //@ required Rx data offset value for LUDP, 26
+#define RSI_PSK_LEN                         64     //@ maximum length of PSK
+#define RSI_SSID_LEN                        34     //@ maximum length of SSID
+#define RSI_BSSID_LEN                       6      //@ BSSID length
+#define RSI_IP_ADD_LEN                      4 
+#define RSI_MAC_ADD_LEN                     6
+#define RSI_MGMT_PKT_TYPE                   0x04
+#define RSI_DATA_PKT_TYPE                   0x05 
+#define RSI_PMK_LEN                         32     //@PMK maximum length                                   
+
+/**
+ * Const declaration
+ *
+ */
+#define RSI_BYTES_3                         3
+#define RSI_BYTES_2                         2
+
+
+
+
+extern const uint8            rsi_frameCmdDebug[RSI_BYTES_3];            
+extern const uint8            rsi_frameCmdBootInsn[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdUpdateInfo[RSI_BYTES_3];            
+extern const uint8            rsi_frameCmdBand[RSI_BYTES_3];            
+extern const uint8            rsi_frameCmdConfig[RSI_BYTES_3];            
+extern const uint8            rsi_frameCmdInit[RSI_BYTES_3];            
+extern const uint8            rsi_frameCmdScan[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdBGScan[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdJoin[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdPsk[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdPower[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdIpparam[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdSocket[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdSocketClose[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdRssi[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdSend[RSI_BYTES_3];  
+extern const uint8            rsi_frameCmdCert[RSI_BYTES_3];    
+extern const uint8            rsi_frameCmdRecv[RSI_BYTES_3];  
+extern const uint8            rsi_frameCmdConnStatus[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdQryNetParms[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdDisconnect[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdQryFwVer[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdSetMacAddr[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdQryMacAddress[RSI_BYTES_3];                
+extern const uint8            rsi_frameCmdOperMode[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdP2pConfig[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdSetEap[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdWebFields[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdAntSel[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdQryGoParms[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdSleepTimer[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdDnsQuery[RSI_BYTES_3];
+extern       uint8            rsi_frameCmdHttpGetReq[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdDnsServer[RSI_BYTES_3];
+extern       uint8            rsi_frameCmdHttpPostReq[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdReset[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdCfgSave[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdCfgEnable[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdCfgGet[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdFeatsel[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdSnr[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdLtcpConnStatus[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdSentBytesCount[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdAPconf[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdWepkey[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdUrlRsp[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdPingRequest[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdGpioconf[RSI_BYTES_3];
+//!snmp commands
+extern const uint8            rsi_frameCmdSnmpEnable[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdSnmpGetRsp[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdSnmpGetStats[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdSnmpGetNextRsp[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdSnmpTrap[RSI_BYTES_3];
+//!IPV6 ipconfig command resp
+extern const uint8            rsi_frameCmdIPconf6[RSI_BYTES_3];
+//!Wireless firmware upgrade ok command
+extern const uint8            rsi_frameCmdWirelessFwUpgrade[RSI_BYTES_3];
+//!Roaming parameters frame 
+extern const uint8            rsi_frameCmdRoamParams[RSI_BYTES_3];
+//!High throughput Capabilities parameters frame 
+extern const uint8            rsi_frameCmdHtCaps[RSI_BYTES_3];
+//!WMM PS parameters frame 
+extern const uint8            rsi_frameCmdWmmPs[RSI_BYTES_3];
+//!WPS Method parameters frame 
+extern const uint8            rsi_frameCmdWpsMethod[RSI_BYTES_3];
+//!Multicast params 
+extern const uint8            rsi_frameCmdMulticast[RSI_BYTES_3]; 
+//!PER MODE
+extern const uint8            rsi_frameCmdPerMode[RSI_BYTES_3];
+//!PER STATS
+extern const uint8            rsi_frameCmdPerStats[RSI_BYTES_3];
+//! UART flow control Enable
+extern const uint8            rsi_frameCmdUartFlowControl[RSI_BYTES_3];
+//!Sleep ack
+extern const uint8            rsi_sleepack[RSI_BYTES_3];
+//!Multicast filter bitmap
+extern const uint8            rsi_frameCmdMcastFilter[RSI_BYTES_3];
+
+//!Management Response list
+extern const uint8            rsi_mgmtRspList[];   
+
+//!JSON & Webpage related
+extern const uint8            rsi_frameCmdWebpageClearFiles[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdWebpageEraseFile[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdJSONCreate[RSI_BYTES_3];
+extern const uint8            rsi_frameCmdJSONEraseFile[RSI_BYTES_3];
+
+//!Set region 
+extern const uint8            rsi_frameSetRegion[RSI_BYTES_3];
+extern const uint8            rsi_frameSetRegionAp[RSI_BYTES_3];
+
+//! Rejoin Params response Frame
+extern const uint8            rsi_frameCmdRejoinParams[RSI_BYTES_3];
+
+//! User store configuration Frame
+extern const uint8			  rsi_frameCmdUserStoreCfg[RSI_BYTES_3];
+//! Http ABort Frame
+extern const uint8            rsi_frameCmdHttpABort[RSI_BYTES_3];
+
+//! Socket configuration
+extern const uint8   rsi_frameSocketConfig[RSI_BYTES_3];
+//! RF Power Level
+extern const uint8   rsi_frameCmdRFCurConfig[RSI_BYTES_3];
+
+//! Trigger auto config Request Frame 
+extern const uint8   rsi_frameCmdTriggerAutoConfigReq[RSI_BYTES_3];
+
+/* set rtc time from host frame frame */ 
+extern const uint8   rsi_frameCmdRtcTime[RSI_BYTES_3];
+
+/* set DHCP client user class option frame */
+extern const uint8   rsi_frameCmdDHCPUsrCls[RSI_BYTES_3]; 
+
+/* set timeout value frame */
+extern const uint8   rsi_frameCmdTimeout[RSI_BYTES_3];
+
+/*===============================================*/
+/**
+ * Debug Structures
+ */
+typedef union {
+    struct {
+    uint8     assertion_type[4];
+    uint8     assertion_level[4];
+    } debugFrameSnd;
+    uint8                 uDebugBuf[8];            //@ byte format to send to the spi interface,8 bytes
+} rsi_uDebug;
+
+
+/*===================================================*/
+/**
+ * set region
+ */
+
+typedef union {
+    struct{
+        uint8     setregion_code_from_user_cmd;
+      /*Enable or disable set region from user:
+         1-take from user configuration;
+         0-Take from Beacons*/
+        uint8     region_code;
+       /*region code(1-US,2-EU,3-JP.4-World Domain)*/
+        uint8 module_type[2];
+        }setRegionFrameSnd;
+        uint8 usetRegionBuf[4];
+}rsi_usetregion;
+
+
+/*======================================================*/
+/**Set region in AP mode
+*
+*/
+#define COUNTRY_CODE_LENGTH      3
+
+#define MAX_POSSIBLE_CHANNEL     24
+typedef union{
+    struct{
+        uint8     setregion_code_from_user_cmd;
+      /*Enable or disable set region from user:
+         1-take from user configuration;
+         0-Take US or EU or JP*/
+        uint8     country_code[3];
+        /*region code(1-US,2-EU,3-JP)*/
+        uint8     no_of_rules[4];
+        struct{
+            uint8   first_channel;
+            uint8   no_of_channels;
+            uint8   max_tx_power;
+        }channel_info[MAX_POSSIBLE_CHANNEL];
+    }setRegionApFrameSnd;
+        uint8 usetRegionApBuf[80];
+}rsi_usetregion_ap_t;
+
+
+/*===============================================*/
+/**
+ * Scan Structures
+ */
+
+//! The scan command argument union/variables
+
+typedef union {
+    struct {
+        uint8     channel[4];                             //@ RF channel to scan, 0=All, 1-14 for 2.5GHz channels 1-14
+        uint8     ssid[RSI_SSID_LEN];                     //@ uint8[34], ssid to scan         
+        uint8     reserved[5];                            //@ uint8[6], reserved fields
+        uint8     scan_feature_bitmap;                    //@ uint8 , scan_feature_bitmap
+        uint8     channel_bit_map_2_4[2];                 //@ uint8[2], channel bit map for 2.4 Ghz
+        uint8     channel_bit_map_5[4];                   //@ uint8[4], channel bit map for 5 Ghz
+    } scanFrameSnd;
+    uint8                 uScanBuf[RSI_SSID_LEN + 16];    //@ byte format to send to the spi interface, 48 bytes
+} rsi_uScan;
+
+/*===============================================*/
+/**
+ * Multicast Structures
+ */
+
+//! Multicast command structure
+typedef union {
+      struct {
+        uint8     ip_version[2];
+        uint8     req_Type[2]; 
+          union
+          {
+             uint8      ipv4_address[4];
+             uint8      ipv6_address[16];
+          }group_address;
+         }multicastFrameSnd;
+        uint8     uMulticastBuf[20];
+}rsi_uMulticast;
+
+
+/*===============================================*/
+/**
+ * BGScan Structures
+ */
+
+//! The BG scan command argument union/variables
+typedef union {
+     struct {
+           uint8    bgscan_enable[2];                //@ enable or disable BG scan        
+           uint8    enable_instant_bgscan[2];        //@ Is it instant bgscan or normal bgscan
+           uint8    bgscan_threshold[2];             //@ bg scan threshold value
+           uint8    rssi_tolerance_threshold[2];     //@ tolerance threshold
+           uint8    bgscan_periodicity[2];           //@ periodicity
+           uint8    active_scan_duration[2];         //@ sctive scan duration
+           uint8    passive_scan_duration[2];        //@ passive scan duration
+           uint8    multi_probe;                     //@ multi probe
+         } bgscanFrameSnd;
+     uint8           ubgScanBuf[15];
+     //@ byte format to send to the spi interface, 68 bytes
+} rsi_ubgScan;
+
+
+/*===============================================*/
+/**
+ * Join Data Frame Structure
+ */
+//! The BG scan command argument union/variables
+typedef union {
+     struct {
+           uint8    timeout_bitmap[4];                //@ enable timeout for join or scan        
+           uint8    timeout_value[2];        //@ value of the timeout in ms
+         } timeoutFrameSnd;
+     uint8           utimeoutBuf[6];
+     //@ byte format to send to the spi interface, 68 bytes
+} rsi_utimeout;
+
+
+/*===============================================*/
+/**
+ * Join Data Frame Structure
+ */
+typedef union {
+    struct {
+           uint8    reserved1;                       //@ reserved bytes:Can be used for security Type
+           uint8    securityType;                    //@ 0- Open, 1-WPA, 2-WPA2,6-MIXED_MODE
+           uint8    dataRate;                        //@ data rate, 0=auto, 1=1Mbps, 2=2Mbps, 3=5.5Mbps, 4=11Mbps, 12=54Mbps
+           uint8    powerLevel;                      //@ transmit power level, 0=low (6-9dBm), 1=medium (10-14dBm, 2=high (15-17dBm)
+           uint8    psk[RSI_PSK_LEN];                //@ pre-shared key, 63-byte string , last charecter is NULL
+           uint8    ssid[RSI_SSID_LEN];              //@ ssid of access point to join to, 34-byte string
+		   uint8    join_feature_bitmap;
+           uint8    reserved2[2];                    //@ reserved bytes
+           uint8    ssid_len;
+		   uint8 	listen_interval[4];
+       uint8  vap_id;
+       uint8  join_bssid[6];
+    } joinFrameSnd;
+    uint8    uJoinBuf[RSI_SSID_LEN + RSI_PSK_LEN + 8];            
+    //@ byte format to send to the spi interface, 106 (0x6A) bytes
+} rsi_uJoin;
+
+/*===============================================*/
+/**
+ * Stations Connected structure
+ */
+typedef struct {
+    uint8 mac_addr[6]; 
+}rsi_uConnected_station_t;
+
+/*===============================================*/
+/**
+ * PSK Frame Structure
+ */
+typedef union {
+  struct {
+    uint8    TYPE;
+    uint8    psk_or_pmk[RSI_PSK_LEN];
+    uint8    ap_ssid[RSI_SSID_LEN] ;
+  } PskFrameSnd;
+  uint8 uPskBuf[1 + RSI_PSK_LEN + RSI_SSID_LEN];
+} rsi_uPsk;
+
+
+/*===============================================*/
+/**
+ * Disconnect Data Frame Structure
+ */
+typedef struct {
+        uint8    mode_flag[2];                       //@ 0- Module in Client mode, 1- AP mode
+        uint8    client_mac_addr[6];                 //@ client MAC address, Ignored/Reserved in case of client mode
+}rsi_disassoc_t;
+
+
+/*===============================================*/
+/**
+ * JSON Structures
+ */
+#define JSON_BUFFER_SIZE                    512
+#define JSON_CHUNK_LEN                      1024
+#define RSI_JSON_MAX_CHUNK_LENGTH           1024
+typedef struct rsi_jsonCreateObject_s
+{
+    char    filename[24];
+    uint8   total_length[2];
+    uint8   current_length[2];
+    char    json_data[RSI_JSON_MAX_CHUNK_LENGTH];
+} rsi_jsonCreateObject_t;
+
+typedef struct rsi_tfs_clear_files_s
+{
+    uint8   clear;
+} rsi_tfs_clear_files_t;
+
+typedef struct rsi_tfs_erase_file_s
+{
+    char    filename[24];
+} rsi_tfs_erase_file_t;
+
+/*=======================================================*/
+/*
+ * TCP/IP Configure structures
+ */
+
+typedef union {
+    struct {
+        uint8    dhcpMode;                           //@ 0=Manual, 1=Use DHCP
+        uint8    ipaddr[4];                          //@ IP address of this module if in manual mode
+        uint8    netmask[4];                         //@ Netmask used if in manual mode
+        uint8    gateway[4];                         //@ IP address of default gateway if in manual mode
+		    uint8    hostname[31];                       //@ DHCP client host name
+        uint8    vap_id;                             //@ vap_id used in concurrent mode, 0 - Station and 1 - AP.
+        uint8    fqdn_flag[4];                       //@ DHCP client FQDN flag option 81
+    } ipparamFrameSnd;
+    uint8                    uIpparamBuf[49];        
+    //@ 16 bytes, byte format to send to spi
+} rsi_uIpparam;
+
+/*===============================================*/
+/*
+ * IPV6 Configure
+ */
+typedef union{
+   struct{
+    uint8     mode[2];
+    uint8     prefixLength[2];
+    uint8     ipaddr6[16];
+    uint8     gateway6[16];
+  }ipconf6FrameSnd;
+   uint8 uIpconf6Buf[36];
+}rsi_uIPconf6;
+
+
+/*===================================================*/
+/**
+ * Socket Configure
+ */
+
+#define WEBS_MAX_URL_LEN   51
+#define WEBS_MAX_HOST_LEN  51
+
+typedef union {
+  struct {
+    uint8    ip_version[2];                     //@ ip version4 or 6
+    uint8    socketType[2];                     //@ 0=TCP Client, 1=UDP Client, 2=TCP Server (Listening TCP)
+    uint8    moduleSocket[2];                   //@ Our local module port number
+    uint8    destSocket[2];                     //@ Port number of what we are connecting to
+    union{
+      uint8     ipv4_address[4];
+      uint8     ipv6_address[16];
+    }destIpaddr;
+    uint8     max_count[2];
+    uint8     tos[4];
+    uint8     ssl_bitmap;
+    uint8     ssl_ciphers;
+    uint8     webs_resource_name[WEBS_MAX_URL_LEN];
+    uint8     webs_host_name[WEBS_MAX_HOST_LEN];
+    uint8     tcp_retry_count;
+    uint8     socket_bitmap;
+    uint8     rx_window_size;
+    uint8     tcp_keepalive_initial_time[2];
+    uint8     vap_id;
+    uint8     tcp_retransmission_timer;
+
+  } socketFrameSnd;
+    uint8                    uSocketBuf[141];        //@ 24 bytes, byte format to send to spi
+} rsi_uSocket;
+
+#if 0
+/*===================================================*/
+/**
+ * Sockets Structure
+ * Structure linking socket number to protocol
+ */
+typedef struct {
+  //! Socket protocol
+  uint8    protocol;                      
+} rsi_socketsStr;
+
+
+/*===================================================*/
+/**
+ * Sockets Structure Array
+ * Array of Structures linking socket number to protocol
+ */
+typedef struct {
+    rsi_socketsStr      socketsArray[RSI_MAXSOCKETS+1];        
+    //@ Socket numbers are from 1 to 10
+} rsi_sockets;
+#endif
+
+/*===================================================*/
+/**
+ * Socket Close
+ */
+typedef union {
+    struct {
+        uint8    socketDescriptor[2];                
+        uint8    port_number[2];                   //@ 2bytes, socket descriptor to close
+    } socketCloseFrameSnd;
+    uint8                 uSocketCloseBuf[2];      //@ byte format to send to the spi interface, 2 bytes
+} rsi_uSocketClose;
+
+
+/*===================================================*/
+/**
+ * Socket Read
+ */
+typedef union {
+  struct {
+    //! Socket descriptor
+    uint8      socketDescriptor; 
+
+    //! Receive data length
+    uint8      data_length[4];  
+
+    //! Timeout in milli seconds
+    uint8      timeout_in_ms[2];
+
+  } socketReadFrameSnd;
+    
+   uint8                 uSocketReadBuf[7];      //@ byte format to send to the spi interface, 2 bytes
+} rsi_uSocketRead;
+
+/*===================================================*/
+/**
+ * LTCP socket Connection status
+ */
+typedef union {
+    struct {
+       uint8    socketDescriptor[2];              //@ 2bytes, socket descriptor for LTCP socket
+    } queryLtcpConnStatusFrameSnd;
+    uint8                 uLtcpConnStatusBuf[2];                    
+    //@ byte format to send to the spi interface, 2 bytes
+ } rsi_uQueryLtcpConnStatus;
+
+
+/*===================================================*/
+/**
+ * sent bytes count
+ */
+typedef union {
+    struct {
+       uint8    socketDescriptor[2];              //@ 2bytes, socket descriptor
+    } querySentBytesCountFrameSnd;
+    uint8                 uSentBytesStatusBuf[2];                    
+    //@ byte format to send to the spi interface, 2 bytes
+ } rsi_uQuerySentBytesCount;
+
+
+/**
+ * New commads for WiseConnect
+ *
+ */
+
+/*===================================================*/
+/**
+ * FIPS Mode 
+ *
+ */  
+typedef union {
+  struct {
+    uint8 fips_mode_enable[4];
+  } fipsModeFrameSnd;
+  uint8         uFipsModeBuf[4];        
+} rsi_uFipsMode;
+
+/*===============================================*/
+/**
+ * RECHECK KEY  Frame Structure
+ */
+typedef union {
+  struct {
+    uint8    type; /*0- PMK 1- EAP password*/
+    uint8    key_store;
+    uint8    key[128]; /*PMK/EAP password*/
+  } RecheckkeyFrameSnd;
+  uint8 uRecheckKeyBuf[2 + 128];
+} rsi_urecheck_key;
+
+/*===============================================*/
+/**
+ * AUTO JOIN KEY  Frame Structure
+ */
+typedef union {
+  struct {
+    uint8    type[2]; /*0- PMK 1- EAP password*/
+    uint8    key[128]; /*PMK/EAP password*/
+  } AutojoinkeyFrameSnd;
+  uint8 uAutojoinKeyBuf[2 + 128];
+} rsi_uautojoin_key;
+
+/*===============================================*/
+/**
+ * FWUPGRADATION KEY  Frame Structure
+ */
+typedef union {
+  struct {
+    uint8    key[16]; /*PMK/EAP password*/
+  } FwupgradationkeyFrameSnd;
+  uint8 uFwupgradationKeyBuf[16];
+} rsi_ufwupgradation_key;
+
+#define RSI_RPS_PAYLOAD_LEN 1024
+typedef struct rsi_fw_up_frm_host_s{
+  uint8 packet_info[4];
+  uint8 payload[RSI_RPS_PAYLOAD_LEN];
+}rsi_fw_up_t;
+
+/*===================================================*/
+/**
+ * Operational Mode 
+ *
+ */  
+typedef union {
+    struct {
+       uint8    oper_mode[4];                       //@ operating mode 0-client, 1-p2p, 2-EAP, 6-AP, 8-PER
+       uint8    feature_bit_map[4];                 //@ BIT(0)-Open mode security, BIT(1)-PSK security, BIT(2) JSON objects
+       uint8    tcp_ip_feature_bit_map[4];          //@ BIT(0)-tcp/ip bypass, BIT(1)-HTTP server,BIT(2)-DHCPV4 client, 
+                                                    //@ BIT(3)-DHCPV6 client, BIT(4)-DHCPV4 server, BIT(5)-DHCPV6 server
+       uint8   custom_feature_bit_map[4]; 
+       uint8   ext_custom_feature_bit_map[4];       //@ extention of custom feature bitmap, valid only if BIT(31) of custom feature bitmap is set
+       uint8   ble_feature_bit_map[4];              //@ BLE custom feature bitmap, valid only if BIT(31) of extention custom feature bitmap is set
+       uint8 ext_tcpip_feature_bit_map[4];
+    } operModeFrameSnd;
+    uint8    uOperModeBuf[28];                
+} rsi_uOperMode;
+
+/*===================================================*/
+/**
+ * Antenna Select 
+ *
+ */  
+typedef union {
+    struct {
+        uint8    AntennaVal;                      //@ uint8, Antenna value to set    
+        uint8    gain_2g;                         //@ uint8, Antenna 2G gain value    
+        uint8    gain_5g;                         //@ uint8, Antenna 5G gain value    
+        uint8    antenna_path;                    //@ uint8, antenna path value
+        uint8    antenna_type;                    //@ uint8, antenna type value
+    } AntennaSelFrameSnd;
+    uint8     AnetnnaReqBuf[5];    
+} rsi_uAntenna;
+
+/*===================================================*/
+/**
+ * Config p2p command 
+ *
+ */  
+typedef union {
+    struct {
+        uint8    GOIntent[2];                     //@ GO Intent Value 0-15 for P2p GO or client , 16 - Soft AP 
+        uint8    deviceName[64];                  //@ name of the device
+        uint8    operChannel[2];                  //@ In which channel we are operating after becomes Group owner
+        uint8    ssidPostFix[64];                 //@ Postfix SSID
+        uint8    psk[64];                         //@ PSK of the device 
+    }configP2pFrameSnd;
+    uint8    uConfigP2pBuf[196];
+}rsi_uConfigP2p;
+
+/*===================================================*/
+/**
+ * DNS Server command 
+ *
+ */  
+typedef union {
+    struct {
+        uint8    ip_version[2];
+        uint8    DNSMode[2];
+        union{
+        uint8    ipv4_address[4];       
+        uint8    ipv6_address[16];       
+    }primary_dns_ip;
+    union{
+        uint8    ipv4_address[4];    
+        uint8    ipv6_address[16];    
+    }secondary_dns_ip;
+    }dnsServerFrameSnd;
+    uint8       uDnsBuf[36];
+}rsi_uDnsServer;
+
+
+
+/*===================================================*/
+/**
+ * DNS query command 
+ *
+ */  
+
+#define MAX_URL_LEN 90
+typedef union {
+    struct {
+        uint8    ip_version[2];
+        uint8    aDomainName[MAX_URL_LEN];        
+        uint8    uDNSServerNumber[2];            
+    }dnsQryFrameSnd;
+    uint8    uDnsQryBuf[MAX_URL_LEN + 4];
+}rsi_uDnsQry;
+
+
+/*===================================================*/
+/**
+ * DNS update command 
+ *
+ */  
+
+#define MAX_ZONE_LEN 31
+#define MAX_HOST_NAME_LEN 31
+
+typedef union {
+    struct {
+        uint8    ip_version;
+        uint8    aZoneName[MAX_ZONE_LEN];        
+        uint8    aHostName[MAX_HOST_NAME_LEN];        
+        uint8    uDNSServerNumber[2]; 
+    		uint8    ttl[2];           
+    }dnsUpdateFrameSnd;
+    uint8    uDnsUpdateBuf[MAX_ZONE_LEN + MAX_HOST_NAME_LEN + 5];
+}rsi_uDnsUpdate;
+
+
+/*====================================================*/
+/**
+ * DHCP USER CLASS command
+ *
+ */
+ 
+ 
+/************************DHCP User CLass MAcros************/
+#define RSI_DHCP_USER_CLASS_MAX_COUNT           2      //@ MAX count of DHCP user class
+#define RSI_DHCP_USER_CLASS_DATA_MAX_LEN	    64     //@ MAX DATA LENGTH of DHCP user class
+
+
+typedef struct dhcp_user_class_data_s
+{
+  uint8 length;
+
+  uint8 data[RSI_DHCP_USER_CLASS_DATA_MAX_LEN];
+} dhcp_user_class_data_t;
+typedef struct rsi_dhcp_user_class_s
+{
+	uint8 mode;
+	//! User class list count
+	uint8 count;
+
+	//! User class data
+	dhcp_user_class_data_t user_class_data[RSI_DHCP_USER_CLASS_MAX_COUNT];
+
+} rsi_dhcp_user_class_t;
+
+/*===================================================*/
+/**
+ * OTAF REQ command 
+ *
+ */ 
+typedef union {
+  struct {
+    uint8    ip_version;
+    union{
+      uint8   ipv4_address[RSI_IP_ADD_LEN];
+      uint8   ipv6_address[RSI_IP_ADD_LEN * 4];
+    }server_address;
+    uint8    server_port[4];        
+    uint8    chunk_number[2]; 
+    uint8    time_out[2];
+    uint8    retry_count[2];           
+  }OtafReqFrameSnd;
+  uint8    uOtafReqBuf[27];
+}rsi_uOtafReq;
+
+/*===================================================*/
+/**
+ * Config EAP command 
+ *
+ */  
+typedef union {
+    struct {
+        uint8   eapMethod[32];                    //@ EAP method
+        uint8   innerMethod[32];                  //@ Inner method
+        uint8   userIdentity[64];                 //@ user name
+        uint8   password[128];                    //@ Password    
+        uint8   okc_enable[4];                    //@Opportunistic Key Caching enable
+        uint8   private_key_passwd[82];          //@ Private key password for encrypted certificates
+    }setEapFrameSnd;
+    uint8   uSetEapBuf[342];
+}rsi_uSetEap;
+
+/*===================================================*/
+/**
+ * Web server command 
+ *
+ */  
+#define MAX_URL_LENGTH             40
+#define MAX_POST_DATA_LENGTH       512
+
+typedef struct
+{
+   uint8   url_length;
+   uint8   url_name[MAX_URL_LENGTH];
+   uint8   request_type;
+   uint8   post_content_length[2];
+   uint8   post_data[MAX_POST_DATA_LENGTH];
+
+}rsi_urlReqFrameRcv; 
+
+#define MAX_WEBPAGE_SEND_SIZE      1024
+typedef struct 
+{ 
+    uint8   filename[24];
+    uint8   total_len[2];
+    uint8   current_len[2];
+    uint8   has_json_data;
+    uint8   webpage[MAX_WEBPAGE_SEND_SIZE];
+} WebpageSnd_t;
+
+typedef union 
+{
+    struct {
+    WebpageSnd_t    Webpage_info; 
+    }webServFrameSnd;
+    uint8     uWebServBuf[1024 + 2 + 2 + 1 + 24]; //@ byte format to send to the spi interface, 1026 bytes 
+}rsi_uWebServer;
+
+
+/*===================================================*/
+/**
+ * Host Web page command 
+ *
+ */  
+#define MAX_HOST_WEBPAGE_SEND_SIZE   1400
+
+typedef struct 
+{ 
+    uint8   total_len[4];
+    uint8   more_chunks;
+    uint8   webpage[MAX_HOST_WEBPAGE_SEND_SIZE];
+} HostWebpageSnd_t;
+
+
+/*===================================================*/
+/**
+ * Web Fields command 
+ *
+ */
+ 
+#define MAX_NO_OF_FIELDS  10
+#ifdef PACKED 
+typedef struct __attribute__((packed)){
+#else
+typedef struct {
+#endif
+  uint8   field_index;
+  uint8   field_val[64];    
+}field_st_t;
+
+typedef union {
+#ifdef PACKED 
+  struct __attribute__((packed)){
+#else
+  struct {
+#endif
+    uint8    field_cnt;
+    field_st_t   field_st[MAX_NO_OF_FIELDS];
+  }webFieldsFrameSnd;
+  uint8   uWebFieldBuf[680];                      //@ byte format to send to the spi interface, 680 bytes 
+}rsi_uWebFields;
+
+/*===================================================*/
+/**
+ * Set Mac Address
+ */
+
+typedef union
+{
+    struct {
+        uint8    macAddr[6];                      //@ byte array, mac address
+    } setMacAddrFrameSnd;
+    uint8   setMacAddrBuf[6];                    
+} rsi_uSetMacAddr;
+
+/*===================================================*/
+/**
+ * Feature select
+ */
+
+typedef union
+{
+    struct {
+        uint8    featsel_bitmapVal[4];            //@ 4 bytes, feat select bitmap value to set    
+    } FeatselFrameSnd;
+    uint8   uFeatselBuf[4];                    
+} rsi_uFeatsel;
+
+/*===================================================*/
+/**
+ * Band
+ */
+
+typedef union 
+{
+    struct {          
+        uint8    bandVal;                         //@ uint8, band value to set    
+    } bandFrameSnd;
+    uint8    uBandBuf;                        
+} rsi_uBand;
+
+/*===================================================*/
+/**
+ * Configuration values
+ */
+
+typedef union 
+{
+    struct {          
+        uint8    config_type[2];                   //@ 2bytes, type of the value to configure i.e For now RTSTHRESHOLD    
+        uint8    config_value[2];                  //@ 2bytes, value to configure    
+    } configFrameSnd;
+    uint8    uConfigBuf[4];                        
+} rsi_uConfig;
+
+/*===================================================*/
+/**
+ * Cfg enable
+ */
+
+typedef union
+{
+    struct {
+        uint8    cfg_enable;                      //@ uint8, config enable flag    
+    } cfgEnableFrameSnd;
+    uint8   ucfgEnableBuf;                        
+} rsi_uCfgEnable;
+
+/*===================================================*/
+/**
+ * 
+ * UART Hardware flow control 
+ *
+ * */
+typedef union {
+struct {
+  uint8 uart_hw_flowcontrol_enable;
+}HwFlowControlEnableFrameSnd;
+  uint8 uHwFlowControlEnableBuf;
+}rsi_uHwFlowControl;
+
+
+/*===================================================*/
+/**
+ * Sleep timer
+ */
+
+typedef union {
+    struct {
+        uint8   TimeVal[2];                       //@ 2bytes, sleep timer value to set    
+    } SleepTimerFrameSnd;
+    uint8   uSleepTimerBuf[2];                        
+} rsi_uSleepTimer;
+
+/*===================================================*/
+/**
+ * RTC time from host
+ */
+
+typedef struct module_rtc_time_s{
+    uint8    tm_sec[4];                           //@ seconds after the minute [0-60] 
+    uint8    tm_min[4];                           //@ minutes after the hour [0-59] 
+    uint8    tm_hour[4];                          //@ hours since midnight [0-23] 
+    uint8    tm_mday[4];                          //@ day of the month [1-31] 
+    uint8    tm_mon[4];                           //@ months since January [0-11] 
+    uint8    tm_year[4];                          //@ year since 0 
+}module_rtc_time_t;
+
+
+#define HTTP_BUFFER_LEN       1200
+#define HTTP_POST_BUFFER_LEN  900
+#define HTTP_PUT_BUFFER_LEN  900
+
+/*===================================================*/
+/** 
+ *  HTTP GET / POST Request
+  */
+typedef union {
+    struct {
+        uint8  ip_version[2];                     //@ ip version 4 or 6
+        uint8  https_enable[2];                   //@ enable http features
+        uint8  http_port[2];                         //@ server port number
+        uint8  buffer[HTTP_BUFFER_LEN];           //@ Username, Password,Hostname, IP address,url,header,data
+    } HttpReqFrameSnd;
+    uint8   uHttpReqBuf[HTTP_BUFFER_LEN + 6];
+} rsi_uHttpReq;
+
+
+
+/*===================================================*/
+/** 
+ *  HTTP POST DATA Request
+  */
+typedef union {
+    struct {
+        uint8  current_chunk_length[2];                     //@ HTTP data chunk length
+        uint8  buffer[HTTP_POST_BUFFER_LEN];                //@ HTTP data
+    } HttpPostDataReqFrameSnd;
+    uint8   uHttpPostDataReqBuf[HTTP_POST_BUFFER_LEN + 2];
+} rsi_uHttpPostDataReq;
+
+
+
+
+
+/*===================================================*/
+/**
+ * HTTP GET/POST Response
+ */
+typedef struct TCP_EVT_HTTP_Data_t{
+  uint8   more[4]; 
+  uint8   offset[4];
+  uint8   data_len[4];
+  uint8   data[1024];
+} rsi_uHttpRsp;
+
+/*===================================================*/
+/**
+ * DNS query struct
+ */
+
+
+
+#define MAX_DNS_REPLY 10 
+
+typedef struct TCP_EVT_DNS_Query_Resp 
+{ 
+ uint8   ip_version[2];
+ uint8   uIPCount[2];  
+ union{
+   uint8   ipv4_address[4];
+   uint8   ipv6_Address[16];
+ }aIPaddr[MAX_DNS_REPLY]; 
+}TCP_EVT_DNS_Query_Resp; 
+
+/*===================================================*/
+/**
+ * Power mode
+ */
+typedef union {
+    struct {
+        uint8   powerVal;                         //@ uint8, power value to set
+        uint8   ulp_mode_enable;                  //@ 0 - LP, 1 - ULP with RAM retention and 2 - ULP without RAM retention
+        uint8   listen_interval_dtim;             //@ valid value is 0 and 1
+        uint8   rsi_psp_type;                     //@ 0 - max PSP, 1 - Fast PSP and 2 - UAPSD
+        uint16  monitor_interval;                  //@ Wake up time in ms when psp_type is 1
+    } powerFrameSnd;
+    uint8   uPowerBuf[6];         
+} rsi_uPower;
+
+/*===================================================*/
+/**
+ * Per mode
+ */
+typedef union {
+    struct {
+        uint8   per_mode_enable[2];               //@ uint8, enable/disable per mode
+        uint8   power[2];                         //@ uint8, per mode power
+        uint8   rate[4];                          //@ uint8, per mode rate
+        uint8   length[2];                        //@ uint8, per mode length
+        uint8   mode[2];                          //@ uint8, per mode mode
+        uint8   channel[2];                       //@ uint8, per mode channel
+        uint8   rate_flags[2];                    //@ uint8, per mode rate_flags
+        uint8   reserved1[2];                     //@ uint8, per mode reserved
+        uint8   aggr_enable[2];                   //@ uint8, per mode aggr_enable
+        uint8   reserved2[2];                    //@ uint8, per mode reserved
+        uint8   no_of_pkts[2];                    //@ uint8, per mode no_of_pkts
+        uint8   delay[4];                         //@ uint8, per mode delay
+    } perModeFrameSnd;
+    uint8   uPerModeBuf[28];         
+}rsi_uPerMode;
+
+/*===================================================*/
+/**
+ * Per stats
+ */
+typedef union {
+    struct {
+      uint8 per_stats_enable[2];
+      uint8 per_stats_channel[2];
+    } perStatsFrameSnd;
+    uint8   uPerStatsBuf[4];         
+}rsi_uPerStats;
+
+/*===================================================*/
+/**
+ * SEND
+ */
+typedef union {
+    struct {
+        uint8   ip_version[2];                    //@ ip version 4 or 6
+        uint8   socketDescriptor[2];              //@ socket descriptor of the already opened socket connection
+        uint8   sendBufLen[4];                    //@ length of the data to be sent
+        uint8   sendDataOffsetSize[2];            //@ Data Offset, TCP=46, UDP=34
+        uint8   padding[RSI_MAX_PAYLOAD_SIZE];    
+        //@ large enough for TCP or UDP frames
+    } sendFrameSnd;
+    struct {
+        uint8   ip_version[2];                    //@ ip version 4 or 6
+        uint8   socketDescriptor[2];              //@ socket descriptor of the already opened socket connection
+        uint8   sendBufLen[4];                    //@ length of the data to be sent
+        uint8   sendDataOffsetSize[2];            //@ Data Offset, TCP=44, UDP=32
+        uint8   destPort[2];
+        union{
+          uint8   ipv4_address[RSI_IP_ADD_LEN];
+          uint8   ipv6_address[RSI_IP_ADD_LEN * 4];
+    }destIPaddr;
+        uint8   sendDataOffsetBuf[RSI_TXDATA_OFFSET_LUDP];    
+        //@ Empty offset buffer, UDP=26
+        uint8   sendDataBuf[RSI_MAX_PAYLOAD_SIZE];            
+        //@ Data payload buffer, 1400 bytes max
+    } sendFrameLudpSnd;
+    uint8   uSendBuf[RSI_MAX_PAYLOAD_SIZE];        
+    //@ byte format to send to spi, TCP is the larger of the two, 1456 bytes
+} rsi_uSend;
+
+/*=============================*/
+
+typedef struct
+{
+  uint8      ip_version;
+  uint8      ttl[2];
+} mdns_init_t;
+
+typedef struct
+{
+  uint8      port[2];
+  uint8      ttl[2];
+  uint8      more;
+} mdns_reg_srv_t;
+
+typedef struct rsi_mdns_t 
+{
+  uint8    command_type;
+  union 
+  {
+    mdns_init_t      mdns_init;
+    mdns_reg_srv_t   mdns_reg_srv;     
+  } mdns_struct;
+    
+  uint8    buffer[1000];
+
+} rsi_mdns_t;
+
+/*=============================*/
+/*===================================================*/
+/**
+ * Frame Descriptor
+ */
+
+typedef union {
+    struct {
+        uint8   dataFrmLenAndQueue[2];                
+        //@ Data frame body length. Bits 14:12=queue, 010 for data, Bits 11:0 are the length
+        uint8    padding[14];                     //@ Unused, set to 0x00
+ } frameDscDataSnd;
+    struct {
+        uint8   mgmtFrmLenAndQueue[2];            
+        //@ Data frame body length. Bits 14:12=queue, 000 for data, Bits 11:0 are the length
+        uint8   mgmtRespType;                
+        //@ Management frame descriptor response status, 0x00=success, else error
+        uint8   padding[9];                       //@ Unused , set to 0x00
+        uint8   mgmtFrmDscRspStatus;
+        uint8   padding1[3];
+    } frameDscMgmtRsp;
+    uint8   uFrmDscBuf[RSI_FRAME_DESC_LEN];       //@ byte format for spi interface, 16 bytes
+} rsi_uFrameDsc;
+
+/*===================================================*/
+/**
+ * Roaming Parameters set structure
+ */
+typedef union {
+    struct {
+       uint8   roam_enable[4];
+       uint8   roam_threshold[4];
+       uint8   roam_hysteresis[4];
+   }roamParamsFrameSnd;
+ uint8   uRoamParamsBuf[12];
+}rsi_uRoamParams;
+
+/*===================================================*/
+/**
+ *Structure for rejoin_params
+ */
+typedef struct rsi_rejoin_params_s{
+      uint8   rsi_max_try[4];
+      uint8    rsi_scan_interval[4];
+      uint8    rsi_beacon_missed_count[4];
+      uint8   rsi_first_time_retry_enable[4];
+} rsi_rejoin_params_t;
+
+
+/*===================================================*/
+/**
+ * HT CAPS Parameters set structure
+ */
+typedef union { 
+  struct {
+    uint8    mode_11n_enable[2];
+    uint8    ht_caps_bitmap[2];
+  }htCapsFrameSnd;
+  uint8   uHtCapsBuf[4];
+}rsi_uHtCaps;
+
+
+/*===================================================*/
+/**
+ * WMM PS Parameters set structure
+ */
+typedef union {
+  struct {
+    uint8   wmm_ps_enable[2];
+    uint8   wmm_ps_type[2];
+    uint8   wmm_ps_wakeup_interval[4];
+    uint8   wmm_ps_uapsd_bitmap; 
+   }wmmPsFrameSnd;
+   uint8  uWmmPsBuf[9];
+}rsi_uWmmPs;
+
+/*===================================================*/
+/**
+ * WPS Parameters set structure
+ */
+#define RSI_WPS_PIN_LEN  8
+typedef union { 
+  struct {
+    uint8   wps_method[2];
+    uint8   generate_pin[2];
+    uint8   wps_pin[RSI_WPS_PIN_LEN];
+  }wpsMethodFrameSnd;
+  uint8   uWpsMethodBuf[12];
+}rsi_uWpsMethod;
+
+/*===================================================*/
+/**
+ * Command Response Frame Union
+ */
+typedef struct {
+    uint8   devState;                             //@ If New device  1; Device left 0
+    uint8   devName[32];                          //@ Name the device found or left 32 bytes
+    uint8   macAddress[6];                        //@ Mac address of the device 
+    uint8   devtype[2];                           //@ Type of the device 1st byte inidcates primary device type;
+                                                  //@ 2nd byte indicates sub catagory
+}rsi_wfdDevInfo;
+
+typedef struct {     
+    rsi_wfdDevInfo  devInfo;    
+}rsi_wfdDevRsp;
+
+typedef struct {
+       uint8   devCount;
+       rsi_wfdDevInfo   strWfdDevInfo[RSI_MAX_WFD_DEV_CNT];    
+                                                   //@ 32 maximum responses from scan command    
+} rsi_wfdDevResponse;
+
+
+typedef struct {
+    uint8   rfChannel;                             //@ rf channel to us, 0=scan for all
+    uint8   securityMode;                          //@ security mode, 0=open, 1=wpa1, 2=wpa2, 3=wep
+    uint8   rssiVal;                               //@ absolute value of RSSI
+    uint8   uNetworkType;
+    uint8   ssid[RSI_SSID_LEN];                    //@ 32-byte ssid of scanned access point
+    uint8   bssid[RSI_BSSID_LEN];
+    uint8   reserved[2];
+} rsi_scanInfo;
+
+typedef struct {
+    uint8   nwType;                                //@ network type, 0=Ad-Hoc (IBSS), 1=Infrastructure
+    uint8   securityType;                          //@ security type, 0=Open, 1=WPA1, 2=WPA2, 3=WEP
+    uint8   dataRate;                              //@ data rate, 0=auto, 1=1Mbps, 2=2Mbps, 3=5.5Mbps, 4=11Mbps, 12=54Mbps
+    uint8   powerLevel;                            //@ transmit power level, 0=low (6-9dBm), 1=medium (10-14dBm, 2=high (15-17dBm)
+    uint8   psk[RSI_PSK_LEN];                      //@ pre-shared key, 32-byte string
+    uint8   ssid[RSI_SSID_LEN];                    //@ ssid of access point to join to, 32-byte string
+    uint8   ibssMode;                              //@ Ad-Hoc Mode (IBSS), 0=Joiner, 1=Creator
+    uint8   ibssChannel;                           //@ rf channel number for Ad-Hoc (IBSS) mode
+    uint8   reserved;
+} rsi_joinInfo;
+
+typedef struct {
+    uint8   scanCount[4];                          //@ 4 bytes, number of access points found
+    uint8   padding[4];
+    rsi_scanInfo    strScanInfo[RSI_AP_SCANNED_MAX];    
+                                                   //@ 32 maximum responses from scan command
+} rsi_scanResponse;
+
+typedef struct {
+  uint8   macAddress1[6];
+  uint8   macAddress2[6];
+}rsi_initResponse;
+
+typedef struct {
+    uint8   macAddress1[6];
+    uint8   macAddress2[6];
+}rsi_qryMacFrameRcv;
+
+typedef struct {
+    uint8   operState;    
+}rsi_joinResponse;
+
+typedef struct {
+    uint8   rssiVal;                           //@ uint8, RSSI value for the device the module is currently connected to
+} rsi_rssiFrameRcv;
+
+typedef struct {
+    uint8   snrVal;                               //@ uint8, RSSI value for the device the module is currently connected to
+} rsi_snrFrameRcv;
+
+
+typedef struct {
+    uint8   ip_version[2];                       //@ ip version 4 or 6  
+    uint8   socketType[2];                       //@ 2 bytes, type of socket created
+    uint8   socketDescriptor[2];                 //@ uinr16, socket descriptor, like a file handle, usually 0x00
+    uint8   moduleSocket[2];                     //@ 2 bytes, Port number of our local socket
+    union{
+      uint8   ipv4_addr[4];                      //@ 4 bytes, Our (module) IPv4 Address
+      uint8   ipv6_addr[16];                     //@ 4 bytes, Our (module) IPv6 Address
+  }moduleIPaddr;
+  uint8   mss[2];                                //@ 2 bytes, Remote peer MSS size
+  uint8   window_size[4];                        //@ 4 bytes, Remote peer Window size
+} rsi_socketFrameRcv;
+
+typedef struct {
+    uint8   socketDsc[2];                         //@ 2 bytes, socket that was closed
+    uint8   sentBytescnt[4];                      //@ 4 bytes, sent bytes count
+} rsi_socketCloseFrameRcv;
+
+typedef struct {
+    uint8    macAddr[6];                          //@ MAC address of this module
+    uint8    ipaddr[4];                           //@ Configured IP address
+    uint8    netmask[4];                          //@ Configured netmask
+    uint8    gateway[4];                          //@ Configured default gateway
+} rsi_ipparamFrameRcv;
+
+typedef struct {
+    uint8   macAddr[6];                           //@ MAC address of this module
+    uint8   ipaddr[4];                            //@ Configured IP address
+    uint8   netmask[4];                           //@ Configured netmask
+    uint8   gateway[4];                           //@ Configured default gateway
+} rsi_recvIpChange;
+
+
+
+typedef struct {
+    uint8   prefixLength[2];                      //@ prefix length
+    uint8   ipaddr6[16];                          //@ Configured IPv address
+    uint8   defaultgw6[16];                       //@ Router IPv6 address
+} rsi_ipconf6FrameRcv;
+
+typedef struct {
+    uint8   object_id[32];                         //@ Object id  
+    uint8   length[4];                             //@ Length of set request
+    uint8   value[200];                            //@ value to be set
+} rsi_snmp_set;
+
+typedef struct {
+    uint8   wps_pin[RSI_WPS_PIN_LEN];
+}rsi_wpsMethodFrameRcv;
+
+/*Region Code response in set region command*/
+typedef struct 
+{
+  //! region code selected
+  uint8 region_code;
+}rsi_uSetRegionRsp;
+
+typedef struct {
+    uint8   state[2];                             //@ 2 bytes, connection state, 0=Not Connected, 1=Connected
+} rsi_conStatusFrameRcv;
+
+typedef struct {
+
+   uint8  sock_handle[2];
+   uint8  SentBytes[4];
+
+} rsi_sentBytesRsp;
+
+typedef struct {
+    uint8   socketDescriptor[2];
+  uint8 ip_version[2];
+  union
+  {
+    uint8   ipv4_address[4];
+    uint8   ipv6_address[16];
+  }dest_ip;
+    uint8   dPort[2];
+} rsi_LtcpConnStatusFrameRcv;
+
+typedef struct sock_info_query_t
+{
+    uint8   sock_id[2];
+    uint8   sock_type[2];
+    uint8   sPort[2];
+    uint8   dPort[2];
+    union{
+        uint8   ipv4_address[4];
+        uint8   ipv6_address[16];
+      }destIpaddr;
+    
+}sock_info_query_t;
+
+typedef struct ftp_rsp_t
+{
+  uint8 command_type;
+  uint8 more;
+  uint16 length;
+  uint8 data[1024];
+}rsi_ftp_rsp_t;
+
+
+typedef struct rsi_sntp_rsp_t
+{
+  uint8 command_type;
+  uint8 sntp_buffer[50];
+}rsi_sntp_rsp_t;
+
+
+//! SMTP response structure
+typedef struct rsi_smtp_rsp_t
+{
+  //! Receive SMTP command type
+  uint8 command_type;
+}rsi_smtp_rsp_t;
+
+typedef struct rsi_http_client_put_rsp_t
+{
+  //!Receive HTTP_PUT command type
+  uint8 command_type;
+  
+  //! HTTP file/resource end of content
+  uint8 end_of_file;
+
+}rsi_http_client_put_rsp_t;
+
+//! SNTP server response structure
+typedef struct rsi_sntp_server_rsp_t
+{
+  UINT8  ip_version;
+  union
+  {
+    UINT8  ipv4_address[4];
+    UINT8  ipv6_address[16];
+  }server_ip_address;
+
+  UINT8  sntp_method;
+}rsi_sntp_server_rsp_t;
+
+
+//! SNTP server info response structure
+typedef struct rsi_sntp_server_info_rsp_t
+{
+  UINT8  command_type;
+  UINT8  ip_version;
+  union
+  {
+    UINT8  ipv4_address[4];
+    UINT8  ipv6_address[16];
+  }server_ip_address;
+
+  UINT8  sntp_method;
+}rsi_sntp_server_info_rsp_t;
+
+typedef struct mdns_rsp_t
+{
+  uint8 command_type;
+
+}rsi_mdns_rsp_t;
+
+#define MN_NUM_SOCKETS             10 
+typedef struct {
+    uint8   wlanState;                            //@ uint8, 0=NOT Connected, 1=Connected
+    uint8   Chn_no;                               //@ channel number of connected AP 
+    uint8   psk[64];                              //@ PSK 
+    uint8   mac_addr[6];                          //@ Mac address
+    uint8   ssid[RSI_SSID_LEN];                   //@ uint8[32], SSID of connected access point
+    uint8   connType[2];                          //@ 2 bytes, 0=AdHoc, 1=Infrastructure
+    uint8   sec_type;
+    uint8   dhcpMode;                             //@ uint8, 0=Manual IP Configuration,1=DHCP
+    uint8   ipaddr[4];                            //@ uint8[4], Module IP Address
+    uint8   subnetMask[4];                        //@ uint8[4], Module Subnet Mask
+    uint8   gateway[4];                           //@ uint8[4], Gateway address for the Module
+    uint8   num_open_socks[2];                    //@ number of sockets opened
+    uint8   prefix_length[2];                     //@ prefix length for ipv6 address
+    uint8   ipv6addr[16];                         //@ modules ipv6 address
+    uint8   defaultgw6[16];                       //@ router ipv6 address
+    uint8   tcp_stack_used;                       //@ BIT(0) =1 - ipv4, BIT(1)=2 - ipv6, BIT(0) & BIT(1)=3 - BOTH
+    sock_info_query_t   socket_info[MN_NUM_SOCKETS];    
+} rsi_qryNetParmsFrameRcv;
+
+
+#define MAX_STA_SUPPORT 4
+
+struct  go_sta_info_s
+{
+   uint8   ip_version[2];                         //@ IP version if the connected client
+   uint8   mac[6];                                //@ Mac Address of the connected client
+  union
+  {
+    uint8   ipv4_address[4];                      //@ IPv4 Address of the Connected client
+    uint8   ipv6_address[16];                     //@ IPv6 Address of the Connected client
+  }ip_address;
+#ifdef PACKED
+}__attribute__((packed));                         //@ to avoid padding in the structures
+#else
+};
+#endif
+
+struct  ip_go_sta_info_s
+{
+   uint8   ip_version[2];                         //@ IP version if the connected client
+   uint8   mac[6];                                //@ Mac Address of the connected client
+   uint8   ipv4_address[4];                      //@ IPv4 Address of the Connected client
+   uint8   ipv6_address[16];                     //@ IPv6 Address of the Connected client
+#ifdef PACKED
+}__attribute__((packed));                         //@ to avoid padding in the structures
+#else
+};
+#endif
+
+typedef struct {
+    uint8   ssid[RSI_SSID_LEN];                   //@ SSID of the P2p GO
+    uint8   bssid[6];                             //@ BSSID of the P2p GO
+    uint8   channel_number[2];                    //@ Operating channel of the GO 
+    uint8   psk[64];                              //@ PSK of the GO
+    uint8   ipv4_address[4];                      //@ IPv4 Address of the GO
+    uint8   ipv6_address[16];                     //@ IPv6 Address of the GO
+    uint8   sta_count[2];                         //@ Number of stations Connected to GO
+    struct  go_sta_info_s sta_info[MAX_STA_SUPPORT];
+}rsi_qryGOParamsFrameRcv;
+
+
+typedef struct {
+    uint8   ssid[RSI_SSID_LEN];                   //@ SSID of the P2p GO
+    uint8   bssid[6];                             //@ BSSID of the P2p GO
+    uint8   channel_number[2];                    //@ Operating channel of the GO 
+    uint8   psk[64];                              //@ PSK of the GO
+    uint8   ipv4_address[4];                      //@ IPv4 Address of the GO
+    uint8   ipv6_address[16];                     //@ IPv6 Address of the GO
+    uint8   sta_count[2];                         //@ Number of stations Connected to GO
+    struct  ip_go_sta_info_s sta_info[MAX_STA_SUPPORT];
+}rsi_qryIPGOParamsFrameRcv;
+
+
+typedef struct {
+    uint8    fwversion[20];                       //@ uint8[20], firmware version text string, x.y.z as 1.3.0
+} rsi_qryFwversionFrameRcv;
+
+
+typedef struct {
+    uint8   ip_version[2];                        //@ 2 bytes, the ip version of the ip address , 4 or 6
+    uint8   recvSocket[2];                        //@ 2 bytes, the socket number associated with this read event
+    uint8   recvBufLen[4];                        //@ 4 bytes, length of data received
+    uint8   recvDataOffsetSize[2];                //@ 2 bytes, offset of data from start of buffer
+    uint8   fromPortNum[2];                       //@ 2 bytes, port number of the device sending the data to us
+    union{
+      uint8   ipv4_address[4];                    //@ 4 bytes, IPv4 Address of the device sending the data to us
+      uint8   ipv6_address[16];                   //@ 4 bytes, IPv6 Address of the device sending the data to us
+  }fromIPaddr;
+    uint8    recvDataOffsetBuf[RSI_RXDATA_OFFSET_UDP_V4]; 
+                                                  //@ uint8, empty offset buffer, 14 for UDP, 42 bytes from beginning of buffer
+    uint8    recvDataBuf[RSI_MAX_PAYLOAD_SIZE];   //@ uint8, buffer with received data
+} rsi_recvFrameUdp;
+
+typedef struct {
+      uint8   ip_version[2];                      //@ 2 bytes, the ip version of the ip address , 4 or 6
+      uint8   recvSocket[2];                      //@ 2 bytes, the socket number associated with this read event
+      uint8   recvBufLen[4];                      //@ 4 bytes, length of data received
+      uint8   recvDataOffsetSize[2];              //@ 2 bytes, offset of data from start of buffer
+      uint8   fromPortNum[2];                     //@ 2 bytes, port number of the device sending the data to us
+    union{
+        uint8   ipv4_address[4];                  //@ 4 bytes, IPv4 Address of the device sending the data to us
+        uint8   ipv6_address[16];                 //@ 4 bytes, IPv6 Address of the device sending the data to us
+  }fromIPaddr;
+    uint8   recvDataOffsetBuf[RSI_RXDATA_OFFSET_UDP_V6];
+    //@ uint8, empty offset buffer, 14 for UDP, 42 bytes from beginning of buffer
+    uint8   recvDataBuf[RSI_MAX_PAYLOAD_SIZE];    //@ uint8, buffer with received data
+} rsi_recvFrameUdp6;
+
+
+typedef struct { 
+      uint8   ip_version[2];                      //@ 2 bytes, the ip version of the ip address , 4 or 6
+      uint8   recvSocket[2];                      //@ 2 bytes, the socket number associated with this read event
+      uint8   recvBufLen[4];                      //@ 4 bytes, length of payload data received
+      uint8   recvDataOffsetSize[2];              //@ 2 bytes, offset of data from start of buffer
+      uint8   fromPortNum[2];                     //@ 2 bytes, port number of the device sending the data to us
+    union{
+       uint8   ipv4_address[4];                   //@ 4 bytes, IPv4 Address of the device sending the data to us
+       uint8   ipv6_address[16];                  //@ 4 bytes, IPv6 Address of the device sending the data to us
+  }fromIPaddr;
+    uint8   recvDataOffsetBuf[RSI_RXDATA_OFFSET_TCP_V4]; //@ uint8, empty offset buffer, 26 for TCP
+    uint8   recvDataBuf[RSI_MAX_PAYLOAD_SIZE];    //@ uint8, buffer with received data
+} rsi_recvFrameTcp;
+
+typedef struct { 
+    uint8   ip_version[2];                        //@ 2 bytes, the ip version of the ip address , 4 or 6
+    uint8   recvSocket[2];                        //@ 2 bytes, the socket number associated with this read event
+    uint8   recvBufLen[4];                        //@ 4 bytes, length of payload data received
+    uint8   recvDataOffsetSize[2];                //@ 2 bytes, offset of data from start of buffer
+    uint8   fromPortNum[2];                       //@ 2 bytes, port number of the device sending the data to us
+    union{
+       uint8   ipv4_address[4];                   //@ 4 bytes, IPv4 Address of the device sending the data to us
+       uint8   ipv6_address[16];                  //@ 4 bytes, IPv6 Address of the device sending the data to us
+  }fromIPaddr;
+    uint8   recvDataOffsetBuf[RSI_RXDATA_OFFSET_TCP_V6]; //@ uint8, empty offset buffer, 26 for TCP
+    uint8   recvDataBuf[RSI_MAX_PAYLOAD_SIZE];    //@ uint8, buffer with received data
+} rsi_recvFrameTcp6;
+
+typedef struct {
+    uint8   socket[2];                                //@ uint8, socket handle for the terminated connection
+    uint8   sentBytescnt[4];                          //@ 4 bytes, sent bytes count
+} rsi_recvRemTerm;
+
+typedef struct{
+ union{
+  uint8   ipv4_address[4];                         //@ primary DNS IPv4
+  uint8   ipv6_address[16];                        //@ primary DNS IPv6
+ }primary_dns_ip;
+
+ union{
+    uint8   ipv4_address[4];                       //@ secondary DNS IPv4
+    uint8   ipv6_address[16];                      //@ secondary DNS IPv6
+ }secondary_dns_ip;
+}rsi_dnsserverResponse;
+
+typedef struct {
+    uint8   ip_version[2];
+    uint8   sock_id[2];                           //@ 2 bytes, socket handle 
+    uint8   fromPortNum[2];                       //@ 2 bytes, remote port number 
+    union{
+        uint8   ipv4_address[4];                  //@  remote IPv4 Address 
+        uint8   ipv6_address[16];                 //@  remote IPv6 Address 
+        }dst_ip_address;
+    uint8   mss[2];                               //@ 2 bytes, remote peer MSS size 
+    uint8   window_size[4];                       //@ 4 bytes, remote peer Window size
+	uint8  srcPortNum[2];
+} rsi_recvLtcpEst;
+
+/* Certificate loading related macros */
+#define MAX_CERT_SEND_SIZE 1400
+
+struct cert_info_s
+{
+  uint8   total_len[2];
+  uint8   CertType;
+  uint8   more_chunks;
+  uint8   CertLen[2];
+  uint8   KeyPwd[128];
+#ifdef PACKED
+}__attribute__((packed));                         //@packed is used to avoid padding
+#else
+};
+#endif
+
+#define MAX_DATA_SIZE (MAX_CERT_SEND_SIZE - sizeof(struct cert_info_s))
+
+struct SET_CHUNK_S
+{ 
+    struct  cert_info_s cert_info;    
+    uint8   Certificate[MAX_DATA_SIZE];
+};
+
+
+/*==================================================*/
+/*This will keep the wepkey params*/
+
+typedef struct {
+    uint8   index[2];
+    uint8   key[4][32];
+}rsi_wepkey;
+
+/*====================================================*/
+/*This will keep the AP configuration parameter*/
+
+typedef struct {
+    uint8   channel_no[2];    
+    uint8   ssid[RSI_SSID_LEN];    
+    uint8   security_type;
+    uint8   encryp_mode;    
+    uint8   psk[RSI_PSK_LEN];
+    uint8   beacon_interval[2];    
+    uint8   dtim_period[2];    
+    uint8   ap_keepalive_type;
+    uint8   ap_keepalive_period;
+    uint8   max_sta_support[2]; // it can be configured from 1 to 4
+}rsi_apconfig;
+
+/*===================================================*/
+/**
+ * HTTP Credentials command 
+ *
+ */  
+
+#define MAX_USERNAME_LEN 31  //! Including NULL character
+#define MAX_PASSWORD_LEN 31  //! Including NULL character
+typedef union {
+    struct {
+        uint8    username[MAX_USERNAME_LEN];
+        uint8    password[MAX_PASSWORD_LEN];        
+    }httpCredentialsFrameSnd;
+    uint8    uhttpCredentialsBuf[MAX_USERNAME_LEN + MAX_PASSWORD_LEN];
+}rsi_uhttpCredentials;
+/*SNMP command structure*/
+#define MAX_SNMP_VALUE 200
+
+/* Maximum length of OID */
+#define MAX_OID_LENGTH     128
+typedef union {
+    struct {
+        uint8   type;
+        uint8   value[MAX_SNMP_VALUE];     
+        uint8   objid[MAX_OID_LENGTH];
+    } snmpFrameSnd;
+    uint8   uSnmpBuf[MAX_SNMP_VALUE + 4 + MAX_OID_LENGTH];
+} rsi_uSnmp;
+
+
+
+typedef struct SNMP_OBJECT_DATA_STRUCT
+{
+
+  uint8           snmp_object_data_type[4];                       /* Type of SNMP data contained         */
+  uint8           snmp_object_data_msw[4];                        /* Most significant 32 bits            */ 
+  uint8           snmp_object_data_lsw[4];                        /* Least significant 32 bits           */ 
+  uint8           snmp_ip_version[4];
+  union{
+    uint8   ipv4_address[4];     
+    uint8   ipv6_address[16];
+  }snmp_nxd_address;
+  uint8           snmp_object_octet_string_size[4];               /* Size of OCTET string                */ 
+
+} SNMP_OBJECT_DATA;
+
+typedef struct SNMP_TRAP_OBJECT_STRUCT
+{
+
+    uint8               snmp_object_string_ptr[40];              /* SNMP object string*/
+    SNMP_OBJECT_DATA    snmp_object_data;                        /* SNMP object data */
+} SNMP_TRAP_OBJECT;
+
+
+#define  RSI_SNMP_TAP_BUFFER_LENGTH  1024
+
+/*SNMP trap structure*/
+typedef union {
+  struct {
+    uint8   snmp_version;
+    uint8   ip_version[4];
+    union{
+      uint8   ipv4_address[4];     
+      uint8   ipv6_address[16];
+    }destIPaddr;
+    uint8   community[32];
+    uint8   trap_type;
+    uint8   elapsed_time[4]; 
+    uint8   trap_oid[51];
+    uint8   obj_list_count;
+    uint8   snmp_buf[RSI_SNMP_TAP_BUFFER_LENGTH];
+  } snmptrapFrameSnd;
+
+     uint8   uSnmptrapBuf[110+RSI_SNMP_TAP_BUFFER_LENGTH];
+} rsi_uSnmptrap;
+
+/* Structure for SNMP Enable */
+typedef union{
+  struct{
+    uint8   snmpEnable;
+ }snmpEnableFrameSnd;
+  uint8   uSnmpenableBuf;
+}rsi_uSnmpEnable;
+
+
+//! PUF
+typedef union{
+  struct{
+    uint8    key_index;
+    uint8    key_size;
+    uint8    key[32];
+  }pufSetKeyFrameSnd;
+  uint8 uPufsetkeyBuf[36];
+} rsi_uPufsetkey; 
+
+
+typedef union{
+  struct{
+    uint8    key_code[44];
+  }pufGetKeyFrameSnd;
+  uint8 uPufgetkey[44];
+} rsi_uPufgetkey; 
+
+
+typedef union{
+  struct{
+    uint8    key_code[44];
+  }pufLoadKeyFrameSnd;
+  uint8 uPufloadkey[44];
+} rsi_uPufloadkey; 
+
+typedef union{
+  struct{
+    uint8    mode;
+    uint8    key[32];
+    uint8    iv[32];
+    uint8    data_size[2];
+    uint8    data[1400];
+  }aesEncryptFrameSnd;
+  uint8 uAesEncrypt[1468];
+} rsi_uAesencrypt; 
+
+typedef union{
+  struct{
+    uint8    mode;
+    uint8    key[32];
+    uint8    iv[32];
+    uint8    data_size[2];
+    uint8    data[1400];
+  }aesDecryptFrameSnd;
+  uint8 uAesDecrypt[1468];
+} rsi_uAesdecrypt; 
+
+typedef union{
+  struct{
+    UINT8    mode;
+    UINT8    key[32];
+    UINT8    iv[32];
+    UINT8    data_size[2];
+    UINT8    data[1400];
+  }aesMacFrameSnd;
+  uint8 uAesMac[1468];
+} rsi_uAesMac; 
+
+/* Ping Response Frame */
+typedef struct {
+	uint8   ip_version[2];
+	uint8   ping_size[2]; 
+	union{
+		uint8   ipv4_addr[4];                         //@ 4 bytes, Our (module) IPv4 Address
+		uint8   ipv6_addr[16];                        //@ 4 bytes, Our (module) IPv6 Address
+	}ping_address;
+} rsi_uPingRsp;
+
+/*structure for ping request command*/
+typedef struct rsi_ping_request_s{
+  uint8   ip_version[2];
+  uint8   ping_size[2];
+  union{
+    uint8   ipv4_address[4];
+    uint8   ipv6_address[16];
+  }ping_address;
+  
+  uint8  timeout[2];
+}rsi_ping_request_t;
+
+/*PSK response structure*/
+typedef struct{
+  uint8   pmk[32];
+}rsi_PmkResponse;
+
+/*P2P connection request from wi-fi device*/
+typedef struct rsi_p2p_conn_req_s{
+  uint8   device_name[32];    
+}rsi_p2p_conn_req_t;
+
+/* Module state response */
+typedef struct rsi_state_notificaton_s{
+    uint8   TimeStamp[4];
+    uint8   stateCode;
+    uint8   reason_code;
+    uint8   rsi_channel;
+    uint8   rsi_rssi;
+    uint8   rsi_bssid[6];
+} rsi_state_notificaton_t;
+
+
+/*User store configuration parameters*/
+#define MAX_HTTP_SERVER_USERNAME 31
+#define MAX_HTTP_SERVER_PASSWORD 31
+
+typedef struct sc_params_s
+{
+  uint8    cfg_enable;
+  uint8    opermode[4];
+  uint8    feature_bit_map[4];
+  uint8    tcp_ip_feature_bit_map[4];
+  uint8    custom_feature_bit_map[4];
+  uint8    band;
+  uint8    scan_feature_bitmap;
+  uint8    join_ssid[RSI_SSID_LEN];
+  uint8    uRate;
+  uint8    uTxPower;
+  uint8    join_feature_bitmap;
+  uint8    reserved_1;
+  uint8    scan_ssid_len;
+  uint8    keys_restore;
+  uint8    csec_mode;
+  uint8    psk[RSI_PSK_LEN];
+  uint8    scan_ssid[RSI_SSID_LEN];
+  uint8    scan_cnum;
+  uint8    dhcp_enable;
+#define IP_ADDRESS_SZ 4
+  uint8    ip[IP_ADDRESS_SZ];
+  uint8    sn_mask[IP_ADDRESS_SZ];
+  uint8    dgw[IP_ADDRESS_SZ];
+
+  uint8    eap_method[32];
+  uint8    inner_method[32];
+  uint8    user_identity[64];
+  uint8    passwd[128];
+
+  uint8    go_intent[2];
+  uint8    device_name[64];
+  uint8    operating_channel[2];
+  uint8    ssid_postfix[64];
+  uint8    psk_key[64];
+#define  WISE_PMK_LEN 32
+  uint8    pmk[WISE_PMK_LEN];
+  rsi_apconfig apconfig;
+  uint8    module_mac[6];
+  uint8    antenna_select;
+  uint8    gain_2g;
+  uint8    gain_5g;
+  uint8    antenna_path;
+  uint8    antenna_type;
+  uint8    fips_bypass_mode[2];
+  rsi_wepkey wep_key;
+  uint8    dhcp6_enable[2];
+  uint8    prefix_length[2];
+  uint8    ip6[16];
+  uint8    dgw6[16];
+  uint8    tcp_stack_used;
+  uint8    bgscan_magic_code[2];
+  uint8    bgscan_enable[2];
+  uint8 	 bgscan_threshold[2];
+  uint8 	 rssi_tolerance_threshold[2];
+  uint8 	 bgscan_periodicity[2];
+  uint8 	 active_scan_duration[2];
+  uint8 	 passive_scan_duration[2];
+  uint8    multi_probe;
+  //!Channel bitmap info
+  uint8    chan_bitmap_magic_code[2];
+  uint8    scan_chan_bitmap_stored_2_4_GHz[4];
+  uint8    scan_chan_bitmap_stored_5_GHz[4];
+  //!Roaming Params info
+  uint8    roam_magic_code[2];
+  rsi_uRoamParams  roam_params_stored;
+  //!rejoin params info
+  uint8    rejoin_magic_code[2];
+  rsi_rejoin_params_t rejoin_param_stored;
+  uint8     region_request_from_host;
+  uint8     rsi_region_code_from_host;
+  uint8     region_code;
+  uint8 	  reserved_4[43];
+  uint8     multicast_magic_code[2];
+  uint8     multicast_bitmap[2];
+  uint8     powermode_magic_code[2];
+  uint8     powermode;
+  uint8     ulp_mode;
+  uint8     wmm_ps_magic_code[2];
+  uint8     wmm_ps_enable;
+  uint8     wmm_ps_type;
+  uint8     wmm_ps_wakeup_interval[4];
+  uint8     wmm_ps_uapsd_bitmap;
+  uint8     listen_interval[4];
+  uint8     listen_interval_dtim;
+  
+  uint8     ext_custom_feature_bit_map[4];
+  uint8     private_key_password[82];
+  uint8     join_bssid[6];
+
+  //! Fast psp parameters
+  uint8      fast_psp_enable;
+  uint8      monitor_interval[2];
+
+  //! Request timeout parameters
+  uint8      req_timeout_magic_word[2];
+  uint8      timeout_value[2];
+  uint8      timeout_bitmap[4];
+
+  //! HT caps
+  rsi_uHtCaps ht_caps;
+  uint8      ht_caps_magic_word[2];
+
+  //! AP IP parameters in Concurrent mode
+  UINT8     dhcp_ap_enable;
+  UINT8     ap_ip[4]; /* Module IP address */
+  UINT8     ap_sn_mask[4]; /* Sub-net mask */
+  UINT8     ap_dgw[4]; /* Default gateway */
+
+  uint8     dhcp6_ap_enable[2]; /* DHCPv6 enable or disable */
+  UINT8     ap_prefix_length[2];/* Prefix length */
+  UINT8     ap_ip6[16];       /* Module IPv6 address */  
+  UINT8     ap_dgw6[16];       /* Module IPv6 address */
+  UINT8     ext_tcp_ip_feature_bit_map[4];
+  
+
+  /* HTTP/HTTPS Server credentials */
+  uint8 http_credentials_avail;
+  uint8 http_username[MAX_HTTP_SERVER_USERNAME];
+  uint8 http_password[MAX_HTTP_SERVER_PASSWORD];
+
+  /* WLAN CONFIGS*/
+  uint8      config_type[2];
+  uint8      config_value[2];
+
+}rsi_user_store_config_t, rsi_cfgGetFrameRcv;
+
+
+typedef struct {
+    uint8   dev_name[32];                         //@ All the characters are part of device name, no Null termination 
+} rsi_ConnAcceptRcv;
+
+
+/* PER stats response */
+typedef struct per_stats_s
+{
+   //! no. of tx pkts
+  uint8 tx_pkts[2];
+  //! no. of rx pkts
+  uint8 reserved_1[2];
+  //! no. of tx retries
+  uint8 tx_retries[2];
+  //! no. of pkts that pass crc
+  uint8 crc_pass[2];
+  //! no. of pkts failing crc chk
+  uint8 crc_fail[2];
+  //! no. of times cca got stuck
+  uint8 cca_stk[2];
+  //! no of times cca didn't get stuck
+  uint8 cca_not_stk[2];
+  //! no. of pkt aborts
+  uint8 pkt_abort[2];
+  //! no. of false rx starts
+  uint8 fls_rx_start[2];
+  //! cca idle time
+  uint8 cca_idle[2];
+  //! Reserved fields
+  uint8 reserved_2[26];
+  //! no. of rx retries
+  uint8 rx_retries[2];
+  //! rssi value
+  uint8 reserved_3[2];
+  //! cal_rssi
+  uint8 cal_rssi[2];
+  //! lna_gain bb_gain
+  uint8 reserved_4[4];
+	//! xretries pkts dropped
+  //! number of tx packets dropped after maximum retries 
+	uint8 xretries[2];
+	//! consecutive pkts dropped
+	uint8 max_cons_pkts_dropped[2];
+  uint8 reserved_5[2];
+  //! BSSID matched broadcast packets count
+  uint8 bss_broadcast_pkts[2];
+  //! BSSID matched multicast packets count
+  uint8 bss_multicast_pkts[2];
+  //! BSSID & multicast filter matched packets count
+  uint8 bss_filter_matched_multicast_pkts[2];
+
+}rsi_uPerStatsRsp;
+
+
+/* Card ready Response */
+typedef struct card_ready_s
+{
+  //! Boot loader checksum
+  uint8 bootloader_checksum[4];
+
+  //! Firmware checksum
+  uint8 firmware_checksum[4];
+}rsi_card_readyRsp;
+
+/* Store Config checksum Response */
+typedef struct store_config_chksum_s
+{
+  uint8 checksum[20];
+}rsi_store_config_checksumRsp;
+
+//! Generate DRBG random
+typedef struct generate_drbg_rand_s
+{
+  uint8 random_number[32];
+}rsi_generate_DRBGRandRsp;
+
+
+//! Socket configuration request frame
+typedef struct socket_config_s
+{
+  //! TCP TX + TCP RX + UDP TX + UDP RX
+  uint8 total_sockets; 
+
+  //! TCP TX + TCP RX
+  uint8 total_tcp_sockets;
+
+  //! UDP TX + UDP RX
+  uint8 total_udp_sockets;
+
+  //! TCP TX
+  uint8 tcp_tx_only_sockets;
+
+  //! TCP RX
+  uint8 tcp_rx_only_sockets;
+
+  //! UDP TX
+  uint8 udp_tx_only_sockets;
+
+  //! UDP RX
+  uint8 udp_rx_only_sockets;
+
+  //! TCP RX High Performance
+  uint8 tcp_rx_high_performance_sockets;
+  
+} rsi_socket_config_t;
+
+//! RF Current mode configuration 
+typedef struct rf_current_config_s
+{
+  //! RF RX current/Power mode
+  uint8 rf_rx_curr_mode;
+  //! RF TX current/Power mode
+  uint8 rf_tx_curr_mode;
+  //! RF TX strength in dbm
+  int16 rf_tx_dbm;
+} rsi_rf_current_config_t;
+
+/* PUF Setkey Response */
+typedef struct puf_setkey_s
+{
+	//! Key Code for set key
+    uint8 key_code[44];
+}rsi_puf_setkeyRsp;
+
+/* PUF Getkey Response */
+typedef struct puf_getkey_s
+{
+	//! Key for get key
+    uint8 key[32];
+}rsi_puf_getkeyRsp;
+
+/* AES Encrypt Response */
+typedef struct aes_encrypt_s
+{
+	//! Encrypted data
+    uint8 encryt_data[1400];
+}rsi_aes_encryptRsp;
+
+/* AES Decrypt Response */
+typedef struct aes_decrypt_s
+{
+	//! decrypted data
+    uint8 decryt_data[1400];
+}rsi_aes_decryptRsp;
+
+/* AES MAC Response */
+typedef struct aes_mac_s
+{
+	//! MAC data
+    uint8 mac[32];
+}rsi_aes_macRsp;
+
+//! FTP client
+#define FTP_USERNAME_LENGTH   31
+#define FTP_PASSWORD_LENGTH   31
+#define FTP_PATH_LENGTH       51
+#define FTP_MAX_CHUNK_LENGTH  1400
+
+typedef struct ftp_connect
+{
+  //! FTP client IP cersion
+  uint8 ip_version;
+
+  union
+  {
+    //! IPv4 address
+    UINT8  ipv4_address[4];
+
+    //! IPv6 address
+    UINT8  ipv6_address[16];
+  } server_ip_address;
+
+  //! FTP client username
+  uint8 username[FTP_USERNAME_LENGTH];
+
+  //! FTP client password
+  uint8 password[FTP_PASSWORD_LENGTH];
+
+  //! FTP server port 
+  uint8 server_port[4];
+} ftp_connect_t;
+
+typedef struct ftp_command
+{
+  //! Directory or file path
+  uint8 path[FTP_PATH_LENGTH];
+
+  //! New file name
+  uint8 new_file_name[FTP_PATH_LENGTH];
+} ftp_command_t;
+
+typedef struct ftp_file_write
+{
+  //! command type
+  uint8 command_type;
+
+  //! End of file
+  uint8 end_of_file;
+
+  //! Path of file to write
+  uint8 file_content[FTP_MAX_CHUNK_LENGTH];
+
+} rsi_ftp_file_write_t;
+
+typedef struct
+{
+  //! FTP command type
+  uint8              command_type;
+
+  union
+  {
+    //! structure for FTP connect
+    ftp_connect_t    ftp_connect;
+
+    //! Structure for other commands
+    ftp_command_t    ftp_command;
+
+  }ftp_client_struct;
+
+}rsi_ftp_client_t;
+
+typedef struct 
+{
+  UINT8  command_type;
+  UINT8  ip_version;
+  union
+  {
+    UINT8  ipv4_address[4];
+    UINT8  ipv6_address[16];
+  }server_ip_address;
+
+  UINT8  sntp_method;
+  UINT8  sntp_timeout[2];
+
+} rsi_sntp_client_t;
+
+
+/*
+ * SMTP client
+ */
+
+#define SMTP_CLIENT_CREATE              1
+#define SMTP_CLIENT_INIT                2
+#define SMTP_CLIENT_MAIL_SEND           3
+#define SMTP_CLIENT_DEINIT              4           
+
+
+/* Define for SMTP client initialization */
+
+typedef struct 
+{
+  //! SMTP server ip version
+  uint8 ip_version;
+
+  union
+  {
+    //! Server ipv4 address
+    uint8  ipv4_address[4];
+
+    //! Server ipv6 address
+    uint8  ipv6_address[16];
+
+  } server_ip_address;
+  
+  //! SMTP server authentication type
+  uint8  auth_type;
+
+  //! SMTP server port number
+  uint8 server_port[4];
+
+}  smtp_client_init_t;
+
+
+/* Define for SMTP client mail send */
+
+typedef struct 
+{
+  //! SMTP mail priority level
+  uint8 smtp_feature;
+
+  // SMTP client mail body length
+  uint8 smtp_client_mail_body_length[2];
+
+} smtp_mail_send_t;
+
+
+/* Define SMTP client structure */
+
+#define  RSI_SMTP_BUFFER_LENGTH  1024
+
+typedef struct 
+{
+  //! SMTP client command type
+  uint8 command_type;
+
+  //! SMTP client command structure
+  union
+  {
+    smtp_client_init_t  smtp_client_init;
+    smtp_mail_send_t    smtp_mail_send;
+  
+  } smtp_struct;
+
+  uint8  smtp_buffer[RSI_SMTP_BUFFER_LENGTH];
+
+} rsi_smtp_client_t;
+
+
+/*
+ * HTTP PUT client
+ */
+
+#define HTTP_CLIENT_PUT_CREATE 1
+#define HTTP_CLIENT_PUT_START  2
+#define HTTP_CLIENT_PUT_PACKET 3
+#define HTTP_CLIENT_PUT_DELETE 4
+#define RSI_HTTP_CLIENT_PUT_BUFFER_LENGTH  900
+
+/* Define for HTTP PUT client initialization */
+
+typedef struct  rsi_http_client_put_start_t
+{
+	//! HTTP server ip version
+	uint8 ip_version;
+
+	//! HTTPS bit map
+	uint8 https_enable[2];
+
+	//! HTTP server port number
+	uint8 port_number[4];
+
+	//! HTTP Content Length
+	uint8 content_length[4];
+
+} rsi_http_client_put_start_t;
+
+/* Define for HTTP PUT client current length */
+
+
+typedef struct rsi_http_client_put_data_req_t
+{
+	//! Current chunk length
+	uint8 current_length[2];
+
+} rsi_http_client_put_data_req_t;
+
+/* Define for HTTP PUT client structure  */
+
+
+typedef struct  rsi_http_client_put_req_s
+{
+	//! Command type
+	uint8  command_type;
+
+	union
+	{
+		rsi_http_client_put_start_t http_client_put_start;
+		rsi_http_client_put_data_req_t http_client_put_data_req;
+
+	}  http_client_put_struct;
+
+	uint8 http_put_buffer[RSI_HTTP_CLIENT_PUT_BUFFER_LENGTH];
+} rsi_http_client_put_req_t;
+
+
+
+/*
+ * POP3 client
+ */
+
+
+#define POP3_CLIENT_MAX_USERNAME_LENGTH   101
+#define POP3_CLIENT_MAX_PASSWORD_LENGTH   101
+
+//! POP3 client commands
+#define POP3_CLIENT_SESSION_CREATE              1
+#define POP3_CLIENT_GET_MAIL_STATS              2
+#define POP3_CLIENT_GET_MAIL_LIST               3
+#define POP3_CLIENT_RETR_MAIL                   4           
+#define POP3_CLIENT_MARK_MAIL                   5           
+#define POP3_CLIENT_UNMARK_MAIL                 6            
+#define POP3_CLIENT_GET_SERVER_STATUS           7           
+#define POP3_CLIENT_SESSION_DELETE              8
+
+
+typedef struct pop3_client_session_create
+{
+    //! POP3 server ip version
+  uint8 ip_version;
+
+  union
+  {
+    //! Server ipv4 address
+    uint8  ipv4_address[4];
+
+    //! Server ipv6 address
+    uint8  ipv6_address[16];
+
+  } server_ip_address;
+
+  //! POP3 server port number
+  uint8 server_port_number[2];
+
+  //! POP3 client authentication type
+  uint8 auth_type;
+
+  //! POP3 client username
+  uint8 username[POP3_CLIENT_MAX_USERNAME_LENGTH];
+
+  //! POP3 client password
+  uint8 password[POP3_CLIENT_MAX_PASSWORD_LENGTH];
+
+} pop3_client_session_create_t;
+
+typedef struct {
+
+  //! POP3 client command type
+  uint8 command_type;
+
+  //! POP3 client command structure
+
+  union
+  {
+    //! POP3 client session create structure
+    pop3_client_session_create_t  pop3_client_session_create;
+
+    //! POP3 client mail index
+    uint8     pop3_client_mail_index[2];
+
+  } pop3_struct;
+
+} rsi_pop3_client_t;
+
+
+typedef struct  rsi_pop3_rsp_s
+{
+
+  uint8 command_type;
+
+  //! Total number of mails
+  uint8  mail_count[2];
+
+  //! Total size of all the mails
+  uint8  size[4];
+
+} rsi_pop3_rsp_t;
+
+
+typedef struct  rsi_pop3_mail_data_resp_s
+{
+  //! Type of the POP3 client command
+  uint8 command_type;
+
+  //! More data pending flag
+  uint8 more;
+
+  //! Length the mail chunk
+  uint8 length[2];
+  
+  //! Data buffer
+  uint8  data[1000];
+
+} rsi_pop3_mail_data_resp_t;
+
+
+/** Contains all the TCP, IP, ICMP and UDP related statistics.
+ */
+typedef struct rsi_snmp_stats_s
+{
+    unsigned long       rsi_total_packet_send_requests;
+    unsigned long       rsi_total_packets_sent;
+    unsigned long       rsi_total_bytes_sent;
+    unsigned long       rsi_total_packets_received;
+    unsigned long       rsi_total_packets_delivered;
+    unsigned long       rsi_total_bytes_received;
+    unsigned long       rsi_packets_forwarded;
+    unsigned long       rsi_packets_reassembled;
+    unsigned long       rsi_reassembly_failures;
+    unsigned long       rsi_invalid_packets;
+    unsigned long       rsi_invalid_transmit_packets;
+    unsigned long       rsi_invalid_receive_address;
+    unsigned long       rsi_unknown_protocols_received;
+    unsigned long       rsi_transmit_resource_errors;
+    unsigned long       rsi_transmit_no_route_errors;
+    unsigned long       rsi_receive_packets_dropped;
+    unsigned long       rsi_receive_checksum_errors;
+    unsigned long       rsi_send_packets_dropped;
+    unsigned long       rsi_total_fragment_requests;
+    unsigned long       rsi_successful_fragment_requests;
+    unsigned long       rsi_fragment_failures;
+    unsigned long       rsi_total_fragments_sent;
+    unsigned long       rsi_total_fragments_received;
+
+    unsigned long       rsi_arp_requests_sent;
+    unsigned long       rsi_arp_requests_received;
+    unsigned long       rsi_arp_responses_sent;
+    unsigned long       rsi_arp_responses_received;
+    unsigned long       rsi_arp_aged_entries;
+    unsigned long       rsi_arp_invalid_messages;
+    unsigned long       rsi_arp_static_entries;
+
+    unsigned long       rsi_udp_packets_sent;
+    unsigned long       rsi_udp_bytes_sent;
+    unsigned long       rsi_udp_packets_received;
+    unsigned long       rsi_udp_bytes_received;
+    unsigned long       rsi_udp_invalid_packets;
+    unsigned long       rsi_udp_no_port_for_delivery;
+    unsigned long       rsi_udp_receive_packets_dropped;
+    unsigned long       rsi_udp_checksum_errors;
+
+    unsigned long       rsi_tcp_packets_sent;
+    unsigned long       rsi_tcp_bytes_sent;
+    unsigned long       rsi_tcp_packets_received;
+    unsigned long       rsi_tcp_bytes_received;
+    unsigned long       rsi_tcp_invalid_packets;
+    unsigned long       rsi_tcp_receive_packets_dropped;
+    unsigned long       rsi_tcp_checksum_errors;
+    unsigned long       rsi_tcp_connections;
+    unsigned long       rsi_tcp_passive_connections;
+    unsigned long       rsi_tcp_active_connections;
+    unsigned long       rsi_tcp_disconnections;
+    unsigned long       rsi_tcp_connections_dropped;
+    unsigned long       rsi_tcp_retransmit_packets;
+    unsigned long       rsi_tcp_resets_received;
+    unsigned long       rsi_tcp_resets_sent;
+
+    unsigned long       rsi_icmp_total_messages_received;
+    unsigned long       rsi_icmp_checksum_errors;
+    unsigned long       rsi_icmp_invalid_packets;
+    unsigned long       rsi_icmp_unhandled_messages;
+    unsigned long       rsi_pings_sent;
+    unsigned long       rsi_ping_timeouts;
+    unsigned long       rsi_ping_threads_suspended;
+    unsigned long       rsi_ping_responses_received;
+    unsigned long       rsi_pings_received;
+    unsigned long       rsi_pings_responded_to;
+
+    unsigned long       rsi_igmp_invalid_packets;
+    unsigned long       rsi_igmp_reports_sent;
+    unsigned long       rsi_igmp_queries_received;
+    unsigned long       rsi_igmp_checksum_errors;
+    unsigned long       rsi_igmp_groups_joined;
+
+    unsigned long       rsi_icmp_total_messages_sent;
+
+} rsi_snmp_stats_t;
+
+
+typedef struct {
+    uint8   rspCode[2];
+    uint8   status[2];                  
+    //@ 0- For Success ,Non-Zero Value is the Error Code return
+    union {
+      //@ response payload    
+      rsi_qryMacFrameRcv              qryMacaddress;
+      rsi_initResponse                initResponse;          
+      rsi_scanResponse                scanResponse;
+      rsi_joinResponse                joinResponse;
+      rsi_PmkResponse                 PmkResponse;   
+      rsi_wfdDevResponse              wfdDevResponse;
+      rsi_rssiFrameRcv                rssiFrameRcv;
+      rsi_socketFrameRcv              socketFrameRcv;
+      rsi_socketCloseFrameRcv         socketCloseFrameRcv;
+      rsi_ipparamFrameRcv             ipparamFrameRcv;
+      rsi_recvIpChange                recvIpchange;
+      rsi_ipconf6FrameRcv             ipconf6FrameRcv;
+      rsi_conStatusFrameRcv           conStatusFrameRcv;
+      rsi_qryNetParmsFrameRcv         qryNetParmsFrameRcv;
+      rsi_qryGOParamsFrameRcv         qryGoParamsFrameRcv;
+      rsi_qryIPGOParamsFrameRcv       qryIPGoParamsFrameRcv;
+      rsi_qryFwversionFrameRcv        qryFwversionFrameRcv;
+      rsi_dnsserverResponse           dnsserverresponse;    
+      rsi_recvFrameUdp                recvFrameUdp;
+      rsi_recvFrameTcp                recvFrameTcp;  
+      rsi_recvFrameUdp6               recvFrameUdp6;
+      rsi_recvFrameTcp6               recvFrameTcp6; 
+      rsi_recvRemTerm                 recvRemTerm;
+      rsi_recvLtcpEst                 recvLtcpEst;
+      TCP_EVT_DNS_Query_Resp          dnsqryresponse;
+      rsi_snrFrameRcv                 snrFrameRcv;    
+      rsi_cfgGetFrameRcv              cfgGetFrameRcv;
+      rsi_LtcpConnStatusFrameRcv      LtcpConnStatRcv;
+      rsi_urlReqFrameRcv              urlReqRcv;
+      rsi_p2p_conn_req_t              dev_req;
+      rsi_ConnAcceptRcv               ConnectReqRcv;
+      rsi_snmp_set                    snmp_set;
+      rsi_wpsMethodFrameRcv           wpsMethodFrameRcv;
+      rsi_state_notificaton_t         stateFrameRcv;
+      rsi_uHttpRsp                    httpFrameRcv;
+      rsi_uSetRegionRsp               setRegFrameRcv;
+      rsi_uPingRsp                    rsi_pingFrameRcv;
+      rsi_uPerStatsRsp                rsi_perFrameRcv;
+      rsi_card_readyRsp               rsi_card_readyRcv;
+      rsi_store_config_checksumRsp    rsi_cfg_chksumRcv;
+      rsi_generate_DRBGRandRsp        rsi_generateDRBGrandRcv; 
+      rsi_sentBytesRsp                SentBytes;
+      rsi_ftp_rsp_t                   ftpFrameRcv;
+      rsi_puf_setkeyRsp				        setkeyFrameRcv;
+      rsi_puf_getkeyRsp				        getkeyFrameRcv;
+      rsi_aes_encryptRsp				      aesEncryptedFrameRcv;
+      rsi_aes_decryptRsp				      aesDecryptedFrameRcv;
+      rsi_aes_macRsp					        aesMacFrameRcv;
+      rsi_sntp_rsp_t                  sntpFrameRcv;
+      rsi_sntp_server_rsp_t           sntp_ServerFrameRcv;
+      rsi_sntp_server_info_rsp_t      sntpServerInfoRcv;
+      rsi_mdns_rsp_t                  mdnsFrameRcv;
+      rsi_smtp_rsp_t                  smtpFrameRcv;
+      rsi_http_client_put_rsp_t       httpClientPutFrameRcv;
+      rsi_pop3_rsp_t                  pop3CmdFrameRcv;
+      rsi_pop3_mail_data_resp_t       pop3MailContentRcv;
+      rsi_snmp_stats_t                snmpStats;
+      uint8                           uCmdRspBuf[RSI_MAX_PAYLOAD_SIZE];
+    }uCmdRspPayLoad;
+} rsi_uCmdRsp;
+
+
+/*===================================================*/
+/**
+ * Interrupt Handeling Structure
+ */
+typedef struct {
+    uint8   mgmtPacketPending;                    //@ TRUE for management packet pending in module
+    uint8   dataPacketPending;                    //@TRUE for data packet pending in module
+    uint8   powerIrqPending;                      //@ TRUE for power interrupt pending in the module
+    uint8   bufferFull;                           //@ TRUE=Cannot send data, FALSE=Ok to send data
+    uint8   bufferEmpty;                          //@TRUE, Tx buffer empty, seems broken on module
+    uint8   isrRegLiteFi;
+} rsi_intStatus;
+
+
+
+
+/*==============================================*/
+
+typedef struct {
+      uint8    *ptrRecvBuf;                       //@ Location of the payload data
+      uint8    recvBufLen[4];                        //@ Length of the payload data
+      int      recvType;                          //@ Whether this receive event was a remote disconnect or read data
+      uint8    socketNumber[2];                   //@ The socket number the event is associated with
+} recvArgs;
+
+
+
+
+/*==================================================*/
+/**
+ * This structure maintain power save state.
+ *
+ */ 
+typedef struct {
+    uint8   current_mode;
+    uint8   ack_pwsave;
+    uint8   sleep_received;
+    uint8   ack_sent;
+}rsi_powerstate;
+
+//! Debug Print Levels
+#define RSI_DEBUG_LVL         0x00ff
+//! These bit values may be ored to all different combinations of debug printing
+#define RSI_PL0                0xffff
+#define RSI_PL1                0x0001
+#define RSI_PL2                0x0002
+#define RSI_PL3                0x0004
+#define RSI_PL4                0x0008
+#define RSI_PL5                0x0010
+#define RSI_PL6                0x0020
+#define RSI_PL7                0x0040
+#define RSI_PL8                0x0080
+#define RSI_PL9                0x0100
+#define RSI_PL10               0x0200
+#define RSI_PL11               0x0400
+#define RSI_PL12               0x0800
+#define RSI_PL13               0x1000
+#define RSI_PL14               0x2000
+#define RSI_PL15               0x4000
+#define RSI_PL16               0x8000
+
+//#define RSI_DPRINT(lvl, fmt, args)              if (lvl & DEBUG_LVL) printf(fmt, ##args)
+
+
+
+enum RSI_INTERRUPT_TYPE {
+    RSI_TXBUFFER_FULL       = 0x01,
+    RSI_TXBUFFER_EMPTY      = 0x02,
+    RSI_MGMT_PENDING        = 0x04,
+    RSI_DATA_PENDING        = 0x08,
+    RSI_PWR_MODE            = 0x10
+};
+
+/**
+ * Enumerations
+ */
+enum RSI_PROTOCOL {
+    RSI_PROTOCOL_UDP_V4     = 0x00,
+    RSI_PROTOCOL_TCP_V4     = 0x01,
+    RSI_PROTOCOL_UDP_V6     = 0x02,
+    RSI_PROTOCOL_TCP_V6     = 0x03
+};
+
+#define BUFFER_FULL_FAILURE -3
+
+/* Status indications */
+#define BUFFER_FULL     0x01
+#define BUFFER_EMPTY    0x02
+#define RX_PKT_PENDING  0x08
+#define POWER_SAVE      0x08
+
+
+
+#define RSI_STATUS_OFFSET         12
+#define RSI_TWOBYTE_STATUS_OFFSET 12 
+#define RSI_RSP_TYPE_OFFSET       2
+
+extern struct SET_CHUNK_S set_chunks;
+extern rsi_wfdDevResponse wfdDevData;
+extern uint32   interrupt_rcvd;
+
+#ifdef RSI_HAL
+#include "rsi_hal.h"
+#endif
+#include "platform_specific.h"
+#include "rsi_config.h"
+#include "rsi_api.h"
+#ifdef LINUX_PLATFORM
+#include "string.h"
+#endif
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_lib_util.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_lib_util.h
new file mode 100755
index 0000000..cf63612
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include/rsi_lib_util.h
@@ -0,0 +1,31 @@
+/**
+ * @file     rsi_lib_util.h
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER UTIL: Util Header file, the things that are used in the library 
+ *
+ * @section Description
+ * This is the util.h file for the utility functions used by library.
+ * Contains prototypes of utils used in rsi_lib_util.c
+ *
+ */
+
+
+#ifndef _RSILIBUTIL_H_
+#define _RSILIBUTIL_H_
+
+#include "rsi_global.h"
+
+void rsi_uint32_to_4bytes(uint8 *dBuf, uint32 val);
+void rsi_uint16_to_2bytes(uint8 *dBuf, uint16 val);
+uint16 rsi_bytes2R_to_uint16(uint8 *dBuf);
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/Makefile b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/Makefile
new file mode 100644
index 0000000..6c66dd6
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/Makefile
@@ -0,0 +1,25 @@
+######################################################################
+#                                                                    #
+#   Makefile                                                         #
+#                                                                    #
+#   2016/09/29 Create(AlphaProject)                                  #
+#                                                                    #
+######################################################################
+
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include
+EXTRA_CFLAGS += -DRSI_HAL
+
+obj-$(CONFIG_WMRP10_SPI) += rsi_wlan_core_all.o
+
+rsi_wlan_core_all-objs := rsi_api.o rsi_band.o rsi_bg_scan.o rsi_bootup_config.o rsi_build_frame_descriptor.o rsi_bytes_sent_count.o rsi_cfg_enable.o rsi_cfg_get.o rsi_cfg_save.o rsi_debug_prints.o rsi_disconnect.o rsi_dns_query.o rsi_dns_server.o rsi_execute_cmd.o rsi_host_rtc_time.o rsi_ht_caps.o rsi_init.o rsi_join.o rsi_lib_util.o rsi_oper_mode.o rsi_p2p_config.o rsi_per_mode.o rsi_per_stats.o rsi_power_mode.o rsi_psk.o rsi_query_conn_status.o rsi_query_fw_version.o rsi_query_go_parms.o rsi_query_mac_address.o rsi_query_net_parms.o rsi_query_rssi.o rsi_rejoin_params.o rsi_rf_current_mode.o rsi_roam_params.o rsi_scan.o rsi_select_antenna.o rsi_send_boot_insn.o rsi_send_raw_data.o rsi_set_ap_config.o rsi_set_certificate.o rsi_set_eap.o rsi_set_mac_addr.o rsi_set_region.o rsi_set_region_ap.o rsi_set_wepkey.o rsi_sleep_timer.o rsi_sys_init.o rsi_trigger_auto_config.o rsi_user_store_config.o rsi_wireless_fwupgrade.o rsi_wmm_ps.o rsi_wps_method.o rsi_config.o rsi_timeout.o
+
+# rsi_dhcp_usr_cls.o rsi_dns_update.o rsi_fwup_frm_host.o rsi_gpio_config.o rsi_http_client_put.o rsi_ota_fw_up.o rsi_query_snr.o rsi_read_data.o rsi_register_interrupt_irq.o rsi_send_websocket_data.o rsi_snmp_get_stats.o rsi_trigger_auto_config.o rsi_uart_flow_control.o rsi_web_fields.o
+
+# rsi_ftp_client.o rsi_http_abort.o rsi_http_credentials.o rsi_http_get.o rsi_http_post.o rsi_http_post_data.o rsi_ip_param_set.o rsi_ipv6_param_set.o rsi_json_create.o rsi_json_erase_file.o rsi_load_web_page.o rsi_ltcp_conn_status.o rsi_mdns_sd.o rsi_multicast.o rsi_multicast_filter.o rsi_ping_request.o rsi_pop3_client.o rsi_send_data.o rsi_send_ludp_data.o rsi_send_url_rsp.o rsi_smtp_client.o rsi_snmp_enable.o rsi_snmp_get_next_rsp.o rsi_snmp_get_rsp.o rsi_snmp_trap.o rsi_sntp_client.o rsi_socket.o rsi_socket_close.o rsi_socket_config.o rsi_webpage_clear_files.o rsi_webpage_erase_file.o
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_api.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_api.c
new file mode 100755
index 0000000..4df327a
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_api.c
@@ -0,0 +1,218 @@
+/**
+ * @file     rsi_api.c
+ * @version  3.6
+ * @date     2013-May-10
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief API: Definitions of various data structures and variables
+ * 
+ * @section Description
+ * This file contain definition of different mangament, control & data commands variables.
+ * These definition are used to construct frames. 
+ *
+ * @section Improvements
+ * New command frames are added.
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_api.h"
+
+
+/**
+ * Global Variables
+ */
+
+/* In the 3 bytes,  
+ * BYTE0[0:7],BYTE1[0:3] together represents length of the payload for the frame command
+ * BYTE1[4:6], indicates queue number 100 - Management,101 - Data
+ * BYTE1[7], Reserved
+ * BYTE2 represents the Frame command type. 
+ */
+
+/*Management Commands */
+/* Debug prints enable */
+const uint8   rsi_frameCmdDebug[RSI_BYTES_3] = {0x08,  0x40, 0x26};
+/* Bootup_cmds */
+const uint8   rsi_frameCmdBootInsn[RSI_BYTES_3] = {0x00,  0x00, 0xFF};
+/* Update Info cmd/message */
+const uint8   rsi_frameCmdUpdateInfo[RSI_BYTES_3] = {0x00,  0x00, 0xE1};
+/* set Operating mode frame */ 
+const uint8   rsi_frameCmdOperMode[RSI_BYTES_3] = {0x1C,  0x40, 0x10};
+/*Band frame*/
+const uint8   rsi_frameCmdBand[RSI_BYTES_3] = {0x01,  0x40, 0x11};
+/* Configuration frame */
+const uint8   rsi_frameCmdConfig[RSI_BYTES_3] = {0x04,  0x40, 0xC6};
+/*Init frame*/
+const uint8   rsi_frameCmdInit[RSI_BYTES_3] = {0x00, 0x40, 0x12};
+/* Scan frame */
+const uint8   rsi_frameCmdScan[RSI_BYTES_3] = {0x32, 0x40, 0x13 };    
+/* Scan frame */
+const uint8   rsi_frameCmdBGScan[RSI_BYTES_3] = {0x0F, 0x40, 0x6a };    
+/* Join Frame */
+const uint8   rsi_frameCmdJoin[RSI_BYTES_3] = {0x75, 0x40, 0x14 };
+
+
+/* PSK mode frame */
+const uint8   rsi_frameCmdPsk[RSI_BYTES_3] = {0x63, 0x40, 0xa5 };
+
+/* Power mode frame */
+const uint8   rsi_frameCmdPower[RSI_BYTES_3] = {0x06, 0x40, 0x15 };    
+/* Set Mac Address frame */
+const uint8   rsi_frameCmdSetMacAddr[RSI_BYTES_3] = {0x06, 0x40, 0x17};    
+/* Query Network Parameters frame */
+const uint8   rsi_frameCmdQryNetParms[RSI_BYTES_3] = {0x00, 0x40, 0x18};    
+/* Disconnect frame */
+const uint8   rsi_frameCmdDisconnect[RSI_BYTES_3] = {0x08, 0x40, 0x19};    
+/* RSSI frame */
+const uint8   rsi_frameCmdRssi[RSI_BYTES_3] = {0x00, 0x40, 0x3A}; 
+/* Antenna selection Frame */
+const uint8   rsi_frameCmdAntSel[RSI_BYTES_3] = {0x05, 0x40, 0x1B};
+/* Sleep timer Frame */
+const uint8   rsi_frameCmdSleepTimer[RSI_BYTES_3] = {0x02, 0x40, 0x16};   
+/* AP configuration frame */
+const uint8   rsi_frameCmdAPconf[RSI_BYTES_3] = {0x6E, 0x40, 0x24};
+/* WEP Key configuration frame*/
+const uint8   rsi_frameCmdWepkey[RSI_BYTES_3] = {0x82, 0x40, 0x25};
+/* Reset the module */
+const uint8   rsi_frameCmdReset[RSI_BYTES_3] = {0x00, 0x40, 0x1C};
+/* Ping Request */
+const uint8   rsi_frameCmdPingRequest[RSI_BYTES_3]={0x16, 0x40, 0x29};
+
+/*Gpio configuation request*/
+const uint8   rsi_frameCmdGpioconf[RSI_BYTES_3]={0x04, 0x40, 0x28};
+
+/* IP parameters frame */
+const uint8   rsi_frameCmdIpparam[RSI_BYTES_3] = {0x31, 0x40, 0x41};    
+/* Socket creation frame */
+const uint8   rsi_frameCmdSocket[RSI_BYTES_3] = {0x8D, 0x40, 0x42};    
+/* Socket close frame */
+const uint8   rsi_frameCmdSocketClose[RSI_BYTES_3] = {0x04, 0x40, 0x43};    
+/* Connection status query frame */
+const uint8   rsi_frameCmdConnStatus[RSI_BYTES_3] = {0x00, 0x40, 0x48};    
+/* Firmware version query frame */
+const uint8   rsi_frameCmdQryFwVer[RSI_BYTES_3] = {0x00, 0x40, 0x49};    
+/*Query mac adress frame */ 
+const uint8   rsi_frameCmdQryMacAddress[RSI_BYTES_3]= {0x00 , 0x40, 0x4A};
+/* P2p Config frame */
+const uint8   rsi_frameCmdP2pConfig[RSI_BYTES_3] = {0xC4, 0x40, 0x4B};
+/* Set eap parameters frame */
+const uint8   rsi_frameCmdSetEap[RSI_BYTES_3]    = {0x56, 0x41, 0x4C};
+/* Certificate loading frame */
+const uint8   rsi_frameCmdCert[RSI_BYTES_3] = {0x00, 0x40, 0x4D};
+/*Query GO parametes frame */
+const uint8   rsi_frameCmdQryGoParms[RSI_BYTES_3] = {0x00, 0x40, 0x4E};
+/* set Web  fields frame */
+const uint8   rsi_frameCmdWebFields[RSI_BYTES_3] = {0xA8, 0x42, 0x4F};
+/* DNS server */
+const uint8   rsi_frameCmdDnsServer[RSI_BYTES_3] = {0X24, 0x40, 0X55};
+/* DNS query */
+const uint8   rsi_frameCmdDnsQuery[RSI_BYTES_3] = {0x5E , 0x40 , 0x44 };
+/* DHCP USER CLASS*/
+const uint8   rsi_frameCmdDHCPUsrCls[RSI_BYTES_3] = {0x84 , 0x40 , 0xEC };
+/* Cfg save frame */
+const uint8   rsi_frameCmdCfgSave[RSI_BYTES_3] = {0x00, 0x40, 0x20};
+/*Cfg enable frame*/
+const uint8   rsi_frameCmdCfgEnable[RSI_BYTES_3] = {0x01,  0x40, 0x21};
+/* Cfg get frame */
+const uint8   rsi_frameCmdCfgGet[RSI_BYTES_3] = {0x00, 0x40, 0x22};
+/* Feature select */
+const uint8   rsi_frameCmdFeatsel[RSI_BYTES_3] = {0x04,  0x40, 0x1E};
+/* SNR query */
+const uint8   rsi_frameCmdSnr[RSI_BYTES_3] = {0x00, 0x40, 0x1F};
+/* LTCP Connection status query*/
+const uint8   rsi_frameCmdLtcpConnStatus[RSI_BYTES_3] = {0x2, 0x40, 0x46};
+/* Sent bytes count query*/
+const uint8   rsi_frameCmdSentBytesCount[RSI_BYTES_3] = {0x2, 0x40, 0xB2};
+/* URL response Frame */
+const uint8   rsi_frameCmdUrlRsp[RSI_BYTES_3] = {0x05, 0x44, 0x56};
+/* Multicast filter response Frame */
+const uint8   rsi_frameCmdMcastFilter[RSI_BYTES_3] = {0x02, 0x40, 0x40};
+
+/*Wireless firmware upgrade frame */
+const uint8   rsi_frameCmdWirelessFwUpgrade[RSI_BYTES_3] = {0x00, 0x40, 0x59};
+
+/*SNMP enable Response frame*/
+const uint8   rsi_frameCmdSnmpEnable[RSI_BYTES_3] = {0x01, 0x40, 0x85};
+/*SNMP get response Response frame*/
+const uint8   rsi_frameCmdSnmpGetRsp[RSI_BYTES_3] = {0x4C, 0x41, 0x83};
+/*SNMP get stats*/
+const uint8   rsi_frameCmdSnmpGetStats[RSI_BYTES_3] = {0x00, 0x40, 0x88};
+/*SNMP get next response Response frame*/
+const uint8   rsi_frameCmdSnmpGetNextRsp[RSI_BYTES_3] = {0x4C, 0x41, 0x84};
+/* IPCONFIG6 for IPV6 */
+const uint8   rsi_frameCmdIPconf6[RSI_BYTES_3] = {0x24, 0x40, 0x90};
+/* Rejoin Params response Frame */
+const uint8   rsi_frameCmdRejoinParams[RSI_BYTES_3] = {0x10, 0x40, 0x6F};
+
+/* Data Commands */
+const uint8   rsi_frameCmdSend[RSI_BYTES_3] = {0x00, 0x50, 0x00};     
+const uint8   rsi_frameCmdRecv[RSI_BYTES_3] = {0x00, 0x50, 0x00};    
+/* Length comes from the received frame descriptor */
+
+/* Roaming parameter frame command */
+const uint8   rsi_frameCmdRoamParams[RSI_BYTES_3] = {0x0C, 0x40, 0x7B};
+
+//HT CAPS parameters frame 
+const uint8   rsi_frameCmdHtCaps[RSI_BYTES_3] = {0x04, 0x40, 0x6D};
+
+//WMM PS parameters frame 
+const uint8   rsi_frameCmdWmmPs[RSI_BYTES_3] = {0x09, 0x40, 0x97};
+
+//WPS method parameters frame 
+const uint8   rsi_frameCmdWpsMethod[RSI_BYTES_3] = {0x0C, 0x40, 0x72};
+
+//Multicast method parameters frame 
+const uint8   rsi_frameCmdMulticast[RSI_BYTES_3] = {0x14, 0x40, 0xB1};
+
+// PER MODE
+const uint8   rsi_frameCmdPerMode[RSI_BYTES_3] = {0x1c, 0x40, 0x7c};
+
+// PER STATS 
+const uint8   rsi_frameCmdPerStats[RSI_BYTES_3] = {0x4, 0x40, 0xA2};
+//! UART flow control Enable
+const uint8   rsi_frameCmdUartFlowControl[RSI_BYTES_3] = {0x01, 0x40, 0xA4};
+
+/* Power save sleep ack */
+const uint8   rsi_sleepack[RSI_BYTES_3] = {0x00, 0x40, 0xDE}; 
+
+/* Management Response list */
+const uint8   rsi_mgmtRspList[] = {0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x64}; 
+/* 9 bytes, list of management frame response codes */
+
+// JSON & Webpage related
+const uint8  rsi_frameCmdWebpageClearFiles[RSI_BYTES_3] = { 0x01, 0x40, 0x7F};
+const uint8  rsi_frameCmdWebpageEraseFile[RSI_BYTES_3]  = { 0x18, 0x40, 0x9A};
+const uint8  rsi_frameCmdJSONCreate[RSI_BYTES_3]        = { 0x1C, 0x44, 0x9C};
+const uint8  rsi_frameCmdJSONEraseFile[RSI_BYTES_3]     = { 0x18, 0x40, 0x9B};
+
+/*Set region frame*/
+const uint8   rsi_frameSetRegion[RSI_BYTES_3]           = {0x04, 0x40, 0x1D};
+
+const uint8	  rsi_frameCmdUserStoreCfg[RSI_BYTES_3]     = {0x0D, 0x45, 0x23};
+
+/*Set Region frame for AP mode*/
+const uint8   rsi_frameSetRegionAp[RSI_BYTES_3] = {0x50, 0x40, 0xBD};
+
+/* RF Current Mode Configuration */
+const uint8   rsi_frameCmdRFCurConfig[RSI_BYTES_3] = {0x04, 0x40, 0xAD};
+
+/* Socket configuration */
+const uint8   rsi_frameSocketConfig[RSI_BYTES_3] = {0x8, 0x40, 0xA7};
+
+/* set rtc time from host frame frame */ 
+const uint8   rsi_frameCmdRtcTime[RSI_BYTES_3] = {0x18,  0x40, 0xe9};
+
+/* set timeout value frame */
+const uint8   rsi_frameCmdTimeout[RSI_BYTES_3] = {0x06,  0x40, 0xea};
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_band.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_band.c
new file mode 100755
index 0000000..d5bb915
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_band.c
@@ -0,0 +1,61 @@
+/**
+ * @file     rsi_band.c
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief BAND: Sets the BAND value 
+ *
+ * @section Description
+ * This file contains the Band function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_band(uint8 band)
+ * @brief       Sends the Band command to the Wi-Fi module
+ * @param[in]   uint8 band, band value to configure,0 for 2.4GHz and 1 for 5GHz.
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to select the 2.4 GHz mode or 5GHz mode. 
+ * which have an option of operating in either the 2.4GHz or 5GHz modes. 
+ * in the 2.4GHz mode. This API has to be called only after the rsi_opermode API.
+ */
+int16 rsi_band(uint8 band)
+{
+  int16               retval;
+  rsi_uBand           uBandFrame;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\nBand Start");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %s %1.1fGHz\n","WLAN","Tx","Set Band Req","Set Band ",(band==0?2.4:5.0));
+#endif
+  uBandFrame.bandFrameSnd.bandVal = band;
+  retval =rsi_execute_cmd((uint8 *)rsi_frameCmdBand,(uint8 *)&uBandFrame, sizeof(rsi_uBand));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_bg_scan.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_bg_scan.c
new file mode 100755
index 0000000..00b6e89
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_bg_scan.c
@@ -0,0 +1,67 @@
+/**
+ * @file     rsi_bg_scan.c
+ * @version  1.0
+ * @date     2014-Jan-07
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief BG SCAN: Back ground Scans for available access points
+ *
+ * @section Description
+ * This file contains the BG Scan function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *
+ * @fn          int16 rsi_bg_scan(rsi_ubgScan *ubgScanFrame)
+ * @brief       Sends the BG Scan command to the Wi-Fi module
+ * @param[in]   rsi_ubgScan *ubgScanFrame,Pointer to BG scan structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to BG scan for Access Points. This API should be called only 
+ * after the rsi_join API.
+ *
+ * @section prerequisite 
+ * rsi_join should be done successfully  
+ */
+
+int16 rsi_bg_scan(rsi_ubgScan *ubgScanFrame)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nBG Scan Start ");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdBGScan, (uint8 *)ubgScanFrame, sizeof(rsi_ubgScan));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_bootup_config.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_bootup_config.c
new file mode 100755
index 0000000..28e953c
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_bootup_config.c
@@ -0,0 +1,294 @@
+/**
+ * @file     rsi_bootup_config.c
+ * @version  1.0
+ * @date     2014-Apr-13
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief BOOTUP: Bootup configuration file 
+ *
+ * @section Description
+ * This file contains the Bootup functionality.
+ * @functions Defined: 
+ * rsi_waitfor_boardready
+ * rsi_select_option
+ * rsi_upgrade_fw
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_api.h"
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_waitfor_boardready(void)
+ * @brief       Waits to receive board ready from WiFi module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              0  = SUCCESS
+ *              < 0 = Failure 
+ *              -3 = Board ready not received
+ *              -4 = Bootup options last configuration not saved
+ *              -5 = Bootup options checksum failed
+ *              -6 = Bootloader version mismatch 
+ * @section description 
+ * This API is used to check board ready from WiFi module.
+ */
+#if (defined(USB_INTERFACE) || defined(SPI_INTERFACE))
+int16 rsi_waitfor_boardready(void)
+{
+  int16 retval = 0;
+  uint16 read_value = 0;
+
+  retval = rsi_boot_insn(REG_READ, &read_value);
+  
+
+  if(retval < 0)
+  {
+    return retval;
+  }
+  if ((read_value & 0xFF00) == (HOST_INTERACT_REG_VALID & 0xFF00))
+  {
+    if((read_value & 0xFF) == BOOTUP_OPTIONS_LAST_CONFIG_NOT_SAVED)
+    {
+#ifdef RSI_DEBUG_PRINT      
+      RSI_DPRINT(RSI_PL3,"BOOTUP OPTIOINS LAST CONFIGURATION NOT SAVED\n");
+#endif
+      return -4;
+    }
+    else if((read_value & 0xFF) == BOOTUP_OPTIONS_CHECKSUM_FAIL)
+    {
+#ifdef RSI_DEBUG_PRINT      
+      RSI_DPRINT(RSI_PL3,"BOOTUP OPTIONS CHECKSUM FAIL\n");
+#endif
+      return -5;
+    }
+#if BOOTLOADER_VERSION_CHECK
+		else if((read_value & 0xFF) == BOOTLOADER_VERSION)
+    {
+#ifdef RSI_DEBUG_PRINT      
+      RSI_DPRINT(RSI_PL3,"BOOTLOADER VERSION CORRECT\n");
+#endif
+    }
+    else
+    {
+#ifdef RSI_DEBUG_PRINT      
+      RSI_DPRINT(RSI_PL3,"BOOTLOADER VERSION NOT MATCHING\n");
+#endif
+
+      return -6;
+    }
+#endif
+
+#ifdef RSI_DEBUG_PRINT      
+    RSI_DPRINT(RSI_PL3,"RECIEVED BOARD READY\n");
+#endif
+		return 0;
+  }
+
+#ifdef RSI_DEBUG_PRINT      
+      RSI_DPRINT(RSI_PL3,"WAITING FOR BOARD READY\n");
+#endif
+  return -3;
+}
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_select_option(uint8 cmd)
+ * @brief       Sends cmd to select option to load or update configuration 
+ * @param[in]   uint8 cmd, type of configuration to be saved
+ * @param[out]  none
+ * @return      errCode
+                < 0 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send firmware load request to WiFi module or update default configurations.
+ */
+int16 rsi_select_option(uint8 cmd)
+{
+  uint16   boot_cmd = 0;
+  int16    retval = 0;
+  uint16   read_value = 0;
+  uint8    image_number  = 0;
+  volatile int32  loop_counter = 0;
+  
+  boot_cmd = HOST_INTERACT_REG_VALID | cmd;
+  if(cmd == RSI_CHECK_CRC)
+  {
+    boot_cmd &= 0xF0FF;
+    boot_cmd |= (image_number << 8);
+  }
+  
+  retval   = rsi_boot_insn(REG_WRITE, &boot_cmd);
+  if(retval < 0)
+  {
+    return retval;
+  }
+  
+  if((cmd != RSI_LOAD_IMAGE_I_FW) && (cmd != RSI_LOAD_IMAGE_I_ACTIVE_LOW_FW))
+  {
+    RSI_RESET_LOOP_COUNTER(loop_counter);
+    RSI_WHILE_LOOP(loop_counter, RSI_LOOP_COUNT_SELECT_OPTION)
+    {
+      retval = rsi_boot_insn(REG_READ, &read_value);
+      if(retval < 0)
+      {
+        return retval;
+      }
+      if(cmd == RSI_CHECK_CRC)
+      {
+        if((read_value & 0xFF) == CHECKSUM_SUCCESS)
+        {
+#ifdef RSI_DEBUG_PRINT      
+          RSI_DPRINT(RSI_PL3,"CHECKSUM SUCCESS\n");
+#endif
+        }
+        else if(read_value == CHECKSUM_FAILURE)
+        {
+#ifdef RSI_DEBUG_PRINT      
+          RSI_DPRINT(RSI_PL3,"CHECKSUM FAIL\n");
+#endif
+        }
+        else if(read_value == CHECKSUM_INVALID_ADDRESS)
+        {
+#ifdef RSI_DEBUG_PRINT      
+          RSI_DPRINT(RSI_PL3,"Invalid Address \n");
+#endif
+        }
+      }
+      if (read_value == (HOST_INTERACT_REG_VALID | cmd))
+      {
+        break;
+      }
+    }
+    RSI_CHECK_LOOP_COUNTER(loop_counter, RSI_LOOP_COUNT_SELECT_OPTION);
+  }
+  
+  return retval;
+}
+/*==============================================*/
+/**
+ * @fn          int16 rsi_upgrade_fw(uint8 image_type, uint8 *fw_image, uint32 fw_image_size)
+ * @brief       Upgrades firmware to WiFi module
+ * @param[in]   uint8 image_type, type of firmware image to upgrade
+ * @param[in]   uint8* fw_image, pointer to firmware
+ * @param[in]   uint32 fw_image_size, size of firmware image
+ * @param[out]  none
+ * @return      errCode
+ *              <0 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to upgrade firmware to WiFi module.
+ */
+int16 rsi_upgrade_fw(uint8 image_type, uint8 *fw_image , uint32 fw_image_size)
+{
+  uint16 boot_cmd = HOST_INTERACT_REG_VALID | image_type;
+  uint16 read_value = 0;
+  uint32 offset = 0;
+  int16  retval = 0;
+  uint32 boot_insn = 0,poll_resp = 0;
+  volatile int32  loop_counter = 0;
+  retval = rsi_boot_insn(REG_WRITE, &boot_cmd);
+  if(retval < 0)
+  {
+    return retval;
+  }
+  RSI_RESET_LOOP_COUNTER(loop_counter);
+  RSI_WHILE_LOOP(loop_counter, RSI_LOOP_COUNT_UPGRADE_REQ)
+  {
+    retval = rsi_boot_insn(REG_READ, &read_value);
+    if(retval < 0)
+    {
+      return retval;
+    }
+    if (read_value == (HOST_INTERACT_REG_VALID | SEND_RPS_FILE))
+    {
+      break;
+    }
+  }
+  RSI_CHECK_LOOP_COUNTER(loop_counter, RSI_LOOP_COUNT_UPGRADE_REQ);
+ 
+  boot_cmd = HOST_INTERACT_REG_VALID | PONG_VALID;
+  while(offset <= fw_image_size){
+    switch (boot_cmd){
+      case (HOST_INTERACT_REG_VALID | PING_VALID):
+        boot_insn = PONG_WRITE;
+        poll_resp = PING_AVAIL;
+        boot_cmd = HOST_INTERACT_REG_VALID |PONG_VALID;
+        break;
+      case (HOST_INTERACT_REG_VALID | PONG_VALID):
+        boot_insn = PING_WRITE;
+        poll_resp = PONG_AVAIL;
+        boot_cmd = HOST_INTERACT_REG_VALID |PING_VALID;
+        break;
+    }
+
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3,"Burning from %x to %x of %x\n", offset, (offset + 4096), fw_image_size);
+#endif
+    retval = rsi_boot_insn(boot_insn, (uint16 *)((uint8 *)fw_image + offset));
+    if(retval < 0)
+    {
+      return retval;
+    }
+
+    RSI_RESET_LOOP_COUNTER(loop_counter);
+    RSI_WHILE_LOOP(loop_counter, RSI_LOOP_COUNT_UPGRADE_CHUNK)
+    {
+      retval = rsi_boot_insn(REG_READ, &read_value);
+      if(retval < 0)
+      {
+        return retval;
+      }
+      if (read_value == (HOST_INTERACT_REG_VALID | poll_resp))
+      {
+        break;
+      }
+    }
+    RSI_CHECK_LOOP_COUNTER(loop_counter, RSI_LOOP_COUNT_UPGRADE_CHUNK);
+    offset += 1024*4;
+  }
+  boot_cmd = HOST_INTERACT_REG_VALID | EOF_REACHED;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"EOF REACHED\n");
+#endif
+  retval = rsi_boot_insn(REG_WRITE, &boot_cmd);
+  if(retval < 0)
+  {
+    return retval;
+  }
+  RSI_RESET_LOOP_COUNTER(loop_counter);
+  while(loop_counter, RSI_LOOP_COUNT_UPGRADE_STATUS)
+  {
+    retval = rsi_boot_insn(REG_READ, &read_value);
+    if(retval < 0)
+    {
+      return retval;
+    }
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3,"WAITING TO RECEIVE FIRMWARE UPGRADATION STATUS\n");
+#endif
+    if (read_value == (HOST_INTERACT_REG_VALID | FWUP_SUCCESSFUL))
+    {
+#ifdef RSI_DEBUG_PRINT
+
+      RSI_DPRINT(RSI_PL3,"FIRMWARE UPGRADATION SUCCESSFUL\n");
+#endif
+
+      break;
+    }
+  }
+  RSI_CHECK_LOOP_COUNTER(loop_counter, RSI_LOOP_COUNT_UPGRADE_STATUS);
+  return retval;
+}
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_build_frame_descriptor.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_build_frame_descriptor.c
new file mode 100755
index 0000000..cdc1b77
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_build_frame_descriptor.c
@@ -0,0 +1,98 @@
+/**
+ * @file     rsi_build_frame_descriptor.c
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Function which builds the frame descriptor
+ *
+ * @section Description
+ * This file contains a function to build the frame descriptor.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*==================================================*/
+/**
+ * @fn          void rsi_build_frame_descriptor(rsi_uFrameDsc *uFrameDscFrame, uint8 *cmd)
+ * @brief       Creates a Frame Descriptor
+ * @param[in]   rsi_uFrameDsc *uFrameDscFrame,Frame Descriptor
+ * @param[in]   uint8 *cmd,Indicates type of the packet(data or management)
+ * @param[out]  none
+ * @return      none
+ * 
+ * @section description 
+ * This API is used to build the frame descriptor for the packet which is supposed to be 
+ * given to the firmware/module 
+ *
+ */
+void rsi_build_frame_descriptor(rsi_uFrameDsc *uFrameDscFrame, uint8 *cmd)
+{
+  uint8        i; 
+  uint8        queue_no;
+  for (i = 0; i < RSI_FRAME_DESC_LEN; i++) 
+  { 
+    uFrameDscFrame->uFrmDscBuf[i] = 0x00; 
+  } 
+  queue_no = (cmd[1] & 0xf0) >> 4;
+  //!zero the frame descriptor buffer
+  //!data or management frame type
+  if ((queue_no == WLAN_MGMT_TYPE )||(queue_no == WLAN_DATA_TYPE)) 
+  {
+    //!The first two bytes have different functions for management frames and
+    //!control frames, but these are set in the pre-defined
+    uFrameDscFrame->uFrmDscBuf[0] = cmd[0];      
+    //!arrays which are the argument passed to this function, so we just set the two values
+    uFrameDscFrame->uFrmDscBuf[1] = cmd[1];
+    uFrameDscFrame->uFrmDscBuf[2] = cmd[2];      
+  }
+  else if ((queue_no == BT_MGMT_TYPE )||(queue_no == BT_DATA_TYPE)) 
+  {
+    //!The first two bytes have different functions for management frames and
+    //!control frames, but these are set in the pre-defined
+    uFrameDscFrame->uFrmDscBuf[0] = cmd[0];      
+    //!arrays which are the argument passed to this function, so we just set the two values
+    uFrameDscFrame->uFrmDscBuf[1] = cmd[1];
+    uFrameDscFrame->uFrmDscBuf[2] = cmd[2];      
+    uFrameDscFrame->uFrmDscBuf[3] = cmd[3];      
+  }
+  else if(queue_no == ZB_MGMT_TYPE)
+  {
+    for (i = 0; i < RSI_FRAME_DESC_LEN; i++) 
+    { 
+      uFrameDscFrame->uFrmDscBuf[i] = cmd[i]; 
+    }  
+  }
+  else
+  {
+#ifdef RSI_DEBUG_PRINT  
+     RSI_DPRINT(RSI_PL4,"\n INVALID QUEUE : ERROR !!!!!\n "); 
+#endif 
+
+  }
+
+
+  return;
+}
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_bytes_sent_count.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_bytes_sent_count.c
new file mode 100755
index 0000000..1c67995
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_bytes_sent_count.c
@@ -0,0 +1,70 @@
+/**
+ * @file     rsi_bytes_sent_count.c
+ * @version  1.0
+ * @date     2014-Oct-31
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief BYTES SENT COUNT: Function to send bytes sent count on socket
+ *
+ * @section Description
+ * This file contains the socket sent bytes count query function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global defines
+ */
+
+
+/**===========================================================================
+ * @fn          int16 rsi_bytes_sent_count(uint16 socketDescriptor)
+ * @brief       Queries the total bytes sent count with the given socket descriptor
+ * @param[in]   uint16 socketDescriptor, socket to query
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *       
+ * @section description  
+ * This API is used to query the total bytes sent count with the given descriptor.
+ * @section prerequisite 
+ * Socket with the given descriptor should already be created.
+ */
+int16 rsi_bytes_sent_count(uint16 socketDescriptor)
+
+{
+  int16                                   retval;
+  rsi_uQuerySentBytesCount                uQuerySentBytesCountFrame;
+  
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\nSent bytes query\n");
+#endif
+
+
+  rsi_uint16_to_2bytes(uQuerySentBytesCountFrame.querySentBytesCountFrameSnd.socketDescriptor, socketDescriptor);
+  
+  retval =rsi_execute_cmd((uint8 *)rsi_frameCmdSentBytesCount,(uint8 *)&uQuerySentBytesCountFrame,sizeof(rsi_uQuerySentBytesCount));
+  return retval;
+
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_cfg_enable.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_cfg_enable.c
new file mode 100755
index 0000000..9577dae
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_cfg_enable.c
@@ -0,0 +1,60 @@
+/**
+ * @file     rsi_cfg_enable.c
+ * @version  2.7
+ * @date     2012-Sep-12
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief CFG ENABLE: Function to Enable/Disable Store Configuration
+ *
+ * @section Description
+ * This file contains the Store Configuration Enable/Disable function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_cfg_enable(uint8 cfg_enable_val)
+ * @brief       Sends the cfg enable command to the Wi-Fi module
+ * @param[in]   uint8 cfg_enable_val,if 1-enables store configuration,
+ *              and if 0 disables store configuration
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+* @section description
+  * To enable(1)/disable(0) store configuration.
+ */
+int16 rsi_cfg_enable(uint8 cfg_enable_val)
+{
+  int16               retval;
+  rsi_uCfgEnable       uCfgEnableFrame;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nCfg enable Start");
+#endif
+
+  uCfgEnableFrame.cfgEnableFrameSnd.cfg_enable = cfg_enable_val;
+  retval =rsi_execute_cmd((uint8 *)rsi_frameCmdCfgEnable ,(uint8 *)&uCfgEnableFrame, sizeof(rsi_uCfgEnable));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_cfg_get.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_cfg_get.c
new file mode 100755
index 0000000..6d53765
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_cfg_get.c
@@ -0,0 +1,66 @@
+/**
+ * @file     rsi_cfg_get.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief CFG GET: Function to retrieve configuration data
+ *
+ * @section Description
+ * This file contains the function which retrieves the stored configuration
+ *
+ */
+
+
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_cfg_get(void)
+ * @brief       Sends the Config Get command to the Wi-Fi module ,gets
+ *         the module configuration information
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give the CONFIG GET Request for the module. 
+ * @section prerequisite 
+ * The rsi_cfg_save should be done sussessfully.
+ */
+ 
+ 
+int16 rsi_cfg_get(void)
+{
+    int16  retval;
+
+ #ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n CFG GET Start");
+ #endif
+  retval =rsi_execute_cmd((uint8 *)rsi_frameCmdCfgGet,NULL,0);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_cfg_save.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_cfg_save.c
new file mode 100755
index 0000000..f1e7798
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_cfg_save.c
@@ -0,0 +1,62 @@
+/**
+ * @file     rsi_cfg_save.c
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief CFG SAVE: Saves the configuration to flash
+ *
+ * @section Description
+ * This file contains the function to save the current configuration.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*==============================================*/
+/**
+ * @fn             int16 rsi_cfg_save(void)
+ * @brief          Config save
+ * @param[in]      none
+ * @param[out]     none
+ * @return         errCode
+ *               SPI:
+ *                 -1 = SPI busy / Timeout
+ *                 -2 = SPI Failure
+ *                 -3 = BUFFER FULL
+ *                 0  = SUCCESS
+ *               UART/USB/USB-CDC:
+ *                 -2 = Command issue failed
+ *                 0  = SUCCESS
+ *
+ * @section description   
+ * This file contains the function to save the current configuration.
+ */
+int16 rsi_cfg_save(void)
+{
+  int16            retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nCFG Save Start");
+#endif
+  
+  retval =rsi_execute_cmd((uint8 *)rsi_frameCmdCfgSave,NULL, 0);
+  
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_config.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_config.c
new file mode 100755
index 0000000..bdb2730
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_config.c
@@ -0,0 +1,62 @@
+/**
+ * @file     rsi_config.c
+ * @version  10.8
+ * @date     2018-APR-09
+ *
+ * Copyright(C) Redpine Signals 2018
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief WLAN_CONFIG: Sets the WLAN_CONFIG value 
+ *
+ * @section Description
+ * This file contains the wlan config function.
+ *
+ */
+/* 2019/05/10 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <linux/spi/spi.h>
+//#ifdef RSI_WLAN_CONFIG_ENABLE  /* APJ : delete */
+#if 1 /* APJ : add */
+/* ============================================== */
+/*
+ * @fn          int16 rsi_config(uint16 config_type, uint16 config_value)
+ * @brief       Sends the configuration (i.e For now, RTSTHRESHOLD) command to the Wi-Fi module
+ * @param[in]   uint16 config_type, for now it is 1(CONFIG_RTSTHRESHOLD).
+ * @param[in]   uint16 config_value, with in the range of [256-2346].
+ * @param[out]  none 
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to configure the RTS threshold value. 
+ * This API can be called anywhere.
+ */
+int16 rsi_config(uint16 config_type, uint16 config_value)
+{
+  int16               retval;
+  rsi_uConfig         uConfigFrame;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\nWLAN Configuration Start");
+#endif
+  memcpy(uConfigFrame.configFrameSnd.config_type, &config_type, 2);
+  memcpy(uConfigFrame.configFrameSnd.config_value, &config_value, 2);
+  retval =rsi_execute_cmd((uint8 *)rsi_frameCmdConfig,(uint8 *)&uConfigFrame, sizeof(rsi_uConfig));
+  return retval;
+}
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_debug_prints.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_debug_prints.c
new file mode 100755
index 0000000..cc4fc65
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_debug_prints.c
@@ -0,0 +1,59 @@
+/**
+ * @file     rsi_debug_prints.c
+ * @version  1.0
+ * @date     2014-Jun-6
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief DEBUG: Enables debug prints
+ *
+ * @section Description
+ * This file contains the Debug enable function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_api.h"
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_debug_prints(rsi_udebug *uDebugFrame)
+ * @brief       Sends the Debug command to the Wi-Fi module,
+ *              used to get debug prints on uart2
+ * @param[in]   rsi_udebug, pointer to debug structure.
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to enable debug prints.
+ * This API has to be called before oper mode command.
+ * Based on the level enabled,debug prints will be coming on UART2 interface
+ */
+int16 rsi_debug_prints(rsi_uDebug *uDebugFrame)
+{
+  int16               retval;  
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nDebug Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdDebug, (uint8 *)uDebugFrame, sizeof(rsi_uDebug));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dhcp_usr_cls.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dhcp_usr_cls.c
new file mode 100755
index 0000000..088b2f4
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dhcp_usr_cls.c
@@ -0,0 +1,70 @@
+/**
+ * @file       rsi_dhcp_usr_cls.c
+ * @version    1.0
+ * @date       2017-May-05
+ *
+ * Copyright(C) Redpine Signals 2015
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SMTP CLIENT: Function which implements SMTP client
+ *
+ * @section Description
+ * This file contains the SMTP client functionality.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_dhcp_client_usr_cls(rsi_dhcp_user_class_t *dhcp_usr_cls)
+ * @brief       Sends the DHCP user class commands to the Wi-Fi module
+ * @param[in]   rsi_dhcp_user_class_t *dhcp_usr_cls, Pointer to DHCP user class structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send DHCP user class commands to the Wi-Fi module.
+ * This API should be called only after join command API.
+ *
+ * @section prerequisite 
+ * The IP configuration should be done sussessfully.
+ */
+
+int16 rsi_dhcp_client_usr_cls(rsi_dhcp_user_class_t *dhcp_usr_cls)
+{
+	int16    retval;
+
+#ifdef RSI_DEBUG_PRINT
+	RSI_DPRINT(RSI_PL3,"\r\n\nDHCP OPTION 77");
+#endif
+
+	retval = rsi_execute_cmd((uint8 *)rsi_frameCmdDHCPUsrCls, (uint8 *)dhcp_usr_cls, sizeof(rsi_dhcp_user_class_t));  
+
+	return retval;
+}
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_disconnect.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_disconnect.c
new file mode 100755
index 0000000..f9e15ba
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_disconnect.c
@@ -0,0 +1,66 @@
+/**
+ * @file     rsi_disconnect.c
+ * @version  2.9
+ * @date     2012-Nov-23
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief DISCONNECT: Function to disconnect
+ *
+ * @section Description
+ * This file contains the DISCONNECT function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+
+/*===================================================*/
+/**
+ * @fn         int16 rsi_disconnect(rsi_disassoc_t *disassoc_Frame)
+ * @brief      Sends the DISCONNECT command to the Wi-Fi module
+ * @param[in]  rsi_disassoc_t *disassoc_Frame, Pointer to disassoc frame structure  
+ * @param[out] none  
+ * @return     errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *
+ * @section description 
+ * This function is used to disconnect the module's Wi-Fi connection.
+ * @section prerequisite 
+ * Wi-Fi connection should be successful
+ */
+
+int16 rsi_disconnect(rsi_disassoc_t *disassoc_Frame)
+{
+  int16            retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nDisconnect Start");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdDisconnect,(uint8 *)disassoc_Frame,sizeof(rsi_disassoc_t));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dns_query.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dns_query.c
new file mode 100755
index 0000000..867ea48
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dns_query.c
@@ -0,0 +1,64 @@
+/**
+ * @file     rsi_dns_query.c
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief DNS Query: Function which gets the DNS IP address.
+ *
+ * @section Description
+ * This file contains the DNS Query function.
+ *
+ *
+ */
+
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/*=================================================*/
+/**
+ *@fn           int16 rsi_dns_query(rsi_uDnsQry  *uDnsQryFrame)
+ * @brief       Sends the DNS Get command to the Wi-Fi module
+ * @param[in]   rsi_uDnsQry  *uDnsQryFrame,pointer to DNS server configuration stucture.
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to resolve the IP Address for the given Domain name.
+ * @section prerequisite 
+ * The rsi_ipparam_set  should be done sussessfully.
+ */
+
+int16 rsi_dns_query(rsi_uDnsQry  *uDnsQryFrame)
+{
+   int16 retval;
+      
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL3,"\r\n\nDns Get");
+#endif
+       
+   retval = rsi_execute_cmd((uint8 *)rsi_frameCmdDnsQuery,(uint8 *)uDnsQryFrame,sizeof(rsi_uDnsQry));  
+   
+   return retval;
+}
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dns_server.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dns_server.c
new file mode 100755
index 0000000..ab65a1e
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dns_server.c
@@ -0,0 +1,61 @@
+/**
+ * @file     rsi_dns_server.c
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief DNS SERVER: Function to set the DNS SERVER IP Addresses
+ *
+ * @section Description
+ * This file contains the DNS SERVER function.
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/*=================================================*/
+/**
+ *@fn           int16 rsi_dns_server(rsi_uDnsServer *uDnsServer)
+ * @brief       Sends the DNS Server command to the Wi-Fi module via SPI
+ * @param[in]   rsi_uDnsServer *uDnsServer ,pointer to DNS server configuration stucture.
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set the DNS Server primary and secondary IPs.
+ * @section prerequisite 
+ * The rsi_ipparam_set  should be done sussessfully.
+ */
+
+int16 rsi_dns_server(rsi_uDnsServer *uDnsServer)
+{
+    int16    retval;
+      
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3,"\r\n\nDns Server");
+#endif
+       
+    retval = rsi_execute_cmd((uint8 *)rsi_frameCmdDnsServer,(uint8 *)uDnsServer,sizeof(rsi_uDnsServer));  
+  
+    return retval;
+}
+
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dns_update.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dns_update.c
new file mode 100755
index 0000000..cb364e0
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_dns_update.c
@@ -0,0 +1,67 @@
+/**
+ * @file     rsi_dns_update.c
+ * @version  2.7
+ * @date     2016-Aug-30
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief DNS Update: Function which updates the hostname (TYPE_A record)in the DNS server.
+ *
+ * @section Description
+ * This file contains the DNS Update function.
+ *
+ *
+ */
+
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/*=================================================*/
+/**
+ *@fn           int16 rsi_dns_update(rsi_uDnsUpdate  *uDnsUpdateFrame)
+ * @brief       Sends the DNS Update command to the Wi-Fi module
+ * @param[in]   rsi_uDnsUpdate  *uDnsUpdateFrame,pointer to DNS client update configuration stucture.
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to update the hostname(TYPE_A record) of the module.
+ * @section prerequisite 
+ * The rsi_ipparam_set  should be done sussessfully.
+ */
+
+int16 rsi_dns_update(rsi_uDnsUpdate  *uDnsUpdateFrame)
+{
+   int16 retval;
+   
+   /* DNS update  */
+   uint8   rsi_frameCmdDnsUpdate[RSI_BYTES_3] = {0x43 , 0x40 , 0xED };
+      
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL3,"\r\n\nDns Update");
+#endif
+       
+   retval = rsi_execute_cmd((uint8 *)rsi_frameCmdDnsUpdate,(uint8 *)uDnsUpdateFrame,sizeof(rsi_uDnsUpdate));  
+   
+   return retval;
+}
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_execute_cmd.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_execute_cmd.c
new file mode 100755
index 0000000..23fe6ad
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_execute_cmd.c
@@ -0,0 +1,160 @@
+/**
+ * @file       rsi_execute_cmd.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Implements common functionality for all the commands
+ *
+ * @section Description
+ * This file contains common api needed for all the commands
+ *
+ *
+ */
+/* 2016/10/11 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+//#ifdef RSI_HAL /* APJ : delete */
+#if 1 /* APJ : add */
+#include "rsi_spi_cmd.h"
+#endif
+#ifdef LINUX
+extern struct net_device *glbl_net_device;
+#endif
+
+/*====================================================*/
+/**
+ * @fn          int16 rsi_execute_cmd(uint8 *descparam,uint8 *payloadparam,uint16 size_param)
+ * @brief       Common function for all the commands.
+ * @param[in]   uint8 *descparam, pointer to the frame descriptor parameter structure
+ * @param[in]   uint8 *payloadparam, pointer to the command payload parameter structure
+ * @param[in]   uint16 size_param, size of the payload for the command
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This is a common function used to process a command to the Wi-Fi module.
+ */
+int16 rsi_execute_cmd(uint8 *descparam,uint8 *payloadparam,uint16 size_param)
+{
+  int16            retval = 0;
+  rsi_uFrameDsc    uFrameDscFrame;
+#ifndef UART_INTERFACE
+  uint8 queueno = (descparam[1] & 0xf0) >> 4;
+  uint8           int_status = 0;
+#endif
+#ifdef LINUX 
+  PRSI_ADAPTER Adapter = rsi_getpriv(glbl_net_device);
+#endif
+#if ((RSI_POWER_MODE == RSI_POWER_MODE_2)||(RSI_POWER_MODE == RSI_POWER_MODE_8))
+  uint8           powersave_enable;
+
+#ifdef LINUX 
+  powersave_enable = Adapter->power_save_enable;
+#else 
+  powersave_enable = rsi_app_cb.power_save_enable;
+#endif
+#endif
+
+#ifndef LINUX 
+#if (RSI_POWER_MODE == RSI_POWER_MODE_3)
+  if (!rsi_app_cb.ps_ok_to_send)
+  {
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL14,"module in sleep; Enquing\n");
+#endif
+    memcpy(rsi_app_cb.ps_descparam, descparam, 16);
+    rsi_app_cb.ps_pkt_pending = payloadparam;
+    rsi_app_cb.ps_size_param  = size_param;
+    return 0;
+  }
+#endif
+#endif
+
+#if ((RSI_POWER_MODE == RSI_POWER_MODE_2)||(RSI_POWER_MODE == RSI_POWER_MODE_8))
+  if(powersave_enable){
+#if (RSI_WMM_PS_SUPPORT && RSI_WMM_PS_TYPE)
+    rsi_wait4wakeup();
+#else
+    rsi_req_wakeup();
+#endif
+  }
+#endif
+#ifndef UART_INTERFACE
+  if ((queueno == WLAN_MGMT_TYPE) || (queueno == WLAN_DATA_TYPE)) {
+    //! Buffer full has to be checked before calling send data
+    retval = rsi_device_interrupt_status(&int_status);
+  }
+ // printk("intr_status = %x\n", int_status);
+  if(retval != 0x0) 
+  {
+#if ((RSI_POWER_MODE == RSI_POWER_MODE_2)||(RSI_POWER_MODE == RSI_POWER_MODE_8))
+  if(powersave_enable){
+    rsi_allow_sleep();
+  }
+#endif
+    return retval;
+  }
+  if(int_status & RSI_IRQ_BUFFERFULL)
+  {
+#ifdef LINUX    
+    Adapter->BufferFull = 1;
+#endif    
+#if ((RSI_POWER_MODE == RSI_POWER_MODE_2)||(RSI_POWER_MODE == RSI_POWER_MODE_8))
+  if(powersave_enable){
+    rsi_allow_sleep();
+  }
+#endif
+    return BUFFER_FULL_FAILURE;
+  }
+  else
+  {
+#ifdef LINUX    
+    Adapter->BufferFull = 0;
+#endif    
+  }
+#endif
+  //! 16 bytes, send/receive command descriptor frame
+  //! Create the Command Frame Descriptor  
+  rsi_build_frame_descriptor(&uFrameDscFrame,descparam);
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"Descriptor write");
+#endif
+  //! Write descriptor and payload
+  retval = rsi_frame_write(&uFrameDscFrame, payloadparam, size_param);
+#if ((RSI_POWER_MODE == RSI_POWER_MODE_2)||(RSI_POWER_MODE == RSI_POWER_MODE_8))
+  if(powersave_enable){
+    rsi_allow_sleep();
+  }
+#endif
+#ifndef UART_INTERFACE
+  if (retval != 0x00) 
+#else
+  if (retval == 0x00) 
+#endif
+  {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL4,"Frame write failErr=%02x", (uint16)retval);
+#endif
+    return retval;
+  }
+  
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ftp_client.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ftp_client.c
new file mode 100755
index 0000000..ae403ff
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ftp_client.c
@@ -0,0 +1,164 @@
+/**
+ * @file       rsi_ftp_client.c
+ * @version    1.0
+ * @date       2015-May-18
+ *
+ * Copyright(C) Redpine Signals 2015
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief FTP CLIENT: Function which implements FTP client
+ *
+ * @section Description
+ * This file contains the FTP client functionality.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_ftp_client(uint8 type, rsi_ftp_client_t*ftp_client)
+ * @brief       Sends the FTP commands to the Wi-Fi module
+ * @param[in]   rsi_ftp_client_t *ftp_client, Pointer to FTP structure
+ * @param[in]   uint8 type, type of FTP command
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send FTP commands to the Wi-Fi module.
+ * This API should be called only after rsi_ip_param_set API.
+ *
+ * @section prerequisite 
+ * The IP configuration should be done sussessfully.
+ */
+int16 rsi_ftp_client(uint8 type, rsi_ftp_client_t *ftp_client)
+{
+  int16          retval;
+  uint8          rsi_frameCmdFTP[RSI_BYTES_3] = {0x00, 0x40, 0xE2};    
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n FTP client");
+#endif
+
+  
+  //! Fill command type
+  ftp_client->command_type = type;
+
+  rsi_uint16_to_2bytes(rsi_frameCmdFTP, ((sizeof(rsi_ftp_client_t) & 0x0FFF) | 0x4000));    
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdFTP, (uint8 *)ftp_client, sizeof(rsi_ftp_client_t));
+
+  return retval;
+}
+
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_ftp_file_write_content(rsi_ftp_file_write_t * ftp_file_write, uint8 *file_content, uint32 file_size, uint8 ip_version)
+ * @brief       Sends the FTP commands to the Wi-Fi module
+ * @param[in]   rsi_ftp_file_write_t *ftp_file_write, pointer to file write structure
+ * @param[in]   uint8 *file_content, poointer to file
+ * @param[in]   uint32 file_size, size of the file
+ * @param[in]   uint8 ip_version, ip version used
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send FTP commands to the Wi-Fi module.
+ * This API should be called only after rsi_ip_param_set API.
+ *
+ * @section prerequisite 
+ * The IP configuration should be done sussessfully.
+ */
+int16 rsi_ftp_file_write_content(rsi_ftp_file_write_t *ftp_file_write, uint8 *file_content, uint32 file_size, uint8 ip_version)
+{
+  int16          retval = 0;
+  uint8          rsi_frameCmdFTP[RSI_BYTES_3] = {0x00, 0x40, 0xE2};    
+  uint32         file_offset = 0;
+  uint32         chunk_size = 0;
+  uint32         send_size = 0;
+  uint8          head_room = 0;
+
+  //! Fill command type
+  ftp_file_write->command_type = FTP_COMMAND_FILE_WRITE_CONTENT;
+
+  if(ip_version == 4)
+  {
+    //! Headroom for IPv4
+    head_room = RSI_TCP_FRAME_HEADER_LEN;
+  }
+  else
+  {
+    //! Headroom for IPv6
+    head_room = RSI_TCP_V6_FRAME_HEADER_LEN;
+  }
+
+  while(file_size)
+  {
+    if(file_size > FTP_MAX_CHUNK_LENGTH)
+    {
+      //! If size exceeds maximum chunk
+      chunk_size = FTP_MAX_CHUNK_LENGTH;
+
+      //! Dont set end of file
+      ftp_file_write->end_of_file = 0;
+    }
+    else
+    {
+      chunk_size = file_size;
+
+      //! Set end of file
+      ftp_file_write->end_of_file = 1;
+    }
+
+    //! Copy file content
+    memcpy((((uint8 *)ftp_file_write) + head_room), (file_content + file_offset), chunk_size);
+
+    //! Add headroom to send size
+    send_size = chunk_size + head_room;
+
+    //! Prepare descriptor 
+    rsi_uint16_to_2bytes(rsi_frameCmdFTP, ((send_size & 0x0FFF) | 0x4000));    
+
+    //! Send chunk
+    retval = rsi_execute_cmd((uint8 *)rsi_frameCmdFTP, (uint8 *)ftp_file_write, send_size);
+
+    //! Increase file offset
+    file_offset  += chunk_size;
+
+    //! Decrese file remaining size
+    file_size -= chunk_size;
+
+  }
+
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_fwup_frm_host.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_fwup_frm_host.c
new file mode 100755
index 0000000..43a6a1f
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_fwup_frm_host.c
@@ -0,0 +1,74 @@
+/**
+ * @file     rsi_fwup_frm_host.c
+ * @version  1.0
+ * @date     2014-Sep-13
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Firmware upgration form host 
+ *
+ * @section Description
+ * This file contains the functionality of upgrading the firmware from host.
+ * @functions Defined: 
+ * rsi_fwup_frm_host()
+ * rsi_parse_rps_file()
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_fwup_frm_host()
+ * @brief       send the rps file to firmare for upgradation
+ * @param[in]   fw_up_params 
+ * @param[in]   rps_file
+ * @param[in]   offset of the file from where to fill the payload
+ * @param[in]   length to be filled in buffer
+ * @param[in]   type 1-> request ,0->payload
+ * @return      errCode
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send the rps file to firmare for upgradation of new image.
+ */
+int16 rsi_fwup_frm_host(rsi_fw_up_t *ptr_fw_up, uint8 *rps_file,uint32 rps_offset,uint16 length,uint16 type)
+{
+  int16               retval;
+  uint8   rsi_frameCmdFwUpFrmHost[RSI_BYTES_3] ;
+  //*(uint16 *)&rsi_frameCmdFwUpFrmHost[0] = (((length+4) & 0xFFF) | (0x4 << 12));
+  rsi_uint16_to_2bytes(rsi_frameCmdFwUpFrmHost, (((length+4) & 0xFFF) | (0x4 << 12)));
+
+  rsi_frameCmdFwUpFrmHost[2]= 0x99;
+  /*fill Type*/
+  //*(uint16 *)&ptr_fw_up->packet_info[0] = type;
+   rsi_uint16_to_2bytes(ptr_fw_up->packet_info, type);
+  /*filling length in the packet info*/
+  //*(uint16 *)&ptr_fw_up->packet_info[2] = length;
+   rsi_uint16_to_2bytes(&ptr_fw_up->packet_info[2], length);
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nFIRMWARE UPGRADTION FROM HOST PACKET OFFSET IS===>>>%d\r\n",rps_offset);
+#endif
+  /*copying the actual payload from the rps file to the buffer*/
+  memcpy(ptr_fw_up->payload,((uint8 *)rps_file + rps_offset),length);
+  /*add 4 in length to include the packet info size*/
+  length += 4;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nFIRMWARE UPGRADTION FROM HOST PACKET LENGTH IS===>>>%d\r\n",length);
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdFwUpFrmHost, (uint8 *)ptr_fw_up, length);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_gpio_config.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_gpio_config.c
new file mode 100755
index 0000000..0eb207a
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_gpio_config.c
@@ -0,0 +1,135 @@
+/**
+ * @file       rsi_gpio_config.c
+ * @version    3.6
+ * @date       2013-May-15
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief GPIO Config: Function to configure GPIOs
+ *
+ * @section Description
+ * This file contains the API for configuring GPIOs. This can be used to configure
+ * the particular GPIOs only.
+ *
+ */
+
+
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_config.h"
+#ifdef SPI_INTERFACE
+#include "rsi_spi_cmd.h"
+#endif
+
+/**
+ * Global Variables
+ */
+/*====================================================*/
+/**
+ * @fn        void rsi_req_wakeup(void)
+ * @brief     set wakeup gpio high. 
+ * @param[in] none
+ * @return    none
+ * @section description
+ * This HAL API is used to set wakeup gpio high and waits for wakeup confirmation pin to get set.
+ */
+int32 rsi_req_wakeup(void)
+{
+  volatile uint32  loop_counter = 0;
+  //!Intitialize with error 
+  int32 retval = -1;
+  config_gpio_output(1);
+  config_gpio_input();
+
+  RSI_RESET_LOOP_COUNTER(loop_counter);
+  RSI_WHILE_LOOP(loop_counter, RSI_LOOP_COUNT_WAKEUP_REQ)
+  {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3,"Checking for value\r\n");
+#endif
+    if(get_gpio_value())
+    {
+#ifdef RSI_DEBUG_PRINT
+      RSI_DPRINT(RSI_PL3,"Module Awake\r\n");
+#endif
+#ifdef SPI_INTERFACE
+#if RSI_ULP_MODE
+      rsi_ulp_wakeup_init();
+	  retval = 0;
+#else
+      retval = 0;
+#endif
+#endif
+      break;
+    }
+  }
+  return retval;
+}
+/*====================================================*/
+/**
+ * @fn         void rsi_wait4wakeup(void)
+ * @brief      wait to get wakeup status to get set by module. 
+ * @param[in]  none
+ * @return     none
+ * @description 
+ * This HAL API is used to set wakeup gpio high and waits for wakeup confirmation pin to get set.
+ */
+int32 rsi_wait4wakeup(void)
+{
+  volatile uint32  loop_counter = 0;
+  //! Default return error
+  int32 retval = -1;
+
+  config_gpio_input();
+
+  RSI_RESET_LOOP_COUNTER(loop_counter);
+  RSI_WHILE_LOOP(loop_counter, RSI_LOOP_COUNT_WAKEUP_WAIT)
+  {
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"Checking for value\r\n");
+#endif
+    if(get_gpio_value())
+    {
+      config_gpio_output(1);
+#ifdef RSI_DEBUG_PRINT
+      RSI_DPRINT(RSI_PL3,"Module Awake\r\n");
+#endif
+#ifdef SPI_INTERFACE
+#if RSI_ULP_MODE
+      rsi_ulp_wakeup_init();
+	  retval = 0;
+#else
+      retval = 0;	  
+#endif
+#endif
+      break;
+    }
+  }
+  RSI_CHECK_LOOP_COUNTER(loop_counter, RSI_LOOP_COUNT_WAKEUP_WAIT);
+  return retval;
+}
+
+/*====================================================*/
+/**
+ * @fn        void rsi_allow_sleep(void)
+ * @brief     set wakeup gpio low. 
+ * @param[in] none
+ * @return    none
+ * @description 
+ * This HAL API is used to set wakeup gpio low .
+ */
+void rsi_allow_sleep(void)
+{
+  config_gpio_output(0);
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_host_rtc_time.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_host_rtc_time.c
new file mode 100755
index 0000000..26262ba
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_host_rtc_time.c
@@ -0,0 +1,59 @@
+/**
+ * @file       rsi_host_rtc_time.c
+ * @version    8.4
+ * @date       2016-April-5
+ *
+ * Copyright(C) Redpine Signals 2016
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief implements the set rtc time command used to initialize the module rtc time.
+ *
+ * @section Description
+ * This file contains the rsi_host_rtc_time function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+
+/*=================================================*/
+/**
+ *@fn            int16 rsi_host_rtc_time(module_rtc_time_t *rtc_time)
+ * @brief        Sends the host rtc time command to the Wi-Fi module via SPI
+ * @param[in]    
+ *               
+ * @param[out]   none
+ * @return       errCode
+ *               SPI:
+ *                -1 = SPI busy / Timeout
+ *                -2 = SPI Failure
+ *                -3 = BUFFER FULL
+ *                0  = SUCCESS
+ *               UART/USB/USB-CDC:
+ *                -2 = Command issue failed
+ *                0  = SUCCESS
+ * @section description 
+ * This API is used to send the host rtc time.
+ */
+int16 rsi_host_rtc_time(module_rtc_time_t *rtc_time)
+{
+  int16    retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nRTC time from host");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdRtcTime,(uint8 *)rtc_time, sizeof(module_rtc_time_t));
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ht_caps.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ht_caps.c
new file mode 100755
index 0000000..3935e31
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ht_caps.c
@@ -0,0 +1,63 @@
+/**
+ * @file       rsi_ht_caps.c
+ * @version    1.0
+ * @date       2014-Apr-16
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HT CAPS: Function which sets the high throughput capabilities parameters 
+ *
+ * @section Description
+ * This file contains the HT CAPS Parameter set function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_ht_caps(rsi_uHtCaps *uHtCapsFrame)
+ * @brief       Sets the HT CAPS parameters in the Wi-Fi module 
+ * @param[in]   rsi_uHtCaps *uHtCapsFrame, Pointer to HT Caps structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give the HT CAPS Request . 
+ * @section prerequisite 
+ * The init should be done sussessfully.
+ */
+ 
+int16 rsi_ht_caps(rsi_uHtCaps *uHtCapsFrame)
+{
+  int16  retval;
+
+ #ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL3,"\r\n\n HT CAPS starts");
+ #endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdHtCaps,(uint8 *)uHtCapsFrame,sizeof(rsi_uHtCaps));
+  
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_abort.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_abort.c
new file mode 100755
index 0000000..1f57e3c
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_abort.c
@@ -0,0 +1,64 @@
+/**
+ * @file       rsi_http_abort.c
+ * @version    2.7
+ * @date       2015-Feb-4
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HTTP ABORT: Function to abort the current execution of the http request.
+ *
+ * @section Description
+ * This file contains the HTTP ABORT function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_http_abort(void)
+ * @brief       Sends the HTTP ABORT command to the Wi-Fi module
+
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ *      
+ * @section description 
+ * This API is used to abort the http request of the Wi-Fi module.
+ */
+int16 rsi_http_abort(void)
+{
+  int16            retval;
+  uint8   rsi_frameCmdHttpAbort[RSI_BYTES_3] = {0x00, 0x40, 0xB3};
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSTART HTTP ABORT\n");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdHttpAbort, NULL,0);
+  return retval;
+}
+
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_client_put.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_client_put.c
new file mode 100755
index 0000000..16245d1
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_client_put.c
@@ -0,0 +1,106 @@
+/**
+ * @file       rsi_http_client_put.c
+ * @version    2.0
+ * @date       2016-Sep-23
+ *
+ * Copyright(C) Redpine Signals 2016
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HTTP CLIENT: Function which implements HTTP client 
+ *
+ * @section Description
+ * This file contains the HTTP PUT client functionality.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_http_client_put(uint8 type, rsi_http_client_put_req_t *http_client_put)
+ * @brief       Sends the HTTP PUT commands to the Wi-Fi module
+ * @param[in]   rsi_http_client_put_req_t *http_client_put, Pointer to HTTP PUT structure
+ * @param[in]   uint8 type, type of HTTP PUT command
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send HTTP PUT commands to the Wi-Fi module.
+ * This API should be called only after rsi_ip_param_set API.
+ *
+ * @section prerequisite 
+ * The IP configuration should be done sussessfully.
+ */
+
+int16 rsi_http_client_put(uint8 type, rsi_http_client_put_req_t *http_client_put)
+{
+
+	int16          retval, str_len =0, buf_len = 0;
+	uint16         pkt_len = 0;
+	uint8          no_of_fields=0, i=0;
+	uint8          rsi_frameCmdHTTPPUT[RSI_BYTES_3] = {0x00, 0x40, 0x53};    
+
+	//! Fill command type
+    http_client_put->command_type = type;
+  
+	if((type == HTTP_CLIENT_PUT_DELETE) || (type == HTTP_CLIENT_PUT_CREATE))
+	{
+		pkt_len = sizeof(rsi_http_client_put_req_t) - RSI_HTTP_CLIENT_PUT_BUFFER_LENGTH;
+	}
+
+	if(http_client_put->command_type == HTTP_CLIENT_PUT_START)
+	{
+		no_of_fields = 6;
+
+		while( i < no_of_fields)
+		{
+			str_len = strlen((char *)&http_client_put->http_put_buffer[buf_len]);
+			buf_len += (str_len + 1);
+			i++;
+		}
+		
+    pkt_len = sizeof(rsi_http_client_put_req_t) - RSI_HTTP_CLIENT_PUT_BUFFER_LENGTH + buf_len;
+	}
+
+	if(http_client_put->command_type == HTTP_CLIENT_PUT_PACKET)
+  {
+    buf_len += rsi_bytes2R_to_uint16(http_client_put->http_client_put_struct.http_client_put_data_req.current_length); 
+
+    pkt_len = sizeof(rsi_http_client_put_req_t) - RSI_HTTP_CLIENT_PUT_BUFFER_LENGTH + buf_len;
+  }
+
+
+  rsi_uint16_to_2bytes(rsi_frameCmdHTTPPUT, ((pkt_len & 0x0FFF) | 0x4000));
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n HTTP client PUT");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdHTTPPUT, (uint8 *)http_client_put, pkt_len);  
+
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_credentials.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_credentials.c
new file mode 100755
index 0000000..139fbe7
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_credentials.c
@@ -0,0 +1,60 @@
+/**
+ * @file       rsi_http_credentials.c
+ * @version    1.0
+ * @date       2015-May-06
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HTTP Server Credentials: Function which implements HTTP server credentials command
+ *
+ * @section Description
+ * This file contains the Join function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_http_credentials(rsi_uhttpCredentials *uhttpCredentialsFrame)
+ * @brief       Sends the Http credentials command to the Wi-Fi module via SPI
+ * @param[in]   rsi_uhttpCredentials *uhttpCredentialsFrame, Pointer to Http credentials structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failed
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set the Credentials to the HTTP server. 
+ * @section prerequisite 
+ * The rsi_ipparam_set  should be done sussessfully.
+ */
+
+int16 rsi_http_credentials(rsi_uhttpCredentials  *uhttpCredentialsFrame)
+{
+   /* Http Credentials */
+   uint8   rsi_frameCmdhttpCredentials[RSI_BYTES_3] = {0x3e , 0x40 , 0xB4 }; 
+   int16 retval;
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL3,"\r\n\nHTTP Credentials");
+#endif
+       
+   retval = rsi_execute_cmd((uint8 *)rsi_frameCmdhttpCredentials,(uint8 *)uhttpCredentialsFrame,sizeof(rsi_uhttpCredentials));  
+   
+   return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_get.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_get.c
new file mode 100755
index 0000000..1498620
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_get.c
@@ -0,0 +1,89 @@
+/**
+ * @file     rsi_http_get.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HTTP GET: Function which implements HTTP GET command
+ *
+ * @section Description
+ * This file contains the Join function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_http_get(rsi_uHttpReq *uHttpGetReqFrame)
+ * @brief       Sends the Http Get command to the Wi-Fi module via SPI
+ * @param[in]   rsi_uHttpReq *uHttpGetReqFrame, Pointer to Http Get structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failed
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give the HTTP GET Request for HTTP server. 
+ * @section prerequisite 
+ * The rsi_ipparam_set  should be done sussessfully.
+ */
+ 
+int16 rsi_http_get(rsi_uHttpReq *uHttpGetReqFrame)
+{
+  int16  retval;
+  uint16 buf_len;
+  uint16 ii =0;
+  uint8 count =0;
+
+  /*Http GET Request Frame */
+  uint8   rsi_frameCmdHttpGetReq[RSI_BYTES_3] = {0x00, 0x40, 0x51};
+
+  buf_len = sizeof(rsi_uHttpReq) - HTTP_BUFFER_LEN;
+
+  if(rsi_bytes2R_to_uint16(uHttpGetReqFrame->HttpReqFrameSnd.https_enable) & 2)
+  {
+    while(count != 6)
+    {
+      if(uHttpGetReqFrame->HttpReqFrameSnd.buffer[ii++] == '\0')
+      {
+        count++;
+        
+      }
+      buf_len++;
+    }
+    buf_len--; // Not considering NULL at the end of the buffer
+  }
+  else
+  {
+    buf_len += strlen((char *)uHttpGetReqFrame->HttpReqFrameSnd.buffer);
+
+  }
+
+  rsi_uint16_to_2bytes(rsi_frameCmdHttpGetReq, (buf_len & 0xFFF));
+
+  rsi_frameCmdHttpGetReq[1] |= 0x40;
+
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n HTTP GET Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdHttpGetReq,(uint8 *)uHttpGetReqFrame, buf_len);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_post.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_post.c
new file mode 100755
index 0000000..72313cb
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_post.c
@@ -0,0 +1,94 @@
+/**
+ * @file       rsi_http_post.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HTTP POST: Function which implements the HTTP POST command
+ *
+ * @section Description
+ * This file contains the HTTP post function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_http_post(rsi_uHttpReq *uHttpPostReqFrame)
+ * @brief       Sends the Http Post command to the Wi-Fi module 
+ * @param[in]   rsi_uHttpReq *uHttpPostReqFrame, Pointer to HTTP POST structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to Post the HTTP data from module to HTTP server. 
+ * @section prerequisite 
+ * The rsi_ipparam_set  should be done sussessfully.
+ */
+
+int16 rsi_http_post(rsi_uHttpReq *uHttpPostReqFrame)
+{
+  int16  retval;
+  uint16 buf_len = 0;
+  uint16 count = 0,ii=0;
+  /*Http Post Request Frame */
+  uint8   rsi_frameCmdHttpPostReq[RSI_BYTES_3] = {0x00, 0x40, 0x52};
+
+  buf_len = sizeof(rsi_uHttpReq) - HTTP_BUFFER_LEN;
+
+  if(rsi_bytes2R_to_uint16(uHttpPostReqFrame->HttpReqFrameSnd.https_enable) & 2)
+  {
+    while(count != 7)
+    {
+      if(uHttpPostReqFrame->HttpReqFrameSnd.buffer[ii++] == '\0')
+      {
+        count++;
+        
+      }
+      buf_len++;
+    }
+    buf_len--; // Not considering NULL at the end of the buffer
+  }
+  else
+  {
+    buf_len += strlen((char *)uHttpPostReqFrame->HttpReqFrameSnd.buffer);
+
+  }
+
+  rsi_uint16_to_2bytes(rsi_frameCmdHttpPostReq, (buf_len & 0xFFF));
+
+  rsi_frameCmdHttpPostReq[1] |= 0x40;
+
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Http Post Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdHttpPostReq,(uint8 *)uHttpPostReqFrame, buf_len);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_post_data.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_post_data.c
new file mode 100755
index 0000000..9379035
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_http_post_data.c
@@ -0,0 +1,70 @@
+/**
+ * @file     rsi_http_post_data.c
+ * @version  1.0
+ * @date     2016-Sep-17
+ *
+ * Copyright(C) Redpine Signals 2016
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HTTP client post data to HTTP server
+ *
+ * @section Description
+ * This file contains the functionality of HTTP client post data.
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_http_post_data(rsi_uHttpPostDataReq *uHttpPostDataReqFrame, uint8 *data, uint16 length, uint32 offset);
+ * @brief       send the HTTP post data command to firmare
+ * @param[in]   uHttpPostDataReqFrame 
+ * @param[in]   data
+ * @param[in]   length of the http data
+ * @param[in]   offset of the data file from where to fill the payload
+ * @return      errCode
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send the HTTP post data command to module.
+ */
+int16 rsi_http_post_data(rsi_uHttpPostDataReq *uHttpPostDataReqFrame, uint8 *data, uint16 length, uint32 offset)
+{
+  int16               retval;
+  uint8   rsi_frameCmdHttpPostData[RSI_BYTES_3] = {0x00, 0x40, 0xEB};
+  
+
+  /* Fill HTTP chunk length */
+  rsi_uint16_to_2bytes(uHttpPostDataReqFrame->HttpPostDataReqFrameSnd.current_chunk_length, length);
+
+  /* Copy HTTP content */
+  memcpy(uHttpPostDataReqFrame->HttpPostDataReqFrameSnd.buffer,((uint8 *)data + offset), length);
+
+  /* Fill length of the command payload */
+  length = (sizeof(rsi_uHttpPostDataReq) - HTTP_POST_BUFFER_LEN + length);
+  
+  //*(uint16 *)&rsi_frameCmdHttpPostData[0] = (((length) & 0xFFF) | (0x4 << 12));
+  rsi_uint16_to_2bytes(rsi_frameCmdHttpPostData, (((length) & 0xFFF) | (0x4 << 12)) );
+  
+  rsi_uint16_to_2bytes(rsi_frameCmdHttpPostData, (length & 0xFFF));
+
+  rsi_frameCmdHttpPostData[1] |= 0x40;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nHTTP POST DATA PACKET LENGTH IS===>>>%d\r\n",length);
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdHttpPostData, (uint8 *)uHttpPostDataReqFrame, length);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_init.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_init.c
new file mode 100755
index 0000000..a59d4b4
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_init.c
@@ -0,0 +1,62 @@
+/**
+ * @file       rsi_init.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief INIT: Function which initiaizes the modules baseband and RF components
+ *
+ * @section Description
+ * This file contains the function to initialize module baseband and RF components
+ * This command must be preceeded by the BAND command
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*==============================================*/
+/**
+ * @fn             int16 rsi_init(void)
+ * @brief          Initializes the baseband and RF components
+ * @param[in]      none
+ * @param[out]     none
+ * @return         errCode
+ *                 SPI:
+ *                  -1 = SPI busy / Timeout
+ *                  -2 = SPI Failure
+ *                  -3 = BUFFER FULL
+ *                  0  = SUCCESS
+ *                 UART/USB/USB-CDC:
+ *                 -2 = Command issue failed
+ *                  0  = SUCCESS
+ * @section description   
+ * This API initializes the Wi-Fi module's Baseband and RF components. 
+ * It has to be called only after the rsi_bootloader and rsi_band APIs.
+ */
+int16 rsi_init(void)
+{
+  int16            retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\nINIT Start");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %-30.25s\n","WLAN","Tx","Init Req","Init initiated");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdInit,NULL, 0);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ip_param_set.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ip_param_set.c
new file mode 100755
index 0000000..010c898
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ip_param_set.c
@@ -0,0 +1,71 @@
+/**
+ * @file       rsi_ip_param_set.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief IP PARAMETERS: Function to set Network parameters, IP Address, Port Number.
+ *
+ * @section Description
+ * This file contains the TCPIP function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/*===============================================*/
+/**
+ * @fn          int16 rsi_ip_param_set(rsi_uIpparam *uIpparamFrame)
+ * @brief       Sends the IPCONFIG (TCP/IP configure)command to the Wi-Fi module
+ * @param[in]   rsi_uIpparam *uIpparamFrame, pointer to ip configuration stucture
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description  
+ * This API is used to configure the IP address, Subnet Mask 
+ * and Gateway IP address for the module in manual mode or DHCP mode. 
+ * The Wi-Fi module should be successfully connected to an Access point 
+ * (using the rsi_join API) before calling this API. If DHCP mode is enabled, then 
+ * it has to be ensured that a DHCP server is present in the network.
+ * 
+ * @section prerequisite 
+ * rsi_join should be done successfully
+ */
+int16 rsi_ip_param_set(rsi_uIpparam *uIpparamFrame)
+{
+  int16            retval;
+
+  //! frame sent to set the IP parameters
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\n IPconfiguration Start");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %s %s\n","WLAN","Tx","Set IP Req",(*(uint8 *)&uIpparamFrame[0]==0?"Set":"Get")," IP Initiated");
+  
+  
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdIpparam,(uint8 *)uIpparamFrame,sizeof(rsi_uIpparam));
+  return retval;
+}
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ipv6_param_set.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ipv6_param_set.c
new file mode 100755
index 0000000..827f6b8
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ipv6_param_set.c
@@ -0,0 +1,60 @@
+/**
+ * @file       rsi_ipv6_param_set.c
+ * @version    1.0
+ * @date       2014-Mar-03
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief IP PARAMETERS: Function to set IPV6 Address to WiFi module.
+ *
+ * @section Description
+ * This file contains the TCPIP function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_ipv6_param_set(rsi_uIPconf6  *uIpconf6Frame)
+ * @brief       Sends the ipv6 address to the Wi-Fi module
+ * @param[in]   rsi_uIPconf6  *uIpconf6Frame
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set ipv6 address.
+ * This API has to be called only after the rsi_join API.
+ */
+
+int16 rsi_ipv6_param_set(rsi_uIPconf6  *uIpconf6Frame)
+{
+  int16               retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nIPV6 ipconfig6 Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdIPconf6,(uint8 *)uIpconf6Frame, sizeof(rsi_uIPconf6));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_join.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_join.c
new file mode 100755
index 0000000..55c2539
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_join.c
@@ -0,0 +1,66 @@
+/**
+ * @file       rsi_join.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief JOIN: Function which implements the join command
+ *
+ * @section Description
+ * This file contains the Join function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+/*=================================================*/
+/**
+ * @fn          int16 rsi_join(rsi_uJoin *uJoinFrame)
+ * @brief       Sends the Join command to the Wi-Fi module via SPI
+ * @param[in]   rsi_uJoin *uJoinFrame, Pointer to join structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to connect the Wi-Fi module to an Access Point. 
+ * This API should be called only after rsi_scan API.
+ *
+ * @section prerequisite 
+ * The rsi_scan for the access point should be done sussessfully.
+ */
+int16 rsi_join(rsi_uJoin *uJoinFrame)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\n Join Start");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %-25.25s-\"%s\"\n","WLAN","Tx","Join Req","Join Initiated with SSID ",&uJoinFrame->uJoinBuf[68]);
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdJoin,(uint8 *)uJoinFrame,sizeof(rsi_uJoin));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_json_create.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_json_create.c
new file mode 100755
index 0000000..f28bf5d
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_json_create.c
@@ -0,0 +1,94 @@
+/**
+ * @file        rsi_json_create.c
+ * @version     2.7
+ * @date        2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Create JSON Object: This function is used to create a JSON object
+ *
+ * @section Description
+ * This file contains the function to create a JSON Object that is associated
+ * with a webpage.
+ *
+ *
+ */
+/* 2016/11/25 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+//#include "sensor_data.h" /* APJ : delete */
+
+//#if (!RSI_TCP_IP_BYPASS & JSON_LOAD) /* APJ : delete */
+#if !RSI_TCP_IP_BYPASS /* APJ : add */
+/**
+ * Global Variables
+ */
+
+/*==============================================*/
+/**
+ * @fn             int16 rsi_json_create(rsi_jsonCreateObject_t* obj)
+ * @brief          Erases all files in the webpage file system
+ * @param[in]      obj -> the structure representing the json filename & string
+ * @param[out]     none
+ * @return         errCode
+ *                 SPI:
+ *                  -1 = SPI busy / Timeout
+ *                  -2 = SPI Failure
+ *                  -3 = BUFFER FULL
+ *                  0  = SUCCESS
+ *                 UART/USB/USB-CDC:
+ *                  -2 = Command issue failed
+ *                  0  = SUCCESS
+* @section description   
+ * This API creates a JSON Object that will be associated with a webpage.
+ */
+int16 rsi_json_create(rsi_jsonCreateObject_t* obj, uint8* json_string_buffer, uint8* json_load_done)
+{
+    int16           retval     =  0;
+    uint16          total_len  =  0;
+    uint16          curr_len   =  0;
+    static uint16   offset;
+
+
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3,"\r\nJSON Create Start");
+#endif
+
+    total_len = strlen((const char *)json_string_buffer);
+    curr_len  = (total_len > JSON_CHUNK_LEN) ? JSON_CHUNK_LEN : total_len;
+
+    //!Initialize both length parameters 
+    *(uint16*) (obj->total_length)   = total_len;
+    *(uint16*) (obj->current_length) = curr_len;
+
+    //! Filename is already initialized, so copy content now 
+    memcpy((uint8*)(obj->json_data), json_string_buffer + offset, curr_len);
+
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3,"\r\nTotal, Current, Offset: %d, %d, %d\n", total_len, curr_len, offset);
+#endif
+
+    //! Send the Command 
+    retval = rsi_execute_cmd((uint8 *)rsi_frameCmdJSONCreate, 
+                             (uint8*)obj, sizeof(rsi_jsonCreateObject_t));
+
+    //!Update the offset
+    offset += curr_len;
+
+    if (offset == total_len) {
+        offset = 0;
+        *json_load_done = 1;
+    }
+
+    return retval;
+}
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_json_erase_file.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_json_erase_file.c
new file mode 100755
index 0000000..73e4a24
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_json_erase_file.c
@@ -0,0 +1,61 @@
+/**
+ * @file        rsi_json_erase_file.c
+ * @version     2.7
+ * @date        2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Erase Webpage File: This function erases one json file in the file system
+ *
+ * @section Description
+ * This file contains the function to erase one json file present in the
+ * module's file system
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*==============================================*/
+/**
+ * @fn             int16 rsi_json_erase_file(void)
+ * @brief          Erases all files in the json file system
+ * @param[in]      none
+ * @param[out]     none
+ * @return         errCode
+ *                 SPI:
+ *                  -1 = SPI busy / Timeout
+ *                  -2 = SPI Failure
+ *                  -3 = BUFFER FULL
+ *                  0  = SUCCESS
+ *                 UART/USB/USB-CDC:
+ *                  -2 = Command issue failed
+ *                  0  = SUCCESS
+ * @section description   
+ * This API erases one json file present in the file system.
+ */
+int16 rsi_json_erase_file(rsi_tfs_erase_file_t* file)
+{
+    int16                   retval;
+
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3,"\r\nJSON erase file Start");
+#endif
+    retval = rsi_execute_cmd((uint8 *)rsi_frameCmdJSONEraseFile,
+                             (uint8 *)file, sizeof(rsi_tfs_erase_file_t));
+    return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_lib_util.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_lib_util.c
new file mode 100755
index 0000000..d01c5e6
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_lib_util.c
@@ -0,0 +1,133 @@
+/**
+ * @file       rsi_lib_util.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief UTIL: Generic function utils such as bytes2Touint16 which are not tied to anything.
+ *
+ * @section Description
+ * This file implements misc utilities/functions.
+ *
+ */
+
+
+/**
+ * Include files
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global defines
+ */
+
+
+/*=============================================================================*/
+/**
+ * @fn              void rsi_uint16_to_2bytes(uint8 *dBuf, uint16 val)
+ * @brief           Convert uint16 to two byte array
+ * @param[in]       uint8 *dBuf,pointer to buffer to put the data in
+ * @param[in]       uint16 data to convert
+ * @param[out]      none
+ * @return          none
+ */
+void rsi_uint16_to_2bytes(uint8 *dBuf, uint16 val)
+{
+#ifdef RSI_LITTLE_ENDIAN
+  dBuf[0] = val & 0x00ff;
+  dBuf[1] = (val >> 8) & 0x00ff;
+#else
+  dBuf[1] = val & 0x00ff;
+  dBuf[0] = (val >> 8) & 0x00ff;
+#endif
+}
+
+/*=============================================================================*/
+/**
+ * @fn              void rsi_uint32_to_4bytes(uint8 *dBuf, uint32 val)
+ * @brief           Convert uint32 to four byte array
+ * @param[in]       uint8 *dBuf,pointer to the buffer to put the data in
+ * @param[in]       uint32 data to convert
+ * @param[out]      none
+ * @return          none
+ */
+void rsi_uint32_to_4bytes(uint8 *dBuf, uint32 val)
+{
+#ifdef RSI_LITTLE_ENDIAN
+  dBuf[0] = val & 0x000000ff;
+  dBuf[1] = (val >> 8) & 0x000000ff;
+  dBuf[2] = (val >> 16) & 0x000000ff;
+  dBuf[3] = (val >> 24) & 0x000000ff;
+#else
+  dBuf[3] = val & 0x000000ff;
+  dBuf[2] = (val >> 8) & 0x000000ff;
+  dBuf[1] = (val >> 16) & 0x000000ff;
+  dBuf[0] = (val >> 24) & 0x000000ff;
+#endif
+}
+
+/*=============================================================================*/
+/**
+ * @fn              uint16 rsi_bytes2R_to_uint16(uint8 *dBuf)
+ * @brief           Convert a 2 byte array to uint16, first byte in array is LSB
+ * @param[in]       uint8 *dBuf,pointer to a buffer to get the data from
+ * @param[out]      none
+ * @return          uint16, converted data
+ */
+uint16 rsi_bytes2R_to_uint16(uint8 *dBuf)
+{
+  uint16        val;    
+#ifdef RSI_LITTLE_ENDIAN
+  val = dBuf[1];
+  val <<= 8;
+  val |= dBuf[0] & 0x000000ff;
+#else
+  val = dBuf[0];
+  val <<= 8;
+  val |= dBuf[1] & 0x000000ff;
+#endif
+  return val;
+}
+
+/*=============================================================================*/
+/**
+ * @fn           uint32 rsi_bytes4R_to_uint32(uint8 *dBuf)
+ * @brief        Convert a 4 byte array to uint32, first byte in array is LSB
+ * @param[in]    uint8 *dBuf,pointer to buffer to get the data from
+ * @param[out]   none
+ * @return       uint32, converted data
+ */
+uint32 rsi_bytes4R_to_uint32(uint8 *dBuf)
+{
+   uint32            val;            //! the 32-bit value to return
+
+#ifdef RSI_LITTLE_ENDIAN
+   val = dBuf[3];
+   val <<= 8;
+   val |= dBuf[2] & 0x000000ff;
+   val <<= 8;
+   val |= dBuf[1] & 0x000000ff;
+   val <<= 8;
+   val |= dBuf[0] & 0x000000ff;
+#else
+   val = dBuf[0];
+   val <<= 8;
+   val |= dBuf[1] & 0x000000ff;
+   val <<= 8;
+   val |= dBuf[2] & 0x000000ff;
+   val <<= 8;
+   val |= dBuf[3] & 0x000000ff;
+#endif
+
+   return val;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_load_web_page.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_load_web_page.c
new file mode 100755
index 0000000..81bc0b9
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_load_web_page.c
@@ -0,0 +1,111 @@
+/**
+ * @file       rsi_load_web_page.c
+ * @version    1.1
+ * @date       2013-Feb-6
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SPI WEB SERVER: Function which implements the spi version of the web server command
+ *
+ * @section Description
+ * This file contains the SPI web server function.
+ *
+ * @Improvements
+ * rsi_webserver function changed to rsi_load_webpage. Now, 3K webpage can
+ * be loaded from module to host. 
+ *
+ */
+/* 2016/11/25 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+/* #if WEB_PAGE_LOAD APJ : delete */
+#if 1 /* APJ : add */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_load_web_page(rsi_uWebServer *uWebServer), uint8 *webpage_morechunks, uint8 *webpage_load_done)
+ * @brief       Sends the Webserver command to the Wi-Fi module via SPI
+ * @param[in]   rsi_uWebServer *uWebServer, Pointer to Webserver structure
+ * @param[in]   uint8 *webpage_morechunks, Pointer to webpage_morechunks
+ * @param[in]   uint8 *webpage_load_done, Pointer to webpage_load_done
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failure
+ *              -1 = Buffer Full
+ *               0 = SUCCESS
+ * @section description 
+ * This API is used to load the webpage to the Wi-Fi module. 
+ * This API should be called only after rsi_init API.
+ *
+ * @section prerequisite 
+ * The rsi_init for the Wi-Fi Module initialization should be done successfully.
+ */
+#if !RSI_TCP_IP_BYPASS
+int16 rsi_load_web_page(rsi_uWebServer *uWebServer, uint8* webpage_file, uint8* webpage_load_done)
+{
+  int16  retval     =  0;
+  uint16 curr_len   =  MAX_WEBPAGE_SEND_SIZE;
+  uint16 file_size  =  *(uint16*)(uWebServer->webServFrameSnd.Webpage_info.total_len);
+
+  static uint16 offset;
+  uint32 send_size = 0;
+
+  /* Webserver loading Frame */
+  uint8   rsi_frameCmdWebServer[RSI_BYTES_3] = {0x1D, 0x44, 0x50};  
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\nLoad Webpage Start\n");
+#endif
+
+  //! Get the current length that you want to send
+  curr_len = (file_size - offset > MAX_WEBPAGE_SEND_SIZE) 
+              ? MAX_WEBPAGE_SEND_SIZE : (file_size - offset);
+
+  //! Update the current length to be sent
+  *(uint16*) (uWebServer->webServFrameSnd.Webpage_info.current_len) = curr_len;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3, "total, current, offset: %d, %d, %d\n", file_size, curr_len, offset);
+#endif
+
+  //! Copy the webpage file contents into the buffer
+  memcpy((uint8*)(uWebServer->webServFrameSnd.Webpage_info.webpage), 
+          (uint8*)(webpage_file + offset), curr_len);
+ 
+  send_size = sizeof(rsi_uWebServer) - MAX_WEBPAGE_SEND_SIZE + curr_len;
+
+  rsi_uint16_to_2bytes(rsi_frameCmdWebServer, ((send_size & 0x0FFF) | 0x4000));
+  
+  
+  //! Send the data 
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdWebServer ,(uint8 *)uWebServer, 
+      send_size);
+
+  //! Adjust the offset
+  offset += curr_len;
+
+  //! Reset offset for next file if required
+  if (offset == file_size) {
+      offset = 0;
+      *webpage_load_done = 1;
+    }
+
+  return retval;
+}
+
+#endif
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ltcp_conn_status.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ltcp_conn_status.c
new file mode 100755
index 0000000..5ef6e73
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ltcp_conn_status.c
@@ -0,0 +1,66 @@
+/**
+ * @file     rsi_ltcp_conn_status.c
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief CTCP: Function to close an open socket
+ *
+ * @section Description
+ * This file contains the LTCP connection status query function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global defines
+ */
+
+
+
+/**===========================================================================
+ * @fn          int16 rsi_ltcp_conn_status(uint16 socketDescriptor)
+ * @brief       Queries the status of the LTCP socket with socket descriptor
+ * @param[in]   uint16 socketDescriptor, socket to query
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *       
+ * @section description  
+ * This API is used to query the connection status of listening TCP socket.
+ * @section prerequisite 
+ * Socket with the given descriptor should already be created.
+ */
+int16 rsi_ltcp_conn_status(uint16 socketDescriptor)
+{
+  int16                                   retval;
+  rsi_uQueryLtcpConnStatus                uQueryLtcpConnStatusFrame;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\nLTCP Conn Status Start\n");
+#endif
+
+  rsi_uint16_to_2bytes(uQueryLtcpConnStatusFrame.queryLtcpConnStatusFrameSnd.socketDescriptor, socketDescriptor);
+  retval =rsi_execute_cmd((uint8 *)rsi_frameCmdLtcpConnStatus,(uint8 *)&uQueryLtcpConnStatusFrame,sizeof(rsi_uQueryLtcpConnStatus));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_mdns_sd.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_mdns_sd.c
new file mode 100755
index 0000000..6bc5828
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_mdns_sd.c
@@ -0,0 +1,101 @@
+/**
+ * @file       rsi_mdns_sd.c
+ * @version    1.0
+ * @date       2015-May-18
+ *
+ * Copyright(C) Redpine Signals 2015
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief MDNS_SD: Function which frames commands to MDNS
+ *
+ * @section Description
+ * This file contains the MDNS commands formation.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_mdns_req(uint8 type, rsi_mdns_t *mdns, uint16 buf_len)
+ * @brief       Sends the MDNS commands to the Wi-Fi module
+ * @param[in]   uint8 type, type of command in MDNS
+ * @param[in]   rsi_mdns_t *mdns, Pointer to MDNS structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send MDNS related commands to the Wi-Fi module.
+ * This API should be called only after rsi_ip_param_set API.
+ *
+ * @section prerequisite 
+ * The IP configuration should be done sussessfully.
+ */
+
+#define MDNSD_BUFFER_SIZE 1000
+
+int16 rsi_mdns_req(uint8 type, rsi_mdns_t *mdns)
+{
+  int16          retval;
+  uint8          rsi_frameCmdMDNS[RSI_BYTES_3] = {0x00, 0x40, 0xDB};
+  uint8 		 i=0, no_of_txt_fields;
+  uint16         pkt_len = 0, str_len = 0, buf_len=0;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n MDNS Command ");
+#endif
+ 
+  //! Fill command type
+  mdns->command_type = type;
+
+  if(mdns->command_type == MDNS_INIT)
+  {
+    buf_len = strlen((const char *)mdns->buffer) + 1;
+    pkt_len = sizeof(rsi_mdns_t) - MDNSD_BUFFER_SIZE + buf_len;
+  }
+ 
+  if(mdns->command_type == MDNS_REGISTER_SERVICE)
+  {
+	  no_of_txt_fields = 3;
+
+	  while( i < no_of_txt_fields)
+	  {
+		  str_len = strlen((const char *)&mdns->buffer[buf_len]);
+		  buf_len += (str_len + 1);
+		  i++;
+	  }
+	 pkt_len = (sizeof(rsi_mdns_t) - MDNSD_BUFFER_SIZE) + buf_len;
+  }
+
+  if(mdns->command_type == MDNS_DEINT)
+  {
+    pkt_len = sizeof(rsi_mdns_t) - MDNSD_BUFFER_SIZE;
+  }
+
+  rsi_uint16_to_2bytes(rsi_frameCmdMDNS, ((pkt_len & 0x0FFF) | 0x4000));    
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdMDNS, (uint8 *)mdns, pkt_len);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_multicast.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_multicast.c
new file mode 100755
index 0000000..682f335
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_multicast.c
@@ -0,0 +1,70 @@
+/**
+ * @file       rsi_multicast.c
+ * @version    1.0
+ * @date       2014-May-12
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief MULTICAST: Function which sends multicast command to module.
+ *
+ * @section Description
+ * This file contains the Multicast function.
+ *
+ *
+ */
+/* 2016/10/11 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *
+ * @fn          int16 rsi_multicast(rsi_uMulticast *uMulticastFrame)
+ * @brief       Sends the Multicast command to the Wi-Fi module
+ * @param[in]   rsi_uMulticast *uMulticastFrame,Pointer to multicast structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to join or leave multicast group. This API should be called only 
+ * after the rsi_ipparam_set API.
+ *
+ * @section prerequisite 
+ * rsi_ipparam_set should be done successfully  
+ */
+
+/* #if RSI_MULTICAST_SUPPORT */
+#if 1 /* APJ : add */
+int16 rsi_multicast(rsi_uMulticast *uMulticastFrame)
+{
+  int16   retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nMulticast Start ");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdMulticast, (uint8 *)uMulticastFrame, sizeof(rsi_uMulticast));
+  return retval;
+}
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_multicast_filter.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_multicast_filter.c
new file mode 100755
index 0000000..86ebc98
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_multicast_filter.c
@@ -0,0 +1,181 @@
+/**
+ * @file       rsi_multicast_filter.c
+ * @version    1.0
+ * @date       2014-Mar-03
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Multicast filter: Multicast filtering 
+ *
+ * @section Description
+ * This file contains the functions to send  multicast mac address to filter and supporting functions
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/*==============================================*/
+/**
+ * @fn          lmac_crc8_c 
+ * @brief       This function is a crc function 
+ *              6 bit value
+ * @param[in]   uint8   crc byte input 
+ * @param[in]   uint8   accumulated crc
+ * @param[in]   uint8   last byte crc
+ * @param[out]  uint8   6bit crc 
+ *                 
+ * @section description 
+ * This API is used to calcuste crc for given byte and accumulate crc.
+ */
+uint8 lmac_crc8_c(uint8 crc8_din, uint8 crc8_state, uint8 end)
+{
+    uint8  din     [8] ;
+    uint8  state   [8] ;
+    uint8  state_c [8] ;
+    uint8  crc8_out    ;
+
+    din[0] = ((crc8_din & BIT(7)) >> 7) ;
+    din[1] = ((crc8_din & BIT(6)) >> 6) ;
+    din[2] = ((crc8_din & BIT(5)) >> 5) ;
+    din[3] = ((crc8_din & BIT(4)) >> 4) ;
+    din[4] = ((crc8_din & BIT(3)) >> 3) ;
+    din[5] = ((crc8_din & BIT(2)) >> 2) ;
+    din[6] = ((crc8_din & BIT(1)) >> 1) ;
+    din[7] = ((crc8_din & BIT(0)) >> 0) ;
+
+    state[0] = ((crc8_state & BIT(0)) >> 0) ;
+    state[1] = ((crc8_state & BIT(1)) >> 1) ;
+    state[2] = ((crc8_state & BIT(2)) >> 2) ;
+    state[3] = ((crc8_state & BIT(3)) >> 3) ;
+    state[4] = ((crc8_state & BIT(4)) >> 4) ;
+    state[5] = ((crc8_state & BIT(5)) >> 5) ;
+    state[6] = ((crc8_state & BIT(6)) >> 6) ;
+    state[7] = ((crc8_state & BIT(7)) >> 7) ;
+
+    state_c[7] = (state[7]^din[7])^(state[6]^din[6])^
+                    (state[5]^din[5]);
+    
+    state_c[6] = (state[6]^din[6])^(state[5]^din[5])^
+                    (state[4]^din[4]);
+
+    state_c[5] = (state[5]^din[5])^(state[4]^din[4])^
+                    (state[3]^din[3]);
+
+    state_c[4] = (state[4]^din[4])^(state[3]^din[3])^
+                    (state[2]^din[2]);
+    
+    state_c[3] = (state[1]^din[1])^(state[2]^din[2])^
+                    (state[3]^din[3])^(state[7]^din[7]);
+
+    state_c[2] = (state[0]^din[0])^(state[1]^din[1])^
+                    (state[2]^din[2])^(state[6]^din[6]);
+
+    state_c[1] = (state[0]^din[0])^(state[1]^din[1])^
+                    (state[6]^din[6]);
+   
+    state_c[0] = (state[0]^din[0])^(state[7]^din[7])^
+                    (state[6]^din[6]);    
+    if(!end){
+      crc8_out =    
+        ((state_c[0] & BIT(0)) << 0)
+        | ((state_c[1] & BIT(0)) << 1)
+        | ((state_c[2] & BIT(0)) << 2)
+        | ((state_c[3] & BIT(0)) << 3)
+        | ((state_c[4] & BIT(0)) << 4)
+        | ((state_c[5] & BIT(0)) << 5)
+        | ((state_c[6] & BIT(0)) << 6)
+        | ((state_c[7] & BIT(0)) << 7)
+        ;
+    }
+    else{
+      crc8_out =    
+        ((state_c[7] & BIT(0)) << 0)
+        | ((state_c[6] & BIT(0)) << 1)
+        | ((state_c[5] & BIT(0)) << 2)
+        | ((state_c[4] & BIT(0)) << 3)
+        | ((state_c[3] & BIT(0)) << 4)
+        | ((state_c[2] & BIT(0)) << 5);
+
+         crc8_out = ~crc8_out;
+         crc8_out &= 0x3f; 
+    }
+    return(crc8_out);
+}
+
+/*==============================================*/
+/**
+ * @fn          multicast_mac_hash 
+ * @brief       This function is to calculate 6bit hash value for given mac address 
+ * @param[in]   uint8   pointer to mac address 
+ * @param[out]  uint8   6bit hash value 
+ *                 
+ * @section description 
+ * This API is used to calculate 6bit hash value from given mac address.
+ */
+
+uint8 multicast_mac_hash(uint8 *mac)
+{
+  uint8 i, crc = 0xff;
+  for(i=0; i<6 ; i++){
+    crc = lmac_crc8_c(mac[i],crc, ((i == 5)?1:0));
+  }
+  return (crc);
+}
+
+/*===========================================================================
+ *
+ * @fn          int16 rsi_multicast_mac_filter(uint8 cmd, uint8 MAC)
+ * @brief       Sends the multicast filter bitmap to the Wi-Fi module
+ * @param[in]   uint8 cmd LS 2 bits are used as command and possible values are
+ *              0 = RSI_MULTICAST_MAC_ADD_BIT
+ *              1 = RSI_MULTICAST_MAC_CLEAR_BIT
+ *              2 = RSI_MULTICAST_MAC_CLEAR_ALL
+ *              3 = RSI_MULTICAST_MAC_SET_ALL
+ * @param[in]   uint8 MAC[6] , Multicast MAC address to be filter
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set/reset the Multicast MAC address bitmap to filter multicast packets. This API should be called only 
+ * after the rsi_init API.
+ *
+ * @section prerequisite 
+ * rsi_init should be done successfully  
+ */
+
+int16 rsi_multicast_mac_filter(uint8 cmd, uint8 MAC[6])
+{
+  int16       retval;
+  uint16      uMcastBitMapFrame;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nMac Filter Start ");
+#endif
+  uMcastBitMapFrame = (uint16)(cmd);
+  if((cmd == RSI_MULTICAST_MAC_ADD_BIT) || (cmd == RSI_MULTICAST_MAC_CLEAR_BIT)){
+    uMcastBitMapFrame |= (multicast_mac_hash(MAC) << 8);
+  }
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdMcastFilter, (uint8 *)&uMcastBitMapFrame, 2);
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_oper_mode.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_oper_mode.c
new file mode 100755
index 0000000..bf78c2a
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_oper_mode.c
@@ -0,0 +1,90 @@
+/**
+ * @file       rsi_oper_mode.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief OPERATING MODE: implements the OPERATING MODE command
+ *
+ * @section Description
+ * This file contains the rsi_opermode function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ *@fn            int16 rsi_oper_mode(rsi_uOperMode *uOperMode)
+ * @brief        Sends the OPERATING MODE command to the Wi-Fi module via SPI
+ * @param[in]    uint8 mode value to configure 0 for legacy client mode , 
+ *               1 for wifi-direct mode , 2 for enterprise security mode.
+ * @param[out]   none
+ * @return       errCode
+ *               SPI:
+ *                -1 = SPI busy / Timeout
+ *                -2 = SPI Failure
+ *                -3 = BUFFER FULL
+ *                0  = SUCCESS
+ *               UART/USB/USB-CDC:
+ *                -2 = Command issue failed
+ *                0  = SUCCESS
+ * @section description 
+ * This API is used to select the Legacy client mode or P2P mode or Enterprise Security Mode.
+ */
+int16 rsi_oper_mode(rsi_uOperMode *uOperMode)
+{
+  int16    retval;
+
+#ifdef RSI_DEBUG_PRINT
+  uint32 opermode = 0, coex = 0;
+  UINT8 opermode_str[15],coex_str[20];
+
+  opermode = *(uint16 *)&uOperMode[0];
+  coex =     *(uint32 *)&uOperMode[0]>>16;
+
+	if(opermode == 0)
+		memcpy(opermode_str,"WLAN Client",13);
+	else if(opermode == 1)
+		memcpy(opermode_str,"WLAN P2P",14);
+	else if(opermode == 2)
+		memcpy(opermode_str,"WLAN EAP Sec",14);
+	else if(opermode == 6)
+		memcpy(opermode_str,"WLAN AP",14);
+	else if(opermode == 8)
+		memcpy(opermode_str,"PER",14);
+
+	if(coex == 0)
+		memcpy(coex_str,"Only",13);
+	else if(coex== 3)
+		memcpy(coex_str,"+ ZigBee Coex ",20);
+	else if(coex== 5)
+		memcpy(coex_str,"+ BT Coex ",20);
+	else if(coex== 13)
+		memcpy(coex_str,"+ BTLE Coex ",20);		
+
+	RSI_DPRINT(RSI_PL3,"\n%-10.7s%-4.2s %-20.15s %s %s  %s\n","WLAN","Tx","Operating Mode Req","Mode:",opermode_str,coex_str);
+	RSI_DPRINT(RSI_PL13,"\r\n\nOperating Mode");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdOperMode,(uint8 *)uOperMode, sizeof(rsi_uOperMode));
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ota_fw_up.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ota_fw_up.c
new file mode 100755
index 0000000..ff01f95
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ota_fw_up.c
@@ -0,0 +1,67 @@
+/**
+ * @file     rsi_ota_fw_up.c
+ * @version  2.7
+ * @date     2016-Oct-7
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief OTAF: Function which upgrades the RS9113 RPS file over the air.
+ *
+ * @section Description
+ * This file contains the OTAF function.
+ *
+ *
+ */
+
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/*=================================================*/
+/**
+ *@fn           int16 rsi_ota_fw_up(rsi_uOtafReq  *uOtafReqFrame)
+ * @brief       Sends the OTAF command to the Wi-Fi module
+ * @param[in]   rsi_uOtafReq  *uOtafReqFrame,pointer to OTAF client configuration stucture.
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used for over the air RS9113 firmware upgradation.
+ * @section prerequisite 
+ * The rsi_ipparam_set  should be done sussessfully.
+ */
+
+int16 rsi_ota_fw_up(rsi_uOtafReq  *uOtafReqFrame)
+{
+   int16 retval;
+   
+   /* OTAF  */
+   uint8   rsi_frameCmdOtafUpgrade[RSI_BYTES_3] = {0x1B , 0x40 , 0xEF };
+      
+#ifdef RSI_DEBUG_PRINT
+   RSI_DPRINT(RSI_PL3,"\r\n\nOTA Firmware Upgradation");
+#endif
+       
+   retval = rsi_execute_cmd((uint8 *)rsi_frameCmdOtafUpgrade,(uint8 *)uOtafReqFrame,sizeof(rsi_uOtafReq));  
+   
+   return retval;
+}
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_p2p_config.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_p2p_config.c
new file mode 100755
index 0000000..56728e2
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_p2p_config.c
@@ -0,0 +1,66 @@
+/**
+ * @file       rsi_p2pcmd.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief , P2P, implements the P2P command
+ *
+ * @section Description
+ * This file contains the rsi_p2pconfig function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_p2p_config(rsi_uConfigP2p *uConfigP2pFrame)
+ * @brief       Sends the P2P command to the Wi-Fi module via SPI
+ * @param[in]   rsi_uConfigP2p *uConfigP2pFrame, Pointer to configP2p structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set the WiFi-direct settings to the WiFi Module
+ * This API should be called only after rsi_spi_init.
+ *
+ * @section prerequisite 
+ * The rsi_init should be done sussessfully.
+ */
+int16 rsi_p2p_config(rsi_uConfigP2p *uConfigP2p)
+{
+  int16          retval;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Config p2p Start");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdP2pConfig,(uint8 *)uConfigP2p, 
+                                                          sizeof(rsi_uConfigP2p));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_per_mode.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_per_mode.c
new file mode 100755
index 0000000..07da1bb
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_per_mode.c
@@ -0,0 +1,63 @@
+/**
+ * @file       rsi_per_mode.c
+ * @version    1.0
+ * @date       2014-Apr-17
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief PER MODE: Function which implements PER command
+ *
+ * @section Description
+ * This file contains the PER  function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_per_mode(rsi_uPerMode *uPerModeFrame)
+ * @brief       Sends the Per Mode command to the Wi-Fi module via SPI
+ * @param[in]   rsi_uPerMode *uPerModeFrame, Pointer to Per Mode structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give the PER MODE parameter set Request . 
+ * @section prerequisite 
+ * The rsi_init  should be done sussessfully.
+ */
+ 
+int16 rsi_per_mode(rsi_uPerMode *uPerModeFrame)
+{
+    int16  retval;
+
+ #ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n PER MODE Start");
+ #endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdPerMode,(uint8 *)uPerModeFrame,sizeof(rsi_uPerMode));
+  
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_per_stats.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_per_stats.c
new file mode 100755
index 0000000..9ea0c8d
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_per_stats.c
@@ -0,0 +1,63 @@
+/**
+ * @file       rsi_per_stats.c
+ * @version    1.0
+ * @date       2014-Sep-02
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief PER STATS: Function which sends the PER statistics command
+ *
+ * @section Description
+ * This file contains the PER stats function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_per_stats(rsi_uPerStats *uPerStatsFrame)
+ * @brief       Sends the Per Stats command to the Wi-Fi module
+ * @param[in]   rsi_uPerStats *uPerStatsFrame, Pointer to Per Stats structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give the PER STATS parameter set Request . 
+ * @section prerequisite 
+ * The rsi_init  should be done sussessfully.
+ */
+ 
+int16 rsi_per_stats(rsi_uPerStats *uPerStatsFrame)
+{
+  int16  retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n PER STATS Start");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdPerStats,(uint8 *)uPerStatsFrame,sizeof(rsi_uPerStats));
+
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ping_request.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ping_request.c
new file mode 100755
index 0000000..8ba51aa
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_ping_request.c
@@ -0,0 +1,68 @@
+/**
+ * @file       rsi_ping_request.c
+ * @version    3.6
+ * @date       2013-Mar-8
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief, PING REQUEST, implements the ping request  command
+ *
+ * @section Description
+ * This file contains the ping request function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_ping_request(rsi_ping_request_t *pingReq)
+ * @brief       Sends the ping request command to the Wi-Fi module
+ * @param[in]   rsi_ping_request_t *pingReq, Pointer to ping request data structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send ping request from Wi-Fi module. 
+ * This API should be called only after successful connection 
+ * establishment and IP configuration..
+ *
+ * @section prerequisite 
+ * The rsi_ipparam_set of the Wi-Fi module should be done successfully.
+ */
+int16 rsi_ping_request(rsi_ping_request_t *pingReq)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Ping Request Start");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdPingRequest ,(uint8 *)pingReq, 
+                                                      sizeof(rsi_ping_request_t));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_pop3_client.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_pop3_client.c
new file mode 100755
index 0000000..0a66aee
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_pop3_client.c
@@ -0,0 +1,75 @@
+/**
+ * @file       rsi_pop3_client.c
+ * @version    1.0
+ * @date       2015-Dec-23
+ *
+ * Copyright(C) Redpine Signals 2015
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief POP3 CLIENT: Function which implements POP3 client
+ *
+ * @section Description
+ * This file contains the POP3 client functionality.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_pop3_client(uint8 type, rsi_pop3_client_t *pop3_client)
+ * @brief       Sends the POP3 commands to the Wi-Fi module
+ * @param[in]   rsi_pop3_client_t *pop3_client, Pointer to POP3 structure
+ * @param[in]   uint8 type, type of POP3 command
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send POP3 commands to the Wi-Fi module.
+ * This API should be called only after rsi_ip_param_set API.
+ *
+ * @section prerequisite 
+ * The IP configuration should be done sussessfully.
+ */
+
+int16 rsi_pop3_client(uint8 type, rsi_pop3_client_t *pop3_client)
+{
+  int16          retval = 0;
+  uint8          rsi_frameCmdPOP3[RSI_BYTES_3] = {0xDF, 0x40, 0xE7};    
+
+  //! Fill command type
+  pop3_client->command_type = type;
+
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n POP3 client");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdPOP3, (uint8 *)pop3_client, sizeof(rsi_pop3_client_t));
+
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_power_mode.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_power_mode.c
new file mode 100755
index 0000000..f3789da
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_power_mode.c
@@ -0,0 +1,144 @@
+/**
+ * @file       rsi_power_mode.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief POWER MODE: Sets the POWER MODE 
+ * This file contains the Power Mode setting function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#ifdef LINUX_PLATFORM
+#include "rsi_nl_app.h"
+#include "rsi_wireless_copy.h"
+#include <sys/ioctl.h>
+#endif
+
+
+/**
+ * Global Variables
+ */
+volatile rsi_powerstate rsi_pwstate;
+
+
+/*===========================================================================*/
+/**
+ * @fn             int16 rsi_power_mode(uint8 powerMode, uint8 ulp_mode_enable, uint8 listen_interval_dtim, uint8 rsi_psp_type, uint16 monitor_interval)
+ * @brief          Sends the SPI POWER MODE command to the Wi-Fi module
+ * @param[in]      uint8 powerMode, power mode value  
+ * @param[in]      uint8 ulp_mode_enable, selects power save mode i.e. LP or ULP
+ * @param[in]      uint8 listen_interval_dtim, selects sleep alignment
+ * @param[in]      uint8 rsi_psp_type, selects power save profile type
+ * @param[in]      uint8 monitor_interval, sets wakeup time in ms
+ * @param[out]     none
+ * @return         errCode
+ *                 SPI:
+ *                  -1 = SPI busy / Timeout
+ *                  -2 = SPI Failure
+ *                  -3 = BUFFER FULL
+ *                  0  = SUCCESS
+ *                UART/USB/USB-CDC:
+ *                 -2 = Command issue failed
+ *                 0  = SUCCESS
+ *
+ * @section description 
+ * This API is used to set different power save modes of the module. Please 
+ * refer to the Software Programming Reference Manual for more information on 
+ * these modes. This API should be called only after rsi_init API.
+ * 
+ * @section prerequisite  
+ * Init command should be complete before this command.
+ */
+int16 rsi_power_mode(uint8 powerMode, uint8 ulp_mode_enable, uint8 listen_interval_dtim, uint8 rsi_psp_type, uint16 monitor_interval)
+{
+  int16            retval;
+  rsi_uPower      uPowerFrame;
+  uPowerFrame.powerFrameSnd.powerVal = powerMode;
+  uPowerFrame.powerFrameSnd.ulp_mode_enable = ulp_mode_enable;
+  uPowerFrame.powerFrameSnd.listen_interval_dtim = listen_interval_dtim;
+  uPowerFrame.powerFrameSnd.rsi_psp_type = rsi_psp_type;
+  uPowerFrame.powerFrameSnd.monitor_interval = monitor_interval;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nPower save command");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdPower,(uint8 *)&uPowerFrame,sizeof(rsi_uPower));
+#ifdef LINUX_PLATFORM
+  if(retval == 0)
+  {
+    rsi_linux_app_cb_t *linux_app_cbPtr = &rsi_linux_app_cb;
+    retval = rsi_ioctl_send_req(linux_app_cbPtr->ioctl_sd, &powerMode, 1, OID_WSC_POWER_SAVE_ENABLE);
+  }
+#else 
+#if RSI_POWER_MODE
+  if(retval == 0)
+  {
+    if(powerMode == 0)
+    {
+      rsi_app_cb.power_save_enable = 0;
+    }
+    else
+    {
+      rsi_app_cb.power_save_enable = 1;
+    }
+  }
+#endif
+#endif
+
+  return retval;
+}
+
+#if 0
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_pwr_save_continue(void)
+ * @brief       To move the module to full power save mode.
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              0  = OK
+ * @section Description
+ * This API is used to move the module back to full power save mode after the 
+ * data/command packets are transmitted by the application.
+ *
+ * @section prerequisite  
+ * should use only for power save mode. 
+ */
+int16 rsi_pwr_save_continue(void)
+{
+  uint8 sleep_confirm_array[4]={0};
+  uint8 localBuf[4];
+  int16 retval;
+
+  sleep_confirm_array[3] = PS_CONFIRM;
+
+    /* wait for ready signal to go low */
+  while(SPI_READY_VAL != RSI_FALSE);
+
+  /* Send power save confirm for the host,
+   * Ack for sleep msg from module 
+   */
+  retval = rsi_spi_send(sleep_confirm_array, 4, localBuf);
+
+  if(retval == 0)
+  {
+    rsi_pwstate.ack_sent = 1;
+    rsi_pwstate.sleep_received = 0;
+  }
+
+  return retval;
+}
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_psk.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_psk.c
new file mode 100755
index 0000000..eb8c566
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_psk.c
@@ -0,0 +1,63 @@
+/**
+ * @file       rsi_psk.c
+ * @version    1.0
+ * @date       2014-Jan-07
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief PSK: sends PSK command to WiFi module
+ *
+ * @section Description
+ * This file contains PSK command
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+/*===========================================================================
+ *
+ * @fn          int16 rsi_psk(rsi_uPsk *uPskReqFrame)
+ * @brief       Sends the PSK command to the Wi-Fi module
+ * @param[in]   rsi_uPsk *uPskReqFrame,Pointer to Psk structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set the desired PSK value 
+ *
+ */
+
+int16 rsi_psk(rsi_uPsk *uPskReqFrame)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nPSK Start ");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdPsk, (uint8 *)uPskReqFrame, sizeof(rsi_uPsk));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_conn_status.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_conn_status.c
new file mode 100755
index 0000000..14e70d4
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_conn_status.c
@@ -0,0 +1,62 @@
+/**
+ * @file       rsi_query_conn_status.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief CONNECTION STATUS: Function to get the status of an existing connection
+ *
+ * @section Description
+ * This file contains the CONNECTION STATUS function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================================================*/
+/**
+ * @fn              int16 rsi_query_conn_status(void)
+ * @brief           QUERY CONNECTION Status through the SPI interface
+ * @param[in]       none
+ * @param[out]      none
+ * @return          errCode
+ *                  SPI:
+ *                   -1 = SPI busy / Timeout
+ *                   -2 = SPI Failure
+ *                   -3 = BUFFER FULL
+ *                   0  = SUCCESS
+ *                  UART/USB/USB-CDC:
+ *                   -2 = Command issue failed
+ *                   0  = SUCCESS
+ * @section description     
+ * This API is used to query the connection status of the Wi-Fi module.
+ */
+
+int16 rsi_query_conn_status(void)
+{
+  int16            retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nConnection Status Start");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdConnStatus, NULL,0);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_fw_version.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_fw_version.c
new file mode 100755
index 0000000..b4d4be7
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_fw_version.c
@@ -0,0 +1,61 @@
+/**
+ * @file       rsi_query_fw_version.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief QUERY FIRMWARE VERSION: Function to get the status of an existing connection
+ *
+ * @section Description
+ * This file contains the QUERY FIRMWARE VERSION function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=====================================================*/
+/**
+ * @fn           int16 rsi_query_fw_version(void)
+ * @brief        SPI, QUERY FIRMWARE VERSION 
+ * @param[in]    none
+ * @param[out]   none
+ * @return       errCode
+ *               SPI:
+ *                 -1 = SPI busy / Timeout
+ *                 -2 = SPI Failure
+ *                 -3 = BUFFER FULL
+ *                 0  = SUCCESS
+ *               UART/USB/USB-CDC:
+ *                 -2 = Command issue failed
+ *                 0  = SUCCESS
+ * @section description  
+ * This API is used to query the firmware version of the Wi-Fi module.
+ */
+int16 rsi_query_fw_version(void)
+{
+  int16            retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery FWVersion Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdQryFwVer,NULL, 0);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_go_parms.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_go_parms.c
new file mode 100755
index 0000000..5346af7
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_go_parms.c
@@ -0,0 +1,64 @@
+/**
+ * @file       rsi_query_go_parms.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief QUERY GO PARAMETERS: Function to get the status of an existing connection
+ *
+ * @section Description
+ * This file contains the QUERY GO PARAMETERS function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_query_go_parms(void)
+ * @brief       SPI, QUERY GO PARAMETERS Command
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *      
+ * @section description 
+ * This API is used to query the GO parameters of the Wi-Fi module.
+ */
+int16 rsi_query_go_parms(void)
+{
+  int16            retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery GO Parms Start");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdQryGoParms,NULL,0);
+
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_mac_address.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_mac_address.c
new file mode 100755
index 0000000..261ce31
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_mac_address.c
@@ -0,0 +1,63 @@
+/**
+ * @file       rsi_query_mac_address.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief QUERY: Function to query mac address.
+ *
+ * @section Description
+ * This file contains the QUERY MAC ADDRESS function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+        
+/*=====================================================*/
+/**
+ * @fn           int16 rsi_query_mac_address(void)
+ * @brief        SPI, QUERY MAC address 
+ * @param[in]    none
+ * @param[out]   none
+ * @return       errCode
+ *               SPI:
+ *                -1 = SPI busy / Timeout
+ *                -2 = SPI Failure
+ *                -3 = BUFFER FULL
+ *                0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *                -2 = Command issue failed
+ *                0  = SUCCESS
+ * @section description  
+ * This API is used to query the mac address of the Wi-Fi module.
+ * @section prerequisite  
+ * This API is used after the successful initialisation of Wi-Fi module.
+ */
+int16 rsi_query_mac_address(void)
+{
+  int16            retval;
+      
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery mac address Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdQryMacAddress,NULL,0);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_net_parms.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_net_parms.c
new file mode 100755
index 0000000..8ee7504
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_net_parms.c
@@ -0,0 +1,67 @@
+/**
+ * @file       rsi_query_net_parms.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief QUERY NETWORK PARAMETERS: Function to get the status of an existing connection
+ *
+ * @section Description
+ * This file contains the QUERY NETWORK PARAMETERS function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_query_net_parms(void)
+ * @brief       SPI, QUERY NETWORK PARAMETERS Command
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *      
+ * @section description 
+ * This API is used to query the network parameters of the Wi-Fi module.
+ */
+int16 rsi_query_net_parms(void)
+{
+  int16            retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery NetworkParms Start");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdQryNetParms, NULL,0);
+  return retval;
+}
+
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_rssi.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_rssi.c
new file mode 100755
index 0000000..9a8e00e
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_rssi.c
@@ -0,0 +1,67 @@
+/**
+ * @file       rsi_query_rssi.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief QUERY RSSI: Get the RSSI
+ *
+ * @section Description
+ * This file contains the QUERY RSSI function.
+ *
+ *
+ */
+/* 2016/10/11 APJ add #if 0 */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#if 0 /* APJ : delete */
+#include <stdio.h>
+#include <string.h>
+#endif /* APJ */
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_query_rssi(void)
+ * @brief       SPI, QUERY RSSI Command
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+* @section description 
+ * This API is used to query the rssi of the Wi-Fi module.
+ */
+int16 rsi_query_rssi(void)
+{
+  int16            retval;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Rssi Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdRssi,NULL,0);
+  return retval;
+}
+
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_snr.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_snr.c
new file mode 100755
index 0000000..1c93887
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_query_snr.c
@@ -0,0 +1,67 @@
+/**
+ * @file       rsi_query_snr.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief QUERY SNR: Get the SNR with respect to connected AP
+ *
+ * @section Description
+ * This file contains the QUERY SNR function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <stdio.h>
+#include <string.h>
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_query_snr(void)
+ * @brief       SPI, QUERY SNR Command
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *      
+ * @section description 
+ * This API is used to query the SNR for the Wi-Fi module with respect to connected AP.
+ */
+int16 rsi_query_snr(void)
+{
+  int16            retval;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nQuery Snr Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSnr,NULL,0);
+  return retval;
+}
+
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_read_data.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_read_data.c
new file mode 100755
index 0000000..33a85dd
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_read_data.c
@@ -0,0 +1,73 @@
+/**
+ * @file       rsi_read_data.c
+ * @version    1.2
+ * @date       2015-Dec-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief READ: Function to read tcp/udp data 
+ *
+ * @section Description
+ * This file contains the READ function.
+ *
+ * @Improvements
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_app.h"
+#include <string.h>
+
+/*
+ * Global Variables 
+ */
+
+
+/*=============================================================*/
+/**
+ * @fn          int16 rsi_read_data(rsi_uSocketRead  *uSocketReadFrame)
+ * @brief       READ Data Packet command
+ * @param[in]   uint16 socketDescriptor, socket descriptor for the socket to send data to
+ * @param[out]  uint32 bytes_sent, number of bytes sent succesfuly
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description
+ * This API used to read TCP/UDP data using an already opened socket. This function
+ * should be called after successfully opening a socket using the rsi_socket API.
+ * If this API return error code-1.
+ */
+#if !RSI_TCP_IP_BYPASS
+int16 rsi_read_data(rsi_uSocketRead  *uSocketReadFrame, uint16 socketDescriptor, uint32 dataLength, uint16 time_out)
+{
+  int16   retval = 0;
+  uint8   rsi_frameCmdReadData[RSI_BYTES_3] = {0x07, 0x50, 0x6B};
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nRead Data");
+#endif
+
+  uSocketReadFrame->socketReadFrameSnd.socketDescriptor   = socketDescriptor;
+  rsi_uint32_to_4bytes(uSocketReadFrame->socketReadFrameSnd.data_length,dataLength);
+  rsi_uint16_to_2bytes(uSocketReadFrame->socketReadFrameSnd.timeout_in_ms, time_out);
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdReadData,(uint8 *)uSocketReadFrame,sizeof(rsi_uSocketRead));  
+  return retval;
+}
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_register_interrupt_irq.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_register_interrupt_irq.c
new file mode 100755
index 0000000..9a45254
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_register_interrupt_irq.c
@@ -0,0 +1,65 @@
+/**
+ * @file       rsi_register_interrupt_irq.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief IRQ: Function to register interrupt irq
+ *
+ * @section Description
+ * This file contains the function used to register the interrupt IRQ
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+ 
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ *@fn           int16 rsi_register_interrupt_irq(uint8 mask)
+ * @brief       Sends the register interrupt irq to the Wi-Fi module via SPI
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to register the interrupt irq.
+ */
+int16 rsi_register_interrupt_irq(void)
+{
+  int16     retval;
+  /* set unblock interrupt frame */  
+  uint8      rsi_frameRegisterInterruptIrq[RSI_BYTES_3] = {0x01,  0x40, 0xEE};
+
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nunblocking interrupt");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameRegisterInterruptIrq, NULL, 0);
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_rejoin_params.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_rejoin_params.c
new file mode 100755
index 0000000..a512442
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_rejoin_params.c
@@ -0,0 +1,65 @@
+/**
+ * @file       rsi_rejoin_params.c
+ * @version    2.7
+ * @date       2014-June-23
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief REJOIN PARAMS: Function which implements the rejoin_params command
+ *
+ * @section Description
+ * This file contains the rejoin params function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_rejoin_params(rsi_rejoin_params_t *uRejoinFrame)
+ * @brief       Sends the Rejoin Params command to the Wi-Fi module via SPI
+ * @param[in]   rsi_rejoin_params_t *uRejoinFrame, Pointer to Rejoin Params structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give rejoin params to WiFi module. 
+ *
+ * @section prerequisite 
+ * None
+ */
+int16 rsi_rejoin_params(rsi_rejoin_params_t *uRejoinFrame)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Rejoin Params Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdRejoinParams,(uint8 *)uRejoinFrame,sizeof(rsi_rejoin_params_t));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_rf_current_mode.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_rf_current_mode.c
new file mode 100755
index 0000000..5005e4c
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_rf_current_mode.c
@@ -0,0 +1,58 @@
+/**
+ * @file       rsi_rf_power_mode.c
+ * @version    2.7
+ * @date       2015-Feb-04
+ *
+ * Copyright(C) Redpine Signals 2015
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief RF POWER: Function which sets the modules RF power levels
+ *
+ * @section Description
+ * This file contains the function to set the module RF power levels
+ * This command must be preceeded by the BAND command
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*==============================================*/
+/**
+ * @fn             int16 rsi_rf_current_config(rsi_rf_current_config_t *rf_config)
+ * @brief          Set RF TX/RX Power/current Levels
+ * @param[in]      rsi_rf_current_config_t *rf_config, Pointer to rf current mode configuration structure
+ * @param[out]     none
+ * @return         errCode
+ *                 -2 = Command execution failed
+ *                 -1 = Buffer Full
+ *                 0  = SUCCESS
+ * @section description   
+ * This API is used set RF current/Power levels. 
+ * It has to be called only before rsi_init APIs.
+ */
+int16 rsi_rf_current_config(rsi_rf_current_config_t *rf_config)
+{
+	int16  retval;
+	
+#ifdef RSI_DEBUG_PRINT
+	RSI_DPRINT(RSI_PL3,"\r\n\nRF Power/Current Command Start");
+#endif
+
+	retval = rsi_execute_cmd((uint8 *)rsi_frameCmdRFCurConfig, (uint8 *)rf_config, sizeof(rsi_rf_current_config_t));
+	return retval;
+		
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_roam_params.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_roam_params.c
new file mode 100755
index 0000000..d3303ff
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_roam_params.c
@@ -0,0 +1,63 @@
+/**
+ * @file       rsi_roam_params.c
+ * @version    1.0
+ * @date       2014-Apr-16
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Roam Params: Function which sets the roaming parameters 
+ *
+ * @section Description
+ * This file contains the Roaming Parameter set function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_roam_params(rsi_uRoamParams *uRoamParamsFrame)
+ * @brief       Sets the Roaming parameters in the Wi-Fi module 
+ * @param[in]   rsi_uRoamParams *uRoamParamsFrame, Pointer to Roam Params structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give the Roaming Parameter set Request . 
+ * @section prerequisite 
+ * The BGscan  should be done sussessfully.
+ */
+ 
+int16 rsi_roam_params(rsi_uRoamParams *uRoamParamsFrame)
+{
+    int16  retval;
+
+ #ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n ROAM PARAMS start");
+ #endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdRoamParams,(uint8 *)uRoamParamsFrame,sizeof(rsi_uRoamParams));
+  
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_scan.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_scan.c
new file mode 100755
index 0000000..0756435
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_scan.c
@@ -0,0 +1,68 @@
+/**
+ * @file      rsi_scan.c
+ * @version   2.7
+ * @date      2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SCAN: Function which scans for available access points
+ *
+ * @section Description
+ * This file contains the Scan function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *
+ * @fn          int16 rsi_scan(rsi_uScan *uScanFrame)
+ * @brief       Sends the Scan command to the Wi-Fi module
+ * @param[in]   rsi_uScan *uScanFrame,Pointer to scan structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+* @section description 
+ * This API is used to scan for Access Points. This API should be called only 
+ * after the rsi_init API.
+ *
+ * @section prerequisite 
+ * rsi_init should be done successfully  
+ */
+
+int16 rsi_scan(rsi_uScan *uScanFrame)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\nScan Start ");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %-30.25s\n","WLAN","Tx","Scan Req","Scan initiated");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdScan, (uint8 *)uScanFrame, sizeof(rsi_uScan));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_select_antenna.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_select_antenna.c
new file mode 100755
index 0000000..b6d5685
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_select_antenna.c
@@ -0,0 +1,69 @@
+/**
+ * @file       rsi_select_antenna.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief ANTENNA SELECTION: Function to set the ANTENNA 
+ *
+ * @section Description
+ * This file contains the rsi_select_antenna function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn             int16 rsi_select_antenna(uint8 type,uint8 gain_2g, uint8 gain_5g, uint8 antenna_path, uint8 antenna_type) 
+ * @brief          This function is used to select antenna on the device
+ * @param[in]   ,  type : INTERNAL_OR_RF_OUT1 , UFL_OR_RF_OUT2 
+ * @param[in]   ,  gain_2g : 0 to 10
+ * @param[in]   ,  gain_5g : 0 to 10
+ * @param[in]   ,  antenna_path : RSI_ANTENNA_PATH_INTERNAL, RSI_ANTENNA_PATH_EXTERNAL
+ * @param[in]   ,  antenna_type : RSI_ANTENNA_TYPE_REDPINE, RSI_ANTENNA_TYPE_FRACTUS, RSI_ANTENNA_TYPE_MOLEX
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to select the Internal Antenna or External Antenna.
+ */
+int16 rsi_select_antenna(uint8 antenna_val,uint8 gain_2g, uint8 gain_5g, uint8 antenna_path, uint8 antenna_type)
+{
+  int16               retval;
+  rsi_uAntenna       uAntSel;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nAntenna Selection");
+#endif
+  uAntSel.AntennaSelFrameSnd.AntennaVal = antenna_val;
+  uAntSel.AntennaSelFrameSnd.gain_2g = gain_2g;
+  uAntSel.AntennaSelFrameSnd.gain_5g = gain_5g;
+  uAntSel.AntennaSelFrameSnd.antenna_path = antenna_path;
+  uAntSel.AntennaSelFrameSnd.antenna_type = antenna_type;
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdAntSel,(uint8 *)&uAntSel, sizeof(rsi_uAntenna));
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_boot_insn.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_boot_insn.c
new file mode 100755
index 0000000..60c3219
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_boot_insn.c
@@ -0,0 +1,221 @@
+/**
+ * @file       rsi_send_boot_insn.c
+ * @version    1.0
+ * @date       2014-Apr-13
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SEND BOOT INSN: send boot instructions to WiFi module 
+ *
+ * @section Description
+ * This file contains boot instructions exchanges with WiFi module.
+ *
+ *
+ */
+/* 2016/11/17 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_boot_insn(uint8 type, uint16 *data)
+ * @brief       Sends boot instructions to WiFi module
+ * @param[in]   uint8 type, type of the insruction to perform
+ * @param[in]   uint32 *data, pointer to data which is to be read/write
+ * @param[out]  none
+ * @return      errCode
+ *              < 0  = Command issued failure/Invalid command 
+ *                0  = SUCCESS
+ *              > 0  = Read value
+ * @section description 
+ * This API is used to send boot instructions to WiFi module.
+ */
+#if (defined(USB_INTERFACE) || defined(SPI_INTERFACE))
+extern int16 rsi_mem_rd(uint32 reg_address, uint16 len, uint8 *value);
+extern int16 rsi_mem_wr(uint32 reg_address, uint16 len, uint8 *value);
+
+int16 rsi_boot_insn(uint8 type, uint16 *data)
+{
+  int16   retval = 0;
+  uint16  local = 0;
+  uint32  j = 0;
+  uint32  cmd = 0; 
+  uint16  read_data = 0;
+  volatile int32  loop_counter = 0;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\nBootInsn\n");
+#endif
+#if (1) /* GfBÄႢɑΉ 20161117 */
+ uint16  tmp16;
+#endif
+
+  switch(type)
+  {
+    case REG_READ:
+#if (1) /* GfBÄႢɑΉ 20161117 */
+      retval = rsi_mem_rd(HOST_INTF_REG_OUT,2,(uint8 *)&read_data);
+      read_data = rsi_bytes2R_to_uint16((uint8 *)&read_data);
+#else
+      retval = rsi_mem_rd(HOST_INTF_REG_OUT,2,(uint8 *)&read_data);
+#endif
+      *data = read_data;
+      break;
+
+    case REG_WRITE:
+#if (1) /* GfBÄႢɑΉ 20161117 */
+      tmp16 = *data;
+      tmp16 = rsi_bytes2R_to_uint16((uint8 *)&tmp16);
+      retval = rsi_mem_wr(HOST_INTF_REG_IN,2, (uint8 *)&tmp16);
+#else
+      retval = rsi_mem_wr(HOST_INTF_REG_IN,2, (uint8 *)data);
+#endif
+      break;
+
+    case PING_WRITE:
+
+      for (j = 0; j<2048; j++){
+#if (1) /* GfBÄႢɑΉ 20161117 */
+        tmp16 = *((uint16 *)((uint32)data + (j*2)));
+        tmp16 = rsi_bytes2R_to_uint16((uint8 *)&tmp16);
+        retval = rsi_mem_wr(0x19000 + (j*2), 2, (uint8 *)&tmp16);
+#else
+        retval = rsi_mem_wr(0x19000 + (j*2), 2, (uint8 *)((uint32)data + (j*2)));
+#endif
+        if(retval < 0)
+        {
+          return retval;
+        }
+      }
+
+      local = 0xab49;
+#if (1) /* GfBÄႢɑΉ 20161117 */
+      local = rsi_bytes2R_to_uint16((uint8 *)&local);
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&local);
+#else
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&local);
+#endif
+      break;
+
+    case PONG_WRITE:
+
+      for (j = 0; j<2048; j++){
+#if (1) /* GfBÄႢɑΉ 20161117 */
+        tmp16 = *((uint16 *)((uint32)data + (j*2)));
+        tmp16 = rsi_bytes2R_to_uint16((uint8 *)&tmp16);
+        retval = rsi_mem_wr(0x1a000 + (j*2), 2 ,(uint8 *)&tmp16);
+#else
+        retval = rsi_mem_wr(0x1a000 + (j*2), 2 ,(uint8 *)((uint32)data + (j*2)));
+#endif
+        if(retval < 0)
+        {
+          return retval;
+        }
+      }
+      // Perform the write operation
+      local = 0xab4f;
+#if (1) /* GfBÄႢɑΉ 20161117 */
+      local = rsi_bytes2R_to_uint16((uint8 *)&local);
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&local);
+#else
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&local);
+#endif
+      break;
+
+    case RSI_UPGRADE_IMAGE_I_FW:
+      cmd = RSI_UPGRADE_IMAGE_I_FW | HOST_INTERACT_REG_VALID;
+#if (1) /* GfBÄႢɑΉ 20161117 */
+      cmd = rsi_bytes4R_to_uint32((uint8 *)&cmd);
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&cmd);
+#else
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&cmd);
+#endif
+      if(retval < 0)
+      {
+        return retval;
+      }
+
+      RSI_RESET_LOOP_COUNTER(loop_counter); 
+      RSI_WHILE_LOOP(loop_counter, RSI_LOOP_COUNT_UPGRADE_IMAGE)
+      {
+#if (1) /* GfBÄႢɑΉ 20161117 */
+        retval = rsi_mem_rd(HOST_INTF_REG_OUT, 2, (uint8 *)&read_data);
+        read_data = rsi_bytes2R_to_uint16((uint8 *)&read_data);
+#else
+        retval = rsi_mem_rd(HOST_INTF_REG_OUT, 2, (uint8 *)&read_data);
+#endif
+        if(retval < 0)
+        {
+          return retval;
+        }
+        if (read_data == (SEND_RPS_FILE | HOST_INTERACT_REG_VALID)){
+          break;
+        }
+      }
+      RSI_CHECK_LOOP_COUNTER(loop_counter, RSI_LOOP_COUNT_UPGRADE_IMAGE);
+      break;
+
+    case RSI_LOAD_IMAGE_I_FW:
+      cmd = RSI_LOAD_IMAGE_I_FW | HOST_INTERACT_REG_VALID;
+#if (1) /* GfBÄႢɑΉ 20161117 */
+      cmd = rsi_bytes4R_to_uint32((uint8 *)&cmd);
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&cmd);
+#else
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&cmd);
+#endif
+      break;
+    case RSI_LOAD_IMAGE_I_ACTIVE_LOW_FW:
+      cmd = RSI_LOAD_IMAGE_I_ACTIVE_LOW_FW | HOST_INTERACT_REG_VALID;
+#if (1) /* GfBÄႢɑΉ 20161117 */
+      cmd = rsi_bytes4R_to_uint32((uint8 *)&cmd);
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&cmd);
+#else
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&cmd);
+#endif
+      break;
+    case RSI_UPGRADE_BL:
+      cmd = RSI_UPGRADE_BL | HOST_INTERACT_REG_VALID;
+#if (1) /* GfBÄႢɑΉ 20161117 */
+      cmd = rsi_bytes4R_to_uint32((uint8 *)&cmd);
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&cmd);
+#else
+      retval = rsi_mem_wr(HOST_INTF_REG_IN, 2, (uint8 *)&cmd);
+#endif
+      if(retval < 0)
+      {
+        return retval;
+      }
+      RSI_RESET_LOOP_COUNTER(loop_counter);
+      RSI_WHILE_LOOP(loop_counter, RSI_LOOP_COUNT_UPGRADE_IMAGE)
+      {
+#if (1) /* GfBÄႢɑΉ 20161117 */
+        retval = rsi_mem_rd(HOST_INTF_REG_OUT,  2, (uint8 *)&read_data);
+        read_data = rsi_bytes2R_to_uint16((uint8 *)&read_data);
+#else
+        retval = rsi_mem_rd(HOST_INTF_REG_OUT,  2, (uint8 *)&read_data);
+#endif
+        if(retval < 0)
+        {
+          return retval;
+        }
+        if (read_data == (SEND_RPS_FILE | HOST_INTERACT_REG_VALID)){
+          break;
+        }
+      }
+      RSI_CHECK_LOOP_COUNTER(loop_counter, RSI_LOOP_COUNT_UPGRADE_IMAGE);
+      break;
+    default:
+      retval = -2;
+      break;
+  }
+  return retval;
+}
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_data.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_data.c
new file mode 100755
index 0000000..3d29b23
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_data.c
@@ -0,0 +1,143 @@
+/**
+ * @file       rsi_send_data.c
+ * @version    1.2
+ * @date       2013-Feb-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SEND: Function to send udp / tcp data to an existing connection
+ *
+ * @section Description
+ * This file contains the SEND function.
+ *
+ * @Improvements
+ *
+ */
+/* 2019/05/14 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_app.h"
+#include <string.h>
+
+#include "wmrp10_rsi.h" /* APJ : add */
+
+/*
+ * Global Variables 
+ */
+
+
+/*=============================================================*/
+/**
+ * @fn          int16 rsi_send_data(uint16 socketDescriptor, uint8 *payload, uint32 payloadLen,uint8 protocol)
+ * @brief       SEND Packet command
+ * @param[in]   uint16 socketDescriptor, socket descriptor for the socket to send data to
+ * @param[in]   uint8 *payload, pointer to the data to send payload buffer
+ * @param[in]   uint32 payloadLen, length of the data to send payload
+ * @param[in]   uint8  protocol, TCPV4/TCPV6
+ * @param[out]  uint32 bytes_sent, number of bytes sent succesfuly
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description
+ * This API used to send TCP/UDP data using an already opened socket. This function
+ * should be called after successfully opening a socket using the rsi_socket API.
+ * If this API return error code-1, Application need to retry this function until
+ * successfully send the packet over WiFi module.
+ */
+//#if !RSI_TCP_IP_BYPASS
+#if !WMRP10_TCP_IP_BYPASS /* APJ : modify */
+int16 rsi_send_data(uint16 socketDescriptor, uint8 *payload, uint32 payloadLen,uint8 protocol,uint32 *bytes_sent)
+{
+  int16   retval = 0;
+  uint16  headerLen = 0;
+  //!payload length sent in each packet
+  uint32  send_payload_len = 0;
+  //!payload offset
+  uint32  payload_offset = 0;
+  //! length of frame without padding bytes
+  uint32  frameLen = 0;
+
+  //! length to pad the transfer so it lines up on a 4 byte boundary
+  uint8  rsi_local_frameCmdSend[RSI_BYTES_3];
+
+  memcpy(rsi_local_frameCmdSend, rsi_frameCmdSend, RSI_BYTES_3);
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\nSend Data Start\n");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %s len-%d, socket-%d\n","WLAN","Tx","Send data Req","Send data on socket",payloadLen,payload[1]);
+#endif
+
+//  rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameSnd.ip_version, RSI_IP_VERSION);
+  rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameSnd.ip_version, WMRP10_IP_VERSION); /* APJ : modify */
+
+  if((protocol & 0xF) == RSI_PROTOCOL_TCP_V4)
+  {
+    headerLen =  RSI_TCP_FRAME_HEADER_LEN;
+  }
+  else
+  {
+    headerLen =  RSI_TCP_V6_FRAME_HEADER_LEN;
+  }
+
+  if(protocol & BIT(7))
+  {
+    //! If websocket is enabled
+    headerLen += ((payloadLen < 126) ? 6 : 8);
+  }
+
+  rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameSnd.sendDataOffsetSize, headerLen);
+
+  rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameSnd.socketDescriptor,socketDescriptor);
+
+  do
+  {
+    if(payloadLen >= RSI_TCP_MAX_SEND_SIZE)
+    {
+      send_payload_len = RSI_TCP_MAX_SEND_SIZE;
+    }
+    else
+    {
+      send_payload_len = payloadLen;
+    }
+    frameLen = send_payload_len + headerLen;
+
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL13," PayloadLen=%08x", (uint16)send_payload_len);
+#endif
+
+    rsi_uint16_to_2bytes(rsi_local_frameCmdSend, ((frameLen & 0x0FFF) | 0x5000));
+    
+
+    rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameSnd.sendBufLen, send_payload_len);
+    
+    memcpy((uint8 *)&rsi_app_cb.uSendFrame.uSendBuf[headerLen],(uint8 *)(payload + payload_offset), send_payload_len);
+    retval = rsi_execute_cmd((uint8 *)rsi_local_frameCmdSend,(uint8 *)&rsi_app_cb.uSendFrame,frameLen);
+    if (retval != 0x00)
+    {
+#ifdef RSI_DEBUG_PRINT
+      RSI_DPRINT(RSI_PL4,"SendCmd Err=%02x", (uint16)retval);
+#endif
+      return retval;
+    }
+    payloadLen     -= send_payload_len;
+    *bytes_sent    += send_payload_len;
+    payload_offset += send_payload_len;
+  } while(payloadLen);
+  return retval;
+}
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_ludp_data.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_ludp_data.c
new file mode 100755
index 0000000..c27f5eb
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_ludp_data.c
@@ -0,0 +1,144 @@
+/**
+ * @file       rsi_send_ludp_data.c
+ * @version    1.2
+ * @date       2013-Feb-18
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SEND LUDP DATA: Function to send ludp data to an existing connection
+ *
+ * @section Description
+ * This file contains the SEND function.
+ *
+ */
+/* 2019/05/14 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <stdio.h>
+#include <string.h>
+#include "rsi_app.h"
+
+#include "wmrp10_rsi.h" /* APJ : add */
+
+/*
+ * Global Variables
+ */
+
+
+/*=============================================================*/
+/**
+ * @fn          int16 rsi_send_ludp_data(uint16 socketDescriptor,
+ *              uint8 *payload, uint32 payloadLen,uint8 protocol,
+ *              uint8 *destIp, uint16 destPort)
+ * @brief       SEND Packet command
+ * @param[in]   uint16 socketDescriptor, socket descriptor for the socket to send data to
+ * @param[in]   uint8 *payload, pointer to the data to send payload buffer
+ * @param[in]   uint32 payloadLen, length of the data to send payload
+ * @param[in]   uint8  protocol, 0 - LUDP
+ * @param[in]   uint8 *destIp, Remote target IP address
+ * @param[in]   uint8 *destPort, Remote target port
+ * @param[out]  uint32 bytes_sent, number of bytes sent
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *
+ * @section description
+ * This API used to send LUDP data using an already opened socket. This function
+ * should be called after successfully opening a socket using the rsi_socket API.
+ * If this API return error codes like -1, Application need to retry this function until
+ * successfully send the packet over WiFi module.
+ */
+//#if !RSI_TCP_IP_BYPASS
+#if !WMRP10_TCP_IP_BYPASS /* APJ : modify */
+int16 rsi_send_ludp_data(uint16 socketDescriptor, uint8 *payload,
+    uint32 payloadLen,uint8 protocol, uint8 *destIp, uint16 destPort,uint32 *bytes_sent)
+{
+  int16         retval = 0;
+  //!payload length sent in each packet
+  uint32        send_payload_len = 0;
+  //!payload offset
+  uint32        payload_offset = 0;
+  uint32        headerLen = 0;
+  //! length of frame without padding bytes
+  uint32        frameLen = 0;
+  //! length to pad the transfer so it lines up on a 4 byte boundary
+  uint8  rsi_local_frameCmdSend[RSI_BYTES_3];
+
+  memcpy(rsi_local_frameCmdSend, rsi_frameCmdSend, RSI_BYTES_3);
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\nSend LUDP Data Start\n");
+#endif
+
+  if(protocol == RSI_PROTOCOL_UDP_V4)
+  {
+    headerLen = RSI_UDP_FRAME_HEADER_LEN;
+  }
+  else
+  {
+    headerLen = RSI_UDP_V6_FRAME_HEADER_LEN;
+  }
+
+  rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameLudpSnd.sendDataOffsetSize, headerLen);
+
+//  rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameLudpSnd.ip_version, RSI_IP_VERSION);
+  rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameLudpSnd.ip_version, WMRP10_IP_VERSION); /* APJ : modify */
+  rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameLudpSnd.socketDescriptor, socketDescriptor);
+  rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameLudpSnd.destPort, destPort);
+
+
+  if(RSI_IP_VERSION == IP_VERSION_4)
+  {
+    memcpy(&rsi_app_cb.uSendFrame.sendFrameLudpSnd.destIPaddr.ipv4_address,destIp,RSI_IP_ADD_LEN);
+  }
+  else
+  {
+    memcpy(&rsi_app_cb.uSendFrame.sendFrameLudpSnd.destIPaddr.ipv6_address,destIp ,16);
+  }
+  while(payloadLen)
+  {
+    if(payloadLen >= RSI_UDP_MAX_SEND_SIZE)
+    {
+      send_payload_len =RSI_UDP_MAX_SEND_SIZE;
+    }
+    else
+    {
+      send_payload_len = payloadLen;
+    }
+    frameLen = send_payload_len + headerLen;
+    rsi_uint16_to_2bytes(rsi_local_frameCmdSend, ((frameLen & 0x0FFF) | 0x5000));
+    
+
+    rsi_uint16_to_2bytes(rsi_app_cb.uSendFrame.sendFrameLudpSnd.sendBufLen,send_payload_len);
+    
+    memcpy((uint8 *)&rsi_app_cb.uSendFrame.uSendBuf[headerLen],(uint8 *)(payload + payload_offset),send_payload_len);
+    retval = rsi_execute_cmd((uint8 *)rsi_local_frameCmdSend,(uint8 *)&rsi_app_cb.uSendFrame, (uint16)frameLen);
+    if (retval != 0x00)
+    {
+#ifdef RSI_DEBUG_PRINT
+      RSI_DPRINT(RSI_PL4,"SendCmd Err=%02x", (uint16)retval);  
+#endif
+      return retval;
+    }
+    payloadLen     -= send_payload_len;
+    *bytes_sent    += send_payload_len;
+    payload_offset += send_payload_len;
+  }
+  return retval;
+}
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_raw_data.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_raw_data.c
new file mode 100755
index 0000000..cdd60f6
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_raw_data.c
@@ -0,0 +1,82 @@
+/**
+ * @file       rsi_send_raw_data.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SEND RAW DATA: Function to send raw data.
+ *
+ * @section Description
+ * This file contains the SEND Raw data function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/*
+ * Global Variables 
+ */
+
+
+/*=============================================================*/
+/**
+ * @fn          int16 rsi_send_raw_data(uint8 *payload, uint32 payloadLen,uint32 *bytes_sent)
+ * @brief       SEND Packet command
+ * @param[in]   uint8 *payload, pointer to the data to payload buffer
+ * @param[in]   uint32 payloadLen, length of the payload
+ * @param[out]  uint32 bytes_sent, number of bytes sent
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *
+ * @section description 
+ * This API used to send raw data over Wi-Fi module. This API is used to send data 
+ * packets in TCP/IP bypass mode.If this API return error code like -1, 
+ * Application need to retry this function until successfully send the packet 
+ * over WiFi module.
+ */
+
+int16 rsi_send_raw_data(uint8 *payload, uint32 payloadLen,uint32 *bytes_sent)
+{
+  int16         retval = 0;
+  rsi_uFrameDsc uFrameDscFrame;
+  
+  if(payloadLen > RSI_RAW_DATA_MAX_SEND_SIZE)
+  {
+    return -2;
+  }
+  rsi_uint16_to_2bytes(uFrameDscFrame.frameDscDataSnd.dataFrmLenAndQueue, ((payloadLen & 0x0FFF) | 0x5000));
+  
+
+  retval = rsi_execute_cmd((uint8 *)&uFrameDscFrame,(uint8 *)payload, payloadLen);
+
+  if (retval != 0x00) 
+  {
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL4,"SndFrmDescErr=%02x", (uint16)retval);  
+#endif
+    return retval;
+  }
+
+  *bytes_sent    = payloadLen;
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_url_rsp.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_url_rsp.c
new file mode 100755
index 0000000..a881cde
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_url_rsp.c
@@ -0,0 +1,140 @@
+/**
+ * @file       rsi_send_url_rsp.c
+ * @version    1.1
+ * @date       2013-Feb-6
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SPI URL RESPONSE: Function which sends host web page.
+ *
+ * @section Description
+ * This file contains the functionality to send host web page.
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_send_url_rsp(HostWebpageSnd_t *uUrlRsp, uint8 *webpage_morechunks, uint8 *webpage_file , uint32 file_size, uint8 first_chunk)
+ * @brief       Sends the Webserver command to the Wi-Fi module via SPI
+ * @param[in]   HostWebpageSnd_t *uUrlRsp, Pointer to WebpageSnd_t structure
+ * @param[in]   uint8 *webpage_morechunks, Pointer to webpage_morechunks
+ * @param[in]   uint8 *webpage_file, pointer to webpage
+ * @param[in]   uint32 file_size, web page total size
+ * @param[in]   uint8 first_chunk, to identify whether it is first chunk or not
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send url response to the Wi-Fi module. 
+ * This API should be called only after rsi_init API.
+ *
+ * @section prerequisite 
+ * The rsi_init for the Wi-Fi Module initialization should be done successfully.
+ */
+/* 2016/11/25 APJ modify */
+
+//#if WEBPAGE_BYPASS_SUPPORT /* APJ : delete */
+#if 1 /* APJ : add */
+int16 rsi_send_url_rsp(HostWebpageSnd_t *uUrlRsp, uint8 *webpage_morechunks, uint8 *webpage_file , uint32 file_size, uint8 first_chunk)
+{
+  int16  retval     =  0;
+  uint16 curr_len   =  0;
+  uint16 send_length = 0;
+  uint8 rsi_framelocalCmdUrlRsp[3] = {0};
+
+  static uint32 offset;
+#ifdef RSI_DEBUG_PRINT
+  static uint16 count=0;
+#endif
+
+  if(first_chunk)
+  {
+    //! If it is the first chunk then reset offset to zero
+    offset = 0;
+  }
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\nLoad Host Webpage Start\n");
+#endif
+
+  //! Get the current length that you want to send
+  curr_len = ((file_size - offset) > MAX_HOST_WEBPAGE_SEND_SIZE) 
+    ? MAX_HOST_WEBPAGE_SEND_SIZE : (file_size - offset);
+
+  //! Fill total host web page size
+  rsi_uint32_to_4bytes(uUrlRsp->total_len, file_size);
+
+  //! Fill more chunks
+  if((file_size - offset) <= MAX_HOST_WEBPAGE_SEND_SIZE)
+  {
+    *webpage_morechunks = 0;
+    uUrlRsp->more_chunks = 0;
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3, "sending Last chunk\n");
+#endif
+  }
+  else
+  {
+    *webpage_morechunks = 1;
+    uUrlRsp->more_chunks = 1;
+  }
+
+  //! Fill web page content
+  memcpy((uint8*)(uUrlRsp->webpage), (uint8*)(webpage_file + offset), curr_len);
+
+  //! calculate length of frame to send
+  send_length = curr_len + (sizeof(HostWebpageSnd_t) - sizeof(uUrlRsp->webpage));
+
+  //! Fill frame length & packet type
+  rsi_uint16_to_2bytes(rsi_framelocalCmdUrlRsp, ((send_length & 0xFFF) | (0x4 << 12)));
+
+  //! Fill frame type
+  rsi_framelocalCmdUrlRsp[2] = RSI_RSP_HOST_WEBPAGE; 
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3, "total, current, send_length, offset, count: %d, %d, %d, %d %d\n", file_size, curr_len, send_length, offset, ++count);
+#endif
+
+  //! Send the current chunk 
+  retval = rsi_execute_cmd((uint8 *)rsi_framelocalCmdUrlRsp ,(uint8 *)uUrlRsp, send_length);
+
+  //! Adjust the offset
+  offset += curr_len;
+
+  //! Reset offset for next file if required
+  if (offset >= file_size) 
+  {
+    offset = 0;
+#ifdef RSI_DEBUG_PRINT
+    count = 0;
+#endif
+  }
+
+  return retval;
+}
+#endif
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_websocket_data.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_websocket_data.c
new file mode 100755
index 0000000..7aa5a82
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_send_websocket_data.c
@@ -0,0 +1,104 @@
+/**
+ * @file       rsi_send_websocket_data.c
+ * @version    1.2
+ * @date       2013-Feb-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SEND: Function to send udp / tcp data to an existing connection
+ *
+ * @section Description
+ * This file contains the SEND function.
+ *
+ * @Improvements
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_app.h"
+
+/*
+ * Global Variables 
+ */
+
+
+/*=============================================================*/
+/**
+ * @fn          int16 rsi_send_websocket_data(uint16 socketDescriptor, uint8 *payload, uint32 payloadLen,uint8 protocol, uint32 *total_bytes_sent)
+ * @brief       SEND websocket Packet command
+ * @param[in]   uint16 socketDescriptor, socket descriptor for the socket to send data to
+ * @param[in]   uint8 *payload, pointer to the data to send payload buffer
+ * @param[in]   uint32 payloadLen, length of the data to send payload
+ * @param[in]   uint8  protocol, TCPV4 or TCPV6
+ * @param[out]  uint32 *total_bytes_sent, number of bytes sent succesfuly
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *
+ * @section description 
+ * This API used to send websocket TCP data using an already opened socket. This function 
+ * should be called after successfully opening a socket using the rsi_socket API.
+ * If this API return error code-1, Application need to retry this function until 
+ * successfully send the packet over WiFi module.
+ */
+#if !RSI_TCP_IP_BYPASS
+int16 rsi_send_websocket_data(uint16 socketDescriptor, uint8 *payload, uint32 payloadLen,uint8 protocol, uint8 opcode, uint32 *total_bytes_sent)
+{
+  int16 retval          = 0;
+  uint32 send_length    = 0;
+  uint32 payload_offset = 0;
+  uint8 websocket_info  = 0;
+  uint32 bytes_sent     = 0;
+
+
+  do
+  {
+    websocket_info = opcode;
+    if(payloadLen > RSI_WEBSOCKET_MAX_SEND_SIZE)
+    {
+      send_length = RSI_WEBSOCKET_MAX_SEND_SIZE;
+    }
+    else
+    {
+      send_length = payloadLen;
+      //! Set the fin bit
+      websocket_info |= BIT(7);
+    }
+    socketDescriptor |= (websocket_info << 8);
+
+    //! call actual send API
+    retval = rsi_send_data(socketDescriptor, (payload + payload_offset), send_length, (protocol | BIT(7)), &bytes_sent);
+    if(retval != 0)
+    {
+#ifdef RSI_DEBUG_PRINT
+      RSI_DPRINT(RSI_PL4,"SendCmd Err=%02x", (uint16)retval);
+#endif
+      return retval;
+    }
+
+    payloadLen           -= bytes_sent;
+    *total_bytes_sent    += bytes_sent;
+    payload_offset       += bytes_sent;
+    bytes_sent = 0;
+
+  } while(payloadLen);
+  return retval;
+}
+#endif
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_ap_config.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_ap_config.c
new file mode 100755
index 0000000..3dde6da
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_ap_config.c
@@ -0,0 +1,62 @@
+/**
+ * @file     rsi_set_ap_config.c
+ * @version  2.9
+ * @date     2012-Nov-21
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief AP CONFIGURATION: Function which implements the apconf command
+ *
+ * @section Description
+ * This file contains the rsi_apconfiguration function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_set_ap_config(rsi_apconfig *apconf)
+ * @param[in]   rsi_apconfig *apconf, Pointer to apconfig structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set AP configuration parameters to the Wi-Fi module.
+ *
+ * @section prerequisite 
+ * The rsi_init should be done sussessfully.
+ */
+int16 rsi_set_ap_config(rsi_apconfig *apconf)
+ {
+    int16 retval;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nAP configuration");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdAPconf, (uint8 *)apconf, sizeof(rsi_apconfig));
+  return retval;   
+ }
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_certificate.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_certificate.c
new file mode 100755
index 0000000..d533ed7
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_certificate.c
@@ -0,0 +1,126 @@
+/**
+ * @file      rsi_set_certificate.c
+ * @version    1.2
+ * @date       2013-Feb-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SET CERTIFICATE: Function which loads the Certificate 
+ *
+ * @section Description
+ * This file contains the SET CERTIFICATE function.
+ *
+ * @Improvements
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+//#include <string.h>
+#include <linux/module.h>
+
+/**
+ * Global Variables
+ */
+
+
+/*===============================================================*/
+/**
+ * @fn        int16 rsi_set_certificate(uint8 certificate_type,uint8 *buffer,uint32 certifictae_length, struct SET_CHUNK_S *SetChunkPtr)
+ * @brief      loads the certificate to the module 
+ * @param[in]  uint8 certificate_type, type of the certificate to load
+ * @param[in]  uint8 *buffer, pointer to the certificate buffer
+ * @param[in]  uint32 certificate_length, length of the certificate 
+ * @param[in]  SET_CHUNK_S *SetChunkPtr, pointer to the certificate structure
+ * @param[out] none
+ * @return     int16 retval
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @description This API is used to load the certificate to the module.
+ */
+
+int16 rsi_set_certificate(uint8 certificate_type,uint8 *buffer, uint32 certificate_length, struct SET_CHUNK_S *SetChunkPtr)
+{ 
+  int16 retval = 0;
+  static uint16 rem_len ;
+  uint16 chunk_size = 0;
+  static uint16 offset;
+  uint8  rsi_local_frameCmdCert[RSI_BYTES_3];
+
+  //!Get the certificate chunk size  
+  chunk_size = (MAX_CERT_SEND_SIZE - sizeof(struct cert_info_s)); 
+  memcpy(rsi_local_frameCmdCert, rsi_frameCmdCert, RSI_BYTES_3);
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\nSet Certificate Start\n");
+#endif
+ //! This means it is the first chunk
+  if(SetChunkPtr->cert_info.more_chunks == 0)
+  {
+	  rem_len = certificate_length;
+  }
+  
+  if(rem_len >= chunk_size)
+  {
+    rsi_uint16_to_2bytes(rsi_local_frameCmdCert, ((MAX_CERT_SEND_SIZE & 0x0FFF) | 0x4000));
+    
+    //! Copy the certificate chunk 
+    memcpy(SetChunkPtr->Certificate, buffer + offset, chunk_size);
+    //! Move the offset by chunk size 
+    offset += chunk_size;
+    //! Subtract the rem_len by the chunk size  
+    rem_len -= chunk_size;
+    //!Set the total length of certificate
+    rsi_uint16_to_2bytes(SetChunkPtr->cert_info.total_len, certificate_length);
+    //! Set the certificate type 
+    SetChunkPtr->cert_info.CertType = certificate_type;
+    //! more chunks to send 
+    SetChunkPtr->cert_info.more_chunks = 1;
+    //! Set the length of the certificate chunk 
+    rsi_uint16_to_2bytes(SetChunkPtr->cert_info.CertLen, chunk_size);
+    //! set the Key_password of the certificate
+    strcpy((char *)&SetChunkPtr->cert_info.KeyPwd,KEY_PASSWORD);
+    retval = rsi_execute_cmd((uint8 *)rsi_local_frameCmdCert,(uint8 *)SetChunkPtr,MAX_CERT_SEND_SIZE);
+  }
+  else
+  {
+    rsi_uint16_to_2bytes(rsi_local_frameCmdCert, (((rem_len + sizeof(struct cert_info_s)) & 0x0FFF) | 0x4000));
+
+    //! Copy the certificate chunk 
+    memcpy(SetChunkPtr->Certificate, buffer + offset, rem_len);
+    //! Move the offset by chunk size 
+    offset += rem_len;
+    //!Set the total length of certificate 
+    rsi_uint16_to_2bytes(SetChunkPtr->cert_info.total_len, certificate_length);
+    //! Set the certificate type 
+    SetChunkPtr->cert_info.CertType = certificate_type;
+    //!This is the last chunks to send
+    SetChunkPtr->cert_info.more_chunks = 0;
+    //! Set the length of the certificate chunk
+    rsi_uint16_to_2bytes(SetChunkPtr->cert_info.CertLen,rem_len);
+    //!set the Key_password of the certificate
+    strcpy((char *)&SetChunkPtr->cert_info.KeyPwd,KEY_PASSWORD); 
+    retval = rsi_execute_cmd((uint8 *)rsi_local_frameCmdCert,(uint8 *)SetChunkPtr,(rem_len + sizeof(struct cert_info_s)));
+
+    //! Reset rem_len and offset 
+    rem_len = 0;
+    offset = 0;
+  }
+
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_eap.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_eap.c
new file mode 100755
index 0000000..4aafb3b
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_eap.c
@@ -0,0 +1,67 @@
+/**
+ * @file       rsi_set_eap.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief EAP: Function which implements the version of the EAP command
+ *
+ * @section Description
+ * This file contains the EAP function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_set_eap(rsi_uSetEap *uSetEapFrame)
+ * @param[in]   rsi_uSetEap *uSetEapFrame, Pointer to EAP structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to set EAP parameters to the Wi-Fi module.
+ *
+ * @section prerequisite 
+ * The rsi_init should be done sussessfully.
+ */
+
+int16 rsi_set_eap(rsi_uSetEap *uSetEap)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\n Set Eap Start");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-7.5s %-15.15s %-30.25s\n","WLAN","Tx","Set EAP","Loading EAP parametrs");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSetEap,(uint8 *)uSetEap, sizeof(rsi_uSetEap));
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_mac_addr.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_mac_addr.c
new file mode 100755
index 0000000..84d4dfd
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_mac_addr.c
@@ -0,0 +1,71 @@
+/**
+ * @file       rsi_set_mac_addr.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2011
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SET MAC ADDRESS: Function to set the mac address
+ *
+ * @section Description
+ * This file contains function to set mac address.
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+//#include <stdio.h>
+//#include <string.h>
+#include <linux/module.h>
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ * @fn           int16 rsi_set_mac_addr(uint8 *macAddress)
+ * @brief        Sends the set MAC Address command to the Wi-Fi module via SPI
+ * @param[in]    uint8 *macAddress
+ * @param[out]   none
+ * @return       errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description  
+ * This API is used to overwrite the MAC address provided by the module. It should be 
+ * called before the rsi_init API.
+ * @section prerequisite  
+ * This API should be called before rsi_init API.
+ */
+int16 rsi_set_mac_addr(uint8 *macAddress)
+{
+  int16                    retval;
+  rsi_uSetMacAddr          uSetMacAddrFrame;  
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\nSetMacAddr Start ");
+#endif
+
+  //!send the MAC Address
+  memcpy(uSetMacAddrFrame.setMacAddrFrameSnd.macAddr,macAddress, RSI_MACADDRLEN);
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSetMacAddr,(uint8 *)&uSetMacAddrFrame,sizeof(rsi_uSetMacAddr));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_region.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_region.c
new file mode 100755
index 0000000..156c6c3
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_region.c
@@ -0,0 +1,67 @@
+/**
+ * @file       rsi_set_region.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SET REGION: Function to set the Region Code.
+ *
+ * @section Description
+ * This file contains the set region function.
+ *
+ *
+ */
+/* 2016/10/11 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ *@fn           int16 rsi_set_region(rsi_uSetRegion *uSetRegionReqFrame)
+ * @brief       Sends the SET Region Code command to the Wi-Fi module via SPI
+ * @param[in]   rsi_uSetRegionReq *uSetRegionReqFrame,Pointer to Set Region structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to select the region code.
+ * This API is called only if opermode is 0 or 2 and is given only after init command
+ */
+//#if SET_REGION_SUPPORT /* APJ : delete */
+#if 1 /* APJ : add */
+int16 rsi_set_region(rsi_usetregion *uSetRegionReqFrame)
+{
+  int16 retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set region");
+#endif
+
+  retval =rsi_execute_cmd((uint8 *)rsi_frameSetRegion,(uint8 *)uSetRegionReqFrame, sizeof(rsi_usetregion));
+  return retval;
+
+  }
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_region_ap.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_region_ap.c
new file mode 100755
index 0000000..67ed7d3
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_region_ap.c
@@ -0,0 +1,67 @@
+/**
+ * @file       rsi_set_region_ap.c
+ * @version    2.7
+ * @date       2014-Jul-1
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SET REGION: Function to set the Region Code in AP mode.
+ *
+ * @section Description
+ * This file contains the set region function.
+ *
+ *
+ */
+/* 2016/10/11 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ *@fn           int16 rsi_set_region_ap(rsi_usetregion_ap_t *uSetRegionApReqFrame)
+ * @brief       Sends the SET Region Code command to the Wi-Fi module via SPI
+ * @param[in]   rsi_usetregion_ap_t *uSetRegionApReqFrame,Pointer to Set Region structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description
+ * This API is used to set region of AP and is given immediately after init command
+ * This command is valid only if opermode is given as 6.
+ */
+
+//#if SET_REGION_AP_SUPPORT /* APJ : delete */
+#if 1 /* APJ : add */
+int16 rsi_set_region_ap(rsi_usetregion_ap_t *uSetRegionApReqFrame)
+{
+  int16         retval;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n Set region AP");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameSetRegionAp,(uint8 *)uSetRegionApReqFrame, sizeof(rsi_usetregion_ap_t));
+  return retval;
+
+}
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_wepkey.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_wepkey.c
new file mode 100755
index 0000000..0803558
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_set_wepkey.c
@@ -0,0 +1,61 @@
+/**
+ * @file       rsi_set_wepkey.c
+ * @version    2.9
+ * @date       2012-Nov-21
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief WEPKEY: Function which implements the wepkey command
+ *
+ * @section Description
+ * This file contains the rsi_set_wepkey function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_set_wepkey(rsi_wepkey *wepkey)
+ * @brief       SPI, SET WEP KEY Command
+ * @param[in]   rsi_wepkey *wepkey - Pointer to the WEP key structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *      
+ * @section description 
+ * This API is used to set the WEP keys for connection to a WEP Secured AP.
+ */
+int16 rsi_set_wepkey(rsi_wepkey *wepkey)
+ {
+    int16 retval;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSet Wepkey");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdWepkey,(uint8 *)wepkey, sizeof(rsi_wepkey));
+  return retval;
+ }
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_sleep_timer.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_sleep_timer.c
new file mode 100755
index 0000000..5aa32dc
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_sleep_timer.c
@@ -0,0 +1,65 @@
+/**
+ * @file       rsi_sleep_timer.c
+ * @version    3.4
+ * @date       2013-Feb-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SLEEP TIMER: Function which sets the SLEEP TIMER value 
+ *
+ * @section Description
+ * This file contains the Sleep timer function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_sleep_timer(rsi_uSleepTimer *uSleepTimer)
+ * @brief       Sends the sleep timer command to the Wi-Fi module
+ * @param[in]   uSleepTimer, Pointer to rsi_uSleepTimer.
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to configure sleep timer in seconds.
+ * This API has to be called only after the intialisation
+ * is done for Wi-Fi module.
+ */
+int16 rsi_sleep_timer(rsi_uSleepTimer *uSleepTimer)
+{
+  int16     retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nBand Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSleepTimer,(uint8 *)uSleepTimer, sizeof(rsi_uSleepTimer));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_smtp_client.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_smtp_client.c
new file mode 100755
index 0000000..d9fe568
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_smtp_client.c
@@ -0,0 +1,119 @@
+/**
+ * @file       rsi_smtp_client.c
+ * @version    1.0
+ * @date       2015-Sep-23
+ *
+ * Copyright(C) Redpine Signals 2015
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SMTP CLIENT: Function which implements SMTP client
+ *
+ * @section Description
+ * This file contains the SMTP client functionality.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_smtp_client(uint8 type, rsi_smtp_client_t *smtp_client)
+ * @brief       Sends the SMTP commands to the Wi-Fi module
+ * @param[in]   rsi_smtp_client_t *smtp_client, Pointer to SMTP structure
+ * @param[in]   uint8 type, type of SMTP command
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send SMTP commands to the Wi-Fi module.
+ * This API should be called only after rsi_ip_param_set API.
+ *
+ * @section prerequisite 
+ * The IP configuration should be done sussessfully.
+ */
+
+int16 rsi_smtp_client(uint8 type, rsi_smtp_client_t *smtp_client)
+{
+  int16          retval, str_len =0, buf_len = 0;
+  uint16         pkt_len = 0;
+  uint8          no_of_fields=0, i=0;
+  uint8          rsi_frameCmdSMTP[RSI_BYTES_3] = {0x00, 0x40, 0xE6};    
+
+  //! Fill command type
+  smtp_client->command_type = type;
+
+  if((type == SMTP_CLIENT_CREATE) || (type == SMTP_CLIENT_DEINIT))
+  {
+    pkt_len = sizeof(rsi_smtp_client_t) - RSI_SMTP_BUFFER_LENGTH;
+  }
+
+  if(smtp_client->command_type == SMTP_CLIENT_INIT)
+  {
+    no_of_fields = 4;
+
+    while( i < no_of_fields)
+    {
+      str_len = strlen((char *)&smtp_client->smtp_buffer[buf_len]);
+      buf_len += (str_len + 1);
+      i++;
+    }
+    pkt_len = sizeof(rsi_smtp_client_t) - RSI_SMTP_BUFFER_LENGTH + buf_len;
+  }
+
+  if(smtp_client->command_type == SMTP_CLIENT_MAIL_SEND)
+  {
+    no_of_fields = 2;
+
+
+    while( i < no_of_fields)
+    {
+      str_len = strlen((char *)&smtp_client->smtp_buffer[buf_len]);
+      buf_len += (str_len + 1);
+      i++;
+    }
+
+    buf_len += rsi_bytes2R_to_uint16(smtp_client->smtp_struct.smtp_mail_send.smtp_client_mail_body_length); 
+
+    if(smtp_client->smtp_struct.smtp_mail_send.smtp_feature & RSI_FEAT_SMTP_EXTENDED_HEADER)
+    {
+      str_len = strlen((char *)&smtp_client->smtp_buffer[buf_len]);
+      buf_len += (str_len + 1);
+    }
+    pkt_len = sizeof(rsi_smtp_client_t) - RSI_SMTP_BUFFER_LENGTH + buf_len;
+  }
+
+
+  rsi_uint16_to_2bytes(rsi_frameCmdSMTP, ((pkt_len & 0x0FFF) | 0x4000));
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n SMTP client");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSMTP, (uint8 *)smtp_client, pkt_len);
+
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_enable.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_enable.c
new file mode 100755
index 0000000..25670a0
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_enable.c
@@ -0,0 +1,60 @@
+/**
+ * @file       rsi_snmp_enable.c
+ * @version    1.0
+ * @date       2014-Mar-03
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SNMP ENABLE: Enables SNMP 
+ *
+ * @section Description
+ * This file contains the Snmp enable function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_snmp_enable(uint8 snmpEnable)
+ * @brief       Sends the SNMP enable command to the Wi-Fi module
+ * @param[in]   uint8 snmpEnable,value to enable snmp
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to enable SNMP.
+ * This API has to be called only after the rsi_ipparm_set or rsi_ipconf6 API.
+ */
+int16 rsi_snmp_enable(uint8 snmpEnable)
+{
+  int16    retval;
+  rsi_uSnmpEnable  usnmpEnableFrame;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSNMP enable Start");
+#endif
+  usnmpEnableFrame.snmpEnableFrameSnd.snmpEnable = snmpEnable;
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSnmpEnable,(uint8 *)&usnmpEnableFrame, sizeof(rsi_uSnmpEnable));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_get_next_rsp.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_get_next_rsp.c
new file mode 100755
index 0000000..d663a40
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_get_next_rsp.c
@@ -0,0 +1,59 @@
+/**
+ * @file       rsi_snmp_get_next_rsp.c
+ * @version    1.0
+ * @date       2014-Mar-03
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SNMP GET NEXT RSP: sends response for SNMP get next request
+ *
+ * @section Description
+ * This file contains the Snmp get next response function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_snmp_get_next_rsp(rsi_uSnmp  *uSnmpGetNextRsp)
+ * @brief       Sends the SNMP get next response command to the Wi-Fi module
+ * @param[in]   rsi_uSnmp *uSnmpGetNextRsp
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send SNMP get next response.
+ * This API has to be called only after the rsi_snmp_enable API.
+ */
+int16 rsi_snmp_get_next_rsp(rsi_uSnmp  *uSnmpGetNextRsp)
+{
+  int16    retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSNMP get next response Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSnmpGetNextRsp,(uint8 *)uSnmpGetNextRsp, sizeof(rsi_uSnmp));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_get_rsp.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_get_rsp.c
new file mode 100755
index 0000000..a71b970
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_get_rsp.c
@@ -0,0 +1,59 @@
+/**
+ * @file       rsi_snmp_get_rsp.c
+ * @version    1.0
+ * @date       2014-Mar-03
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SNMP GET RSP: sends response for SNMP get request
+ *
+ * @section Description
+ * This file contains the Snmp get response function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_snmp_get_rsp(rsi_uSnmp  *uSnmpGetRsp)
+ * @brief       Sends the SNMP get response command to the Wi-Fi module
+ * @param[in]   rsi_Snmp *uSnmpGetRsp
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send SNMP get response.
+ * This API has to be called only after the rsi_snmp_enable API.
+ */
+int16 rsi_snmp_get_rsp(rsi_uSnmp  *uSnmpGetRsp)
+{
+  int16               retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSNMP get response Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSnmpGetRsp,(uint8 *)uSnmpGetRsp, sizeof(rsi_uSnmp));
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_get_stats.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_get_stats.c
new file mode 100755
index 0000000..7eebe10
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_get_stats.c
@@ -0,0 +1,51 @@
+/**
+ * @file       rsi_snmp_get_stats.c
+ * @version    1.0
+ * @date       2017-Thu-04
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SNMP GET STATS: sends intermediate response for SNMP get request
+ *
+ * @section Description
+ * This file contains the Snmp get stats function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/*==============================================*/
+/**
+ * @fn          void rsi_snmp_get_rsp(void)
+ * @brief       Sends the SNMP statistics as an intermediate response
+ * @param[in]   none
+ * @param[out]  none
+ * @return      none
+ * @section description 
+ * This API is used to send SNMP statistics as response.
+ * This API has to be called only after the rsi_snmp_enable API.
+ */
+int16 rsi_snmp_get_stats(void)
+{
+  int16 retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSNMP get stats Start");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSnmpGetStats, NULL, 0);
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_trap.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_trap.c
new file mode 100755
index 0000000..66820ff
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_snmp_trap.c
@@ -0,0 +1,69 @@
+/**
+ * @file       rsi_snmp_trap.c
+ * @version    1.0
+ * @date       2014-Mar-03
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SNMP TRAP: sends SNMP trap
+ *
+ * @section Description
+ * This file contains the Snmp trap function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_snmp_trap(rsi_uSnmptrap *uSnmpTrapFrame)
+ * @brief       Sends the SNMP trap command to the Wi-Fi module
+ * @param[in]   rsi_uSnmptrap *uSnmpTrapFrame
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used for SNMP trap command.
+ * This API has to be called only after the rsi_snmp_enable API.
+ */
+
+
+int16 rsi_snmp_trap(rsi_uSnmptrap  *uSnmpTrapFrame, int snmp_len)
+{
+  int16               retval;
+
+
+  /*SNMP trap Response frame*/
+  uint8   rsi_frameCmdSnmpTrap[RSI_BYTES_3] = {0x6E, 0x44, 0x86};
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nSNMP trap Start");
+#endif
+
+  rsi_uint16_to_2bytes(rsi_frameCmdSnmpTrap, (snmp_len & 0xFFF));
+
+  rsi_frameCmdSnmpTrap[1] |= 0x40;
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSnmpTrap,(uint8 *)uSnmpTrapFrame, snmp_len);
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_sntp_client.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_sntp_client.c
new file mode 100755
index 0000000..3ee7e1b
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_sntp_client.c
@@ -0,0 +1,75 @@
+/**
+ * @file       rsi_sntp_client.c
+ * @version    1.0
+ * @date       2015-Jun-11
+ *
+ * Copyright(C) Redpine Signals 2015
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SNTPP CLIENT: Function which implements SNTP client
+ *
+ * @section Description
+ * This file contains the SNTP client functionality.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <string.h>
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_sntp_client(uint8 type, rsi_sntp_client_t *sntp_client)
+ * @brief       Sends the SNTP commands to the Wi-Fi module
+ * @param[in]   rsi_sntp_client_t *sntp_client, Pointer to SNTP structure
+ * @param[in]   uint8 type, type of SNTP command
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to send SNTP commands to the Wi-Fi module.
+ * This API should be called only after rsi_ip_param_set API.
+ *
+ * @section prerequisite 
+ * The IP configuration should be done sussessfully.
+ */
+
+int16 rsi_sntp_client(uint8 type, rsi_sntp_client_t *sntp_client)
+{
+  int16          retval;
+  uint8          rsi_frameCmdSNTP[RSI_BYTES_3] = {0x00, 0x40, 0xE4};    
+
+  //! Fill command type
+  sntp_client->command_type = type;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n SNTP client");
+#endif
+
+  rsi_uint16_to_2bytes(rsi_frameCmdSNTP, ((sizeof(rsi_sntp_client_t) & 0x0FFF) | 0x4000));    
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSNTP, (uint8 *)sntp_client, sizeof(rsi_sntp_client_t));
+
+  return retval;
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_socket.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_socket.c
new file mode 100755
index 0000000..1157bec
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_socket.c
@@ -0,0 +1,67 @@
+/**
+ * @file     rsi_socket.c
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SOCKET: Function which creates the socket connection 
+ *
+ * @section Description
+ * This file contains the SOCKET function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *
+ * @fn          int16 rsi_socket(rsi_uSocket *uSocketFrame)
+ * @brief       Sends the SOCKET open command to the Wi-Fi module
+ * @param[in]   rsi_uSocket *uSocketFrame, pointer to socket create structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to open a TCP/UDP Server/Client socket in the Wi-Fi module. 
+ * It has to be called only after the module has been assigned an IP address using the 
+ * rsi_ipparam_set API.
+ * @section prerequisite 
+ * WiFi Connection should be established before opening the sockets
+ */
+int16 rsi_socket(rsi_uSocket *uSocketFrame)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\nSocket Open Start");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %s\n","WLAN","Tx","Socket Open Req","Request for opening a socket");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSocket,(uint8 *)uSocketFrame,sizeof(rsi_uSocket));
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_socket_close.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_socket_close.c
new file mode 100755
index 0000000..c6d2d51
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_socket_close.c
@@ -0,0 +1,68 @@
+/**
+ * @file     rsi_socket_close.c
+ * @version  2.7
+ * @date     2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SOCKET CLOSE: Function which closes an open socket
+ *
+ * @section Description
+ * This file contains the SOCKET CLOSE function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/**===========================================================================
+ * @fn          int16 rsi_socket_close(uint16 socketDescriptor, uint16 port_number)
+ * @brief       Closes an open socket
+ * @param[in]   uint16 socketDescriptor, socket to close
+ * @param[in]   uint16 port_number, to close all LTCP connection with provided port number
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ *       
+ * @section description  
+ * This API is used to close an already open socket.
+ * @section prerequisite 
+ * Socket with the given descriptor should already been created
+ */
+int16 rsi_socket_close(uint16 socketDescriptor, uint16 port_number)
+{
+  int16                                   retval;
+  rsi_uSocketClose                        uSocketCloseFrame;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\nSocket Close Start\n");
+#endif
+
+  rsi_uint16_to_2bytes(uSocketCloseFrame.socketCloseFrameSnd.socketDescriptor, socketDescriptor);
+  rsi_uint16_to_2bytes(uSocketCloseFrame.socketCloseFrameSnd.port_number, port_number);
+  
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdSocketClose,(uint8 *)&uSocketCloseFrame,sizeof(rsi_uSocketClose));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_socket_config.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_socket_config.c
new file mode 100755
index 0000000..8ed0b42
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_socket_config.c
@@ -0,0 +1,65 @@
+/**
+ * @file     rsi_socket_config.c
+ * @version  1.0
+ * @date     2015-Feb-23
+ *
+ * Copyright(C) Redpine Signals 2015
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SOCKET CONFIG: Function sets the sockets configuration 
+ *
+ * @section Description
+ * This file contains the SOCKET CONFIGURATION function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/**===========================================================================
+ * @fn          int16 rsi_socket_config(rsi_socket_config_t *socket_config)
+ * @brief       API is used to set the sockets configuration
+ * @param[in]   socket_config, pointer to socket configration sructure
+ * @param[out]  none
+ * @return      errCode
+ *                 SPI:
+ *                  -1 = SPI busy / Timeout
+ *                  -2 = SPI Failure
+ *                  -3 = BUFFER FULL
+ *                  0  = SUCCESS
+ *                 UART/USB/USB-CDC:
+ *                  -2 = Command issue failed
+ *                  0  = SUCCESS
+ *       
+ * @section description  
+ * This API is used to set the sockets configuration.
+ * @section prerequisite 
+ * It has to be called only after the module has been assigned an IP address using the 
+ * rsi_ipparam_set API.
+ */
+int16 rsi_socket_config(rsi_socket_config_t *socket_config)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\nSocket Config\n");
+#endif
+  retval = rsi_execute_cmd((uint8 *)rsi_frameSocketConfig,(uint8 *)socket_config,sizeof(rsi_socket_config_t));
+  return retval;
+}
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_sys_init.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_sys_init.c
new file mode 100755
index 0000000..6655214
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_sys_init.c
@@ -0,0 +1,71 @@
+/** 
+ * @file       rsi_sys_init.c
+ * @version    2.0.0.0
+ * @date       2011-Feb-25
+ *
+ * Copyright(C) Redpine Signals 2011
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SYS INIT: Top level system initializations
+ * 
+ * @section Description
+ * Any initializations which are not module or platform specific are done here
+ * Any plaform or module specific initializations are called from here
+ *
+ */
+/* 2019/6/28 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include "rsi_spi_cmd.h"
+#if 0 /* APJ : delete */
+#include <stdio.h>
+#endif /* APJ */
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================*/
+/**
+ * @fn            int16 rsi_sys_init()
+ * @brief         SYSTEM INIT, Initializes the system specific hardware
+ * @param[in]     none
+ * @param[out]    none
+ * @return        errCode
+ *              
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ * @description This API is used to initialize the module and its SPI interface.
+ */
+int16 rsi_sys_init(void) /* APJ : modify */
+{
+  int16    retval;              
+
+  //! cycle the power to the module
+  retval = rsi_module_power_cycle();
+  if(retval != 0)
+  {
+    return retval;
+  }
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT( RSI_PL3,"\r\n\nSPI Interface Init ");
+#endif  
+  //!Init the module SPI interface, can only be done once after power on
+  retval = rsi_spi_iface_init();
+  if(retval != 0)
+  {
+    return retval;
+  }
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_timeout.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_timeout.c
new file mode 100755
index 0000000..ce9b99c
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_timeout.c
@@ -0,0 +1,68 @@
+/**
+ * @file      rsi_timeout.c
+ * @version   2.7
+ * @date      2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief SCAN: Function which configure timeouts
+ *
+ * @section Description
+ * This file contains the Timeout function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================
+ *
+ * @fn          int16 rsi_timeout(rsi_utimeout *uScanFrame)
+ * @brief       Sends the Scan command to the Wi-Fi module
+ * @param[in]   rsi_utimeout *uTimeoutFrame,Pointer to timeout structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+* @section description 
+ * This API is used to configure timeouts. This API should be called only 
+ * after the rsi_init API.
+ *
+ * @section prerequisite 
+ * rsi_init should be done successfully  
+ */
+
+int16 rsi_timeout(rsi_utimeout *uTimeoutFrame)
+{
+  int16          retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL13,"\r\n\nTimeout Start ");
+  RSI_DPRINT(RSI_PL3,"%-10.7s%-4.2s %-20.15s %-30.25s\n","WLAN","Tx","Timeout Req","Timeout initiated");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdTimeout, (uint8 *)uTimeoutFrame, sizeof(rsi_utimeout));
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_trigger_auto_config.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_trigger_auto_config.c
new file mode 100755
index 0000000..cdc0ec7
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_trigger_auto_config.c
@@ -0,0 +1,54 @@
+/**
+ * @file     rsi_trigger_auto_config.c
+ * @version  2.7
+ * @date     2015-Mar-4
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Trigger Auto config: To Trigger the auto configuration. 
+ *
+ * @section Description
+ * This file contains the Band function.
+ *
+ *
+ */
+
+/* 2019/6/28 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/*==============================================*/
+/**
+ * @fn          int16 rsi_trigger_auto_config(void)
+ * @brief       Sends the Trigger auto config command to the Wi-Fi module
+ * @param[in]   none
+ * @param[out]  none
+ * @return      errCode
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to trigger the auto configuration. 
+ * This API has to be called only after the Card Ready response.
+ */
+
+
+int16 rsi_trigger_auto_config(void)
+{
+  int16               retval;
+
+  /*Trigger auto config Request Frame */
+  uint8   rsi_frameCmdTriggerAutoConfigReq[RSI_BYTES_3] = {0x00, 0x40, 0x91};
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdTriggerAutoConfigReq,NULL, 0);
+  return retval;	
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_uart_flow_control.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_uart_flow_control.c
new file mode 100755
index 0000000..d0b744a
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_uart_flow_control.c
@@ -0,0 +1,70 @@
+/**
+ * @file       rsi_uart_flow_control.c
+ * @version    2.7
+ * @date       2015-Feb-6
+ *
+ * Copyright(C) Redpine Signals 2015
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief ENABLE/DISABLE UART HARDWARE FLOW CONTROL:Enable/disable UART hw flow control
+ *
+ * @section Description
+ * This file contains API to enable/disable hardware flow control
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+#include <stdio.h>
+#include <string.h>
+ 
+
+/**
+ * Global Variables
+ */
+
+
+/*===========================================================================*/
+/**
+ * @fn          int16 rsi_uart_flow_control(uint8 enable)
+ * @brief       Enable/disable UART hw flow control 
+ * @param[in]   enable = 1/disable =0
+ * @param[out]  none
+ * @return      errCode
+ *                SPI:
+ *                  -1 = SPI busy / Timeout
+ *                  -2 = SPI Failure
+ *                  -3 = BUFFER FULL
+ *                  0  = SUCCESS
+ *                 UART/USB/USB-CDC:
+ *                  -2 = Command issue failed
+ *                  0  = SUCCESS
+ *      
+ * @section description 
+ * This API is used to enable/disable hardware flow control 
+ * */
+int16 rsi_uart_flow_control(uint8 enable)
+{
+
+  int16            retval;
+  rsi_uHwFlowControl UartHwFlowcontrol;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nUART flow control Enable");
+#endif
+  UartHwFlowcontrol.HwFlowControlEnableFrameSnd.uart_hw_flowcontrol_enable = enable;
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdUartFlowControl,(uint8 *)&UartHwFlowcontrol,1);
+  return retval;
+}
+
+
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_user_store_config.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_user_store_config.c
new file mode 100755
index 0000000..1217445
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_user_store_config.c
@@ -0,0 +1,62 @@
+/**
+ * @file     	rsi_user_store_config.c
+ * @version		1.0
+ * @date 		2014-August-01
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief USER STORE CONFIG : sends User store configuration command
+ *
+ * @section Description
+ * This file contains the user store configuration command
+ *
+ *
+ */
+/* 2016/11/16 APJ modify */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/* #if ENABLE_USER_STORE_CONFIGURATION */
+#if 1 /* APJ : add */
+/*==============================================*/
+/**
+ * @fn          rsi_user_storecfg(rsi_uUserStoreCfg_t *ptr_userstrcfg)
+ * @brief       Sends the user store configuration parameters command to the Wi-Fi module
+ * @param[in]   rsi_user_storecfg(rsi_uUserStoreCfg_t *ptr_userstrcfg)
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description
+ * This API is used for send user stpre configuration parameters
+ *  * This API has to be called only after the rsi_snmp_enable API.
+ */
+ 
+int16 rsi_user_store_config(rsi_user_store_config_t  *ptr_userstrcfg)
+{
+  int16               retval;
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nUSER STORE CONFIGURATION");
+#endif
+
+   retval = rsi_execute_cmd((uint8 *)rsi_frameCmdUserStoreCfg, (uint8 *)ptr_userstrcfg, sizeof(struct sc_params_s));
+  return retval;
+}
+#endif
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_web_fields.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_web_fields.c
new file mode 100755
index 0000000..715318f7
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_web_fields.c
@@ -0,0 +1,66 @@
+/**
+ * @file      rsi_web_fields.c
+ * @version   2.7
+ * @date      2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief WEB FIELDS: Function which implements the web fields command
+ *
+ * @section Description
+ * This file contains the web fields function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_web_fields(rsi_uWebFields *uWebFields)
+ * @brief       Sends the WebFields command to the Wi-Fi module via SPI
+ * @param[in]   rsi_uWebFields *uWebFields, Pointer to Webfields structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to load the webpage to the Wi-Fi module. 
+ * This API should be called only after rsi_init API.
+ *
+ * @section prerequisite 
+ * The rsi_init for the Wi-Fi Module initialization should be done successfully.
+ */
+int16 rsi_web_fields(rsi_uWebFields *uWebFields)
+{
+	int16	retval;
+
+#ifdef RSI_DEBUG_PRINT
+	RSI_DPRINT(RSI_PL3,"\r\n\n Web Fields Start");
+#endif
+
+	retval = rsi_execute_cmd((uint8 *)rsi_frameCmdWebFields ,(uint8 *)uWebFields, sizeof(rsi_uWebFields));
+	return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_webpage_clear_files.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_webpage_clear_files.c
new file mode 100755
index 0000000..3dd8974
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_webpage_clear_files.c
@@ -0,0 +1,61 @@
+/**
+ * @file        rsi_webpage_clear_files.c
+ * @version     2.7
+ * @date        2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Clear Webpage Files: This function deletes all webpages in the file system
+ *
+ * @section Description
+ * This file contains the function to erase all webpage files present in the
+ * module's file system
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*==============================================*/
+/**
+ * @fn             int16 rsi_webpage_clear_files(void)
+ * @brief          Erases all files in the webpage file system
+ * @param[in]      none
+ * @param[out]     none
+ * @return         errCode
+ *                 SPI:
+ *                  -1 = SPI busy / Timeout
+ *                  -2 = SPI Failure
+ *                  -3 = BUFFER FULL
+ *                  0  = SUCCESS
+ *                 UART/USB/USB-CDC:
+ *                  -2 = Command issue failed
+ *                  0  = SUCCESS
+ * @section description   
+ * This API erases all webpage files present in the file system.
+ */
+int16 rsi_webpage_clear_files(rsi_tfs_clear_files_t* clear)
+{
+    int16                   retval;
+
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3,"\r\nWebpage Clear Files Start");
+#endif
+    retval = rsi_execute_cmd((uint8 *)rsi_frameCmdWebpageClearFiles, 
+                            (uint8*)clear, sizeof(rsi_tfs_clear_files_t));
+    return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_webpage_erase_file.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_webpage_erase_file.c
new file mode 100755
index 0000000..c3f73c1
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_webpage_erase_file.c
@@ -0,0 +1,61 @@
+/**
+ * @file        rsi_webpage_erase_file.c
+ * @version     2.7
+ * @date        2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Erase Webpage File: This function erases one webpage in the file system
+ *
+ * @section Description
+ * This file contains the function to erase one webpage file present in the
+ * module's file system
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*==============================================*/
+/**
+ * @fn             int16 rsi_webpage_erase_file(void)
+ * @brief          Erases all files in the webpage file system
+ * @param[in]      none
+ * @param[out]     none
+ * @return         errCode
+ *                 SPI:
+ *                  -1 = SPI busy / Timeout
+ *                  -2 = SPI Failure
+ *                  -3 = BUFFER FULL
+ *                  0  = SUCCESS
+ *                 UART/USB/USB-CDC:
+ *                 -2 = Command issue failed
+ *                  0  = SUCCESS
+ * @section description   
+ * This API erases one webpage file present in the file system.
+ */
+int16 rsi_webpage_erase_file(rsi_tfs_erase_file_t* file)
+{
+    int16                   retval;
+
+#ifdef RSI_DEBUG_PRINT
+    RSI_DPRINT(RSI_PL3,"\r\nWebpage erase file Start");
+#endif
+    retval = rsi_execute_cmd((uint8 *)rsi_frameCmdWebpageEraseFile,
+                            (uint8*)file, sizeof(rsi_tfs_erase_file_t));
+    return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_wireless_fwupgrade.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_wireless_fwupgrade.c
new file mode 100755
index 0000000..70cd2b7
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_wireless_fwupgrade.c
@@ -0,0 +1,62 @@
+/**
+ * @file       rsi_wireless_fwupgrade.c
+ * @version    2.7
+ * @date       2012-Sep-26
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief WIRELESS FIRMWARE UPGRADE: Function to send wireless firmware upgrade request's response
+ *
+ * @section Description
+ * This file contains the WIRELESS FIRMWARE UPGRADE function.
+ *
+ *
+ */
+
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+
+/*=================================================================================*/
+/**
+ * @fn              int16 rsi_wireless_fwupgrade(void)
+ * @brief           Wireless firmware upgradation Status through the SPI interface
+ * @param[in]       none
+ * @param[out]      none
+ * @return          errCode
+ *                  SPI:
+ *                   -1 = SPI busy / Timeout
+ *                   -2 = SPI Failure
+ *                   -3 = BUFFER FULL
+ *                   0  = SUCCESS
+ *                  UART/USB/USB-CDC:
+ *                   -2 = Command issue failed
+ *                   0  = SUCCESS
+ * @section description     
+ * This API is used to upgrde firmware wirelessly in Wi-Fi module.
+ */
+
+int16 rsi_wireless_fwupgrade(void)
+{
+  int16            retval;
+
+#ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\nWireless firmware upgradation Start");
+#endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdWirelessFwUpgrade, NULL,0);
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_wmm_ps.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_wmm_ps.c
new file mode 100755
index 0000000..bf0e83a
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_wmm_ps.c
@@ -0,0 +1,58 @@
+/**
+ * @file       rsi_wmm_ps.c
+ * @version    1.0
+ * @date       2014-Apr-16
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief WMM PS : Function which sets the WMM PS parameters 
+ *
+ * @section Description
+ * This file contains the WMM PS Parameter set function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_wmm_ps(rsi_uWmmPs *uWmmPsFrame)
+ * @brief       Sets the Wmm Ps parameters in the Wi-Fi module 
+ * @param[in]   rsi_uWmmPs *uWmmPsFrame, Pointer to WMM Ps structure
+ * @param[out]  none
+ * @return      errCode
+ *              -2 = Command execution failed
+ *              -1 = Buffer Full
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give the WMM PS Request . 
+ * @section prerequisite 
+ * The join should be done sussessfully.
+ */
+ 
+int16 rsi_wmm_ps(rsi_uWmmPs *uWmmPsFrame)
+{
+    int16  retval;
+
+ #ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n WMM PS Start");
+ #endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdWmmPs,(uint8 *)uWmmPsFrame,sizeof(rsi_uWmmPs));
+  
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_wps_method.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_wps_method.c
new file mode 100755
index 0000000..a94ad68
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/src/rsi_wps_method.c
@@ -0,0 +1,63 @@
+/**
+ * @file       rsi_wps_method.c
+ * @version    1.0
+ * @date       2014-Apr-16
+ *
+ * Copyright(C) Redpine Signals 2014
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief WPS METHOD: Function which sets the WPS METHOD parameters 
+ *
+ * @section Description
+ * This file contains the WPS METHOD Parameter set function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include "rsi_global.h"
+
+/**
+ * Global Variables
+ */
+
+/*=================================================*/
+/**
+ * @fn          int16 rsi_wps_method(rsi_uWpsMethod *uWpsMethodFrame)
+ * @brief       Sets the WPS PIN METHOD parameters in the Wi-Fi module 
+ * @param[in]   rsi_uWpsMethod *uWpsMethodFrame, Pointer to WPS Method structure
+ * @param[out]  none
+ * @return      errCode
+ *              SPI:
+ *              -1 = SPI busy / Timeout
+ *              -2 = SPI Failure
+ *              -3 = BUFFER FULL
+ *              0  = SUCCESS
+ *              UART/USB/USB-CDC:
+ *              -2 = Command issue failed
+ *              0  = SUCCESS
+ * @section description 
+ * This API is used to give the WPS  method Parameter set Request . 
+ * @section prerequisite 
+ * The scan should be done sussessfully.
+ */
+ 
+int16 rsi_wps_method(rsi_uWpsMethod *uWpsMethodFrame)
+{
+    int16  retval;
+
+ #ifdef RSI_DEBUG_PRINT
+  RSI_DPRINT(RSI_PL3,"\r\n\n WPS METHOD start");
+ #endif
+
+  retval = rsi_execute_cmd((uint8 *)rsi_frameCmdWpsMethod,(uint8 *)uWpsMethodFrame,sizeof(rsi_uWpsMethod));
+  
+  return retval;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include/rsi_app.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include/rsi_app.h
new file mode 100755
index 0000000..980d5ac
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include/rsi_app.h
@@ -0,0 +1,147 @@
+/**
+ * @file     rsi_app.h
+ * @version      1.0
+ * @date         2014-Jan-31
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER, APP, APPLICATION Header file which contains application specific structures 
+ *
+ * @section Description
+ * This file contains the Application related information.
+ *
+ *
+ */
+/* 2018/02/15 APJ add #if 0 */
+
+#include "rsi_config.h"
+#if 0 /* APJ : delete */
+#include "sensor_data.h"
+#endif /* APJ */
+#ifndef _RSI_APP_CB_H
+#define _RSI_APP_CB_H
+#define RSI_MAXSOCKETS                       10     //@ Maximum number of open sockets
+
+/* Application control block */
+
+
+/*===================================================*/
+/**
+ * Sockets Structure
+ * Structure linking socket number to protocol
+ */
+typedef struct {
+  uint8    ip_version[2];                   //@ ip version
+  uint8    socketDescriptor[2];             //@ socket descriptor
+  uint8    protocol;                        //@ PROTOCOL_UDP, PROTOCOL_TCP or PROTOCOL_UNDEFINED
+  uint8    src_port[2];                     //@ socket local port number
+  union{
+    uint8     ipv4_address[4];              //@ Destination ipv4 address
+    uint8     ipv6_address[16];              //@ Destination ipv6 address
+  }dest_ip;
+  uint8    dest_port[2];                    //@ Destination port number  
+} rsi_socketsStr;
+
+/*===================================================*/
+/**
+ * Sockets Structure Array
+ * Array of Structures linking socket number to protocol
+ */
+typedef struct {
+    rsi_socketsStr      socketsArray[RSI_MAXSOCKETS+1];        
+    //@ Socket numbers are from 1 to 10
+} rsi_sockets;
+
+
+//! Host MIB structure and Object OID list  
+typedef struct MIB_ENTRY_STRUCT
+{
+
+  char       *obj_id;
+} MIB_ENTRY;
+
+
+typedef struct 
+{
+  /* Error code */
+  uint16        error_code;
+  /* Buffer to receive to response from Wi-Fi module */
+  rsi_uCmdRsp   *uCmdRspFrame;
+
+  /* For Certificate */
+  struct        SET_CHUNK_S set_chunks;
+  /* received paket count */
+  uint32        rcvd_data_pkt_count;
+  /* Mac address */
+  uint8         mac_addr[6];
+#if RSI_CONCURRENT_MODE
+  /* Mac address */
+  uint8         ap_mac_addr[6];
+#endif
+  /* packet pending flag */
+  volatile      uint32 pkt_pending;
+
+#if (RSI_POWER_MODE == RSI_POWER_MODE_3)
+  //! backup of frame type 
+  uint8         ps_descparam[16];   
+  //! Paket pending for power save
+  void *        ps_pkt_pending;   
+  //! size of currently held packet
+  uint16        ps_size_param;
+  //! devide sleep indication
+  uint16        ps_ok_to_send;
+#endif
+#if (RSI_POWER_MODE)
+  uint16        power_save_enable;
+#endif
+#if (defined(UART_INTERFACE) && !defined(TCP_IP_BYPASS))
+  volatile int  ack_flag;
+#endif
+  /* PER Continous wave mode state*/
+  int8          per_cont_mode_state;
+
+  rsi_uConnected_station_t stations_connected[RSI_NO_OF_CLIENTS_SUPPORTED];
+
+  /* Buffer to hold the received packet */
+  uint8         read_packet_buffer[RSI_MAX_PAYLOAD_SIZE];
+
+  /* For Webpage write */
+  uint8         webpage_morechunks;
+
+  /* flag to enable send data*/
+  uint8         glbl_send_data;
+
+  /*structure to store socket information */
+  volatile      rsi_sockets   socketsStrArray;  
+
+  /* Send buffer data */
+  uint8         send_buffer[RSI_MAX_PAYLOAD_SIZE];
+ 
+  uint8         write_packet_buffer[RSI_MAX_PAYLOAD_SIZE];
+
+#if JSON_LOAD
+  /* Json buffer */
+  uint8         json_buffer[JSON_BUFFER_SIZE];
+  uint8         json_load_done;
+  /* User Data Structures */
+  app_data_t    sensor_data;
+#endif
+  #if WEB_PAGE_LOAD 
+  uint8         webpage_load_done;
+#endif
+  //! frame sent for the send command,  includes data
+  rsi_uSend     uSendFrame;   
+  uint8         abort_call;
+}rsi_app_cb_t;
+
+#define RSI_FILL_PARAMETERS(x,y) rsi_fill_parameters(x,y)
+
+extern rsi_app_cb_t rsi_app_cb;
+
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include/rsi_app_util.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include/rsi_app_util.h
new file mode 100755
index 0000000..5edde17
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include/rsi_app_util.h
@@ -0,0 +1,58 @@
+/**
+ * @file         rsi_app_util.h
+ * @version      3.1
+ * @date         2012-Dec-21
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief HEADER UTIL: Util Header file, the things that are useful for application 
+ *
+ * @section Description
+ * This is the rsi_app_util.h file for the utility functions used by applications that
+ * are using this library.
+ *
+ *
+ */
+
+
+#ifndef _RSIAPPUTIL_H_
+#define _RSIAPPUTIL_H_
+#include "rsi_global.h"
+
+void   rsi_strcat(void *src, void *dst, uint8 len);
+uint8  rsi_strrev(void *src, void *dst, uint8 len);
+uint16 rsi_bytes2_to_uint16(uint8 *dBuf);
+uint32 rsi_bytes4_to_uint32(uint8 *dBuf);
+void   rsi_swap_2bytes(uint8 *buffer);
+void   rsi_swap_4bytes(uint8 *buffer);
+void   rsi_print_n_chars (int8* st, int16 n);
+void   rsi_print_uint8_as_binary(uint8 number);
+int16  rsi_in_uint8_list(uint8 arg, uint8 *list, uint8 nargs);
+int8   *rsi_bytes6_to_ascii_mac_addr(uint8 *hexAddr,uint8 *strBuf);
+int8   *rsi_bytes4_to_ascii_dot_addr(uint8 *hexAddr,uint8 *strBuf);
+void   rsi_ascii_dot_address_to_4bytes(uint8 *hexAddr, int8 *asciiDotAddress);
+void   rsi_ascii_mac_address_to_6bytes(uint8 *hexAddr, int8 *asciiMacAddress);
+uint32 rsi_bytes4R_to_uint32(uint8 *dBuf);
+uint16 rsi_bytes2R_to_uint16(uint8 *dBuf);
+int8   asciihex_2_num(int8 ascii_hex_in);
+int8   rsi_charHex_2_Dec ( int8 *cBuf);
+void   register_socket_protocol(rsi_uSocket *);
+uint16 rsi_aToi(uint8 *src, uint8 src_len);
+int16  rsi_wifi_init(void);
+int8   rsi_charhex_2_dec ( int8 *cBuf);
+void   unregister_socket_protocol(void);
+uint16 rs22_aToi(uint8 *src, uint8 src_len);
+uint16 rsi_convert_ip_to_string(uint8 *num_buff, uint8 *ip_buff);
+uint32 parseHex(uint8 *str );
+void   parse_ipv6_address(uint8 *v6, uint8 *buf);
+uint8  convert_lower_case_to_upper_case(uint8 lwrcase);
+void rsi_uint32_to_4bytes(uint8 *dBuf, uint32 val);
+void rsi_uint16_to_2bytes(uint8 *dBuf, uint16 val);
+void string2array(uint8 *dst, uint8 *src, uint32 length);
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include/rsi_config.h b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include/rsi_config.h
new file mode 100755
index 0000000..6a75b26
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include/rsi_config.h
@@ -0,0 +1,739 @@
+/**
+ * @file           rsi_config.h
+ * @version        3.6
+ * @date           2013-May-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief CONFIG INIT contains the default configurations used in the api's
+ *
+ * @section Description
+ * USER is supposed to configure the module/API's  by using the following defines 
+ *
+ *
+ */
+
+#ifndef _INITSTRUCT_H_
+#define _INITSTRUCT_H_
+
+
+#include "rsi_api.h"
+/*==============================================*/
+/**
+ * Global Defines
+ */
+
+
+#define RSI_INTERFACE RSI_SPI            //@ RSI_SPI or RSI_UART or RSI_USB host interface for communication with module
+
+#if (RSI_INTERFACE == RSI_SPI)
+#ifndef SPI_INTERFACE
+#define SPI_INTERFACE
+#endif
+#undef  UART_INTERFACE
+#undef  USB_INTERFACE
+#elif (RSI_INTERFACE == RSI_UART)
+#ifndef UART_INTERFACE
+#define UART_INTERFACE
+#endif
+#undef  SPI_INTERFACE
+#undef  USB_INTERFACE
+#elif (RSI_INTERFACE == RSI_USB)
+#ifndef USB_INTERFACE
+#define USB_INTERFACE
+#endif
+#undef  SPI_INTERFACE
+#undef  UART_INTERFACE
+#endif
+
+#ifdef UART_INTERFACE
+#ifndef RSI_UART_DEVICE
+#ifdef LINUX_PLATFORM
+#define RSI_UART_DEVICE                    "/dev/ttyUSB0"
+#elif WINDOWS 
+#define RSI_UART_DEVICE                    "\\\\.\\COM98"
+#define BYPASS_CARD_READY 							0 //@ 0 - for Card Ready Bypass and 1 - Wait for Card Ready 
+#endif
+
+#endif
+#define RSI_USE_HOST_WAKEUP_AS_INTERRUPT    ENABLE
+#endif
+
+#define HOST_INTERACTION_MODE      DISABLE                      //@ ENABLE or DISABLE host interaction for bootloader
+#define BOOTLOADER_VERSION         0x16                        //@ Bootloader version 
+#define BOOTLOADER_VERSION_CHECK 	 DISABLE								     //@ Enable/Disable Bootloader Version check
+#define USB_DUAL_ENUMERATION       DISABLE                     //@ ENABLE or DISABLE dual enumeration for USB mode
+#define UART_FLOW_CONTROL          DISABLE                     //@ ENABLE or DISABLE Hardware flow control in UART
+
+#define RSI_NO_WLAN_MODE					 DISABLE                     //@ ENABLE to quit wlan application after opermode
+
+
+/* Configuration values types */
+#define RSI_WLAN_CONFIG_ENABLE     DISABLE
+#define CONFIG_RTSTHRESHOLD	       1
+
+#define RSI_CONFIG_TYPE		         CONFIG_RTSTHRESHOLD
+#define RSI_CONFIG_VALUE	         2346                        //@ Range, {256 - 2346}. Default value is 2346
+
+#define RSI_TCP_IP_BYPASS          DISABLE                     //@ ENABLE or DISABLE TCP/IP bypass mode
+#define WFU_UPGRADE                DISABLE                     //@ ENABLE or DISABLE Wireless firmware upgradation
+#define FW_UPGRADE                 DISABLE                     //@ ENABLE or DISABLE firmware upgrade from host
+#define RSI_UPGRADE_IMAGE_TYPE     RSI_UPGRADE_IMAGE_I_FW      //@ RSI_UPGRADE_IMAGE_I_FW or RSI_UPGRADE_IMAGE_I_FW or RSI_UPGRADE_BL
+#define RSI_LOAD_IMAGE_TYPE        RSI_LOAD_IMAGE_I_FW         //@ RSI_LOAD_IMAGE_I_FW or RSI_LOAD_IMAGE_I_ACTIVE_LOW_FW
+#define RSI_DEFAULT_IMAGE_SELECT   RSI_SELECT_IMAGE_I_BY_DEFAULT //@ RSI_SELECT_IMAGE_I_BY_DEFAULT 
+#define RSI_BOOT_BYPASS_SELECT     RSI_ENABLE_BOOT_BYPASS      //@ RSI_ENABLE_BOOT_BYPASS or RSI_DISABLE_BOOT_BYPASS 
+#define RSI_HOST_BOOTUP_OPTION     RSI_LOAD_IMAGE_TYPE         //@ RSI_LOAD_IMAGE_TYPE or RSI_DEFAULT_IMAGE_SELECT or RSI_HOST_BOOTUP_CMD
+#define RSI_AUTOMATION_ENABLE      DISABLE                     //@ ENABLE or DISABLE Automation mode
+
+#define FIPS_MODE_ENABLE           DISABLE
+#if FIPS_MODE_ENABLE
+#define RSI_RECHECK_PMK            "661cb4a09ddffbb778372f302900919d57b5e065a261234de7b2962ca7a0d830"                          //@ PMK "661cb4a09ddffbb778372f302900919d57b5e065a261234de7b2962ca7a0d830"//"1d55d6ad23a22b46af91b222348e9a195341204320fed8b6b4193ce557c0d555"
+#define RSI_RECHECK_KEY_TYPE       CHECK_PMK                   //@ CHECK_PMK or CHECK_EAP_PASSWORD
+#define RSI_KEY_STORE              DISABLE
+#define RSI_ENABLE_UPGRADATION_FROM_HOST DISABLE
+#define RECHECK_PASSWORD           "\"test123\""               //@ Password
+#define RSI_LOAD_FWUPGRADATION_KEY ENABLE
+#if RSI_LOAD_FWUPGRADATION_KEY            
+#define RSI_FWUPGRADATION_KEY      "123456789061234de7b2962ca7a0d830"                         //@ secret key to be loaded for DSA  
+#endif
+#define RSI_AUTO_JOIN_KEY_TYPE     1
+#define RSI_AUTO_JOIN_KEY          "03cafbe7d1671947dc649af44d0219e6f7f62d4c26e5f6e0aa614e11b33ed24d"
+#endif
+#define RSI_ENABLE_UPGRADATION_FROM_HOST DISBLE
+#define RSI_BAND                   RSI_BAND_2P4GHZ             //@ RSI_BAND_2P4GHZ or RSI_BAND_5GHZ or RSI_DUAL_BAND
+#define RSI_CONFIGURE_ANTENNA      RSI_TYPE_RF_OUT_2           //@ 0 for internal antenna 1 for external antenna
+#define RSI_ANTENNA_GAIN_2G        0                           //@ antenna gain for 2.4 GHz band
+#define RSI_ANTENNA_GAIN_5G        0                           //@ antenna gain for 5 GHz band
+#define RSI_ANTENNA_PATH           RSI_ANTENNA_PATH_INTERNAL   //@ RSI_ANTENNA_PATH_INTERNAL or RSI_ANTENNA_PATH_EXTERNAL 
+#define RSI_ANTENNA_TYPE           RSI_ANTENNA_TYPE_REDPINE    //@ RSI_ANTENNA_TYPE_REDPINE or RSI_ANTENNA_TYPE_FRACTUS or RSI_ANTENNA_TYPE_MOLEX
+#define RSI_DATA_RATE              RSI_DATA_RATE_AUTO          //@ RSI_DATA_RATE_AUTO or RSI_DATA_RATE_(1, 2, 5P5, 11, 6, 9, 12)
+#define RSI_POWER_LEVEL            RSI_POWER_LEVEL_HIGH        //@ RSI_POWER_LEVEL_LOW or RSI_POWER_LEVEL_MEDIUM or RSI_POWER_LEVEL_HIGH
+#define RSI_STORE_CONFIG           DISABLE                     //@ ENABLE or DISABLE store configuration
+
+#define RSI_WIFI_OPER_MODE             0                       //@ 0-For legacy client , 1-P2p mode , 2-Enterprise security mode, 6- AP mode, 8-per mode 
+#define RSI_COEX_MODE                  0                       //@ 0-wlan only, 3- wlan+zigbee coex 5- wlan+bt coex  13- wlan+btle coex
+#define RSI_OPERMODE               (RSI_WIFI_OPER_MODE | ( RSI_COEX_MODE << 16))            
+#define RSI_FEATURE_BIT_MAP        FEAT_SECURITY_OPEN          //@ To set wlan feature select bit map
+#define RSI_TCP_IP_FEATURE_BIT_MAP (TCP_IP_FEAT_DHCPV4_CLIENT | TCP_IP_FEAT_HTTP_CLIENT)
+#define RSI_EXT_TCP_IP_FEATURE_BIT_MAP  0
+
+#define RSI_NO_OF_CLIENTS_SUPPORTED     1                          //@ Number of clients to support possible values 1 to 8            
+#define RSI_CUSTOM_FEATURE_BIT_MAP      0                          //@ To set custom feature select bit map 
+#define RSI_EXT_CUSTOM_FEATURE_BIT_MAP  0                          //@ extention of custom feature select bit map and is valid only if BIT(31) of custom feature bitmap is set
+#define RSI_BLE_CUSTOM_FEATURE_BIT_MAP  0                          //@ BLE custom feature select bit map and is valid only if BIT(31) of extention custom feature bitmap is set
+
+#define RSI_SECURITY_MODE          SECURITY_MODE_OPEN          //@ For selecting different security mode APs.
+#define RSI_PSK_SUPPORT            DISABLE                     //@ ENABLE or DISABLE PSK support
+#define RSI_PSK                    ""                          //@ PSK.If we are using WPA2, this is the key, In open mode NULL
+#define RSI_PMK                    ""                          //@ PMK "661cb4a09ddffbb778372f302900919d57b5e065a261234de7b2962ca7a0d830"//"1d55d6ad23a22b46af91b222348e9a195341204320fed8b6b4193ce557c0d555"
+#define RSI_PSK_TYPE               RSI_PSK_FROM_HOST           //@ RSI_PSK_FROM_HOST or RSI_PMK_FROM_HOST or RSI_GENERATE_PMK
+#define RSI_SCAN_SSID              "REDPINE_AP"                //@ SSID to scan, null string ("") to scans all ssids
+#define RSI_SCAN_CHANNEL           0                           //@ scan channel number.0 to scans all channels
+#define RSI_SCAN_FEAT_BITMAP       0                           //@ scan_feature_bitmap ,valid only if specific channel and ssid are given
+#define RSI_SCAN_CHANNEL_BIT_MAP_2_4    0                      //@ scan channle bit map,valid if RSI_SCAN_CHANNEL is 0
+#define RSI_SCAN_CHANNEL_BIT_MAP_5      0                      //@ scan channle bit map,valid if RSI_SCAN_CHANNEL is 0
+#define RSI_JOIN_SSID              "REDPINE_AP"                //@ SSID to join
+#define SEND_PSK_IN_JOIN           1                           //@ 1-to send PSK in join frame, 0 - not to send PSK in join
+#define RSI_AP_BSSID               "00:00:00:00:00:00"         //@ BSSID of the selected AP
+#define RSI_MAC_ADDRESS            "00:17:34:51:68:85"         //@ MAC address of the module
+#define RSI_JOIN_FEAT_BIT_MAP	   0						   //@ RSI_JOIN_FEAT_STA_BG_ONLY_MODE_ENABLE or RSI_JOIN_FEAT_LISTEN_INTERVAL_VALID
+#define RSI_LISTEN_INTERVAL		   0
+//@ Power save Parameters
+#define RSI_POWER_MODE             RSI_POWER_MODE_0            //@ RSI_POWER_MODE_0 or RSI_POWER_MODE_1 or RSI_POWER_MODE_2 or  
+                                                               //@ RSI_POWER_MODE_3 or RSI_POWER_MODE_8 or RSI_POWER_MODE_9 
+#define RSI_ULP_MODE               RSI_LP_MODE				   //@ RSI_LP_MODE or RSI_ULP_MODE_WITH_RAM_RET or RSI_ULP_MODE_NO_RAM_RET 
+#define RSI_LISTEN_INTERVAL_DTIM   DISABLE
+#define RSI_PSP_TYPE               RSI_MAX_PSP
+#define RSI_MONITOR_INTERVAL       50
+/* sleep timer value */
+#define RSI_TIMEVAL                10                          //@ Sleep time value in seconds used in power save mode 9
+
+
+//@ DEBUG prints support
+#define RSI_TIMEOUT_ENABLE        DISABLE                 //@ ENABLE or DISABLE timeout value
+#define RSI_TIMEOUT_BIT_MAP       1                       //@BIT(0): set timeout for authentication and association, BIT(1): set the each channel active scan time
+#define RSI_TIMEOUT_VALUE         1500                      //@ Timeout value in ms
+
+/* WEPKEY support */
+#define RSI_WEP_INDEX              0                           //@ WEP key index to use. Possible values are 0 to 3
+#define RSI_WEPKEY0                "1234567890"                //@ WEP KEY1 
+#define RSI_WEPKEY1                "1234567980"                //@ WEP KEY2
+#define RSI_WEPKEY2                "1234567120"                //@ WEP KEY3
+#define RSI_WEPKEY3                "1234567130"                //@ WEP KEY4
+
+//@ DEBUG prints support
+#define RSI_DEBUG_PRINTS_ENABLE        ENABLE                 //@ ENABLE or DISABLE debug prints
+#define RSI_DEBUG_ASSERTION_TYPE       4                       //@ type 1 to 4
+#define RSI_DEBUG_ASSERTION_LEVEL      15                      //@ level 1 to 15
+
+//@ Roaming related info
+#define RSI_ROAMING_SUPPORT            DISABLE                 //@ ENABLE or DISABLE roaming support
+#define RSI_ROAMING_THRESHOLD          10                      //@ roaming threshold value 
+#define RSI_ROAMING_HYSTERISIS         4                       //@ roaming hysterisis value
+
+//@ Rejoin params related info
+#define RSI_ENABLE_REJOIN_PARAMS       DISABLE                 //@ ENABLE or DISABLE rejoin params
+#define RSI_REJOIN_MAX_RETRY           0                       //@ Rejoin retry count. If 0 retries infinity times
+#define RSI_REJOIN_SCAN_INTERVAL       4                       //@ Periodicity of rejoin attempt
+#define RSI_REJOIN_BEACON_MISSED_CNT   40                      //@ Beacon missed count
+#define RSI_REJOIN_FIRST_TIME_RETRY    DISABLE                 //@ ENABLE or DISABLE retry for first time join failure
+
+//@ High Throughput Capabilies related information
+#define RSI_MODE_11N_ENABLE            DISABLE                 //@ ENABLE or DISABLE 11n mode in AP mode
+#define RSI_HT_CAPS_BIT_MAP            10                      //@ HT caps bit map.
+
+//@ WMM PS parameters
+#define RSI_WMM_PS_SUPPORT             DISABLE                 //@ ENABLE or DISABLE WMM PS support
+#define RSI_WMM_PS_TYPE                0                       //@ 0 - wmm_ps tx based, 1- wmm ps periodic
+#define RSI_WMM_PS_WAKEUP_INTERVAL     0                       //@ wmm ps wakeup interval
+#define RSI_WMM_PS_UAPSD_BITMAP        0                       //@ wmm ps uapsd bit map. Possible values are 0 to 15
+
+//@ WPS Method params
+#define RSI_WPS_SUPPORT                DISABLE                 //@ ENABLE or DISABLE WPS support
+#define RSI_WPS_METHOD                 RSI_WPS_PIN_METHOD      //@ RSI_WPS_PIN_METHOD or RSI_WPS_PUSH_METHOD
+#define RSI_GENERATE_PIN               DISABLE                 //@ ENABLE-GENERATE or DISABLE-VALIDATE WPS PIN
+#define RSI_WPS_PIN                    ""                      //@ WPS pin 
+
+/* Enable or Disable BG scan command */
+#define RSI_BG_SCAN_ENABLE             DISABLE                 //@ ENABLE or DISABLE BG scan
+#define RSI_INSTANT_BG                 DISABLE                 //@ ENABLE or DISABLE instant BG scan
+#define RSI_BG_SCAN_THRESHOLD          10                      //@ BG scan threshold value
+#define RSI_RSSI_TOLERANCE_THRESHOLD   4                       //@ RSSI tolerance Threshold
+#define RSI_BG_SCAN_PERIODICITY        10                      //@ BG scan periodicity 
+#define RSI_ACTIVE_SCAN_DURATION       15                      //@ Active scan duration
+#define RSI_PASSIVE_SCAN_DURATION      20                      //@ Passive scan duration
+#define RSI_MULTIPROBE                 DISABLE
+
+/*For Disconnect command*/
+#define MODE_FLAG                      1                       //@ Disconnect mode.0 for client and 1 for AP
+#define CLIENT_MAC_ADDRESS             "00:17:34:51:68:86"     //@ MAC address of the client to be disconnected
+
+/*Mac address filter*/
+#define RSI_MULTICAST_FILTER_ENABLE    DISABLE                   //@ ENABLE or DIABLE multicast filter   
+#define RSI_MULTICAST_MAC_CMD_TYPE     RSI_MULTICAST_MAC_SET_ALL //@ RSI_MULTICAST_MAC_ADD_BIT or RSI_MULTICAST_MAC_CLEAR_BIT or RSI_MULTICAST_MAC_CLEAR_ALL or RSI_MULTICAST_MAC_SET_ALL
+#define RSI_MULTICAST_MAC_ADDRESS      "01:00:5E:7F:FF:FA"       //@ MAC address used to calculate hash value for multicast filtering
+
+#define CLIENT_MODE                    (RSI_WIFI_OPER_MODE == 0)
+#define P2P_MODE                       (RSI_WIFI_OPER_MODE == 1)
+#define ENTERPRISE_MODE                (RSI_WIFI_OPER_MODE == 2)
+#define AP_MODE                        (RSI_WIFI_OPER_MODE == 6)
+#define PER_MODE                       (RSI_WIFI_OPER_MODE == 8)
+#define RSI_CONCURRENT_MODE            (RSI_WIFI_OPER_MODE == 9)
+
+
+#if (RSI_WIFI_OPER_MODE == 0|| RSI_WIFI_OPER_MODE == 2)
+//Set region parameters
+#define SET_REGION_SUPPORT             DISABLE                 //@ ENABLE or DISABLE set region
+#define SET_REGION_FROM_USER_OR_BEACON 1                       //@ IF 1:region configurations taken from user ;0:region configurations taken from beacon
+#define REGION_CODE                    1                       //@ 0-Default Region domain ,1-US, 2-EUROPE, 3-JAPAN
+#define MODULE_TYPE                    1                       //@ Module type from host, 0- Without onboard antenna, 1- With onboard antenna
+#endif
+
+#if(RSI_WIFI_OPER_MODE == 6)
+#define SET_REGION_AP_SUPPORT          DISABLE                 //@ ENABLE or DISABLE set region AP
+#define SET_REGION_AP_FROM_USER        DISABLE                 //@ IF 1:region configurations taken from user ;0:region configurations taken from firmware
+#define RSI_COUNTRY_CODE               "US"                    //@ "US" or "EU" or "JP" or other region codes
+#endif
+
+/* RF Current Configuration */ 
+#define RSI_RF_CURRENT_CONFIG			DISABLE					//@  ENABLE or DISABLE RF Current/Power configuration
+#define RSI_RF_TX_POWER					1						//@  0 - High  1 - Medium  2 - Low
+#define RSI_RF_RX_POWER					1						//@  0 - High  1 - Medium  2 - Low
+#define RSI_TX_POWER_DBM				0						//deafult		
+
+
+/* P2P mode Configurations */
+#define P2P_DEVICE_NAME                "WSC1.1"                //@ P2P device name
+#define POST_FIX_SSID                  "WSC_1_0_0"             //@ P2P prefix name
+#define GO_INTENT_VALUE                15                      //@ P2P go intent value.possible value are 0 to 16
+#define P2P_OPER_CHANNEL               11                      //@ P2P operating channel 
+
+/* Enterprise client mode configurations */
+#define CERT_LEN                       6522                    //@ Certificate length, ZERO in case of clearing the certificate
+#define EAP_METHOD                     "TTLS"                  //@ Eap method TTLS, TLS, PEAP, FAST
+#define EAP_CERTIFICATE_TYPE		       RSI_EAP_TLS_CERTIFICATE //@ certificate to be loaded RSI_EAP_TLS_CERTIFICATE or RSI_EAP_FAST_PAC_CERTIFICATE
+#define INNER_METHOD                   "\"auth=MSCHAPV2\""     //@ Inner method MSCHAPV2
+#define USER_IDENTITY                  "\"user1\""             //@ user name 
+#define PASSWORD                       "\"test123\""           //@ Password
+#define KEY_PASSWORD                   "\"wifi\""              //@ Key Pass word
+#define EAP_OKC_ENABLE                 ENABLE                  //@ ENABLE or DISABLE Opportunistic Key Caching
+#define PRIVATE_KEY_PASSWORD           ""                      //@ Private Key Password is required for encrypted private key, format is like "\"12345678\""
+
+/* AP mode Configurations */
+#define RSI_DTIM_PERIOD                4                       //@ AP DTIM Period to configure 
+#define RSI_BEACON_INTERVAL            100                     //@ AP beacon interval
+#define RSI_AP_CHANNEL_NUM             1                       //@ AP channel number
+#define RSI_SECURITY_TYPE              RSI_SECURITY_NONE       //@ AP security type
+#define RSI_ENCRYPTION_MODE            RSI_ENCRYPTION_NONE     //@ AP Encryption type 
+#define MAX_NO_OF_CLIENTS              4                       //@ AP:Maximum number of clients can connect.Possible values are 1 to 4
+#define AP_KEEPALIVE_TYPE                0                       //@ AP:Keep alive type 0 -disable keep alive ,  1 - enables deauth based keep alive ,3 - enables null data based keep alive
+#define AP_KEEPALIVE_PERIOD              100                       //@ AP:Keep alive period (KEEP_ALIVE_PERIOD*32*Beacon_interval time duartion AP waits for packet form connected stations)
+#define RSI_CONCURRENT_AP_JOIN_SSID     "REDPINE_CON_AP1"       //@ SSID to create AP in concurrent mode only
+#define RSI_CONCURRENT_AP_PSK           ""                     //@ SSID to create AP in concurrent mode only
+
+/* PER mode configurations */
+#define RSI_PER_MODE_SUPPORT           DISABLE                 //@ ENABLE or DISABLE PER mode
+#define RSI_PER_MODE_POWER             0                       //@ PER MODE power 
+#define RSI_PER_MODE_RATE              RSI_RATE_1              //@ PER MODE rate
+#define RSI_PER_MODE_LENGTH            30                      //@ PER MODE length
+#define RSI_PER_MODE_MODE              RSI_PER_BURST_MODE      //@ PER MODE mode
+#define RSI_PER_MODE_CHANNEL           1                       //@ PER MODE channel
+#define RSI_PER_MODE_RATE_FLAGS        0                       //@ PER MODE rate flags
+#define RSI_PER_MODE_PER_CH_BW         0                       //@ PER MODE per channel bandwidth
+#define RSI_PER_MODE_AGGR_ENABLE       DISABLE                 //@ PER MODE aggregation enable or disable
+#define RSI_PER_MODE_AGGR_COUNT        0                       //@ PER MODE aggregation count
+#define RSI_PER_MODE_NO_OF_PKTS        0                       //@ PER MODE number of packets to send
+#define RSI_PER_MODE_DELAY             0                       //@ PER MODE delay
+
+/* PER stats configuration */
+#define RSI_PER_STATS                  1                       //@ Start/Stop PER stats. 0-start, 1-stop
+#define RSI_PER_STATS_CHANNEL          11                      //@ PER stats channel number
+
+
+/* TCP/IP configurations */
+//@ Module IP Parameters
+#define RSI_IP_CFG_MODE                RSI_DHCP_IP_MODE        //@ RSI_DHCP_IP_MODE or RSI_STATIC_IP_MODE .static or DHCPV4 mode for IPv4,RSI_FEAT_DHCP_HOST_NAME for dhcp client host name from host or 
+                                                               //@ RSI_FEAT_DHCP_FQDN to enable DHCP OPTION 81 or RSI_DHCP_UNICAST_OFFER_SUPPORT to support DHCP unicast offer.
+
+#define RSI_DHCP_HOST_NAME             "dhcp_client"           //@ DHCP HOST NAME
+#define RSI_IPV6_CFG_MODE              RSI_STATIC_IP_MODE      //@ RSI_DHCP_IP_MODE or RSI_STATIC_IP_MODE.static or DHCPV6 mode for IPv6
+#define IPV6_SUPPORT                   DISABLE                 //@ ENABLE or DISABLE IPV6 support
+#define RSI_IP_VERSION                 IP_VERSION_4            //@ IP_VERSION_4 or IP_VERSION_6. IP version to use.
+#define RSI_DHCP_FQDN_FLAG             1                   
+#define RSI_ICMP_FROM_MODULE           ENABLE                 //@ ENABLE or DISABLE ICMP from module support
+
+/* IPv4 parameterrs */
+#define RSI_MODULE_IP_ADDRESS          "192.168.100.67"        //@ IP Address of the WiFi Module
+#define RSI_GATEWAY                    "192.168.100.1"         //@ Default Gateway
+#define RSI_TARGET_IP_ADDRESS          "192.168.100.120"       //@ IP Address we will connect to
+#define RSI_NETMASK                    "255.255.255.0"         //@ Netmask
+
+/* IPv4 parameterrs for Concurrent mode AP*/
+#define RSI_CONCURRENT_AP_IP_ADDRESS          "192.168.101.76"        //@ IP Address of the WiFi Module 
+#define RSI_CONCURRENTAP_IP_NETMASK                 "255.255.255.0"         //@ Netmask
+
+/* IPV6 address parameters */
+#define RSI_IPV6_PREFIX_LENGTH         64                      //@ IPV6 prefix length  
+#define RSI_MODULE_IPV6_ADDRESS        "2001.db8.1.0.0.0.0.123"   //@ module IPv6 address
+#define RSI_TARGET_IPV6_ADDRESS        "2001.db8.1.0.0.0.0.124"   //@ Target IPv6 address
+#define RSI_DEFAULT_ROUTER_IPV6_ADDRESS "2001.db8.1.0.0.0.0.1" //@ Router IPv6 address
+
+//@ Socket configuration
+#define RSI_TOTAL_SOCKETS                     2                //@ Total number of sockets. TCP TX + TCP RX + UDP TX + UDP RX
+#define RSI_TOTAL_TCP_SOCKETS                 1                //@ Total TCP sockets. TCP TX + TCP RX
+#define RSI_TOTAL_UDP_SOCKETS                 1                //@ Total UDP sockets. UDP TX + UDP RX
+#define RSI_TCP_TX_ONLY_SOCKETS               0                //@ Total TCP TX only sockets. TCP TX
+#define RSI_TCP_RX_ONLY_SOCKETS               1                //@ Total TCP RX only sockets. TCP RX
+#define RSI_UDP_TX_ONLY_SOCKETS               0                //@ Total UDP TX only sockets. UDP TX 
+#define RSI_UDP_RX_ONLY_SOCKETS               1                //@ Total UDP RX only sockets. UDP RX
+#define RSI_TCP_RX_HIGH_PERFORMANCE_SOCKETS   1                //@ Total TCP RX High Performance sockets
+//@ Socket Info
+#define RSI_SOCKET_TYPE                RSI_SOCKET_LUDP         //@ Set type of socket to open
+#define SOCKET_FEATURE                 DISABLE                 //@ DISABLE or RSI_SSL_SUPPORT or RSI_WEBS_SUPPORT or RSI_SSL_WEBS_SUPPORT or RSI_SSL_TLS_V_1 or RSI_SSL_TLS_V_1_2 or RSI_TCP_HIGH_PERFORMANCE
+#define SSL_CIPHERS                    SSL_ALL_CIPHERS         //@ Set SSL cipher 
+#define RSI_MAX_LTCP_CONNECTIONS       5                       //@ Set maximum clients can connect to a LTCP socket.Possible values are 1 to 9
+#define RSI_TOS                        0                       //@ Type of service. possible values are 0 to 7
+#define DATA_TRANSFER_TYPE             DATA_TX                 //@ Set data transfer type DATA_TX or DATA_RX
+#define WEBS_RESOURCE_NAME             "/websocket"            //@ WEBS resource name
+#define TCP_RETRANMISSIONS_COUNT       10                      //@ Maximum tcp retransmissions count
+#define WEBS_HOST_NAME                 "localhost"             //@ WEBS host name
+#define SOCKET_BITMAP                  DISABLE                 //@ DISABLE or RSI_LTCP_ACCEPT or RSI_SYNCHRONOUS_DATA_READ or RSI_TCP_RX_WINDOW or RSI_ASYNCHRONOUS_DATA_READ 
+#define TCP_RX_WINDOW_SIZE             2                       //@ TCP RX window size
+#define KEEP_ALIVE_INTERVAL            1200                    //@ Keep alive interval
+#define SOCKET_VAP_ID                  RSI_CLIENT_VAP_ID       //@ VAP ID RSI_AP_VAP_ID or RSI_CLIENT_VAP_ID
+#define TCP_RETRANSMISSION_TIMER       10                      //@ TCP retransmission timer between the packets 
+
+
+//@ OTA Firmware Upgradation
+#define RSI_OTAF                       DISABLE                  //@ ENABLE or DISABLE for OTAF
+#define RSI_OTAF_IP_VERSION            IP_VERSION_4             //@ IP_VERSION_4 or IP_VERSION_6. IP version to use.
+#define RSI_OTAF_SERVER_IPV4_ADDRESS   "192.168.0.101"          //@ OTAF server ipv4 address 
+#define RSI_OTAF_SERVER_IPV6_ADDRESS   "2001.db8.1.0.0.0.0.124" //@ OTAF server ipv6 address
+#define RSI_OTAF_SERVER_PORT           5001                     //@ OTAF server port number
+#define RSI_OTAF_CHUNK_NUMBER          1                        //@ OTAF RPS content chunk number
+#define RSI_OTAF_RX_TIMEOUT            200                      //@ OTAF Receie timeout
+#define RSI_OTAF_TCP_RETRY_COUNT       20                        //@ OTAF TCP retry count
+
+//@ Max sockets
+#define RSI_MAX_SOCKETS                1                      //@ Max sockets count                     
+
+//@ Socket Info
+#define RSI_MODULE_SOCKET_ONE          5001                    //@ Module Socket/Port Number
+#define RSI_TARGET_SOCKET_ONE          5001                    //@ Port Number of we will connect to
+
+//@ Socket Info
+#define RSI_MODULE_SOCKET_TWO          50000                   //@ Module Socket/Port Number
+#define RSI_TARGET_SOCKET_TWO          50000                   //@ Port Number of we will connect to
+
+//@ Socket Info
+#define RSI_MODULE_SOCKET_THREE        55500                   //@ Module Socket/Port Number
+#define RSI_TARGET_SOCKET_THREE        55000                   //@ Port Number of we will connect to
+
+//@ Socket Info
+#define RSI_MODULE_SOCKET_FOUR         18046                   //@ Module Socket/Port Number
+#define RSI_TARGET_SOCKET_FOUR         18046                   //@ Port Number of we will connect to
+
+//@ Socket Info
+#define RSI_MODULE_SOCKET_FIVE         15046                   //@ Module Socket/Port Number
+#define RSI_TARGET_SOCKET_FIVE         15046                   //@ Port Number of we will connect to
+
+//@ Socket Info
+#define RSI_MODULE_SOCKET_SIX          16046                   //@ Module Socket/Port Number
+#define RSI_TARGET_SOCKET_SIX          16046                   //@ Port Number of we will connect to
+
+//@ Socket Info
+#define RSI_MODULE_SOCKET_SEVEN        17046                   //@ Module Socket/Port Number
+#define RSI_TARGET_SOCKET_SEVEN        17046                   //@ Port Number of we will connect to
+
+/* Webpage bypass */
+#define WEBPAGE_BYPASS_SUPPORT         DISABLE                  //@ Enable or Disable webpage bypass feature
+
+//@ multicast params
+#define RSI_MULTICAST_SUPPORT              DISABLE             //@ ENABLE or DISABLE multicast support
+#define RSI_MULTICAST_MESSAGE_TYPE         RSI_MULTICAST_JOIN  //@ RSI_MULTICAST_JOIN or RSI_MULTICAST_LEAVE
+#define RSI_MULTICAST_GROUP_IPV4_ADDRESS   "239.255.0.1"       //@ Multicast IPv4 address
+#define RSI_MULTICAST_GROUP_IPV6_ADDRESS   "FF01:0:0:0:0:0:0:1"//@ Multicast IPv6 address
+
+/* HTTP GET/POST REQ */
+#define RSI_HTTP_URL                 "/index.html"             //@ HTTP URL name
+#define RSI_HTTP_IP                  "192.168.10.1"             //@ HTTP server IPv4 address
+#define RSI_HTTP_IPV6                "2001.db8.1.0.0.0.0.124"  //@ HTTP server IPv6 address
+#define RSI_HTTP_DATA                "START+++Readpine Signals String+++END" //@ HTTP data to send
+#define RSI_HTTPS_SUPPORT            0                        //@ 1 to enable HTTPS support or RSI_SSL_TLS_V_1 or RSI_SSL_TLS_V_1_2 or RSI_HTTP_NULL_DELIMITER or RSI_FEAT_HTTP_POST_DATA or RSI_FEAT_HTTP_V_1_1
+#define RSI_HTTP_USERNAME            "username"                //@ set HTTP user name
+#define RSI_HTTP_PASSWORD            "password"                //@ set HTTP password
+#define RSI_HTTP_HOSTNAME            "posttestserver.com"           //@ set HTTP hostname
+#define RSI_HTTP_SERVER_PORT         80                        //@ set HTTP port number
+
+#define RSI_HTTP_POST_DATA_SUPPORT   DISABLE                    //@ ENABLE or DISABLE HTTP post data feature
+#define RSI_HTTP_DATA_LENGTH         2768                      //@ Total length of the HTTP data to send 
+
+
+/* HTTP Credentials */
+#define RSI_HTTP_SERVER_USERNAME     "admin"                     //@ HTTP SERVER USERNAME
+#define RSI_HTTP_SERVER_PASSWORD     "admin"                     //@ HTTP SERVER PASSWORD
+/* set DNS sever */
+#define DNS_CLIENT_SUPPORT              DISABLE
+#define RSI_DNS_CFG_MODE                RSI_DNS_MODE_DISABLE   //@ RSI_DNS_MODE_DISABLE - DNS IP takes from User or RSI_DNS_MODE_ENABLE - DNS IP takes through DHCP
+#define RSI_PRIMARY_DNS_IP_ADDRESS      "4.2.2.2"              //@ Primary DNS IPv4 address
+#define RSI_SECONDARY_DNS_IP_ADDRESS    "8.8.8.8"              //@ Secondary DNS IPv4 address
+#define RSI_PRIMARY_DNS_IPV6_ADDRESS    "2001.db8.1.0.0.0.0.4" //@ Primary DNS IPv6 address
+#define RSI_SECONDARY_DNS_IPV6_ADDRESS  "2001.db8.1.0.0.0.0.5" //@ Secondary DNS IPv6 address
+#define DNS_QRY_URL                     "www.google.com"       //@ DNS URL to query  
+#define DNS_ZONE_NAME                   "rps.com"              //@ DNS URL to query  
+#define DNS_HOST_NAME                   "redpine"              //@ DNS URL to query  
+#define DNS_SERVER_NUM                  1                      //@ 1 or 2.Primary or secondary DNS server to use for quering DNS request
+#define DNS_UPDATE_TTL                  53                     //@ Hostname time to live value
+
+/* set DHCP USER CLASS */
+#define DHCP_USER_CLASS_SUPPORT         DISABLE                //@ ENABLE or DISABLE DHCP clien User Class option -77 support
+#define DHCP_USER_CLASS_MODE            2                      //@ 1- RFC format mode 2- Windows format mode
+#define DHCP_USER_CLASS_COUNT           1                      //@ USER CLASS data count (Max count 2)
+#define DHCP_USER_CLASS_DATA_1          "Redpine-class1"       //@ USER CLASS data (MAX LENGTH 64 bytes)
+#define DHCP_USER_CLASS_DATA_LENGTH_1   14                     //@ USER CLASS 1 data length (MAX LENGTH 64 bytes)
+#define DHCP_USER_CLASS_DATA_2          "Redpine-class2"       //@ USER CLASS data 
+#define DHCP_USER_CLASS_DATA_LENGTH_2   14                     //@ USER CLASS 2 data length (MAX LENGTH 64 bytes)
+
+
+/* Webpage related configuration */
+#define WEB_PAGE_LOAD                 DISABLE                  //@ ENABLE or DISABLE web page load support
+#define WEB_PAGE_FILENAME             "sample.html"            //@ web page file name to load
+#define WEB_PAGE_LENGTH               2772                     //@ Length of the webpage to load
+#define WEB_PAGE_HAS_JSON             1                        //@ 0 or 1. 1 - web page contains JSON, 0 -web page does not contain JSON
+#define WEB_PAGE_CLEAR_ALL_FILES      1
+
+/* JSON data configuration */
+#define JSON_LOAD                     DISABLE                  //@ ENABLE or DISABLE JSON load
+#define JSON_FILENAME                 "sample.html"            //@ file name for which JSON has to be load
+
+/*Ping command params*/
+#define RSI_PING_VERSION              IP_VERSION_4             //@ PING IP version to use 
+#define RSI_PING_DATA_SIZE            40                       //@ PING size. Possible values are 1 to 300
+#define RSI_PING_TARGET_IP            "192.168.1.104"          //@ PING target IPv4 address  
+#define RSI_PING_TARGET_IPV6          "2001.db8.1.0.0.0.0.120" //@ PING target IPv6 address
+#define RSI_PING_REPLY_TIMEOUT        10                       //@ PING timeout. 1sec = 10*100ms
+
+/* SNMP PARAMTERS */
+#define SNMP_SUPPORT                  DISABLE                  //@ ENABLE or DISABLE SNMP support
+#define SNMP_STATS                    DISABLE                  //@ ENABLE or DISABLE SNMP STATS support
+#define RSI_SNMP_ENABLE               DISABLE                  //@ ENABLE or DISABLE SNMP agent functionality
+#define SNMP_WALK_SUPPORT             DISABLE                  //@ ENABLE or DISABLE SNMP agent functionality
+#define RSI_SNMP_OBJ_TYPE             SNMP_ANS1_OCTET_STRING   //@ SNMP object type
+#define RSI_SNMP_OBJ_VALUE            "sample snmp object"     //@ SNMP object value 
+
+#define RSI_SNMP_VERSION              SNMP_VERSION_2           //@ SNMP version to use
+#define RSI_SNMP_TARGET_IP_ADDRESS    "192.168.10.10"          //@ SNMMP target IPv4 address
+#define RSI_SNMP_TARGET_IPV6_ADDRESS  "2001.db8.1.0.0.0.0.123" //@ SNMP target IPv6 address
+#define RSI_SNMP_COMMUNITY            "public"                 //@ SNMP community
+#define RSI_SNMP_TRAP_TYPE            SNMP_TRAP_WARM_START     //@ SNMP trap type
+#define RSI_SNMP_TRAP_OID             "1.2.3.4.5.6.7.7.8"      //@ SNMP trap OID
+#define RSI_SNMP_ELAPSED_TIME         1234                     //@ SNMP Elapsed time
+#define RSI_SNMP_OBJECT_LIST_COUNT    10                        //@ SNMP object list count
+
+//! FTP client
+#define RSI_FTP_CLIENT                DISABLE                   //@ ENABLE or DISABLE FTP client
+#define RSI_FTP_PASSIVE_MODE          DISABLE                   //@ EANBLE or DISABLE FTP Client passive mode
+#define RSI_FTP_SERVER_IP_ADDRESS     "192.168.0.150"
+#define RSI_FTP_USERNAME              "admin"
+#define RSI_FTP_PASSWORD              "admin"
+#define RSI_FTP_SERVER_PORT           21
+#define RSI_FTP_CHANGE_DIRECTORY_PATH "ftp_client"
+#define RSI_FTP_PATH                  "ftp_file_write.txt"
+#define RSI_FTP_FILE_WRITE            "ftp_file_write.txt"
+
+//! SNTP client
+#define RSI_SNTP_CLIENT                DISABLE                   //@ ENABLE or DISABLE FTP client
+#define RSI_SNTP_IP_VERSION            IP_VERSION_4              //@ IP_VERSION_4 or IP_VERSION_6
+#define RSI_SNTP_SERVER_IP_ADDRESS     "192.168.1.150"           //@ SNTP server IPv4 address
+#define RSI_SNTP_SERVER_IPV6_ADDRESS   ""                        //@ SNTP server IPv6 address
+#define RSI_SNTP_METHOD                SNTP_UNICAST_MODE         //@ SNTP_UNICAST_MODE - unicast
+                                                                 //@ SNTP_BROADCAST_MODE -broadcast mode
+#define RSI_SNTP_TIMEOUT               15                        //@ SNTP_TIMEOUT in seconds (Ex: 15 sec)
+
+//! MDNS-SD
+#define RSI_MDNS_SD                   DISABLE
+#define MDNS_IP_VERSION               IP_VERSION_4
+#define MDNS_INIT_TTL                 300
+#define MDNS_SRV_TTL                  300
+#define MDNS_SRV_PORT                 80
+#define MDNS_SRV_MORE                 0
+
+#define MDNS_HOST_NAME                "http-wsc_obe.local."
+#define MDNS_PTR_NAME                 "_http._tcp.local."
+#define MDNS_SRV_NAME                 "wsc_obe._http._tcp.local"
+#define MDNS_TXT_NAME                 "text_field"
+
+//! SMTP Client
+#define RSI_SMTP_CLIENT                 DISABLE
+#define RSI_SMTP_IP_VERSION             IP_VERSION_4
+#define RSI_SMTP_SERVER_IPV4_ADDRESS    "203.196.161.92"
+#define RSI_SMTP_SERVER_IPV6_ADDRESS    ""
+#define RSI_SMTP_FEATURE                RSI_SMTP_MAIL_PRIORITY_NORMAL
+#define RSI_SMTP_SERVER_PORT            25
+#define RSI_SMTP_AUTH_TYPE              RSI_SMTP_AUTH_LOGIN 
+#define RSI_SMTP_CLIENT_USERNAME        "redpine.xxx@redpinesignals.com"
+#define RSI_SMTP_CLIENT_PASSWORD        "Chnr&Na8T"
+#define RSI_SMTP_FROM_ADDRESS           "redpine.xxx@redpinesignals.com"
+#define RSI_SMTP_LOCAL_DOMAIN           "mail.redpinesignals.com"
+#define RSI_SMTP_MAIL_RECIPIENT_ADDRESS "redpine.yyy@redpinesignals.com"
+#define RSI_SMTP_MAIL_SUBJECT_LINE      "@@@ SUBJECT @@@"
+#define RSI_SMTP_MAIL_BODY              "### BODY ###"
+
+/* HTTP PUT  REQ */
+#define RSI_HTTP_CLIENT_PUT                 DISABLE
+#define RSI_HTTP_CLIENT_PUT_IP_VERSION      IP_VERSION_4
+#define RSI_HTTP_PUT_SERVER_IPV4_ADDRESS    "192.168.0.102"             //@ HTTP server IPv4 address
+#define RSI_HTTP_PUT_SERVER_IPV6_ADDRESS    "2001.db8.1.0.0.0.0.124"  //@ HTTP server IPv6 address
+#define RSI_HTTP_PUT_URL                    "/index.html"             //@ HTTP URL name
+#define RSI_HTTP_PUT_USERNAME               "username"                //@ set HTTP user name
+#define RSI_HTTP_PUT_PASSWORD               "password"                //@ set HTTP password
+#define RSI_HTTP_PUT_HOSTNAME               "posttestserver.com"           //@ set HTTP hostname
+#define RSI_HTTP_PUT_SERVER_PORT            80                        //@ set HTTP port number
+#define RSI_HTTPS_PUT_ENABLE                0                        //@ 1 to enable HTTPS_PUT_ENABLE or  HTTPS support or RSI_SSL_TLS_V_1 or RSI_SSL_TLS_V_1_2 or RSI_HTTP_NULL_DELIMITER or RSI_FEAT_HTTP_POST_DATA or RSI_FEAT_HTTP_V_1_1
+
+
+//! POP3 Client
+#define RSI_POP3_CLIENT                 DISABLE                    //@ ENABLE or DISABLE POP3 Client feature
+#define RSI_POP3_IP_VERSION             IP_VERSION_4               //@ POP3 client ip version
+#define RSI_POP3_SERVER_IPV4_ADDRESS    "203.196.161.92"           //@ POP3 server ipv4 address
+#define RSI_POP3_SERVER_IPV6_ADDRESS    ""                         //@ POP3 server ipv6 address
+#define RSI_POP3_SERVER_PORT            110                        //@ POP3 server port number
+#define RSI_POP3_AUTH_TYPE              0                          //@ POP3 server authenticatio type (Dummy)
+#define RSI_POP3_CLIENT_USERNAME        "admin"                    //@ POP3 client username
+#define RSI_POP3_CLIENT_PASSWORD        "admin"                    //@ POP3 client password
+
+//@ Wait on host
+#define  TRIGGER_AUTO_CONFIG                 DISABLE                 //@ ENABLE or DISABLE WAIT ON AUTO CONFIG
+
+//@ User Store configuration
+#define  ENABLE_USER_STORE_CONFIGURATION     DISABLE                 //@ ENABLE or DISABLE User store configuration support
+#define  RSI_STORE_PMK_SUPPORT               ENABLE                  //@ ENABLE or DISABLE storing PMK
+#define  RSI_STORE_WEP_KEY_SUPPORT           ENABLE                  //@ ENABLE or DISABLE storing WEP key
+#define  RSI_STORE_IPV6_ENABLE               ENABLE                  //@ ENABLE or DISABLE IPV6 related paramerters
+//! Enable or disable Auto join/Auto create
+#define  USER_CFG_CFG_ENABLE                 DISABLE                 //@ Enable or disable store configuration
+//!Opermode parameters
+#define  USER_CFG_WLAN_OPERMODE              0                       //@ 0-For legacy client , 1-P2p mode , 2-Enterprise security mode, 6- AP mode, 8-per mode  
+#define  USER_CFG_COEX_MODE                  0                       //@ 0-wlan only, 3- wlan+zigbee coex 5- wlan+bt coex  13- wlan+btle coex    
+#define  USER_CFG_OPERMODE                   (USER_CFG_WLAN_OPERMODE|(USER_CFG_COEX_MODE << 16))                           //@ opermode
+#define  USER_CFG_FEATURE_BIT_MAP            FEAT_SECURITY_OPEN      //@ Station Security type
+#define  USER_CFG_TCP_IP_FEATURE_BIT_MAP     (TCP_IP_FEAT_DHCPV4_CLIENT | TCP_IP_FEAT_HTTP_SERVER)
+#define  USER_CFG_NO_OF_CLIENTS_SUPPORTED    1                       //@ Number of clients to support possible values 1 to 8
+#define  USER_CFG_CUSTOM_FEATURE_BIT_MAP     (USER_CFG_NO_OF_CLIENTS_SUPPORTED << 13)                       //@ Custom
+#define  USER_CFG_EXT_CUSTOM_FEATURE_BIT_MAP 0                       //@ extended Custom feature bitmap, this is valid only if BIT(31) of custom feature bitmap is set
+//! Band
+#define  USER_CFG_BAND                       0                       //@ Band
+//! Tcp ip stack used
+#define  USER_CFG_TCP_STACK_USED             1                       //@ 1 - ipv4, 2 - ipv6, 3 - BOTH
+//! Join parameters
+#define  USER_CFG_JOIN_SSID                  "REDPINE_AP"                //@ SSid to join in station mode
+#define  USER_CFG_URATE                      RSI_DATA_RATE_AUTO      //@ join data rate
+#define  USER_CFG_UTX_POWER                  RSI_POWER_LEVEL_HIGH    //@ Join @power level
+#define  USER_CFG_CHANNEL_SECURITY_MODE      SECURITY_MODE_OPEN      //@ Type of security 
+
+#define  USER_CFG_JOIN_FEAT_BIT_MAP	   		 0						   //@ RSI_JOIN_FEAT_STA_BG_ONLY_MODE_ENABLE or RSI_JOIN_FEAT_LISTEN_INTERVAL_VALID
+#define  USER_CFG_LISTEN_INTERVAL		   	 0
+
+#if (USER_CFG_WLAN_OPERMODE == 0 ||USER_CFG_WLAN_OPERMODE == 2)
+#define  USER_CFG_PSK                        ""              		 //@ PSK  12345678
+//! PMK key for client
+#define  USER_CFG_PMK                        ""                      //@ PMK key 992194d7a6158009bfa25773108291642f28a0c32a31ab2556a15dee97ef0dbb
+#endif
+
+#if (USER_CFG_WLAN_OPERMODE == 0 ||USER_CFG_WLAN_OPERMODE == 2)
+#define  USER_CFG_SCAN_SSID                  "REDPINE_AP"                //@ Scan ssid
+#define  USER_CFG_SCAN_CHANN_NUM             1                       //@ Scan channel number
+#define  USER_CFG_SCAN_FEAT_BITMAP           0                         //@ scan_feature_bitmap ,valid only if specific channel and ssid are given
+#define  USER_CFG_SCAN_CHAN_BITMAP_STORED_2_4_GHZ      31        	 //@ Scan channel bitmap for 2.4ghz
+#define  USER_CFG_SCAN_SCAN_CHAN_BITMAP_STORED_5_GHZ   15    	     //@ scan channel bitmap for 5ghz
+
+#endif
+
+#if((USER_CFG_TCP_STACK_USED == 1 ||USER_CFG_TCP_STACK_USED == 3 ))
+//! IPv4 configuration parameters
+#define  USER_CFG_DHCP_ENABLE                ENABLE                       //@ Dhcp enable or disable
+#define  USER_CFG_IPV4_ADDRESS               "192.168.100.67"         //@ IPv4 address of module
+#define  USER_CFG_SUBNETMASKV4_ADDRESS       "255.255.255.0"          //@ IPv4 subnet mask address
+#define  USER_CFG_GATEWAYV4_ADDRESS          "192.168.100.1"          //@ IPv4 Gateway address
+#endif
+#if (USER_CFG_WLAN_OPERMODE == 2)
+//! Enterprise security parameters
+#define  USER_CFG_EAP_METHOD                 "TTLS"                  //@ EAP Method to be used
+#define  USER_CFG_INNER_METHOD               "\"auth=MSCHAPV2\""     //@ Inner method
+#define  USER_CFG_USER_IDENTITY              "\"user1\""             //@ User identity
+#define  USER_CFG_PASSWORD                   "\"test123\""           //@ User password
+#define  USER_CFG_PRIVATE_KEY_PASSWORD       ""                      //@ User private key password if private is encrypted
+#endif
+#if (USER_CFG_WLAN_OPERMODE == 1)
+//! Wifi direct parameters (This feature is not supported in auto join or auto create)
+#define  USER_CFG_GO_INTENT                  15                      //@ GO intent value
+#define  USER_CFG_DEVICE_NAME                "WSC1.1"                //@ Device name
+#define  USER_CFG_OPERATING_CHANNEL          11                      //@ Operating channel
+#define  USER_CFG_SSID_POSTFIX               "WSC_1_0_0"             //@ Ssid postfix
+#define  USER_CFG_PSK_KEY                    "12345678"              //@ PSK key for AP
+#endif
+
+
+#if (USER_CFG_WLAN_OPERMODE == 6)
+//! AP configuration parameters
+#define  USER_CFG_APCONFIG_CHANNEL_NUM       1                       //@ AP configuration channel number
+#define  USER_CFG_APCONFIG_SSID              "REDPINE_AP"                //@ SSID of Access point
+#define  USER_CFG_APCONFIG_SECURITY_TYPE     RSI_SECURITY_NONE       //@ Security mode of AP
+#define  USER_CFG_APCONFIG_ENCRYP_MODE       RSI_ENCRYPTION_NONE     //@ Encryption mode of AP
+#define  USER_CFG_APCONFIG_PSK               ""                      //@ PSK of AP
+#define  USER_CFG_APCONFIG_BEACON_INTERVAL   100                     //@ Beacon interval
+#define  USER_CFG_APCONFIG_DTIM_PERIOD       4                       //@ DTIM period
+#define  USER_CFG_APCONFIG_MAX_STA_SUPPORT   4                       //@ Max station support by AP
+#define  USER_CFG_AP_KEEPALIVE_TYPE          0                       //@ AP:Keep alive type 0 -disable keep alive ,  1 - enables deauth based keep alive ,3 - enables null data based keep alive
+#define  USER_CFG_AP_KEEPALIVE_PERIOD        100                      //@ AP:Keep alive period (KEEP_ALIVE_PERIOD*32*Beacon_interval time duartion AP waits for packet form connected stations)
+#endif
+//! Module MAC Address
+//! Module MAC should be set to 00:00:00:00:00:00
+//! if user does not want to change the MAC address
+#define  USER_CFG_MODULE_MAC                 "00:00:00:00:00:00"     //@ MAC address of module
+#define  USER_CFG_ANTENNA_SELECT             0                       //@ 0 for internal antenna 1 for external antenna 
+#if(USER_CFG_WLAN_OPERMODE == 0)
+#if RSI_STORE_WEP_KEY_SUPPORT 
+#define  USER_CFG_WEPKEY_INDEX               0                       //@ WEP key index valid values are 0 to 3
+#define  USER_CFG_WEPKEY_KEY0                "1234567890"            //@ WEP key0
+#define  USER_CFG_WEPKEY_KEY1                "1234567980"            //@ WEP key1
+#define  USER_CFG_WEPKEY_KEY2                "1234567120"            //@ WEP key2
+#define  USER_CFG_WEPKEY_KEY3                "1234567130"            //@ WEP key3
+#endif
+#endif
+
+#if(USER_CFG_TCP_STACK_USED == 2 ||USER_CFG_TCP_STACK_USED == 3 )
+//! IPv6 configuration parameters
+#if RSI_STORE_IPV6_ENABLE
+#define  USER_CFG_DHCPV6_ENABLE              0                       //@ ENABLE or DISABLE DHCPv6 mode
+#define  USER_CFG_PREFIX_LENGTH              64                      //@ Prefix length
+#define  USER_CFG_IPV6_ADDRESS               "2001.db8.1.0.0.0.0.123"//@ IPV6 address of module
+#define  USER_CFG_GATEWAYV6_ADDRESS          "2001.db8.1.0.0.0.0.120"//@ IPv6 Gateway
+#endif
+#endif
+#define   RSI_MAGIC_CODE                     0x4321                  //@ Magic code
+#if (USER_CFG_WLAN_OPERMODE == 0 || USER_CFG_WLAN_OPERMODE == 2 )
+//!Bg scan Parameters
+#define   USER_CFG_BGSCAN_ENABLE                        DISABLE             //@ ENABLE or DISABLE BG scan
+#define   USER_CFG_BGSCAN_THRESHOLD                     10                  //@ BG scan threshold value
+#define   USER_CFG_BGSCAN_RSSI_TOLERANCE_THRESHOLD      4                   //@ BG scan threshold value
+#define   USER_CFG_BGSCAN_PERIODICITY                   10                  //@ BG scan periodicity
+#define   USER_CFG_BGSCAN_ACTIVE_SCAN_DURATION          15                  //@ Active scan duration
+#define   USER_CFG_BGSCAN_PASSIVE_SCAN_DURATION         20                  //@ Passive scan duration
+#define   USER_CFG_BGSCAN_MULTI_PROBE                   ENABLE              //@ Enable or disable multi probe
+#endif
+#if (USER_CFG_WLAN_OPERMODE == 0||USER_CFG_WLAN_OPERMODE == 1 || USER_CFG_WLAN_OPERMODE == 2)
+//!Roaming information
+#define   USER_CFG_ROAM_ENABLE                          DISABLE             //@ ENABLE or DISABLE roaming
+#define   USER_CFG_ROAM_THRESHOLD                       10                  //@ Roaming threshold value
+#define   USER_CFG_ROAM_HYSTERESIS                      4                   //@ Roam hysterisis  value
+#endif
+#if(USER_CFG_WLAN_OPERMODE == 0|| USER_CFG_WLAN_OPERMODE == 2)
+//!Rejoin information
+#define   USER_CFG_REJOIN_MAX_RETRY_COUNT               0                   //@ Rejoin Max retry count
+#define   USER_CFG_REJOIN_SCAN_INTERVAL                 4                   //@ Rejoin scan interval
+#define   USER_CFG_REJOIN_BEACON_MISSED_COUNT           40                  //@ Beacon missed count
+#define   USER_CFG_REJOIN_FIRST_TIME_RETRY_ENABLE       DISABLE             //@ ENABLE or disable first time retry
+#endif
+#if(USER_CFG_WLAN_OPERMODE == 0 || USER_CFG_WLAN_OPERMODE == 2 || USER_CFG_WLAN_OPERMODE == 6 || USER_CFG_WLAN_OPERMODE == 9)
+#define   USER_CFG_REGION_REQUEST_FROM_HOST             DISABLE             //@ ENABLE or DISABLE set region
+#define   USER_CFG_REGION_CODE_FROM_HOST                DISABLE             //@ IF 1:region configurations taken from user ;0:region configurations taken from beacon(If opermode is 0 or 2)
+																			 //@ Should be Disable in AP mode.Disable:Takes the region regulations(from flash) based on the region code
+#define   USER_CFG_REGION_CODE                          1                   //@ 0-Default Region domain ,1-US, 2-EUROPE, 3-JAPAN
+#endif
+
+#define   USER_CFG_FIPS_BYPASS_MODE                     1             //@ 0 - ENABLE FIPS bypass mode, 1 - DISABLE FIPS bypass mode
+#define   USER_CFG_KEYS_RESTORE                         DISABLE       //@ 0 - Makes all the keys Zero, 1 - Restore the previous keys 
+//! Multicast MAC filter support
+#define   USER_CFG_MULTICAST_SUPPORT                    DISABLE                    //@ ENABLE or DISABLE multicast support
+#if USER_CFG_MULTICAST_SUPPORT
+#define   USER_CFG_MULTICAST_MAC_CMD_TYPE               RSI_MULTICAST_MAC_SET_ALL  //@ RSI_MULTICAST_MAC_ADD_BIT or RSI_MULTICAST_MAC_CLEAR_BIT or RSI_MULTICAST_MAC_CLEAR_ALL or RSI_MULTICAST_MAC_SET_ALL
+#define   USER_CFG_MULTICAST_MAC_ADDRESS                "00:23:A7:1a:d0:50"        //@ MAC address used to calculate hash value for multicast filtering
+#endif
+//! Power Mode Support
+#define   USER_CFG_POWER_MODE_SUPPORT                   DISABLE                    //@ Enable/Disable Power Save support 
+#if  USER_CFG_POWER_MODE_SUPPORT
+#define   USER_CFG_POWER_MODE                           1                          //@ Power mode value,possible values 1,2,3 
+#define   USER_CFG_ULP_MODE                             0                          //@ Enable/Disable ULP mode 1- Enable,0 - Disable 
+#define   USER_CFG_LISTEN_INTERVAL_DTIM   				DISABLE
+#endif
+//! WMM PS Support 
+#define   USER_CFG_WMM_PS_SUPPORT                       DISABLE
+#if USER_CFG_WMM_PS_SUPPORT
+#define   USER_CFG_WMM_PS_ENABLE                        DISABLE                    //@ ENABLE or DISABLE WMM PS support 
+#define   USER_CFG_WMM_PS_TYPE                          0                          //@ 0 - wmm_ps tx based, 1- wmm ps periodic 
+#define   USER_CFG_WMM_PS_WAKEUP_INTERVAL               0                          //@ wmm ps wakeup interval 
+#define   USER_CFG_WMM_PS_UAPSD_BITMAP                  0                          //@ wmm ps uapsd bit map. Possible values are 0 to 15
+ 
+#endif
+
+//! HTTP SERVER CREDENTIALS
+#define   USER_CFG_HTTP_SERVER_CREDENTIALS_SUPPORT      DISABLE                     //@ ENABLE or DISABLE http server credentials from host
+#if  USER_CFG_HTTP_SERVER_CREDENTIALS_SUPPORT
+#define   USER_CFG_HTTP_SERVER_USERNAME                 "redpine"                   //@ HTTP server username 
+#define   USER_CFG_HTTP_SERVER_PASSWORD                 "admin"                     //@ HTTP server password 
+
+#endif
+
+//! JOIN BSSID
+#define   USER_CFG_JOIN_BSSID_SUPPORT                    DISABLE
+#if  USER_CFG_JOIN_BSSID_SUPPORT 
+#define   USER_CFG_JOIN_BSSID                           "00:00:00:00:00:00"         //@ MAC address used to calculate hash value for multicast filtering
+#endif
+
+#define   SECURITY_MODE_OPEN      0             //@ Open mode or Dont care
+#define   SECURITY_MODE_WPA       1             //@ Selects only WPA mode AP
+#define   SECURITY_MODE_WPA2      2             //@ Selects only WPA2 mode AP
+#define   SECURITY_MODE_WEP       3             //@ For WEP security mode
+#define   SECURITY_MODE_WPA_EAP   4             //@ For EAP-WPA
+#define   SECURITY_MODE_WPA2_EAP  5             //@ For EAP-WPA2
+#define   SECURITY_MODE_MIXED     6             //@ For Mixed Mode AP
+
+#define   RSI_PUF_ENABLE                 				DISABLE                  //@ ENABLE or DISABLE
+#endif
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/src/Makefile b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/src/Makefile
new file mode 100644
index 0000000..33f4e49
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/src/Makefile
@@ -0,0 +1,26 @@
+######################################################################
+#                                                                    #
+#   Makefile                                                         #
+#                                                                    #
+#   2016/09/29 Create(AlphaProject)                                  #
+#                                                                    #
+######################################################################
+
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/hal/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/intf/spi/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/bt/core/include
+EXTRA_CFLAGS += -Idrivers/net/wireless/wmrp10/wmrp10_apis/apis/ble/core/include
+EXTRA_CFLAGS += -DRSI_HAL
+
+obj-$(CONFIG_WMRP10_SPI) += rsi_wlan_ref_app_all.o
+
+rsi_wlan_ref_app_all-objs := rsi_app_util.o rsi_buildHttpExtendedHeader.o
+
+
+# rsi_dhcp_usr_cls.o rsi_dns_update.o rsi_fwup_frm_host.o rsi_gpio_config.o rsi_http_client_put.o rsi_ota_fw_up.o rsi_query_snr.o rsi_read_data.o rsi_register_interrupt_irq.o rsi_send_websocket_data.o rsi_snmp_get_stats.o rsi_trigger_auto_config.o rsi_uart_flow_control.o rsi_web_fields.o
+
+# rsi_ftp_client.o rsi_http_abort.o rsi_http_credentials.o rsi_http_get.o rsi_http_post.o rsi_http_post_data.o rsi_ip_param_set.o rsi_ipv6_param_set.o rsi_json_create.o rsi_json_erase_file.o rsi_load_web_page.o rsi_ltcp_conn_status.o rsi_mdns_sd.o rsi_multicast.o rsi_multicast_filter.o rsi_ping_request.o rsi_pop3_client.o rsi_send_data.o rsi_send_ludp_data.o rsi_send_url_rsp.o rsi_smtp_client.o rsi_snmp_enable.o rsi_snmp_get_next_rsp.o rsi_snmp_get_rsp.o rsi_snmp_trap.o rsi_sntp_client.o rsi_socket.o rsi_socket_close.o rsi_socket_config.o rsi_webpage_clear_files.o rsi_webpage_erase_file.o
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/src/rsi_app_util.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/src/rsi_app_util.c
new file mode 100755
index 0000000..c632b85
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/src/rsi_app_util.c
@@ -0,0 +1,751 @@
+/**
+ * @file            rsi_app_util.c
+ * @version         3.6
+ * @date            2013-June-16
+ *
+ * Copyright(C) Redpine Signals 2013
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file. 
+ *
+ * @brief UTIL: Generic util functions such as swapping which are not tied to anything.
+ *
+ * @section Description
+ * This file implements misc utilities/functions.
+ *
+ * @section Improvements
+ * asciihex_2_num() function is added.
+ */
+
+
+/**
+ * Include files
+ */
+#include "rsi_global.h"
+#include "rsi_app_util.h"
+#ifdef WLAN_ENABLE
+#include "rsi_app.h"
+#endif
+
+/**
+ * Global defines
+ */
+
+#if 0
+/*================================================*/
+/**
+ * @fn             void rsi_print_n_chars (char* st, int n)
+ * @brief          Print n characters from the string passed
+ * @param[in]      char* st,string to print from
+ * @param[in]      int n,number of characters to print
+ * @param[out]     none
+ * @return         none
+ */
+void rsi_print_n_chars (int8* st, int16 n)
+{
+   int16         i;
+
+   for (i = 0; i < n; i++) {
+      putchar(st[i]);
+   }
+}
+
+#endif
+
+
+/*=============================================================================*/
+/**
+ * @fn             int8 * rsi_bytes6_to_ascii_mac_addr(uint8 *hexAddr)
+ * @brief          Convert an uint8 6-Byte array to  : notation MAC address
+ * @param[in]      uint8 *hexAddress, Address to convert
+ * @param[in]      uint8 *strBuf, pointer to a dummy String to hold the MAC address
+ * @param[out]     none
+ * @return         int8 * destString, pointer to the string with the data
+ */
+int8 * rsi_bytes6_to_ascii_mac_addr(uint8 *hexAddr,uint8 *strBuf)
+{
+   uint8         i;                  //! loop counter
+   uint8         cBuf[3];            //! character buffer
+   uint8         *destString;
+
+   strBuf[0] = 0;                     //! make  strcat think the array is empty
+   for (i = 0; i < 5; i++) {          //! MAC Address is 6 bytes long
+      //! This will take care of the first5 bytes
+      sprintf ((char *)cBuf, "%02x", (((uint8*)hexAddr)[i]));
+      cBuf[2] = 0;                     //! terminate the string
+      destString =(uint8 *) strcat((char *)strBuf,(char *) cBuf);
+      destString = (uint8 *)strcat((char *)strBuf, (char *)":");
+   }
+   //! take care of the last entry outside the loop, there is no . after the last octet
+   sprintf ((char *)cBuf, "%02x", (((uint8*)hexAddr)[i]));
+   cBuf[2] = 0;                                             
+   //! terminate the string
+   destString = (uint8 *)strcat((char *)strBuf,(char *) cBuf);
+   return (int8 *) destString;
+}
+
+
+/*=============================================================================*/
+/**
+ * @fn             void rsi_swap_2bytes(uint8 *buffer)
+ * @brief          swap the first 2 bytes of an array
+ * @param[in]      uint8 *buffer,pointer to buffer of data to convert
+ * @param[out]     none
+ * @return         value returned in the array passed
+ */
+void rsi_swap_2bytes(uint8 *buffer)
+{
+   uint8         tmp;
+
+   tmp = buffer[0];
+   buffer[0] = buffer[1];
+   buffer[1] = tmp;
+}
+
+
+/*=============================================================================*/
+/**
+ * @fn             void rsi_swap_4bytes(uint8 *buffer)
+ * @brief          swap the byte order of a 4 Byte array
+ * @param[in]      uint8 *buffer,pointer to buffer of data to convert
+ * @param[out]     none
+ * @return         value returned in the array passed
+ */
+void rsi_swap_4bytes(uint8 *buffer)
+{
+   uint8         tmp;
+
+   tmp = buffer[0];
+   buffer[0] = buffer[3];
+   buffer[3] = tmp;
+   tmp = buffer[1];
+   buffer[1] = buffer[2];
+   buffer[2] = tmp;
+}
+
+
+/*=============================================================================*/
+/**
+ * @fn            void rsi_print_uint8_as_binary(uint8 number)
+ * @brief         print an uint8 number in binary, as in: 0x31 --> 00110001
+ * @param[in]     uint8 number to print
+ * @param[out]    none
+ * @return        value returned in the array passed
+ */
+#if 0
+void rsi_print_uint8_as_binary(uint8 number)
+{
+   uint16         i;                  // loop counter
+
+   i = 1<<(sizeof(number) * 8 - 1);
+
+
+   while (i > 0) {
+      if (number & i) {
+         printf("1");
+      }
+      else {
+         printf("0");
+      }
+      i >>= 1;
+   }
+}
+#endif
+
+
+/*=============================================================================*/
+/**
+ * @fn             int16 rsi_is_uint8_in_list(uint8 arg, uint8 *list, uint8 nargs)
+ * @brief          check if a uint8 number is in a list
+ * @param[in]      uint8 arg,number to be checked in the list
+ * @param[in]      uint8 *list,list of numbers to check against
+ * @param[in]      uint8 nargs,number of arguments
+ * @param[out]     none
+ * @return         value returned in the array passed
+ */
+int16 rsi_in_uint8_list(uint8 arg, uint8 *list, uint8 nargs)
+{
+   int16            retval;       //! return value, TRUE or FALSE
+   uint8            i;            //! loop counter
+
+   retval = RSI_FALSE;                                                
+   //! start off with a false, if we find a match, then change to a true to return
+   for (i = 0; i < nargs; i++) {
+      if (arg == list[i]) {
+         retval = RSI_TRUE;
+         break;
+      }
+   }
+
+   return retval;
+}
+
+
+/*=============================================================================*/
+/**
+ * @fn             int8 * rsi_bytes4_to_ascii_dot_addr(uint8 *hexAddr, uint8 *strBuf)
+ * @brief          Convert an uint8 4-Byte array to  . notation network address
+ * @param[in]      uint8 *hexAddress, Address to convert
+ * @param[in]      uint8 *strBuf, String Pointer to hold the Concatenated String
+ * @param[out]     none
+ * @return         char * destString, pointer to the string with the data
+ */
+int8 * rsi_bytes4_to_ascii_dot_addr(uint8 *hexAddr,uint8 *strBuf)
+{
+  uint8         i;                     //! loop counter
+  uint8         ii;                    //! loop counter
+  int8         cBuf[4];                //! character buffer
+  int8         *destString;
+
+  strBuf[0] = 0;                        //! make  strcat think the array is empty
+  for (i = 0; i < 3; i++) {             //! we are assuming IPV4, so 4 bytes
+    //! This will take care of the first 3 bytes
+    //! zero out the character buffer since we don't know how long the string will be
+    for(ii = 0; ii < sizeof(cBuf); ii++) { cBuf[ii] = 0; }   
+    sprintf ((char *)cBuf, "%d", (((uint8*)hexAddr)[i]));
+    destString =(int8 *) strcat((char *)strBuf,(char *) cBuf);
+    destString = (int8 *)strcat((char *)strBuf,(char *) ".");
+  }
+  //! take care of the last entry outside the loop, there is no . after the last octet
+  //! zero out the character buffer since we don't know how long the string will be
+  for(ii = 0; ii < sizeof(cBuf); ii++) { cBuf[ii] = 0; }      
+  sprintf ((char *)cBuf, "%d", (((uint8*)hexAddr)[i]));
+  destString = (int8 *) strcat((char *)strBuf,(char *) cBuf);
+  return destString;
+}
+
+/*=============================================================================*/
+/**
+ * @fn         int8 asciihex_2_num ( int8 ascii_hex_in)
+ * @brief      Convert given ASCII hex notation to descimal notation (used for mac address)
+ * @param[in]  int8 ascii_hex_in, byte in ascii hex format
+ * @return     value in hex num
+ */
+ 
+int8 asciihex_2_num(int8 ascii_hex_in)
+{
+   if((ascii_hex_in >= '0') && (ascii_hex_in <= '9'))
+      return (ascii_hex_in - '0');
+   if((ascii_hex_in >= 'A') && (ascii_hex_in <= 'F'))
+      return (ascii_hex_in - 'A' + 10);
+   if((ascii_hex_in >= 'a') && (ascii_hex_in <= 'f'))      
+      return (ascii_hex_in - 'a' + 10);
+   
+   return 0;
+}
+
+/*=============================================================================*/
+/**
+ * @fn            int8 rsi_charhex_2_dec ( uint8 *cBuf)
+ * @brief         Convert given ASCII hex notation to descimal notation (used for mac address)
+ * @param[in]     int8 *cBuf, ASCII hex notation string
+ * @return        value in integer
+ */
+int8 rsi_charhex_2_dec ( int8 *cBuf)
+{
+   int8 k=0;
+   uint8 i;
+   for(i=0;i<strlen((char*)cBuf);i++)
+    {
+      k = ((k*16) + asciihex_2_num(cBuf[i])); 
+     }
+    return k;
+}    
+
+/*=============================================================================*/
+/**
+ * @fn            void rsi_ascii_mac_address_to_6bytes(uint8 *hexAddr, int8 *asciiMacAddress)
+ * @brief         Convert an ASCII : notation MAC address to a 6-byte hex address
+ * @param[in      int8 *asciiMacFormatAddress, source address to convert, must be a null terminated string
+ * @param[out]    uint8 *hexAddr, converted address is returned here 
+ * @return        none
+ */
+void rsi_ascii_mac_address_to_6bytes(uint8 *hexAddr, int8 *asciiMacAddress)
+{
+  uint8         i;                  //! loop counter
+  uint8         cBufPos;            //! which char in the ASCII representation
+  uint8         byteNum;            //! which byte in the 32BitHexAddress
+  int8         cBuf[6];             //! temporary buffer
+
+  byteNum = 0;
+  cBufPos = 0;
+  for (i = 0; i < strlen((char *)asciiMacAddress); i++) {
+    //! this will take care of the first 5 octets
+    if (asciiMacAddress[i] == ':') {      //! we are at the end of the address octet
+      cBuf[cBufPos] = 0;                  //! terminate the string
+      cBufPos = 0;                        //! reset for the next char
+      hexAddr[byteNum++] = (uint8)rsi_charhex_2_dec((int8 *)cBuf);   //! convert the strint to an integer
+    }
+    else {
+      cBuf[cBufPos++] = asciiMacAddress[i];
+    }
+  }
+  //! handle the last octet                  //! we are at the end of the string with no .
+  cBuf[cBufPos] = 0x00;                     //! terminate the string
+  hexAddr[byteNum] = (uint8)rsi_charhex_2_dec((int8 *)cBuf);      //! convert the strint to an integer
+}
+
+
+
+/*=============================================================================*/
+/**
+ * @fn	    		void rsi_ascii_mac_address_to_6Bytes_rev(uint8 *hexAddr, int8 *asciiMacAddress)
+ * @brief		    Convert an ASCII : notation MAC address to a 6-byte hex address
+ * @param[in		int8 *asciiMacFormatAddress, source address to convert, must be a null terminated string
+ * @param[out]	uint8 *hexAddr, converted address is returned here 
+ * @return	  	none
+ */
+void rsi_ascii_mac_address_to_6bytes_rev(uint8 *hexAddr, int8 *asciiMacAddress)
+{
+  uint8			i;						  //! loop counter
+  uint8		  cBufPos;				//! which char in the ASCII representation
+  uint8			byteNum;				//! which byte in the 32BitHexAddress
+  int8			cBuf[6];				//! temporary buffer
+
+  byteNum = 5;
+  cBufPos = 0;
+  for (i = 0; i < strlen((char *)asciiMacAddress); i++) {
+    // this will take care of the first 5 octets
+    if (asciiMacAddress[i] == ':') {			//! we are at the end of the address octet
+      cBuf[cBufPos] = 0;						      //! terminate the string
+      cBufPos = 0;							          //! reset for the next char
+      hexAddr[byteNum--] = (uint8)rsi_charhex_2_dec((int8 *)cBuf);	//! convert the strint to an integer
+    }
+    else {
+      cBuf[cBufPos++] = asciiMacAddress[i];
+    }
+  }
+  // handle the last octet						//! we are at the end of the string with no .
+  cBuf[cBufPos] = 0x00;							  //! terminate the string
+  hexAddr[byteNum] = (uint8)rsi_charhex_2_dec((int8 *)cBuf);		//! convert the strint to an integer
+}
+
+
+
+/*=============================================================================*/
+/**
+ * @fn            void rsi_ascii_dot_address_to_4bytes(uint8 *hexAddr, int8 *asciiDotAddress)
+ * @brief         Convert an ASCII . notation network address to 4-byte hex address
+ * @param[in]     int8 *asciiDotFormatAddress, source address to convert, must be a null terminated string
+ * @param[out]    uint8 *hexAddr,   Output value is passed back in the 4-byte Hex Address
+ * @return        none
+ */
+void rsi_ascii_dot_address_to_4bytes(uint8 *hexAddr, int8 *asciiDotAddress)
+{
+  uint8         i;                                             
+  //! loop counter
+  uint8         cBufPos;                                       
+  //! which char in the ASCII representation
+  uint8         byteNum;                                       
+  //! which byte in the 32BitHexAddress
+  int8         cBuf[4];                                       
+  //! character buffer
+
+  byteNum = 0;
+  cBufPos = 0;
+  for (i = 0; i < strlen((char *)asciiDotAddress); i++) {
+    //! this will take care of the first 3 octets
+    if (asciiDotAddress[i] == '.') {                              
+       //! we are at the end of the address octet
+      cBuf[cBufPos] = 0;                                       
+      //! terminate the string
+      cBufPos = 0;                                          
+      //! reset for the next char
+      hexAddr[byteNum++] = (uint8)atoi((char *)cBuf);                        
+      //! convert the strint to an integer
+    }
+    else {
+      cBuf[cBufPos++] = asciiDotAddress[i];
+    }
+  }
+  //! handle the last octet                                       
+  //! we are at the end of the string with no .
+  cBuf[cBufPos] = 0x00;                                          
+  //! terminate the string
+  hexAddr[byteNum] = (uint8)atoi((char *)cBuf);                              
+  //! convert the strint to an integer
+}
+#ifdef WLAN_ENABLE
+/*=========================================================================*/
+/**
+ * @fn          void register_socket_protocol(rsi_api  *ptrStrApi)
+ * @brief       Register socket information
+ * @param[in]   rsi_api  *ptrStrApi,pointer to global parameter structure
+ * @param[out]  none
+ * @return      none
+ *          
+ * @section description 
+ * This funtion is used to link the socket number with the protocol.
+ * It also tags the socket with its protocol. 
+ */
+void register_socket_protocol(rsi_uSocket *ptrStrApi)
+{
+
+  uint16 socket_descriptor = 0;
+
+  //! Get IP version
+  uint16 ip_version = rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.ip_version);
+
+  //! Get socket descriptor
+  socket_descriptor  = rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketDescriptor);
+  //! ip version
+  memcpy((uint8 *)rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].ip_version, rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.ip_version, 2);
+  //! socket descriptor
+  memcpy((uint8 *)rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].socketDescriptor, rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketDescriptor, 2);
+  //! source port number
+  memcpy((uint8 *)rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].src_port, rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.moduleSocket, 2);
+  
+  if(ip_version == IP_VERSION_4)
+  {
+    //! detination ipv4 address
+    memcpy((uint8 *)rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].dest_ip.ipv4_address, ptrStrApi->socketFrameSnd.destIpaddr.ipv4_address, 4);
+   
+    /* Tag the socket with its protocol in the sockets array structure */
+    if (rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketType) == RSI_SOCKET_TCP_CLIENT) 
+    {
+      rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].protocol = RSI_PROTOCOL_TCP_V4;
+    }
+    else if (rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketType) == RSI_SOCKET_TCP_SERVER) 
+    {
+      rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].protocol = RSI_PROTOCOL_TCP_V4;
+    }
+    else if (rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketType) == RSI_SOCKET_UDP_CLIENT) 
+    {
+      rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].protocol = RSI_PROTOCOL_UDP_V4;
+    }
+    else if (rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketType) == RSI_SOCKET_LUDP) 
+    {
+      rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].protocol = RSI_PROTOCOL_UDP_V4;
+    } 
+  }
+  else
+  {
+    //! destination ipv6 address
+    memcpy((uint8 *)rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].dest_ip.ipv6_address, ptrStrApi->socketFrameSnd.destIpaddr.ipv6_address, 16);
+    
+    /* Tag the socket with its protocol in the sockets array structure */
+    if (rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketType) == RSI_SOCKET_TCP_CLIENT) 
+    {
+      rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].protocol = RSI_PROTOCOL_TCP_V6;
+    }
+    else if (rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketType) == RSI_SOCKET_TCP_SERVER) 
+    {
+      rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].protocol = RSI_PROTOCOL_TCP_V6;
+    }
+    else if (rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketType) == RSI_SOCKET_UDP_CLIENT) 
+    {
+      rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].protocol = RSI_PROTOCOL_UDP_V6;
+    } 
+    else if (rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv.socketType) == RSI_SOCKET_LUDP) 
+    {
+      rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].protocol = RSI_PROTOCOL_UDP_V6;
+    } 
+
+  }
+  
+  //! destination port
+  memcpy((uint8 *)rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor].dest_port, ptrStrApi->socketFrameSnd.destSocket, 2);
+}
+
+
+/*=========================================================================*/
+/**
+ * @fn          void unregister_socket_protocol(void)
+ * @brief       Unregister socket information
+ * @param[in]   none
+ * @param[out]  none
+ * @return      none
+ *          
+ * @section description 
+ * This funtion is used to delink the socket number with the protocol.
+ * It also tags the socket with its protocol. 
+ */
+void unregister_socket_protocol(void)
+{
+
+  uint16 socket_descriptor = 0;
+  socket_descriptor  = rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->uCmdRspPayLoad.socketCloseFrameRcv.socketDsc);
+  memset((uint8 *)&rsi_app_cb.socketsStrArray.socketsArray[socket_descriptor], 0, sizeof(rsi_socketsStr));
+}
+#endif
+
+/*FUNCTION*********************************************************************
+Function Name  : rs22_aToi
+Description    : This function converts the string to integer
+Returned Value : Converted integer value
+Parameters     : 
+
+-----------------+-----+-----+-----+------------------------------
+Name             | I/P | O/P | I/O | Purpose
+-----------------+-----+-----+-----+------------------------------
+src              |  X  |     |     | string to be converted to the integer
+src_len          |  X  |     |     | len of the string
+
+*END****************************************************************************/
+
+uint16 rs22_aToi(uint8 *src, uint8 src_len)
+{
+   uint16 src_index = 0;
+   uint16 temp = 0;
+   
+   for(src_index = 0; src_index < src_len; src_index++)
+   {
+      temp = temp*10;
+      temp = temp + (src[src_index] - 0x30);
+   }
+
+   return temp;
+}
+
+/*=========================================================================*/
+/**
+ * @fn          uint16 rsi_convert_ip_to_string(uint8 *num_buff, uint8 *ip_buff)
+ * @brief       converts  IP address to string
+ * @param[in]   source buffer pointer of IP address
+ * @param[in]   destination buffer pointer to store the converted IP address
+ * @return      none
+ * @section description 
+ * This function is used to convert ip address to string  
+ */
+uint16 rsi_convert_ip_to_string(uint8 *num_buff, uint8 *ip_buff)
+{
+    uint8 temp_buf[8];
+   uint8 temp_buf2[8];
+   uint16 temp;
+   uint16 num_index = 0, ip_index = 0;
+   uint16 temp_index = 0, temp_index2 = 0;
+    
+    
+   memset(ip_buff, 0, 17);
+   while (num_index < 4)
+   {
+      temp = num_buff[num_index++];
+      
+
+      do
+      {
+         temp_buf[temp_index++] = (temp%10) + '0';
+         temp = temp/10;
+         ip_index++;
+      }while(temp);
+      rsi_strrev(temp_buf, temp_buf2, temp_index);
+       rsi_strcat(temp_buf2, ip_buff + temp_index2, temp_index);
+      
+      temp_index = 0;
+        if (num_index < 4)
+           ip_buff[ip_index++] = '.';
+         temp_index2 = ip_index;
+         
+   }
+   
+   return ip_index;
+}
+
+/*=========================================================================*/
+/**
+ * @fn          uint8 rsi_strrev(void *src, void *dst,uint8 len)
+ * @brief       This API is used to reverse the given string
+ * @param[in]   source buffer pointer
+ * @param[in]   destination buffer pointer
+ * @param[in]   length of the string 
+ * @return      zero
+ * @section description 
+ * This function is used to reverse the string  
+ */
+uint8 rsi_strrev(void *src, void *dst, uint8 len)
+{
+   uint8 *dst1;
+   uint8 *src1;
+   dst1 = dst;
+   src1 = src;
+     
+   src1 = src1 + len - 1;
+     
+   while(len-- != 0)
+        *dst1++ = *src1--;
+   *dst1 = '\0';
+   return 0;
+}
+/*=========================================================================*/
+/**
+ * @fn          uint16 rsi_strcat(void *src, void *dst,uint8 len)
+ * @brief       This API is used to concatinate the two given strings
+ * @param[in]   source buffer pointer
+ * @param[in]   destination buffer pointer
+ * @param[in]   length of the string 
+ * @return      none
+ * @section description 
+ * This function is used to concatinate the source string to 
+ * destination string  
+ */
+void rsi_strcat(void *src, void *dst, uint8 len)
+{
+   uint8 *dst1;
+   uint8 *src1;
+   dst1 = dst;
+   src1 = src;
+  
+   while(len-- != 0)
+    *dst1++ = *src1++;
+   
+}
+/*=========================================================================*/
+/**
+ * @fn          uint32 parseHex(uint8 *str)
+ * @brief       This API is used tp parse the hex values to the respective decimal values
+ * @param[in]   Hex string pointer 
+ * @return      decimal value
+ * @section description 
+ * This function is used to convert the hex value to decimal value
+ */
+uint32 parseHex(uint8 *str )
+{
+    uint32 value = 0;
+    uint8 i=0;
+
+    for(i= 0 ;i <8 ; i++,++str ) 
+      switch( *str )
+    {
+        case '0': case '1': case '2': case '3': case '4':
+        case '5': case '6': case '7': case '8': case '9':
+            value = (value << 4) | (*str & 0xf);
+            break;
+        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+            value = (value << 4 | 9) + (*str & 0xf);
+            break;
+        case '\0':
+        default:
+            return value;
+    }
+   return 0;
+}
+/*=========================================================================*/
+/**
+ * @fn          void parse_ipv6_address(uint8 *v,uint8 *buf)
+ * @brief       Parse the IPV6 address
+ * @param[in]   source IPV6 buffer pointer
+ * @param[in]   destination buffer pointer
+ * @return      none
+ * @section description 
+ * This function is used to convert IPV6 Address.
+ * destination string  
+ */
+
+void parse_ipv6_address(uint8 *v, uint8 *buf)
+{
+  uint8 value = 0;
+  uint8 offset = 0;
+  uint8 index = 0;
+  uint16 buffer_offset = 0;
+  uint8 i = 0;
+  uint8 temp_buff[10];
+  uint32 v6[4] = {'\0'};
+  temp_buff[0] = '\0';
+  
+  //! Total 8 octets
+  for(index = 0; index < 8 ;index++)
+  {
+    //! each octet contains max of 5 characters including . dot
+    for(offset = 0;offset < 5 ; offset++)
+    {
+      value = buf[buffer_offset++];
+      if((value == '.') || (value == ':'))
+      {
+        break;
+      }
+      temp_buff[offset] =  value;      
+    }
+    temp_buff[offset]= '\0';
+    if(index % 2 == 0)
+    {
+      v6[index/2] = (parseHex(temp_buff) << 16);
+    }
+    else
+    {
+      v6[index/2] |= parseHex(temp_buff);
+    }
+    temp_buff[0] = '\0';
+  }
+  for(i = 0; i < 4; i++)
+  {
+    rsi_uint32_to_4bytes((v+(4*i)), v6[i]);
+  }
+
+}
+/*=========================================================================*/
+/**
+ * @fn          uint8 convert_lower_case_to_upper_case(uint8 lwrcase)
+ * @brief       Converts the lower case character to upper case
+ * @param[in]   character to convert 
+ * @return      converted character
+ * @section description 
+ * This function is used to convert the given lower case character to upper case
+ * destination string  
+ */
+uint8 convert_lower_case_to_upper_case(uint8 lwrcase)
+{
+  uint8 digit = (lwrcase >= 'a' && lwrcase <= 'f') ? (lwrcase-0x20) : lwrcase;
+  return (digit >= 'A' && digit <= 'F') ? digit - 0x37 : digit - '0';
+}
+
+void string2array(uint8 *dst, uint8 *src, uint32 length)
+{
+  int i = 0,j = 0;
+  for(i=0 ,j=0 ; i < (length * 2) && j < length; i+=2,j++)
+  {
+    if(src[i] && src[i + 1])
+    {
+      dst[j]  = ((uint16 )convert_lower_case_to_upper_case(src[i])) * 16;
+      dst[j] += convert_lower_case_to_upper_case(src[i + 1]); 
+    }
+    else
+    {
+      dst[j]  = 0;
+    }
+  }
+    
+}
+
+
+/*=========================================================================*/
+/**
+ * @fn          void rsi_itoa( uint32 val, uint8 *str)
+ * @brief       Converts string to array
+ * @param[in]   Pointer to destination array
+ * @return      Pointer to source string
+ * @section description 
+ * This function is used to convert the given string to 
+ * destination array
+ */
+uint8* rsi_itoa(uint32 val, uint8 *str)
+{
+  int16  ii = 0, jj = 0;
+  uint8  tmp[10];
+  if(val ==0)
+  {
+    //! if value is zero then handling
+    str[jj] = '0';
+    jj++;
+    str[jj]='\0';
+    return str;
+  }
+
+  while( val)
+  {
+    tmp[ii] = '0' + (val % 10);
+    val /= 10;
+    ii++;
+  }
+
+  for( jj = 0, ii--; ii >= 0; ii--, jj++)
+  {
+    str[jj] = tmp[ii];
+  }
+  str[jj]='\0';
+
+  return str;
+}
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/src/rsi_buildHttpExtendedHeader.c b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/src/rsi_buildHttpExtendedHeader.c
new file mode 100755
index 0000000..11e9b45
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/apis/wlan/ref_apps/src/rsi_buildHttpExtendedHeader.c
@@ -0,0 +1,56 @@
+/**
+ * @file     rsi_buildHttpExtendedHeader.c
+ * @version  2.7
+ * @date     2012-Sep-12
+ *
+ * Copyright(C) Redpine Signals 2012
+ * All rights reserved by Redpine Signals.
+ *
+ * @section License
+ * This program should be used on your own responsibility.
+ * Redpine Signals assumes no responsibility for any losses
+ * incurred by customers or third parties arising from the use of this file.
+ *
+ * @brief Extended HTTP header: Adds Extended HTTP header
+ *
+ * @section Description
+ * This file contains the Store Configuration Enable/Disable function.
+ *
+ *
+ */
+
+/**
+ * Includes
+ */
+#include <string.h>
+#include "rsi_global.h"
+
+/*==============================================*/
+/**
+ * @fn          void rsi_buildHttpExtendedHeader(uint8 *http_header, uint8 delimiter_mode)
+ * @brief       User configurable Extended http header 
+ * @param[in]   uint8 uint8 *http_header
+ * @param[in]   uint8 delimiter_mode mode of delimiter
+ * @param[out]  none
+  *
+ * @section description
+  * To build the user configurable http header.user can add http header fields.
+ */
+
+void rsi_buildHttpExtendedHeader(uint8 *http_header, uint8 delimiter_mode)
+{
+
+  if(delimiter_mode)
+  {
+    strcpy((char *)http_header ,"User-Agent: curl/7.30.0\r\n");
+  }
+  else
+  {
+    strcat((char *)http_header ,"User-Agent: curl/7.30.0\r\n");
+  }
+  strcat((char *)http_header ,"Accept: */*\r\n");
+  strcat((char *)http_header ,"Content-Type: application/x-www-form-urlencoded\r\n");
+
+}
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_apis.c b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_apis.c
new file mode 100755
index 0000000..1aadd53
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_apis.c
@@ -0,0 +1,65 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_apis.c                                                  */
+/*   WLAN APIS処理                                                  */
+/*                                                                  */
+/*   2016/12/15 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#include "wmrp10_rsi.h"
+#include "wmrp10_os.h"
+#include "wmrp10_bt_rsi.h"
+#include "wmrp10_bt_os.h"
+#include "wmrp10_ble_rsi.h"
+#include "wmrp10_ble_os.h"
+#include "wmrp10_apis.h"
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_apis_init()                                              */
+/*      初期化処理                                                  */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_apis_init(void)
+{
+    int16 ret;
+    int16 retval = WMRP10_ERR_SUCCESS;
+    
+    ret = wmrp10_os_init();                             /* OS初期化 */
+    ret = wmrp10_os_bt_init();                             /* OS初期化 */
+    ret = wmrp10_os_ble_init();                             /* OS初期化 */
+    if(ret != WMRP10_ERR_SUCCESS)
+    {
+        retval = WMRP10_ERR_ABORT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_apis_exit()                                              */
+/*      終了処理                                                    */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_apis_exit(void)
+{
+    int16 ret;
+    int16 retval = WMRP10_ERR_SUCCESS;
+    
+    ret = wmrp10_os_exit();                               /* OS終了 */
+    ret = wmrp10_os_bt_exit();                               /* OS終了 */
+    ret = wmrp10_os_ble_exit();                               /* OS終了 */
+    if(ret != WMRP10_ERR_SUCCESS)
+    {
+        retval = WMRP10_ERR_ABORT;
+    }
+    return retval;
+
+}
+
+
+/* End of File */
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_apis.h b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_apis.h
new file mode 100755
index 0000000..4bf9315
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_apis.h
@@ -0,0 +1,20 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_apis.h                                                  */
+/*   WLAN APIS処理                                                  */
+/*                                                                  */
+/*   2016/12/15 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#ifndef _WMRP10_APIS_H_
+#define _WMRP10_APIS_H_
+
+#include "wmrp10_rsi.h"
+
+int16 wmrp10_apis_init(void);
+int16 wmrp10_apis_exit(void);
+
+
+#endif /* _WMRP10_APIS_H_ */
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_os.c b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_os.c
new file mode 100755
index 0000000..7902dcb
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_os.c
@@ -0,0 +1,335 @@
+﻿/********************************************************************/
+/*                                                                  */
+/*   wmrp10_ble_os.c                                                */
+/*   BLE OS依存部                                                   */
+/*                                                                  */
+/*   2019/07/19 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/ieee80211.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <linux/spi/spi.h>
+#include <linux/semaphore.h>
+#include <linux/etherdevice.h>
+#include <linux/gpio.h>
+
+#include "rsi_app.h"
+#include "rsi_app_util.h"
+#include "rsi_api.h"
+#include "rsi_ble_api.h"
+#include "rsi_ble_global.h"
+#include "wmrp10.h"
+#include "wmrp10_os.h"
+#include "wmrp10_rsi.h"
+#include "wmrp10_ble_os.h"
+#include "wmrp10_ble_rsi.h"
+#include "wmrp10_err.h"
+
+#include "rsi_api.h"
+#include "rsi_ble_api.h"
+
+#define WMRP10_GPIO_POWER    0x3C0
+#define WMRP10_GPIO_RESET    0x36D
+
+/* 制御用パラメータの構造体定義 */
+struct wmrp10_ble_os_param
+{
+    struct semaphore sema_spi;
+    struct semaphore sema_cmd;
+    
+    struct completion comp_rsp_cmd;
+};
+
+/* レスポンス情報の構造体定義 */
+struct wmrp10_ble_os_res
+{
+    UINT16 size;
+    UINT8 trigger_auto_flg;
+    RSI_BLE_RESPONSE response;
+};
+
+/* イベント情報の構造体定義 */
+struct wmrp10_ble_os_event
+{
+    UINT16 size;
+    T_WMRP10_BLE_EVENT event;
+};
+
+static struct wmrp10_ble_os_param g_wmrp10_ble_os_prm;
+static struct wmrp10_ble_os_res g_wmrp10_ble_os_rsp;
+static struct wmrp10_ble_os_event g_wmrp10_ble_os_event[BLE_EVENT_MAX];
+static int g_wmrp10_ble_os_init_flg = 0;
+
+extern struct spi_device *g_wmrp_spi;
+
+static int16 wmrp10_ble_os_wait_rsp(uint16 *wait_type,
+                                uint16 type_len,
+                                uint16 *res_type,
+                                uint8 *tri_auto_flg,
+                                rsi_uCmdRsp **uCmdRspFrame,
+                                uint16 *err_code,
+                                int32 timeout);
+
+static volatile UINT08 ble_num_event;                  /* イベント数 */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_ble_init()                                            */
+/*      OSの初期化                                                  */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_ble_init(void)
+{
+    if(g_wmrp10_ble_os_init_flg == 0)
+    {
+        /* 初回のみ実行 */
+        sema_init(&(g_wmrp10_ble_os_prm.sema_spi), 1);
+        sema_init(&(g_wmrp10_ble_os_prm.sema_cmd), 1);
+        init_completion(&(g_wmrp10_ble_os_prm.comp_rsp_cmd));
+        g_wmrp10_ble_os_init_flg = 1;
+    }
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_ble_exit()                                            */
+/*      OSの終了処理                                                */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_ble_exit(void)
+{
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_ble_os_spi_lock()                                        */
+/*      SPIの排他制御(セマフォ資源獲得)                                */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_ble_os_spi_lock(void)
+{
+    down(&(g_wmrp10_ble_os_prm.sema_spi));
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_ble_os_spi_unlock()                                          */
+/*      SPIの排他制御(セマフォ資源返却)                                */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_ble_os_spi_unlock(void)
+{
+    up(&(g_wmrp10_ble_os_prm.sema_spi));
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_ble_os_cmd_lock()                                       */
+/*      コマンドの排他制御(セマフォ資源獲得)                            */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_ble_os_cmd_lock(void)
+{
+    down(&(g_wmrp10_ble_os_prm.sema_cmd));
+    g_wmrp10_ble_os_prm.comp_rsp_cmd.done = 0;  /* Waitクリア */
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_ble_os_cmd_unlock()                                      */
+/*      コマンドの排他制御(セマフォ資源返却)                            */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_ble_os_cmd_unlock(void)
+{
+    up(&(g_wmrp10_ble_os_prm.sema_cmd));
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_fr_ble_cmd()                                          */
+/*      コマンドのレスポンス処理                                       */
+/*      input   :  rsp                 レスポンス                    */
+/*      return  :  0                   成功                         */
+/*              :  < 0                 失敗                         */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_fr_ble_cmd(RSI_BLE_RESPONSE *rsp, UINT08 trigger_auto_flg)
+{
+    g_wmrp10_ble_os_rsp.size = sizeof(rsi_uCmdRsp);
+    g_wmrp10_ble_os_rsp.trigger_auto_flg = trigger_auto_flg;
+    memcpy(&g_wmrp10_ble_os_rsp.response, rsp, sizeof(rsi_uCmdRsp));
+    
+    complete(&(g_wmrp10_ble_os_prm.comp_rsp_cmd));
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_fr_ble_event()                                        */
+/*      イベント処理                                                  */
+/*      input   :  read_packet_buffer  リードバッファ                  */
+/*              :  rsp                 レスポンス                    */
+/*      return  :  0                   成功                         */
+/*              :  < 0                 失敗                         */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_fr_ble_event(UINT08 *read_packet_buffer, RSI_BLE_RESPONSE *rsp)
+{
+    UINT08 rx_bytes[2];
+    
+    rx_bytes[0] = read_packet_buffer[0];
+    rx_bytes[1] = (UINT08)(read_packet_buffer[1] & 0x0F);
+    g_wmrp10_ble_os_event[ble_num_event].size = (UINT16)rx_bytes[0] + ((UINT16)rx_bytes[1] << 8);
+    g_wmrp10_ble_os_event[ble_num_event].event.response_type = rsi_bytes2R_to_uint16(rsp->ResponseCode);
+    g_wmrp10_ble_os_event[ble_num_event].event.err_code      = rsi_bytes2R_to_uint16(rsp->Status);
+    memcpy(&g_wmrp10_ble_os_event[ble_num_event].event.event.uCmdRspBuf,
+           rsp->uCmdRspPayLoad.uCmdRspBuf,
+           g_wmrp10_ble_os_event[ble_num_event].size);
+
+    complete(&(g_wmrp10_ble_os_prm.comp_rsp_cmd));
+    
+    if(ble_num_event < BLE_EVENT_MAX -1 )
+    {
+        ble_num_event++;
+    }
+    else
+    {
+        ble_num_event=0;
+    }
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_ble_cmd()                                         */
+/*      レスポンスを待つ                                              */
+/*      input   :  wait_type   待つレスポンスID                       */
+/*              :  type_len    待ちレスポンスの数                     */
+/*              :  res_type    レスポンスID格納先アドレス              */
+/*              :  uCmdRspPtr  レスポンスアドレスの格納先アドレス        */
+/*              :  err_code    エラーコード格納先アドレス               */
+/*              :  timeout     タイムアウト値(-1:FEVER)                */
+/*      return  :  0           成功                                 */
+/*              :  < 0         失敗                                 */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_rsp_ble_cmd(UINT16 *wait_type,
+                            UINT16 type_len,
+                            UINT16 *res_type,
+                            RSI_BLE_RESPONSE **uCmdRspPtr,
+                            UINT16 *err_code,
+                            INT32 timeout)
+{
+    INT16 retval = WMRP10_ERR_SUCCESS;
+    UINT16 type_index;
+    UINT16 type_flg;
+    INT16 ret;
+    
+    /* レスポンス待ち */
+    ret = wait_for_completion_timeout(&(g_wmrp10_ble_os_prm.comp_rsp_cmd),
+                                      timeout * HZ / 1000);
+    if(ret < 0)
+    {
+        retval = WMRP10_ERR_TIMEOUT;
+    }
+    
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        /* レスポンスを受信 */
+        *uCmdRspPtr = &g_wmrp10_ble_os_rsp.response;
+        *err_code = rsi_bytes2R_to_uint16((*uCmdRspPtr)->Status);
+        *res_type = rsi_bytes2R_to_uint16((*uCmdRspPtr)->ResponseCode);
+        
+        /* 待ちレスポンスIDの確認 */
+        retval = WMRP10_ERR_ABORT;
+        for(type_index = 0; type_index < type_len; type_index++)
+        {
+            if(*res_type == wait_type[type_index])
+            {
+                if(*err_code == 0x0000)
+                {
+                    retval = WMRP10_ERR_SUCCESS;
+                }
+                else
+                {
+                    retval = WMRP10_ERR_CMD;/* IDは正しいがエラー発生 */
+                }
+                break;
+            }
+        }
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_ble_event()                                           */
+/*      イベントを待つ                                                */
+/*      input   :  event      イベント格納先アドレス                    */
+/*              :  num_event  イベント数の格納先アドレス                */
+/*              :  timeout    タイムアウト値(-1:FEVER, 0:Poll)         */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_ble_event(T_WMRP10_BLE_EVENT *event, INT32 timeout)
+{
+    INT16 retval = WMRP10_ERR_NON_RECV;
+    UINT32 time_end;
+    static UINT08 num_event=0;
+    
+    if(num_event == ble_num_event)
+    {
+        retval = wait_for_completion_timeout(&(g_wmrp10_ble_os_prm.comp_rsp_cmd),
+                                             timeout * HZ / 1000);
+        
+        if(retval < 0)
+        {
+            retval = WMRP10_ERR_TIMEOUT;
+        }
+    }
+    else
+    {
+        retval = WMRP10_ERR_SUCCESS;
+    }
+    
+    
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy(event,&g_wmrp10_ble_os_event[num_event].event,
+               (g_wmrp10_ble_os_event[num_event].size + 4));
+        
+        /* 取り出した分はフラッシュ */
+        memset(&g_wmrp10_ble_os_event[num_event].event,0,
+               (g_wmrp10_ble_os_event[num_event].size + 4));
+        g_wmrp10_ble_os_event[num_event].size = 0;
+        if(num_event < BLE_EVENT_MAX -1 )
+        {
+            num_event++;
+        }
+        else
+        {
+            num_event = 0;
+        }
+        
+    }
+    
+    return retval;
+}
+
+/* End of File */
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_os.h b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_os.h
new file mode 100755
index 0000000..efa7918
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_os.h
@@ -0,0 +1,45 @@
+﻿/********************************************************************/
+/*                                                                  */
+/*   wmrp10_ble_os.h                                                */
+/*   BLEコマンド                                                    */
+/*                                                                  */
+/*   2019/05/17 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#ifndef _WMRP10_BLE_OS_H_
+#define _WMRP10_BLE_OS_H_
+
+#include "rsi_ble_global.h"
+#include "wmrp10_ble_rsi.h"
+
+/***** 初期化 *****/
+INT16 wmrp10_os_ble_init(void);
+
+/***** 終了処理 *****/
+INT16 wmrp10_os_ble_exit(void);
+
+/***** 排他制御 *****/
+int16 wmrp10_ble_os_spi_lock(void);
+int16 wmrp10_ble_os_spi_unlock(void);
+int16 wmrp10_ble_os_cmd_lock(void);
+int16 wmrp10_ble_os_cmd_unlock(void);
+
+/***** 受信したものを振り分ける *****/
+INT16 wmrp10_os_fr_ble_cmd(RSI_BLE_RESPONSE *rsp, UINT08 trigger_auto_flg);
+INT16 wmrp10_os_fr_ble_event(UINT08 *read_packet_buffer, RSI_BLE_RESPONSE *rsp);
+
+/***** レスポンスを受ける *****/
+INT16 wmrp10_os_rsp_ble_cmd(UINT16 *wait_type,
+                            UINT16 type_len,
+                            UINT16 *res_type,
+                            RSI_BLE_RESPONSE **uCmdRspPtr,
+                            UINT16 *err_code,
+                            INT32 timeout);
+
+/***** イベントを待つ *****/
+INT16 wmrp10_os_ble_event(T_WMRP10_BLE_EVENT *event, INT32 timeout);
+
+#endif /* _WMRP10_BLE_OS_H_ */
+
+/* End of File */
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_rsi.c b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_rsi.c
new file mode 100755
index 0000000..7544684
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_rsi.c
@@ -0,0 +1,1710 @@
+﻿/********************************************************************/
+/*                                                                  */
+/*   wmrp10_ble_rsi.c                                               */
+/*   BLEコマンド                                                    */
+/*                                                                  */
+/*   2019/07/09 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#include "wmrp10_err.h"
+#include "wmrp10_os.h"
+#include "wmrp10_bt_rsi.h"
+#include "wmrp10_bt_os.h"
+#include "wmrp10_ble_rsi.h"
+#include "wmrp10_ble_os.h"
+#include "rsi_bt_api.h"
+#include "rsi_ble_api.h"
+
+extern rsi_app_cb_t rsi_app_cb;
+extern unsigned char wmrp10_rsicmd_flg;
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_frame_read()                                     */
+/*      レスポンスまたはイベントを受信して仕分ける。                       */
+/*      input   :  なし                                             */
+/*      return  :  WMRP10_ERR_SUCCESS   成功                        */
+/*              :  その他               失敗                        */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_frame_read(void)
+{
+    INT16  ret;
+    INT16  retval = WMRP10_ERR_NON_RECV;
+    INT16  os_retval;
+    UINT16 response_type;
+    UINT08 int_status = 0;
+    UINT08 trigger_auto_flg;
+    UINT08 bt_flg;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    
+    rsi_device_interrupt_status(&int_status);
+    if(int_status & 0x08)
+    {
+        ret = rsi_frame_read(rsi_app_cb.read_packet_buffer);
+        if(ret == RSI_SUCCESS)
+        {
+            trigger_auto_flg = rsi_app_cb.read_packet_buffer[15];
+            bt_flg           = (rsi_app_cb.read_packet_buffer[1] & 0x20) >> 5;
+            
+            /********** WLAN mode **********/
+            if(bt_flg == 0)
+            {
+                rsi_app_cb.uCmdRspFrame = wmrp10_rsi_parse_response(rsi_app_cb.read_packet_buffer);
+                response_type = rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->rspCode);
+                switch(response_type)
+                {
+                    /***** レスポンス *****/
+                    case RSI_RSP_OPERMODE:             /* rsi_oper_mode */
+                    case RSI_RSP_BAND:                      /* rsi_band */
+                    case RSI_RSP_INIT:                      /* rsi_init */
+                    case RSI_RSP_SCAN:                      /* rsi_scan */
+                    case RSI_RSP_PWRMODE:             /* rsi_power_mode */
+                    case RSI_RSP_SLEEP_TIMER:        /* rsi_sleep_timer */
+                    case RSI_RSP_MACADDRESS_SET:    /* rsi_set_mac_addr */
+                    case RSI_RSP_NETWORK_PARAMS: /* rsi_query_net_parms */
+                    case RSI_RSP_DISCONNECT:          /* rsi_disconnect */
+                    case RSI_RSP_ANTENNA_SEL:     /* rsi_select_antenna */
+                    case RSI_RSP_SET_REG_CODE:        /* rsi_set_region */
+                    case RSI_RSP_CFG_SAVE:              /* rsi_cfg_save */
+                    case RSI_RSP_CFG_ENABLE:          /* rsi_cfg_enable */
+                    case RSI_RSP_CFG_GET:                /* rsi_cfg_get */
+                    case RSI_RSP_USER_STORE_CFG:/*rsi_user_store_config */
+                    case RSI_RSP_APCONFIG:         /* rsi_set_ap_config */
+                    case RSI_RSP_SET_WEP_KEY:         /* rsi_set_wepkey */
+                    case RSI_RSP_RSSI_QUERY:          /* rsi_query_rssi */
+                    case RSI_RSP_CONNECTION_STATUS: /* rsi_query_conn_status */
+                    case RSI_RSP_FWVERSION_QUERY:/*rsi_query_fw_version */
+                    case RSI_RSP_MAC_QUERY:    /* rsi_query_mac_address */
+                    case RSI_RSP_BG_SCAN:                /* rsi_bg_scan */
+                    case RSI_RSP_AP_HT_CAPS:             /* rsi_ht_caps */
+                    case RSI_RSP_REJOIN_PARAMS:    /* rsi_rejoin_params */
+                    case RSI_RSP_WPS_METHOD:          /* rsi_wps_method */
+                    case RSI_RSP_ROAM_PARAMS:        /* rsi_roam_params */
+                    case RSI_RSP_CARD_READY:       /* rsi_select_option */
+                    case 0x91:               /* rsi_trigger_auto_config */
+                    case RSI_RSP_WMM_PS:                  /* rsi_wmm_ps */
+                    case RSI_RSP_HOST_PSK:                   /* rsi_psk */
+                    case RSI_RSP_RF_CURRENT_CONFIG:/*rsi_rf_current_config*/
+                    case RSI_RSP_SET_REG_AP:       /* rsi_set_region_ap */
+                    case 0xE9:                     /* rsi_host_rtc_time */
+                    case RSI_RSP_TIMEOUT:                /* rsi_timeout */
+                    case RSI_RSP_CONFIG:                  /* rsi_config */
+                        retval = wmrp10_os_fr_cmd(rsi_app_cb.uCmdRspFrame,
+                                                  trigger_auto_flg);
+                        break;
+                    case RSI_RSP_JOIN:                      /* rsi_join */
+                        if(wmrp10_rsicmd_flg == 0x00)
+                        {
+                            retval = wmrp10_os_fr_msg(rsi_app_cb.read_packet_buffer,
+                                                      rsi_app_cb.uCmdRspFrame);
+                        }
+                        else
+                        {
+                            retval = wmrp10_os_fr_cmd(rsi_app_cb.uCmdRspFrame,
+                                                      trigger_auto_flg);
+                            wmrp10_rsicmd_flg = 0x00;
+                        }
+                        break;
+                    /***** データ *****/
+                    case RSI_RSP_DATA_RECEIVE:
+                        retval = wmrp10_os_fr_data(rsi_app_cb.read_packet_buffer,
+                                                   rsi_app_cb.uCmdRspFrame);
+                        break;
+                    /***** 非同期メッセージ *****/
+                    case RSI_FWUP_RSP:/* Wireless Firmware Upgrade(要求) */
+                    case RSI_FWUP_OK: /* Wireless Firmware Upgrade(完了) */
+                    case RSI_RSP_MODULE_STATE:/* Asynchronous message for connection state notification */
+                    case RSI_RSP_CLIENT_CONNECTED:/* Station connect indication in AP mode */
+                    case RSI_RSP_CLIENT_DISCONNECTED:/* Station disconnect indication in AP mode */
+                        retval = wmrp10_os_fr_msg(rsi_app_cb.read_packet_buffer,
+                                                  rsi_app_cb.uCmdRspFrame);
+                        break;
+                    default:
+                        retval = WMRP10_ERR_ABORT;
+                        break;
+                }
+            }
+            /********** BLE mode **********/
+            else
+            {
+                uCmdRspPtr = (RSI_BLE_RESPONSE *)wmrp10_rsi_bt_parse_response(rsi_app_cb.read_packet_buffer);
+                response_type = rsi_bytes2R_to_uint16(uCmdRspPtr->ResponseCode);
+                switch(response_type)
+                {
+                    /***** レスポンス *****/
+                    case RSI_BT_RSP_CARD_READY:
+                    case RSI_BT_RSP_SET_LOCAL_NAME:
+                    case RSI_BT_RSP_QUERY_LOCAL_NAME:
+                    case RSI_BT_RSP_QUERY_RSSI:
+                    case RSI_BT_RSP_QUERY_LOCAL_BD_ADDRESS:
+                        retval = wmrp10_os_fr_bt_cmd((RSI_BT_RESPONSE *)uCmdRspPtr,
+                                                      trigger_auto_flg);
+                        break;
+                    case RSI_BLE_RSP_ADVERTISE:
+                    case RSI_BLE_RSP_SCAN:
+                    case RSI_BLE_RSP_CONNECT:
+                    case RSI_BLE_RSP_DISCONNECT:
+                    case RSI_BLE_RSP_QUERY_DEVICE_STATE:
+                    case RSI_BLE_RSP_START_ENCRYPTION:
+                    case RSI_BLE_RSP_SMP_PAIR_REQUEST:
+                    case RSI_BLE_RSP_SMP_RESPONSE:
+                    case RSI_BLE_RSP_SMP_PASSKEY:
+                    case RSI_BLE_RSP_QUERY_PROFILES_LIST:
+                    case RSI_BLE_RSP_QUERY_PROFILE:
+                    case RSI_BLE_RSP_QUERY_CHARACTERISTIC_SERVICES:
+                    case RSI_BLE_RSP_QUERY_INCLUDE_SERVICES:
+                    case RSI_BLE_RSP_READ_CHAR_VALUE_BY_UUID:
+                    case RSI_BLE_RSP_QUERY_ATT_DESC:
+                    case RSI_BLE_RSP_QUERY_ATT_VALUE:
+                    case RSI_BLE_RSP_QUERY_MULTIPLE_ATT_VALUES:
+                    case RSI_BLE_RSP_QUERY_LONG_ATT_VALUE:
+                    case RSI_BLE_RSP_SET_ATT_VALUE:
+                    case RSI_BLE_RSP_SET_LONG_ATT_VALUE:
+                    case RSI_BLE_RSP_SET_PREPARE_LONG_ATT_VALUE:
+                    case RSI_BLE_RSP_EXECUTE_LONG_ATT_VALUE_WRITE:
+                    case RSI_BLE_RSP_ANTENNA_SELECT:
+                    case RSI_BLE_RSP_CONFIG_ENABLE:
+                    case RSI_BLE_RSP_LINKKEY_REPLY:
+                    case RSI_BLE_RSP_ADD_SERVICE:
+                    case RSI_BLE_RSP_ADD_ATTRIBUTE:
+                    case RSI_BLE_RSP_SET_LOCAL_ATT_VALUE:
+                    case RSI_BLE_RSP_GET_LOCAL_ATT_VALUE:
+                    case RSI_BLE_RSP_SET_ADVERTISE_DATA:
+                    case RSI_BLE_RSP_GET_LE_PING_TIMEOUT:
+                    case RSI_BLE_RSP_SET_LE_PING_TIMEOUT:
+                    case 0x00A3:                 /* Set Random Address */
+                    case RSI_BLE_RSP_ANTENNA_TX_POWER_LEVEL:
+                        retval = wmrp10_os_fr_ble_cmd((RSI_BLE_RESPONSE *)uCmdRspPtr,
+                                                      trigger_auto_flg);
+                        break;
+                    /***** イベント *****/
+                    case RSI_BT_EVT_DISCONNECTED:
+                    case RSI_BLE_EVENT_ADVERTISE_REPORT:
+                    case RSI_BLE_EVENT_CONNECTION_STATUS:
+                    case RSI_BLE_EVENT_SMP_REQUEST:
+                    case RSI_BLE_EVENT_SMP_RESPONSE:
+                    case RSI_BLE_EVENT_SMP_PASSKEY:
+                    case RSI_BLE_EVENT_SMP_FAILED:
+                    case RSI_BLE_EVENT_GATT_NOTIFICATION:
+                    case RSI_BLE_EVENT_GATT_INDICATION:
+                    case RSI_BLE_EVENT_ENCRYPT_ENABLED:
+                    case RSI_BLE_EVENT_GATT_WRITE_VALUE:
+                    case RSI_BLE_EVENT_MTU_SIZE_VALUE:
+                    case RSI_BLE_EVENT_PXPR_LINK_LOSS_ALERT:
+                    case RSI_BLE_EVENT_PXPR_IMMEDIATE_ALERT:
+                    case RSI_BLE_EVENT_PXPR_LINK_IS_LOST:
+                        retval = wmrp10_os_fr_ble_event(rsi_app_cb.read_packet_buffer,
+                                                        uCmdRspPtr);
+                        break;
+                    default:
+                        retval = WMRP10_ERR_ABORT;
+                        break;
+                }
+            }
+        }
+        else
+        {
+            /* frame readが失敗するとここに来る */
+            retval = WMRP10_ERR_ABORT;
+        }
+    }
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_advertise()                                      */
+/*      Advertise Local Deviceコマンドを発行しレスポンスを待つ      */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_advertise(RSI_BLE_CMD_ADVERTISE *req,
+                               UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_advertise(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_ADVERTISE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_scan()                                           */
+/*      Scanコマンドを発行しレスポンスを待つ                        */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_scan(RSI_BLE_CMD_SCAN *req, UINT16 *err_code,
+                          INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_scan(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_SCAN;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_connect()                                        */
+/*      Connectコマンドを発行しレスポンスを待つ                     */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_connect(RSI_BLE_CMD_CONNECT *req, UINT16 *err_code,
+                             INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_connect(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_CONNECT;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_disconnect()                                     */
+/*      Disconnectコマンドを発行しレスポンスを待つ                  */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_disconnect(RSI_BLE_CMD_DISCONNECT *req,
+                                UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_disconnect(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_DISCONNECT;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_query_device_state()                             */
+/*      Query Device Stateコマンドを発行しレスポンスを待つ          */
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_query_device_state(RSI_BLE_RESP_QUERY_DEVICE_STATE *rsp,
+                                        UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_query_device_state();
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_QUERY_DEVICE_STATE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryDevState;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_start_encryption()                               */
+/*      Start Encryptionコマンドを発行しレスポンスを待つ            */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_start_encryption(RSI_BLE_CMD_ENCRYPTTION *req,
+                                      UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_start_encryption(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_START_ENCRYPTION;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_smp_pair_request()                               */
+/*      SMP Pair Requestコマンドを発行しレスポンスを待つ            */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_smp_pair_request(RSI_BLE_CMD_SMP_PAIR_REQUEST *req,
+                                      UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_smp_pair_request(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_SMP_PAIR_REQUEST;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_smp_response()                                   */
+/*      SMP Responseコマンドを発行しレスポンスを待つ                */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_smp_response(RSI_BLE_CMD_SMP_RESPONSE *req,
+                                  UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_smp_response(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_SMP_RESPONSE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_smp_passkey()                                    */
+/*      SMP Passkeyコマンドを発行しレスポンスを待つ                 */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_smp_passkey(RSI_BLE_CMD_SMP_PASSKEY *req,
+                                 UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_smp_passkey(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_SMP_PASSKEY;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_set_advertise_data()                             */
+/*      BLE Set Advertise Dataコマンドを発行しレスポンスを待つ      */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_set_advertise_data(RSI_BLE_CMD_SET_ADVERTISE_DATA *req,
+                                        UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_set_advertise_data(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_SET_ADVERTISE_DATA;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_set_random_address()                             */
+/*      BLE Set Random Addressコマンドを発行しレスポンスを待つ      */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_set_random_address(RSI_BLE_CMD_SET_RANDOM_ADDRESS *req,
+                                        UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_set_random_address(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = 0x00A3;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_query_profiles_list()                            */
+/*      Query profiles listコマンドを発行しレスポンスを待つ         */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_query_profiles_list(RSI_BLE_CMD_PROFILE_LIST *req,
+                                         RSI_BLE_RESP_QUERY_PROFILES_LIST *rsp,
+                                         UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_query_profiles_list(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_QUERY_PROFILES_LIST;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryProfList;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_query_profile()                                  */
+/*      Query Profileコマンドを発行しレスポンスを待つ               */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_query_profile(RSI_BLE_CMD_QUERY_PROFILE *req,
+                                   RSI_BLE_RESP_QUERY_PROFILE_DESCRIPTOR *rsp,
+                                   UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_query_profile(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_QUERY_PROFILE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryProf;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_query_characteristic_services()                  */
+/*      Query Characteristic Servicesコマンドを発行しレスポンスを待つ*/
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_query_characteristic_services(RSI_BLE_CMD_QUERY_CHARACTERISTIC_SERVICES *req,
+                                                   RSI_BLE_RESP_QUERY_CHARACTERISTIC_SERVICES *rsp,
+                                                   UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_query_characteristic_services(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_QUERY_CHARACTERISTIC_SERVICES;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryCharServ;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_query_include_service()                          */
+/*      Query Include Servicesコマンドを発行しレスポンスを待つ      */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_query_include_service(RSI_BLE_CMD_QUERY_INCLUDE_SERVICES *req,
+                                           RSI_BLE_RESP_QUERY_INCLUDE_SERVICE *rsp,
+                                           UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_query_include_service(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_QUERY_INCLUDE_SERVICES;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryIncServ;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_read_char_value_by_UUID()                        */
+/*      Read Characteristic Value by UUIDコマンドを発行しレスポンスを待つ*/
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_read_char_value_by_UUID(RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID *req,
+                                             RSI_BLE_RESP_READ_CHAR_VALUE_BY_UUID *rsp,
+                                             UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_read_char_value_by_UUID(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_READ_CHAR_VALUE_BY_UUID;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryCharVal;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_query_att()                                      */
+/*      Query Attributeコマンドを発行しレスポンスを待つ             */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_query_att(RSI_BLE_CMD_QUERY_ATT_DESC *req,
+                               RSI_BLE_RESP_QUERY_ATT_DESC *rsp,
+                               UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_query_att(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_QUERY_ATT_DESC;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryDescList;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_query_att_value()                                */
+/*      Query Attribute Valueコマンドを発行しレスポンスを待つ       */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_query_att_value(RSI_BLE_CMD_QUERY_ATT_VALUE *req,
+                                     RSI_BLE_RESP_QUERY_ATT_VALUE *rsp,
+                                     UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_query_att_value(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_QUERY_ATT_VALUE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryAttVal;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_query_multi_att_values()                         */
+/*      Query Multiple Attribute Valuesコマンドを発行しレスポンスを待つ*/
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_query_multi_att_values(RSI_BLE_CMD_QUERY_MULTIPLE_ATT_VALUES *req,
+                                            RSI_BLE_RESP_QUERY_MULTIPLE_ATT_VALUES *rsp,
+                                            UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_query_multi_att_values(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_QUERY_MULTIPLE_ATT_VALUES;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryAttVals;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_query_long_att_value()                           */
+/*      Query Long Attribute Valueコマンドを発行しレスポンスを待つ  */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_query_long_att_value(RSI_BLE_CMD_QUERY_LONG_ATT_VALUE *req,
+                                          RSI_BLE_RESP_QUERY_LONG_ATT_VALUE *rsp,
+                                          UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_query_long_att_value(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_QUERY_LONG_ATT_VALUE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryLongAttVal;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_set_att_value()                                  */
+/*      Set Attribute Valueコマンドを発行しレスポンスを待つ         */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_set_att_value(RSI_BLE_CMD_SET_ATT_VALUE *req,
+                                   UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_set_att_value(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_SET_ATT_VALUE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_set_long_att_value()                             */
+/*      Set Long Attribute Valueコマンドを発行しレスポンスを待つ    */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_set_long_att_value(RSI_BLE_CMD_SET_LONG_ATT_VALUE *req,
+                                        UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_set_long_att_value(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_SET_LONG_ATT_VALUE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_set_prep_long_att_value()                        */
+/*      Set Prepare Long Attribute Valueコマンドを発行しレスポンスを待つ*/
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_set_prep_long_att_value(RSI_BLE_CMD_SET_PREPARE_LONG_ATT_VALUE *req,
+                                             UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_set_prep_long_att_value(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_SET_PREPARE_LONG_ATT_VALUE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_execute_long_att_value()                         */
+/*      Execute Long Attribute Valueコマンドを発行しレスポンスを待つ*/
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_execute_long_att_value(RSI_BLE_CMD_EXECUTE_LONG_ATT_VALUE_WRITE *req,
+                                            UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_execute_long_att_value(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_EXECUTE_LONG_ATT_VALUE_WRITE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_device_AddService()                              */
+/*      Add GATT Service Recordコマンドを発行しレスポンスを待つ     */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_device_AddService(RSI_BLE_CMD_ADD_GATT_SERVICE *req,
+                                       RSI_BLE_RESP_ADD_GATT_SERVICE *rsp,
+                                       UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_device_AddService(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_ADD_SERVICE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryAddService;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_device_AddServiceAttribute()                     */
+/*      Add Attribute Recordコマンドを発行しレスポンスを待つ        */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_device_AddServiceAttribute(RSI_BLE_CMD_ADD_GATT_ATTRIBUTE *req,
+                                                UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_device_AddServiceAttribute(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_ADD_ATTRIBUTE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_device_ChangeLocalAttValue()                     */
+/*      Set Local Attribute Valueコマンドを発行しレスポンスを待つ   */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_device_ChangeLocalAttValue(RSI_BLE_CMD_SET_LOCAL_ATT_VALUE *req,
+                                                UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_device_ChangeLocalAttValue(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_SET_LOCAL_ATT_VALUE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_device_GetLocalAttValue()                        */
+/*      Get Local Attribute Valueコマンドを発行しレスポンスを待つ   */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_device_GetLocalAttValue(RSI_BLE_CMD_GET_LOCAL_ATT_VALUE *req,
+                                             RSI_BLE_RESP_GET_LOCAL_ATT_VALUE *rsp,
+                                             UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    RSI_BLE_RESPONSE *uCmdRspPtr;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_ble_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_ble_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ble_device_GetLocalAttValue(req);
+    
+    wmrp10_ble_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_ble_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_BLE_RSP_GET_LOCAL_ATT_VALUE;
+    retval = wmrp10_os_rsp_ble_cmd(&wait_type, 1, &response_type,
+                                   &uCmdRspPtr, err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = *(RSI_BLE_RESP_GET_LOCAL_ATT_VALUE *)uCmdRspPtr->uCmdRspPayLoad.uCmdRspBuf;
+    }
+    wmrp10_ble_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ble_event()                                          */
+/*      イベントを受ける                                            */
+/*      input   :  event    イベントの格納先アドレス                */
+/*              :  num_event  イベント数の格納先アドレス            */
+/*              :  timeout  タイムアウト値(-1:FEVER, 0:Poll)        */
+/*      return  :  0        成功                                    */
+/*              :  < 0      失敗                                    */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_ble_event(T_WMRP10_BLE_EVENT *event, INT32 timeout)
+{
+    INT16 retval;
+    
+    /* イベントを受ける */
+    retval = wmrp10_os_ble_event(event, timeout);
+    
+    return retval;
+}
+
+
+/* End of File */
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_rsi.h b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_rsi.h
new file mode 100755
index 0000000..f5870e7
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_ble_rsi.h
@@ -0,0 +1,124 @@
+﻿/********************************************************************/
+/*                                                                  */
+/*   wmrp10_ble_rsi.h                                               */
+/*   BLEコマンド                                                    */
+/*                                                                  */
+/*   2019/07/09 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#ifndef _WMRP10_BLE_RSI_H_
+#define _WMRP10_BLE_RSI_H_
+
+#include "rsi_bt_generic.h"
+#include "rsi_ble_api.h"
+#include "rsi_ble_global.h"
+
+#define BLE_EVENT_MAX  100                          /* イベント最大数 */
+
+/* イベント用構造体定義 */
+typedef struct t_wmrp10_ble_event
+{
+    UINT16 response_type;
+    UINT16 err_code;
+    union
+    {
+        RSI_BLE_EVENT_DISCONNECTION_STATUS          uDiscStatus;
+        RSI_BLE_EVENT_RESP_ADVERTISE_REPORT         uAdvReport;
+        RSI_BLE_EVENT_RESP_CONNECTION_STATUS        uConnStatus;
+        RSI_BT_EVENT_SMP_REQ                        uSmpReq;
+        RSI_BT_EVENT_SMP_RESP                       uSmpResp;
+        RSI_BT_EVENT_SMP_PASSKEY                    uSmpPasskey;
+        RSI_BT_EVENT_SMP_FAILED                     uSmpFailed;
+        RSI_BLE_EVENT_MTU_SIZE	                    uMTUSize;
+        RSI_BLE_EVENT_GATT_CHAR_VALUE_NOTIFICATIONS uNotifications;
+        RSI_BLE_EVENT_GATT_CHAR_VALUE_INDICATION    uIndication;
+        RSI_BLE_EVENT_GATT_WRITE                    uWrite;
+        UINT08 uCmdRspBuf;
+    }event;
+    
+}T_WMRP10_BLE_EVENT;
+
+/***** 受信したものを振り分ける *****/
+INT16 wmrp10_rsi_ble_frame_read(void);
+
+
+/* BLE Core commands */
+INT16 wmrp10_rsi_ble_advertise(RSI_BLE_CMD_ADVERTISE *req,
+                               UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_scan(RSI_BLE_CMD_SCAN *req, UINT16 *err_code,
+                          INT32 timeout);
+INT16 wmrp10_rsi_ble_connect(RSI_BLE_CMD_CONNECT *req,
+                             UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_disconnect(RSI_BLE_CMD_DISCONNECT *req,
+                                UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_query_device_state(RSI_BLE_RESP_QUERY_DEVICE_STATE *rsp,
+                                        UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_start_encryption(RSI_BLE_CMD_ENCRYPTTION *req,
+                                      UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_smp_pair_request(RSI_BLE_CMD_SMP_PAIR_REQUEST *req,
+                                      UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_smp_response(RSI_BLE_CMD_SMP_RESPONSE *req,
+                                  UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_smp_passkey(RSI_BLE_CMD_SMP_PASSKEY *req,
+                                 UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_set_advertise_data(RSI_BLE_CMD_SET_ADVERTISE_DATA *req,
+                                        UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_set_random_address(RSI_BLE_CMD_SET_RANDOM_ADDRESS *req,
+                                        UINT16 *err_code, INT32 timeout);
+
+/* BLE GATT Profile commands */
+INT16 wmrp10_rsi_ble_query_profiles_list(RSI_BLE_CMD_PROFILE_LIST *req,
+                                         RSI_BLE_RESP_QUERY_PROFILES_LIST *rsp,
+                                         UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_query_profile(RSI_BLE_CMD_QUERY_PROFILE *req,
+                                   RSI_BLE_RESP_QUERY_PROFILE_DESCRIPTOR *rsp,
+                                   UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_query_characteristic_services(RSI_BLE_CMD_QUERY_CHARACTERISTIC_SERVICES *req,
+                                                   RSI_BLE_RESP_QUERY_CHARACTERISTIC_SERVICES *rsp,
+                                                   UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_query_include_service(RSI_BLE_CMD_QUERY_INCLUDE_SERVICES *req,
+                                           RSI_BLE_RESP_QUERY_INCLUDE_SERVICE *rsp,
+                                           UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_read_char_value_by_UUID(RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID *req,
+                                             RSI_BLE_RESP_READ_CHAR_VALUE_BY_UUID *rsp,
+                                             UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_query_att(RSI_BLE_CMD_QUERY_ATT_DESC *req,
+                               RSI_BLE_RESP_QUERY_ATT_DESC *rsp,
+                               UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_query_att_value(RSI_BLE_CMD_QUERY_ATT_VALUE *req,
+                                     RSI_BLE_RESP_QUERY_ATT_VALUE *rsp,
+                                     UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_query_multi_att_values(RSI_BLE_CMD_QUERY_MULTIPLE_ATT_VALUES *req,
+                                            RSI_BLE_RESP_QUERY_MULTIPLE_ATT_VALUES *rsp,
+                                            UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_query_long_att_value(RSI_BLE_CMD_QUERY_LONG_ATT_VALUE *req,
+                                          RSI_BLE_RESP_QUERY_LONG_ATT_VALUE *rsp,
+                                          UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_set_att_value(RSI_BLE_CMD_SET_ATT_VALUE *req,
+                                   UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_set_long_att_value(RSI_BLE_CMD_SET_LONG_ATT_VALUE *req,
+                                        UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_set_prep_long_att_value(RSI_BLE_CMD_SET_PREPARE_LONG_ATT_VALUE *req,
+                                             UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_execute_long_att_value(RSI_BLE_CMD_EXECUTE_LONG_ATT_VALUE_WRITE *req,
+                                            UINT16 *err_code, INT32 timeout);
+
+/* BLE Create New Service Commands */
+INT16 wmrp10_rsi_ble_device_AddService(RSI_BLE_CMD_ADD_GATT_SERVICE *req,
+                                       RSI_BLE_RESP_ADD_GATT_SERVICE *rsp,
+                                       UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_device_AddServiceAttribute(RSI_BLE_CMD_ADD_GATT_ATTRIBUTE *req,
+                                                UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_device_ChangeLocalAttValue(RSI_BLE_CMD_SET_LOCAL_ATT_VALUE *req,
+                                                UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_ble_device_GetLocalAttValue(RSI_BLE_CMD_GET_LOCAL_ATT_VALUE *req,
+                                             RSI_BLE_RESP_GET_LOCAL_ATT_VALUE *rsp,
+                                             UINT16 *err_code, INT32 timeout);
+
+/***** イベントを受ける *****/
+INT16 wmrp10_rsi_ble_event(T_WMRP10_BLE_EVENT *event, INT32 timeout);
+
+#endif /* _WMRP10_BLE_RSI_H_ */
+
+/* End of File */
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_os.c b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_os.c
new file mode 100755
index 0000000..509b25b
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_os.c
@@ -0,0 +1,327 @@
+﻿/********************************************************************/
+/*                                                                  */
+/*   wmrp10_bt_os.c                                                 */
+/*   BT-Classic OS依存部                                            */
+/*                                                                  */
+/*   2019/07/19 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/ieee80211.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <linux/spi/spi.h>
+#include <linux/semaphore.h>
+#include <linux/etherdevice.h>
+#include <linux/gpio.h>
+
+#include "rsi_app.h"
+#include "rsi_app_util.h"
+#include "rsi_api.h"
+#include "rsi_bt_api.h"
+#include "rsi_bt_global.h"
+#include "wmrp10.h"
+#include "wmrp10_os.h"
+#include "wmrp10_rsi.h"
+#include "wmrp10_bt_os.h"
+#include "wmrp10_bt_rsi.h"
+#include "wmrp10_err.h"
+
+#include "rsi_api.h"
+#include "rsi_bt_api.h"
+
+#define WMRP10_GPIO_POWER    0x3C0
+#define WMRP10_GPIO_RESET    0x36D
+
+/* 制御用パラメータの構造体定義 */
+struct wmrp10_bt_os_param
+{
+    struct semaphore sema_spi;
+    struct semaphore sema_cmd;
+    struct completion comp_rsp_cmd;
+};
+
+/* レスポンス情報の構造体定義 */
+struct wmrp10_bt_os_res
+{
+    UINT16 size;
+    UINT8 trigger_auto_flg;
+    RSI_BT_RESPONSE response;
+};
+
+static struct wmrp10_bt_os_param g_wmrp10_bt_os_prm;
+static struct wmrp10_bt_os_res g_wmrp10_bt_os_rsp;
+static struct wmrp10_bt_os_event g_wmrp10_bt_os_event[BT_EVENT_MAX];
+static int g_wmrp10_bt_os_init_flg = 0;
+
+extern struct spi_device *g_wmrp_spi;
+
+static int16 wmrp10_bt_os_wait_rsp(uint16 *wait_type,
+                                uint16 type_len,
+                                uint16 *res_type,
+                                uint8 *tri_auto_flg,
+                                rsi_uCmdRsp **uCmdRspFrame,
+                                uint16 *err_code,
+                                int32 timeout);
+
+static volatile UINT08 bt_num_event=0;                  /* イベント数 */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_bt_init()                                             */
+/*      OSの初期化                                                  */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_bt_init(void)
+{
+    if(g_wmrp10_bt_os_init_flg == 0)
+    {
+        /* 初回のみ実行 */
+        sema_init(&(g_wmrp10_bt_os_prm.sema_spi), 1);
+        sema_init(&(g_wmrp10_bt_os_prm.sema_cmd), 1);
+        init_completion(&(g_wmrp10_bt_os_prm.comp_rsp_cmd));
+        g_wmrp10_bt_os_init_flg = 1;
+    }
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_bt_exit()                                             */
+/*      OSの終了処理                                                */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_bt_exit(void)
+{
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_bt_os_spi_lock()                                            */
+/*      SPIの排他制御(セマフォ資源獲得)                                */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_bt_os_spi_lock(void)
+{
+    down(&(g_wmrp10_bt_os_prm.sema_spi));
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_bt_os_spi_unlock()                                          */
+/*      SPIの排他制御(セマフォ資源返却)                                */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_bt_os_spi_unlock(void)
+{
+    up(&(g_wmrp10_bt_os_prm.sema_spi));
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_bt_os_cmd_lock()                                            */
+/*      コマンドの排他制御(セマフォ資源獲得)                            */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_bt_os_cmd_lock(void)
+{
+    down(&(g_wmrp10_bt_os_prm.sema_cmd));
+    g_wmrp10_bt_os_prm.comp_rsp_cmd.done = 0;  /* Waitクリア */
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_bt_os_cmd_unlock()                                          */
+/*      コマンドの排他制御(セマフォ資源返却)                            */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_bt_os_cmd_unlock(void)
+{
+    up(&(g_wmrp10_bt_os_prm.sema_cmd));
+    return WMRP10_ERR_SUCCESS;
+}
+/*------------------------------------------------------------------*/
+/*  wmrp10_bt_os_fr_bt_cmd()                                           */
+/*      コマンドのレスポンス処理                                       */
+/*      input   :  rsp                 レスポンス                    */
+/*              :  trigger_auto_flg                                 */
+/*      return  :  0                   成功                         */
+/*              :  < 0                 失敗                         */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_fr_bt_cmd(RSI_BT_RESPONSE *rsp, UINT08 trigger_auto_flg)
+{
+    g_wmrp10_bt_os_rsp.size = sizeof(rsi_uCmdRsp);
+    g_wmrp10_bt_os_rsp.trigger_auto_flg = trigger_auto_flg;
+    memcpy(&g_wmrp10_bt_os_rsp.response, rsp, sizeof(rsi_uCmdRsp));
+    
+    complete(&(g_wmrp10_bt_os_prm.comp_rsp_cmd));
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_fr_bt_event()                                         */
+/*      イベント処理                                                  */
+/*      input   :  read_packet_buffer  リードバッファ                  */
+/*              :  rsp                 レスポンス                     */
+/*      return  :  0                   成功                         */
+/*              :  < 0                 失敗                         */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_fr_bt_event(UINT08 *read_packet_buffer, RSI_BT_RESPONSE *rsp)
+{
+    UINT08 rx_bytes[2];
+    
+    rx_bytes[0] = read_packet_buffer[0];
+    rx_bytes[1] = (UINT08)(read_packet_buffer[1] & 0x0F);
+    g_wmrp10_bt_os_event[bt_num_event].size = (UINT16)rx_bytes[0] + ((UINT16)rx_bytes[1] << 8);
+    g_wmrp10_bt_os_event[bt_num_event].event.response_type = rsi_bytes2R_to_uint16(rsp->ResponseCode);
+    g_wmrp10_bt_os_event[bt_num_event].event.err_code      = rsi_bytes2R_to_uint16(rsp->Status);
+    memcpy(&g_wmrp10_bt_os_event[bt_num_event].event.event.uCmdRspBuf,
+           rsp->uCmdRspPayLoad.uCmdRspBuf,
+           g_wmrp10_bt_os_event[bt_num_event].size);
+    complete(&(g_wmrp10_bt_os_prm.comp_rsp_cmd));
+    
+    if(bt_num_event < BT_EVENT_MAX - 1)
+    {
+        bt_num_event++;
+    }
+    else
+    {
+        bt_num_event=0;
+    }
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_bt_cmd()                                         */
+/*      レスポンスを待つ                                              */
+/*      input   :  wait_type     待つレスポンスのIDの配列             */
+/*              :  type_len      待ちレスポンスの数                   */
+/*              :  res_type      レスポンスID格納先アドレス            */
+/*              :  tri_auto_flg  Auto Ttiggerフラグ格納先アドレス      */
+/*              :  uCmdRspFrame  レスポンスアドレスの格納先アドレス      */
+/*              :  err_code      エラーコード格納先アドレス             */
+/*              :  timeout       タイムアウト値(-1:FEVER, 0:Poll)      */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_rsp_bt_cmd(UINT16 *wait_type,
+                           UINT16 type_len,
+                           UINT16 *res_type,
+                           UINT08 *tri_auto_flg,
+                           RSI_BT_RESPONSE **uCmdRspFrame,
+                           UINT16 *err_code,
+                           INT32 timeout)
+{
+    int16 retval = WMRP10_ERR_SUCCESS;
+    uint16 type_index;
+    uint16 type_flg;
+    int16 ret;
+    
+    /* レスポンス待ち */
+    ret = wait_for_completion_timeout(&(g_wmrp10_bt_os_prm.comp_rsp_cmd),
+                                      timeout * HZ / 1000);
+    if(ret < 0)
+    {
+        retval = WMRP10_ERR_TIMEOUT;
+    }
+    
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        /* レスポンスを受信 */
+        *uCmdRspFrame = &g_wmrp10_bt_os_rsp.response;
+        *err_code = rsi_bytes2R_to_uint16((*uCmdRspFrame)->Status);
+        *res_type = rsi_bytes2R_to_uint16((*uCmdRspFrame)->ResponseCode);
+        *tri_auto_flg = g_wmrp10_bt_os_rsp.trigger_auto_flg;
+        
+        /* 待ちレスポンスIDの確認 */
+        retval = WMRP10_ERR_ABORT;
+        for(type_index = 0; type_index < type_len; type_index++)
+        {
+            if(*res_type == wait_type[type_index])
+            {
+                if(*err_code == 0x0000)
+                {
+                    retval = WMRP10_ERR_SUCCESS;
+                }
+                else
+                {
+                    retval = WMRP10_ERR_CMD;/* IDは正しいがエラー発生 */
+                }
+                break;
+            }
+        }
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_bt_event()                                            */
+/*      イベントを待つ                                                 */
+/*      input   :  event      イベント格納先アドレス                    */
+/*              :  num_event  イベント数の格納先アドレス                */
+/*              :  timeout    タイムアウト値(-1:FEVER, 0:Poll)         */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_os_bt_event(T_WMRP10_BT_EVENT *event, INT32 timeout)
+{
+    INT16 retval = WMRP10_ERR_NON_RECV;
+    UINT32 time_end;
+    UINT08 i;
+    static UINT08 num_event=0;
+    
+    if(num_event == bt_num_event)
+    {
+        retval = wait_for_completion_timeout(&(g_wmrp10_bt_os_prm.comp_rsp_cmd),
+                                             timeout * HZ / 1000);
+        
+        if(retval < 0)
+        {
+            retval = WMRP10_ERR_TIMEOUT;
+        }
+    }
+    else
+    {
+        retval = WMRP10_ERR_SUCCESS;
+    }
+    
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy(event,&g_wmrp10_bt_os_event[num_event].event,
+              (g_wmrp10_bt_os_event[num_event].size + 4));
+        /* 取り出した分はフラッシュ */
+        memset(&g_wmrp10_bt_os_event[num_event].event,0,(g_wmrp10_bt_os_event[num_event].size + 4));
+        
+        if(num_event < BT_EVENT_MAX - 1)
+        {
+            num_event++;
+        }
+        else
+        {
+            num_event = 0;
+        }
+    }
+    
+    return retval;
+}
+
+/* End of File */
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_os.h b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_os.h
new file mode 100755
index 0000000..eefbb9c
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_os.h
@@ -0,0 +1,53 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_bt_os.h                                                 */
+/*   BT-Classic R}h                                            */
+/*                                                                  */
+/*   2019/05/17 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#ifndef _WMRP10_BT_OS_H_
+#define _WMRP10_BT_OS_H_
+
+#include "rsi_bt_global.h"
+#include "wmrp10_bt_rsi.h"
+
+/* Cxg̍\̒` */
+typedef struct wmrp10_bt_os_event
+{
+    UINT16 size;
+    T_WMRP10_BT_EVENT event;
+}WMRP10_BT_EVENT_PRM;
+
+/*****  *****/
+INT16 wmrp10_os_bt_init(void);
+
+/***** I *****/
+INT16 wmrp10_os_bt_exit(void);
+
+/***** r *****/
+int16 wmrp10_bt_os_spi_lock(void);
+int16 wmrp10_bt_os_spi_unlock(void);
+int16 wmrp10_bt_os_cmd_lock(void);
+int16 wmrp10_bt_os_cmd_unlock(void);
+
+/***** M̂U蕪 *****/
+INT16 wmrp10_os_fr_bt_cmd(RSI_BT_RESPONSE *rsp, UINT08 trigger_auto_flg);
+INT16 wmrp10_os_fr_bt_event(UINT08 *read_packet_buffer, RSI_BT_RESPONSE *rsp);
+
+/***** X|X󂯂 *****/
+INT16 wmrp10_os_rsp_bt_cmd(UINT16 *wait_type,
+                           UINT16 type_len,
+                           UINT16 *res_type,
+                           UINT08 *tri_auto_flg,
+                           RSI_BT_RESPONSE **uCmdRspPtr,
+                           UINT16 *err_code,
+                           INT32 timeout);
+
+/***** Cxg҂ *****/
+INT16 wmrp10_os_bt_event(T_WMRP10_BT_EVENT *event, INT32 timeout);
+
+#endif /* _WMRP10_BT_OS_H_ */
+
+/* End of File */
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_rsi.c b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_rsi.c
new file mode 100755
index 0000000..3b83a8e
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_rsi.c
@@ -0,0 +1,2363 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_bt_rsi.c                                                */
+/*   BT-Classic R}h                                            */
+/*                                                                  */
+/*   2019/05/21 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#include "wmrp10_err.h"
+#include "wmrp10_rsi.h"
+#include "wmrp10_os.h"
+#include "wmrp10_bt_rsi.h"
+#include "wmrp10_bt_os.h"
+#include "rsi_bt_api.h"
+
+extern rsi_app_cb_t rsi_app_cb;
+extern unsigned char wmrp10_rsicmd_flg;
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_frame_read()                                      */
+/*      X|X܂̓f[^܂̓bZ[WMĎdB  */
+/*      input   :  Ȃ                                             */
+/*      return  :  WMRP10_ERR_SUCCESS                           */
+/*              :  ̑               s                        */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_frame_read(void)
+{
+    INT16  ret;
+    INT16  retval = WMRP10_ERR_NON_RECV;
+    INT16  os_retval;
+    UINT16 response_type;
+    UINT08 int_status = 0;
+    UINT08 trigger_auto_flg;
+    UINT08 bt_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        printk("spi_lock_err\n");
+        return os_retval;
+    }
+    
+    rsi_device_interrupt_status(&int_status);
+    if(int_status & 0x08)
+    {
+        ret = rsi_frame_read(rsi_app_cb.read_packet_buffer);
+        if(ret == RSI_SUCCESS)
+        {
+            trigger_auto_flg = rsi_app_cb.read_packet_buffer[15];
+            bt_flg           = (rsi_app_cb.read_packet_buffer[1] & 0x20) >> 5;
+            
+            /********** WLAN mode **********/
+            if(bt_flg == 0)
+            {
+                rsi_app_cb.uCmdRspFrame = wmrp10_rsi_parse_response(rsi_app_cb.read_packet_buffer);
+                response_type = rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->rspCode);
+                switch(response_type)
+                {
+                    /***** X|X *****/
+                    case RSI_RSP_OPERMODE:             /* rsi_oper_mode */
+                    case RSI_RSP_BAND:                      /* rsi_band */
+                    case RSI_RSP_INIT:                      /* rsi_init */
+                    case RSI_RSP_SCAN:                      /* rsi_scan */
+                    case RSI_RSP_PWRMODE:             /* rsi_power_mode */
+                    case RSI_RSP_SLEEP_TIMER:        /* rsi_sleep_timer */
+                    case RSI_RSP_MACADDRESS_SET:    /* rsi_set_mac_addr */
+                    case RSI_RSP_NETWORK_PARAMS: /* rsi_query_net_parms */
+                    case RSI_RSP_DISCONNECT:          /* rsi_disconnect */
+                    case RSI_RSP_ANTENNA_SEL:     /* rsi_select_antenna */
+                    case RSI_RSP_SET_REG_CODE:        /* rsi_set_region */
+                    case RSI_RSP_CFG_SAVE:              /* rsi_cfg_save */
+                    case RSI_RSP_CFG_ENABLE:          /* rsi_cfg_enable */
+                    case RSI_RSP_CFG_GET:                /* rsi_cfg_get */
+                    case RSI_RSP_USER_STORE_CFG:/*rsi_user_store_config */
+                    case RSI_RSP_APCONFIG:         /* rsi_set_ap_config */
+                    case RSI_RSP_SET_WEP_KEY:         /* rsi_set_wepkey */
+                    case RSI_RSP_RSSI_QUERY:          /* rsi_query_rssi */
+                    case RSI_RSP_CONNECTION_STATUS: /* rsi_query_conn_status */
+                    case RSI_RSP_FWVERSION_QUERY:/*rsi_query_fw_version */
+                    case RSI_RSP_MAC_QUERY:    /* rsi_query_mac_address */
+                    case RSI_RSP_BG_SCAN:                /* rsi_bg_scan */
+                    case RSI_RSP_AP_HT_CAPS:             /* rsi_ht_caps */
+                    case RSI_RSP_REJOIN_PARAMS:    /* rsi_rejoin_params */
+                    case RSI_RSP_WPS_METHOD:          /* rsi_wps_method */
+                    case RSI_RSP_ROAM_PARAMS:        /* rsi_roam_params */
+                    case RSI_RSP_CARD_READY:       /* rsi_select_option */
+                    case 0x91:               /* rsi_trigger_auto_config */
+                    case RSI_RSP_WMM_PS:                  /* rsi_wmm_ps */
+                    case RSI_RSP_HOST_PSK:                   /* rsi_psk */
+                    case RSI_RSP_RF_CURRENT_CONFIG:/*rsi_rf_current_config*/
+                    case RSI_RSP_SET_REG_AP:       /* rsi_set_region_ap */
+                    case 0xE9:                     /* rsi_host_rtc_time */
+                    case RSI_RSP_TIMEOUT:                /* rsi_timeout */
+                    case RSI_RSP_CONFIG:                  /* rsi_config */
+                        retval = wmrp10_os_fr_cmd(rsi_app_cb.uCmdRspFrame,
+                                                  trigger_auto_flg);
+                        break;
+                    case RSI_RSP_JOIN:                      /* rsi_join */
+                        if(wmrp10_rsicmd_flg == 0x00)
+                        {
+                            retval = wmrp10_os_fr_msg(rsi_app_cb.read_packet_buffer,
+                                                      rsi_app_cb.uCmdRspFrame);
+                        }
+                        else
+                        {
+                            retval = wmrp10_os_fr_cmd(rsi_app_cb.uCmdRspFrame,
+                                                      trigger_auto_flg);
+                            wmrp10_rsicmd_flg = 0x00;
+                        }
+                        break;
+                    /***** f[^ *****/
+                    case RSI_RSP_DATA_RECEIVE:
+                        retval = wmrp10_os_fr_data(rsi_app_cb.read_packet_buffer,
+                                                   rsi_app_cb.uCmdRspFrame);
+                        break;
+                    /***** 񓯊bZ[W *****/
+                    case RSI_FWUP_RSP:/* Wireless Firmware Upgrade(v) */
+                    case RSI_FWUP_OK: /* Wireless Firmware Upgrade() */
+                    case RSI_RSP_MODULE_STATE:/* Asynchronous message for connection state notification */
+                    case RSI_RSP_CLIENT_CONNECTED:/* Station connect indication in AP mode */
+                    case RSI_RSP_CLIENT_DISCONNECTED:/* Station disconnect indication in AP mode */
+                        retval = wmrp10_os_fr_msg(rsi_app_cb.read_packet_buffer,
+                                                  rsi_app_cb.uCmdRspFrame);
+                        break;
+                    default:
+                        retval = WMRP10_ERR_ABORT;
+                        break;
+                }
+            }
+            /********** BT mode **********/
+            else
+            {
+                uCmdRspPtr = wmrp10_rsi_bt_parse_response(rsi_app_cb.read_packet_buffer);
+                response_type = rsi_bytes2R_to_uint16(uCmdRspPtr->ResponseCode);
+                switch(response_type)
+                {
+                    /***** X|X *****/
+                    case RSI_BT_RSP_CARD_READY:
+                    case RSI_BT_RSP_SET_LOCAL_NAME:
+                    case RSI_BT_RSP_QUERY_LOCAL_NAME:
+                    case RSI_BT_RSP_SET_LOCAL_COD:
+                    case RSI_BT_RSP_QUERY_LOCAL_COD:
+                    case RSI_BT_RSP_QUERY_RSSI:
+                    case RSI_BT_RSP_QUERY_LINK_QUALITY:
+                    case RSI_BT_RSP_QUERY_LOCAL_BD_ADDRESS:
+                    case RSI_BT_RSP_INIT:
+                    case RSI_BT_RSP_DEINIT:
+                    case RSI_BT_RSP_ANTENNA_SELECT:
+                    case RSI_BT_RSP_FEATURE_BIT_MAP:
+                    case RSI_BT_RSP_SET_PROFILE_MODE:
+                    case RSI_BT_RSP_SET_DISCV_MODE:
+                    case RSI_BT_RSP_QUERY_DISCOVERY_MODE:
+                    case RSI_BT_RSP_SET_CONNECTABILITY_MODE:
+                    case RSI_BT_RSP_QUERY_CONNECTABILITY_MODE:
+                    case RSI_BT_RSP_SET_PAIR_MODE:
+                    case RSI_BT_RSP_QUERY_PAIR_MODE:
+                    case RSI_BT_RSP_REMOTE_NAME_REQUEST:
+                    case RSI_BT_RSP_REMOTE_NAME_REQUEST_CANCEL:
+                    case RSI_BT_RSP_INQUIRY:
+                    case RSI_BT_RSP_INQUIRY_CANCEL:
+                    case RSI_BT_RSP_BOND:
+                    case RSI_BT_RSP_BOND_CANCEL:
+                    case RSI_BT_RSP_UNBOND:
+                    case RSI_BT_RSP_SET_PIN_TYPE:
+                    case RSI_BT_RSP_QUERY_PIN_TYPE:
+                    case RSI_BT_RSP_USER_CONFIRMATION:
+                    case RSI_BT_RSP_PASSKEY_REPLY:
+                    case RSI_BT_RSP_PINCODE_REPLY:
+                    case RSI_BT_RSP_QUERY_ROLE:
+                    case RSI_BT_RSP_SET_ROLE:
+                    case RSI_BT_RSP_QUERY_SERVICES:
+                    case RSI_BT_RSP_SEARCH_SERVICE:
+                    case RSI_BT_RSP_LINKKEY_REPLY:
+                    case RSI_BT_RSP_SSP_ENABLE:
+                    case RSI_BT_RSP_START_SNIFF_MODE:
+                    case RSI_BT_RSP_STOP_SNIFF_MODE:
+                    case RSI_BT_RSP_SNIFF_SUBRATING_MODE:
+                    case RSI_BT_RSP_SPP_CONNECT:
+                    case RSI_BT_RSP_SPP_DISCONNECT:
+                    case RSI_BT_RSP_SPP_TRANSFER:
+                    case RSI_BT_RSP_PER_TX:
+                    case RSI_BT_RSP_PER_RX:
+                    case RSI_BT_RSP_PER_STATS:
+                    case RSI_BT_RSP_CW_MODE:
+                        retval = wmrp10_os_fr_bt_cmd(uCmdRspPtr, trigger_auto_flg);
+                        break;
+                    /***** Cxg *****/
+                    case RSI_BT_EVT_ROLE_CHANGE_STATUS:
+                    case RSI_BT_EVT_UNBOND_STATUS:
+                    case RSI_BT_EVT_BOND_RESPONSE:
+                    case RSI_BT_EVT_INQUIRY_RESPONSE:
+                    case RSI_BT_EVT_REMOTE_DEVICE_NAME:
+                    case RSI_BT_EVT_REMOTE_NAME_REQUEST_CANCEL:
+                    case RSI_BT_EVT_DISCONNECTED:
+                    case RSI_BT_EVT_USER_CONFIRMATION_REQUEST:
+                    case RSI_BT_EVT_USER_PASKEY_DISPLAY:
+                    case RSI_BT_EVT_USER_PINCODE_REQUEST:
+                    case RSI_BT_EVT_USER_PASSKEY_REQUEST:
+                    case RSI_BT_EVT_INQ_COMPLETE:
+                    case RSI_BT_EVT_AUTH_COMPLETE:
+                    case RSI_BT_EVT_USER_LINKKEY_REQUEST:
+                    case RSI_BT_EVT_USER_LINKKEY_SAVE:
+                    case RSI_BT_EVT_SSP_COMPLETE:
+                    case RSI_BT_EVT_MODE_CHANGE:
+                    case RSI_BT_EVT_SNIFF_SUBRATING_CHANGED:
+                    case RSI_BT_EVT_USER_PASKEY_NOTIFY:
+                    case RSI_BT_EVT_SPP_RECEIVE:
+                    case RSI_BT_EVT_SPP_CONNECTED:
+                    case RSI_BT_EVT_SPP_DISCONNECTED:
+                        retval = wmrp10_os_fr_bt_event(rsi_app_cb.read_packet_buffer, uCmdRspPtr);
+                        break;
+                    default:
+                        retval = WMRP10_ERR_ABORT;
+                        break;
+                }
+            }
+        }
+        else
+        {
+            printk("rsi_frame_read_err\n");
+            /* frame readsƂɗ */
+            retval = WMRP10_ERR_ABORT;
+        }
+    }
+    /**/
+    else
+    {
+    printk("spi_lock_err\n");
+    }
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_parse_response()                                  */
+/*      X|Xobt@̉                                    */
+/*      input   :  rsp  X|Xobt@                          */
+/*      return  :  X|Xt[ւ̃|C^                   */
+/*                 (ID+G[R[h+yC[h)                     */
+/*------------------------------------------------------------------*/
+RSI_BT_RESPONSE *wmrp10_rsi_bt_parse_response(UINT08 *rsp)
+{
+    RSI_BT_RESPONSE *temp_uCmdRspPtr = NULL;
+    UINT16 temp_rspCode;
+    UINT16 temp_status;
+    UINT08 *descPtr = rsp ;
+    UINT08 *payloadPtr = rsp + RSI_BT_FRAME_DESC_LEN;
+    
+    /* Retrieve response code from the received packet */
+    temp_status  = rsi_bytes2R_to_uint16(descPtr + RSI_BT_STATUS_OFFSET);
+    temp_rspCode = rsi_bytes2R_to_uint16(descPtr + RSI_BT_RSP_TYPE_OFFSET);
+    
+    /* Copy the response type and status to payloadPtr-4, payloadPtr-2
+    * locations respectively.
+    */
+    rsi_uint16_to_2bytes((payloadPtr - 2), temp_status);
+    rsi_uint16_to_2bytes((payloadPtr - 4), temp_rspCode);
+    
+    temp_uCmdRspPtr = (RSI_BT_RESPONSE *)(payloadPtr - 4);
+    
+    return temp_uCmdRspPtr;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_oper_mode()                                       */
+/*      Set Operation ModeR}h𔭍sX|X҂          */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_oper_mode(rsi_uOperMode *req, UINT16 *err_code,
+                              INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_oper_mode(req);
+    
+    wmrp10_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_RSP_OPERMODE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* BTABLE[h̏ꍇACard readyX|X҂Kv  */
+    wait_type = RSI_BT_RSP_CARD_READY;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_set_local_name()                                  */
+/*      Set Local nameR}h𔭍sX|X҂              */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_set_local_name(RSI_BT_CMD_SET_LOCAL_NAME *req,
+                                   UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_set_local_name(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SET_LOCAL_NAME;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_local_name()                                */
+/*      Query Local nameR}h𔭍sX|X҂            */
+/*      input   :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_local_name(RSI_BT_RESP_QUERY_LOCAL_NAME *rsp,
+                                     UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_local_name();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_LOCAL_NAME;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryLocalName;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_set_local_cod()                                   */
+/*      Set local CODR}h𔭍sX|X҂               */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_set_local_cod(RSI_BT_CMD_SET_LOCAL_COD *req,
+                                  UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_set_local_cod(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SET_LOCAL_COD;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_local_cod()                                 */
+/*      Query Local CODR}h𔭍sX|X҂             */
+/*      input   :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_local_cod(RSI_BT_RESP_QUERY_LOCAL_COD *rsp,
+                                    UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_local_cod();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_LOCAL_COD;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryLocalCOD;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_rssi()                                      */
+/*      Query RSSIR}h𔭍sX|X҂                  */
+/*      input   :  req        R}hp[^                    */
+/*              :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_rssi(RSI_BT_CMD_QUERY_RSSI *req,
+                               RSI_BT_RESP_QUERY_RSSI *rsp,
+                               UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_rssi(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_RSSI;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryRssi;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_link_quality()                              */
+/*      Query Link QualityR}h𔭍sX|X҂          */
+/*      input   :  req        R}hp[^                    */
+/*              :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_link_quality(RSI_BT_CMD_QUERY_LINK_QUALITY *req,
+                                       RSI_BT_RESP_QUERY_LINK_QUALITY *rsp,
+                                       UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_link_quality(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_LINK_QUALITY;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryLinkQuality;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_local_bd_address()                          */
+/*      Query Local BD AddressR}h𔭍sX|X҂      */
+/*      input   :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_local_bd_address(RSI_BT_RESP_QUERY_LOCAL_BD_ADDRESS *rsp,
+                                           UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_local_bd_address();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_LOCAL_BD_ADDRESS;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryLocalBDAddr;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_device_init()                                     */
+/*      Initialize BT moduleR}h𔭍sX|X҂        */
+/*      input   :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_device_init(UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_device_init();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_INIT;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_device_deinit()                                   */
+/*      Deinitialize BT moduleR}h𔭍sX|X҂      */
+/*      input   :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_device_deinit(UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_device_deinit();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_DEINIT;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_antenna_select()                                  */
+/*      BT Antenna SelectR}h𔭍sX|X҂           */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_antenna_select(RSI_BT_CMD_ANTENNA_SELECT *req,
+                                   UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_antenna_select(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_ANTENNA_SELECT;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_enable_set_feature_bitmap()                       */
+/*      Set Feature BitmapR}h𔭍sX|X҂          */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_enable_set_feature_bitmap (RSI_BT_CMD_FEATURE_BIT_MAP *req,
+                                               UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_enable_set_feature_bitmap(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_FEATURE_BIT_MAP;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_set_profile_mode()                                */
+/*      Set Profile ModeR}h𔭍sX|X҂            */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_set_profile_mode(RSI_BT_CMD_SET_PROFILE_MODE *req,
+                                     UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_set_profile_mode(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SET_PROFILE_MODE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_set_discovery_mode()                              */
+/*      Set Device Discovery modeR}h𔭍sX|X҂   */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_set_discovery_mode(RSI_BT_CMD_SET_DISCV_MODE *req,
+                                       UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_set_discovery_mode(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SET_DISCV_MODE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_discovery_mode()                            */
+/*      Get Device Discovery modeR}h𔭍sX|X҂   */
+/*      input   :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_discovery_mode(RSI_BT_RESP_QUERY_DISCOVERY_MODE *rsp,
+                                         UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_discovery_mode();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_DISCOVERY_MODE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryDiscvMode;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_set_connectability_mode()                         */
+/*      Set Connectability modeR}h𔭍sX|X҂     */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_set_connectability_mode(RSI_BT_CMD_SET_CONNECTABILITY_MODE *req,
+                                            UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_set_connectability_mode(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SET_CONNECTABILITY_MODE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_connectability_mode()                       */
+/*      Get Connectability modeR}h𔭍sX|X҂     */
+/*      input   :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_connectability_mode(RSI_BT_RESP_QUERY_CONNECTABILITY_MODE *rsp,
+                                              UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_connectability_mode();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_CONNECTABILITY_MODE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryConnMode;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_set_pair_mode()                                   */
+/*      Set Pair modeR}h𔭍sX|X҂               */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_set_pair_mode(RSI_BT_CMD_SET_PAIR_MODE *req,
+                                  UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_set_pair_mode(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SET_PAIR_MODE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_pair_mode()                                 */
+/*      Get Pair modeR}h𔭍sX|X҂               */
+/*      input   :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_pair_mode(RSI_BT_RESP_QUERY_PAIR_MODE *rsp,
+                                    UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_pair_mode();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_PAIR_MODE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryPairMode;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_remote_name_request()                             */
+/*      Remote Name RequestR}h𔭍sX|X҂         */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_remote_name_request(RSI_BT_CMD_REMOTE_NAME_REQUEST *req,
+                                        UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_remote_name_request(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_REMOTE_NAME_REQUEST;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_remote_name_request_cancel()                      */
+/*      Remote Name Request CancelR}h𔭍sX|X҂  */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_remote_name_request_cancel(RSI_BT_CMD_REMOTE_NAME_REQUEST_CANCEL *req,
+                                               UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_remote_name_request_cancel(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_REMOTE_NAME_REQUEST_CANCEL;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_inquiry()                                         */
+/*      InquiryR}h𔭍sX|X҂                     */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_inquiry(RSI_BT_CMD_INQUIRY *req, UINT16 *err_code,
+                            INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_inquiry(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_INQUIRY;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_inquiry_cancel()                                  */
+/*      Inquiry CancelR}h𔭍sX|X҂                   */
+/*      input   :  err_code   G[R[hi[AhX                */
+/*              :  timeout    ^CAEgl(-1:FEVER)                 */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_inquiry_cancel(UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_inquiry_cancel();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_INQUIRY_CANCEL;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_bond()                                            */
+/*      Bond or Create ConnectionR}h𔭍sX|X҂   */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_bond(RSI_BT_CMD_BOND *req, UINT16 *err_code,
+                         INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_bond(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_BOND;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_bond_cancel()                                     */
+/*      Bond CancelR}h𔭍sX|X҂                 */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_bond_cancel(RSI_BT_CMD_BOND_CANCEL *req,
+                                UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_bond_cancel(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_BOND_CANCEL;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_unbond()                                          */
+/*      Unbond or DisconnectR}h𔭍sX|X҂        */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_unbond(RSI_BT_CMD_UNBOND *req, UINT16 *err_code,
+                           INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_unbond(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_UNBOND;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_set_pin_type()                                    */
+/*      Set Pin typeR}h𔭍sX|X҂                */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_set_pin_type(RSI_BT_CMD_SET_PIN_TYPE *req,
+                                 UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_set_pin_type(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SET_PIN_TYPE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_pin_type()                                  */
+/*      Get Pin typeR}h𔭍sX|X҂                */
+/*      input   :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_pin_type(RSI_BT_RESP_QUERY_PIN_TYPE *rsp,
+                                   UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_pin_type();
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_PIN_TYPE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryPinType;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_user_confirmation()                               */
+/*      User confirmationR}h𔭍sX|X҂           */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_user_confirmation(RSI_BT_CMD_USER_CONFIRMATION *req,
+                                      UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_user_confirmation(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_USER_CONFIRMATION;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_passkey_request_reply()                           */
+/*      Pass key Request ReplyR}h𔭍sX|X҂      */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_passkey_request_reply(RSI_BT_CMD_PASSKEY_REPLY *req,
+                                          UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_passkey_request_reply(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_PASSKEY_REPLY;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_pincode_reply()                                   */
+/*      Pincode Request ReplyR}h𔭍sX|X҂       */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_pincode_reply(RSI_BT_CMD_PINCODE_REPLY *req,
+                                  UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_pincode_reply(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_PINCODE_REPLY;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_role()                                      */
+/*      Get Local Device RoleR}h𔭍sX|X҂       */
+/*      input   :  req        R}hp[^                    */
+/*              :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_role(RSI_BT_CMD_QUERY_ROLE *req,
+                               RSI_BT_RESP_QUERY_ROLE *rsp,
+                               UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_role(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_ROLE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryRole;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_set_role()                                        */
+/*      Set Local Device RoleR}h𔭍sX|X҂       */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_set_role(RSI_BT_CMD_SET_ROLE *req,
+                             UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_set_role(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SET_ROLE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_query_services()                                  */
+/*      Get Service ListR}h𔭍sX|X҂            */
+/*      input   :  req        R}hp[^                    */
+/*              :  rsp        X|Xi[AhX              */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_query_services(RSI_BT_CMD_QUERY_SERVICES *req,
+                                   RSI_BT_RESP_QUERY_SERVICES *rsp,
+                                   UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_query_services(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_QUERY_SERVICES;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    
+    /* X|Xi[ */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspPtr->uCmdRspPayLoad.uQryServ;
+    }
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_search_service()                                  */
+/*      Search ServiceR}h𔭍sX|X҂              */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_search_service(RSI_BT_CMD_SEARCH_SERVICE *req,
+                                   UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_search_service(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SEARCH_SERVICE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_linkkey_reply()                                   */
+/*      Linkkey ReplyR}h𔭍sX|X҂               */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_linkkey_reply(RSI_BT_CMD_LINKKEY_REPLY *req,
+                                  UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_linkkey_reply(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_LINKKEY_REPLY;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_enable_ssp_mode()                                 */
+/*      Set SSP modeR}h𔭍sX|X҂                */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_enable_ssp_mode(RSI_BT_CMD_SSP_MODE *req,
+                                    UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_enable_ssp_mode(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SSP_ENABLE;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_spp_connect()                                     */
+/*      SPP ConnectR}h𔭍sX|X҂                 */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_spp_connect(RSI_BT_CMD_SPP_CONNECT *req,
+                                UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_spp_connect(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SPP_CONNECT;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_spp_disconnect()                                  */
+/*      SPP DisconnectR}h𔭍sX|X҂              */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_spp_disconnect(RSI_BT_CMD_SPP_DISCONNECT *req,
+                                   UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_spp_disconnect(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SPP_DISCONNECT;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_spp_transfer()                                    */
+/*      SPP TransferR}h𔭍sX|X҂                */
+/*      input   :  req        R}hp[^                    */
+/*              :  err_code   G[R[hi[AhX            */
+/*              :  timeout    ^CAEgl(-1:FEVER)              */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_spp_transfer(RSI_BT_CMD_SPP_TRANSFER *req,
+                                 UINT16 *err_code, INT32 timeout)
+{
+    INT16 retval;
+    INT16 os_retval;
+    UINT16 wait_type;
+    UINT16 response_type;
+    UINT08 tri_auto_flg;
+    RSI_BT_RESPONSE *uCmdRspPtr;
+    
+    /* R}hs */
+    os_retval = wmrp10_bt_os_cmd_lock();     /* R}hr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_bt_os_spi_lock();          /* SPIr(Jn) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bt_spp_transfer(req);
+    
+    wmrp10_bt_os_spi_unlock();                    /* SPIr(I) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_bt_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* X|X҂ */
+    wait_type = RSI_BT_RSP_SPP_TRANSFER;
+    retval = wmrp10_os_rsp_bt_cmd(&wait_type, 1, &response_type,
+                                  &tri_auto_flg, &uCmdRspPtr, err_code, timeout);
+    wmrp10_bt_os_cmd_unlock();               /* R}hr(I) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bt_event()                                           */
+/*      Cxg󂯂                                               */
+/*      input   :  event      Cxg̊i[AhX                  */
+/*              :  timeout    ^CAEgl(-1:FEVER, 0:Poll)         */
+/*      return  :  0                                            */
+/*              :  < 0        s                                  */
+/*------------------------------------------------------------------*/
+INT16 wmrp10_rsi_bt_event(T_WMRP10_BT_EVENT *event, INT32 timeout)
+{
+    INT16 retval;
+    
+    /* Cxg󂯂 */
+    retval = wmrp10_os_bt_event(event, timeout);
+    
+    return retval;
+}
+
+
+/* End of File */
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_rsi.h b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_rsi.h
new file mode 100755
index 0000000..2d33c45
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_bt_rsi.h
@@ -0,0 +1,148 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_bt_rsi.h                                                */
+/*   BT-Classic R}h                                            */
+/*                                                                  */
+/*   2017/04/11 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#ifndef _WMRP10_BT_RSI_H_
+#define _WMRP10_BT_RSI_H_
+
+#include "rsi_bt_api.h"
+#include "rsi_bt_generic.h"
+#include "rsi_bt_global.h"
+#include "rsi_global.h"
+
+#define BT_EVENT_MAX  10                           /* Cxgő吔 */
+
+/* Cxgp\̒` */
+typedef struct t_wmrp10_bt_event
+{
+    UINT16 response_type;
+    UINT16 err_code;
+    union
+    {
+        RSI_BT_EVENT_ROLE_CHANGE_STATUS         uRoleChangeStatus;
+        RSI_BT_EVENT_UNBOND_STATUS              uUnbondStatus;
+        RSI_BT_EVENT_BOND_RESPONSE              uBondResp;
+        RSI_BT_EVENT_INQUIRY_RESPONSE           uInqResp;
+        RSI_BT_EVENT_REMOTE_DEVICE_NAME         uRemDevName;
+        RSI_BT_EVENT_REMOTE_NAME_REQUEST_CANCEL uRemNameReqCancel;
+        RSI_BT_EVENT_DISCONNECTED               uDisconn;
+        RSI_BT_EVENT_USER_CONFIRMATION_REQUEST  uUserConfReq;
+        RSI_BT_EVENT_USER_PASKEY_DISPLAY        uUserPaskeyDisp;
+        RSI_BT_EVENT_USER_PINCODE_REQUEST       uUserPincodeReq;
+        RSI_BT_EVENT_USER_PASSKEY_REQUEST       uUserPasskeyReq;
+        RSI_BT_EVENT_AUTH_COMPLETE              uAuthComp;
+        RSI_BT_EVENT_USER_LINKKEY_REQUEST       uLinkkeyReq;
+        RSI_BT_EVENT_USER_LINKKEY_SAVE          uLinkkeySave;
+        RSI_BT_EVENT_MODE_CHANGE                uModeChange;
+        RSI_BT_EVENT_SSP_COMPLETE               uSspComp;
+        RSI_BT_EVENT_SPP_RECEIVE                uSppRecv;
+        RSI_BT_EVENT_SPP_CONNECTED              uSppConn;
+        RSI_BT_EVENT_SPP_DISCONNECTED           uSppDisConn;
+        UINT08 uCmdRspBuf;
+    }event;
+    
+}T_WMRP10_BT_EVENT;
+
+/***** M̂U蕪 *****/
+INT16 wmrp10_rsi_bt_frame_read(void);
+RSI_BT_RESPONSE *wmrp10_rsi_bt_parse_response(UINT08 *rsp);
+
+
+/***** Generic commands *****/
+INT16 wmrp10_rsi_bt_oper_mode(rsi_uOperMode *req, UINT16 *err_code,
+                              INT32 timeout);
+INT16 wmrp10_rsi_bt_set_local_name(RSI_BT_CMD_SET_LOCAL_NAME *req,
+                                   UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_local_name(RSI_BT_RESP_QUERY_LOCAL_NAME *rsp,
+                                     UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_set_local_cod(RSI_BT_CMD_SET_LOCAL_COD *req,
+                                  UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_local_cod(RSI_BT_RESP_QUERY_LOCAL_COD *rsp,
+                                    UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_rssi(RSI_BT_CMD_QUERY_RSSI *req,
+                               RSI_BT_RESP_QUERY_RSSI *rsp,
+                               UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_link_quality(RSI_BT_CMD_QUERY_LINK_QUALITY *req,
+                                       RSI_BT_RESP_QUERY_LINK_QUALITY *rsp,
+                                       UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_local_bd_address(RSI_BT_RESP_QUERY_LOCAL_BD_ADDRESS *rsp,
+                                           UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_device_init(UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_device_deinit(UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_antenna_select(RSI_BT_CMD_ANTENNA_SELECT *req,
+                                   UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_enable_set_feature_bitmap (RSI_BT_CMD_FEATURE_BIT_MAP *req,
+                                               UINT16 *err_code, INT32 timeout);
+
+/***** Core commands *****/
+INT16 wmrp10_rsi_bt_set_profile_mode(RSI_BT_CMD_SET_PROFILE_MODE *req,
+                                     UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_set_discovery_mode(RSI_BT_CMD_SET_DISCV_MODE *req,
+                                       UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_discovery_mode(RSI_BT_RESP_QUERY_DISCOVERY_MODE *rsp,
+                                         UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_set_connectability_mode(RSI_BT_CMD_SET_CONNECTABILITY_MODE *req,
+                                            UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_connectability_mode(RSI_BT_RESP_QUERY_CONNECTABILITY_MODE *rsp,
+                                              UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_set_pair_mode(RSI_BT_CMD_SET_PAIR_MODE *req,
+                                  UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_pair_mode(RSI_BT_RESP_QUERY_PAIR_MODE *rsp,
+                                    UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_remote_name_request(RSI_BT_CMD_REMOTE_NAME_REQUEST *req,
+                                        UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_remote_name_request_cancel(RSI_BT_CMD_REMOTE_NAME_REQUEST_CANCEL *req,
+                                               UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_inquiry(RSI_BT_CMD_INQUIRY *req,
+                            UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_inquiry_cancel(UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_bond(RSI_BT_CMD_BOND *req, UINT16 *err_code,
+                         INT32 timeout);
+INT16 wmrp10_rsi_bt_bond_cancel(RSI_BT_CMD_BOND_CANCEL *req,
+                                UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_unbond(RSI_BT_CMD_UNBOND *req, UINT16 *err_code,
+                           INT32 timeout);
+INT16 wmrp10_rsi_bt_set_pin_type(RSI_BT_CMD_SET_PIN_TYPE *req,
+                                 UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_pin_type(RSI_BT_RESP_QUERY_PIN_TYPE *rsp,
+                                   UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_user_confirmation(RSI_BT_CMD_USER_CONFIRMATION *req,
+                                      UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_passkey_request_reply(RSI_BT_CMD_PASSKEY_REPLY *req,
+                                          UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_pincode_reply(RSI_BT_CMD_PINCODE_REPLY *req,
+                                  UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_role(RSI_BT_CMD_QUERY_ROLE *req,
+                               RSI_BT_RESP_QUERY_ROLE *rsp,
+                               UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_set_role(RSI_BT_CMD_SET_ROLE *req,
+                             UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_query_services(RSI_BT_CMD_QUERY_SERVICES *req,
+                                   RSI_BT_RESP_QUERY_SERVICES *rsp,
+                                   UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_search_service(RSI_BT_CMD_SEARCH_SERVICE *req,
+                                   UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_linkkey_reply(RSI_BT_CMD_LINKKEY_REPLY *req,
+                                  UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_enable_ssp_mode(RSI_BT_CMD_SSP_MODE *req,
+                                    UINT16 *err_code, INT32 timeout);
+
+/***** SPP commands *****/
+INT16 wmrp10_rsi_bt_spp_connect(RSI_BT_CMD_SPP_CONNECT *req,
+                                UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_spp_disconnect(RSI_BT_CMD_SPP_DISCONNECT *req,
+                                   UINT16 *err_code, INT32 timeout);
+INT16 wmrp10_rsi_bt_spp_transfer(RSI_BT_CMD_SPP_TRANSFER *req,
+                                 UINT16 *err_code, INT32 timeout);
+
+/***** Cxg󂯂 *****/
+INT16 wmrp10_rsi_bt_event(T_WMRP10_BT_EVENT *event, INT32 timeout);
+
+#endif /* _WMRP10_BT_RSI_H_ */
+
+/* End of File */
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_def.h b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_def.h
new file mode 100755
index 0000000..544d68c
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_def.h
@@ -0,0 +1,19 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_def.h                                                   */
+/*   WLAN 設定定義                                                  */
+/*                                                                  */
+/*   2019/05/21 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#ifndef _WMRP10_DEF_H_
+#define _WMRP10_DEF_H_
+
+#include "rsi_global.h"
+#include "rsi_api.h"
+
+#define WMRP10_TCP_IP_BYPASS    ENABLE
+#define WMRP10_IP_VERSION       IP_VERSION_4
+
+#endif /* _WMRP10_DEF_H_ */
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_err.h b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_err.h
new file mode 100755
index 0000000..f7f3a05
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_err.h
@@ -0,0 +1,21 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_err.h                                                   */
+/*   WLAN エラーコード定義                                          */
+/*                                                                  */
+/*   2016/09/29 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#ifndef _WMRP10_ERR_H_
+#define _WMRP10_ERR_H_
+
+#define WMRP10_ERR_NOT_READY 1                   /* board ready待ち */
+#define WMRP10_ERR_NON_RECV  1                          /* 受信なし */
+#define WMRP10_ERR_SUCCESS   0                      /* コマンド成功 */
+#define WMRP10_ERR_ABORT    -1
+#define WMRP10_ERR_TIMEOUT  -2
+#define WMRP10_ERR_CMD      -3                      /* コマンド失敗 */
+
+#endif /* _WMRP10_ERR_H_ */
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_os.c b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_os.c
new file mode 100755
index 0000000..34f0810
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_os.c
@@ -0,0 +1,2740 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_os.c                                                    */
+/*   WLAN OS依存部                                                  */
+/*                                                                  */
+/*   2019/07/19 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/ieee80211.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <linux/spi/spi.h>
+#include <linux/semaphore.h>
+#include <linux/etherdevice.h>
+#include <linux/gpio.h>
+#include "rsi_global.h"
+#include "rsi_app.h"
+#include "rsi_app_util.h"
+#include "wmrp10.h"
+#include "wmrp10_os.h"
+#include "wmrp10_err.h"
+
+#define WMRP10_GPIO_POWER    0x3C0
+#define WMRP10_GPIO_RESET    0x36D
+
+/* 制御用パラメータの構造体定義 */
+struct wmrp10_os_param
+{
+    struct semaphore sema_spi;
+    struct semaphore sema_cmd;
+    
+    struct completion comp_rsp_cmd;
+};
+
+/* レスポンス情報の構造体定義 */
+struct wmrp10_os_res
+{
+    uint16 size;
+    uint8 trigger_auto_flg;
+    rsi_uCmdRsp response;
+};
+
+static struct wmrp10_os_param g_wmrp10_os_prm;
+//static rsi_uCmdRsp g_wmrp10_os_rsp;
+static struct wmrp10_os_res g_wmrp10_os_rsp;
+int g_wmrp10_os_init_flg = 0;
+
+extern struct spi_device *g_wmrp_spi;
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_init()                                                */
+/*      OSの初期化                                                  */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_init(void)
+{
+    if(g_wmrp10_os_init_flg == 0)
+    {
+        /* 初回のみ実行 */
+        sema_init(&(g_wmrp10_os_prm.sema_spi), 1);
+        sema_init(&(g_wmrp10_os_prm.sema_cmd), 1);
+        
+        init_completion(&(g_wmrp10_os_prm.comp_rsp_cmd));
+        
+        g_wmrp10_os_init_flg = 1;
+    }
+    gpio_direction_output(WMRP10_GPIO_POWER, 1);
+    gpio_direction_output(WMRP10_GPIO_RESET, 0);
+    msleep(30);   /* >= 20ms */
+    gpio_direction_output(WMRP10_GPIO_RESET, 1);
+    msleep(50);   /* >= 27ms */
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_exit()                                                */
+/*      OSの終了処理                                                */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_exit(void)
+{
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_spi_lock()                                            */
+/*      SPIの排他制御(セマフォ資源獲得)                                */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_spi_lock(void)
+{
+    down(&(g_wmrp10_os_prm.sema_spi));
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_spi_unlock()                                          */
+/*      SPIの排他制御(セマフォ資源返却)                                */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_spi_unlock(void)
+{
+    up(&(g_wmrp10_os_prm.sema_spi));
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_cmd_lock()                                            */
+/*      コマンドの排他制御(セマフォ資源獲得)                            */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_cmd_lock(void)
+{
+    down(&(g_wmrp10_os_prm.sema_cmd));
+    g_wmrp10_os_prm.comp_rsp_cmd.done = 0;  /* Waitクリア */
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_cmd_unlock()                                          */
+/*      コマンドの排他制御(セマフォ資源返却)                            */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_cmd_unlock(void)
+{
+    up(&(g_wmrp10_os_prm.sema_cmd));
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_fr_cmd()                                              */
+/*      コマンドのレスポンス処理                                   　　　　*/
+/*      input   :  rsp   レスポンス                                  */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_fr_cmd(rsi_uCmdRsp *rsp,
+                       uint8 trigger_auto_flg)
+{
+    g_wmrp10_os_rsp.size = sizeof(rsi_uCmdRsp);
+    g_wmrp10_os_rsp.trigger_auto_flg = trigger_auto_flg;
+    memcpy(&g_wmrp10_os_rsp.response, rsp, sizeof(rsi_uCmdRsp));
+    
+    complete(&(g_wmrp10_os_prm.comp_rsp_cmd));
+
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_fr_data()                                             */
+/*      受信したデータの処理                                          */
+/*      input   :  read_packet_buffer  リードバッファ                  */
+/*              :  rsp                 レスポンス                    */
+/*      return  :  0                   成功                         */
+/*              :  < 0                 失敗                         */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_fr_data(uint8 *read_packet_buffer, rsi_uCmdRsp *rsp)
+{
+    struct wmrp10_priv *priv = dev_get_drvdata(&(g_wmrp_spi->dev));
+    struct net_device_stats *stats = &(priv->stats);
+    struct sk_buff *skb;
+    unsigned long length;
+    int err;
+    u8 * buf;
+    
+    length = read_packet_buffer[1] & 0x0F;
+    length <<= 8;
+    length += read_packet_buffer[0];
+    if((0 < length) && (length < 60))
+    {
+        memset(&(rsp->uCmdRspPayLoad.uCmdRspBuf[length]),
+               0, (60 - length));
+        length = 60;
+    }
+    
+    skb = dev_alloc_skb(length + NET_IP_ALIGN + 3);
+    
+    skb_reserve(skb, NET_IP_ALIGN);
+    buf = skb_put(skb, length);
+    
+    memcpy(buf, rsp->uCmdRspPayLoad.uCmdRspBuf, length);
+    
+    skb->protocol = eth_type_trans(skb, priv->ndev);
+    
+    err = netif_rx_ni(skb);
+    if(err != NET_RX_SUCCESS)
+    {
+        printk("%s: netif_rx => %d\n", __func__, err);
+    }
+    
+    stats->rx_packets++;
+    stats->rx_bytes += length;
+    
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_fr_msg()                                              */
+/*      受信したメッセージの処理                                       */
+/*      input   :  read_packet_buffer  リードバッファ                  */
+/*              :  rsp                 レスポンス                    */
+/*      return  :  0                   成功                         */
+/*              :  < 0                 失敗                         */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_fr_msg(uint8 *read_packet_buffer, rsi_uCmdRsp *rsp)
+{
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_select_option()                                   */
+/*      rsi_select_optionコマンドのレスポンスを待つ                     */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_select_option(uint8 *rsp, uint16 *err_code,
+                                  int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_CARD_READY;
+    
+    /* レスポンス解析 */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = tri_auto_flg;
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_oper_mode()                                       */
+/*      rsi_oper_modeコマンドのレスポンスを待つ                         */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_oper_mode(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_OPERMODE;
+    
+    /* レスポンス受信 */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_band()                                            */
+/*      rsi_bandコマンドのレスポンスを待つ                              */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_band(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_BAND;
+    
+    
+    /* レスポンス受信 */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_set_mac_addr()                                    */
+/*      rsi_set_mac_addrコマンドのレスポンスを待つ                      */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_set_mac_addr(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_MACADDRESS_SET;
+    
+    /* レスポンス受信 */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_init()                                            */
+/*      rsi_initコマンドのレスポンスを待つ                              */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_init(rsi_initResponse *rsp, uint16 *err_code,
+                         int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_INIT;
+    
+    /* レスポンス受信 */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* エラーチェック と 結果の格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.initResponse,
+                sizeof(rsi_initResponse));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_per_mode()                                        */
+/*      rsi_per_modeコマンドのレスポンスを待つ                          */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_per_mode(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_PER_PARAMS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_select_antenna()                                  */
+/*      Antenna Selectionコマンドのレスポンスを待つ                     */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_select_antenna(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_ANTENNA_SEL;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_p2p_config()                                      */
+/*      Configure Wi-Fi Direct P2Pコマンドのレスポンスを待つ            */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_p2p_config(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_CFG_P2P;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_set_ap_config()                                   */
+/*      rsi_set_ap_configコマンドのレスポンスを待つ                     */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_set_ap_config(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_APCONFIG;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_wps_method()                                      */
+/*      rsi_wps_methodコマンドのレスポンスを待つ                        */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_wps_method(rsi_wpsMethodFrameRcv *rsp,
+                               uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_WPS_METHOD;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.wpsMethodFrameRcv,
+                sizeof(rsi_wpsMethodFrameRcv));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_scan()                                            */
+/*      rsi_scanコマンドのレスポンスを待つ                              */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_scan(rsi_scanResponse *rsp, uint16 *err_code,
+                         int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SCAN;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.scanResponse,
+                sizeof(rsi_scanResponse));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_join()                                            */
+/*      rsi_joinコマンドのレスポンスを待つ                              */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_join(rsi_joinResponse *rsp, uint16 *err_code,
+                         int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_JOIN;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.joinResponse,
+                sizeof(rsi_joinResponse));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_rejoin_params()                                   */
+/*      rsi_rejoin_paramsコマンドのレスポンスを待つ                     */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_rejoin_params(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_REJOIN_PARAMS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_wmm_ps()                                          */
+/*      rsi_wmm_psコマンドのレスポンスを待つ                            */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_wmm_ps(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_WMM_PS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_sleep_timer()                                     */
+/*      rsi_sleep_timerコマンドのレスポンスを待つ                       */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_sleep_timer(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SLEEP_TIMER;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_power_mode()                                      */
+/*      rsi_power_modeコマンドのレスポンスを待つ                        */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_power_mode(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_PWRMODE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_psk()                                             */
+/*      rsi_pskコマンドのレスポンスを待つ                               */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_psk(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_HOST_PSK;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_set_wepkey()                                      */
+/*      rsi_set_wepkeyコマンドのレスポンスを待つ                        */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_set_wepkey(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SET_WEP_KEY;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_set_eap()                                         */
+/*      rsi_set_eapコマンドのレスポンスを待つ                           */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_set_eap(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SET_EAP_CFG;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_set_certificate()                                 */
+/*      rsi_set_certificateコマンドのレスポンスを待つ                   */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_set_certificate(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SET_CERT;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_disconnect()                                      */
+/*      rsi_disconnectコマンドのレスポンスを待つ                        */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_disconnect(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_DISCONNECT;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_bg_scan()                                         */
+/*      rsi_bg_scanコマンドのレスポンスを待つ                           */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_bg_scan(rsi_scanResponse *rsp, uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_BG_SCAN;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.scanResponse,
+                sizeof(rsi_scanResponse));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_roam_params()                                     */
+/*      rsi_roam_paramsコマンドのレスポンスを待つ                       */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_roam_params(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_ROAM_PARAMS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_ht_caps()                                         */
+/*      rsi_ht_capsコマンドのレスポンスを待つ                           */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_ht_caps(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_AP_HT_CAPS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_query_fw_version()                                */
+/*      rsi_query_fw_versionコマンドのレスポンスを待つ                  */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_query_fw_version(rsi_qryFwversionFrameRcv *rsp,
+                                     uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_FWVERSION_QUERY;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.qryFwversionFrameRcv,
+                sizeof(rsi_qryFwversionFrameRcv));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_query_rssi()                                      */
+/*      rsi_query_rssiコマンドのレスポンスを待つ                        */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_query_rssi(rsi_rssiFrameRcv *rsp, uint16 *err_code,
+                               int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_RSSI_QUERY;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.rssiFrameRcv,
+                sizeof(rsi_rssiFrameRcv));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_query_mac_address()                               */
+/*      rsi_query_mac_addressコマンドのレスポンスを待つ                 */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_query_mac_address(rsi_qryMacFrameRcv *rsp,
+                                      uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_MAC_QUERY;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.qryMacaddress,
+                sizeof(rsi_qryMacFrameRcv));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_query_net_parms()                                 */
+/*      rsi_query_net_parmsコマンドのレスポンスを待つ                   */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_query_net_parms(rsi_qryNetParmsFrameRcv *rsp,
+                                    uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_NETWORK_PARAMS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.qryNetParmsFrameRcv,
+                sizeof(rsi_qryNetParmsFrameRcv));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_query_go_parms()                                  */
+/*      rsi_query_go_parmsコマンドのレスポンスを待つ                    */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_query_go_parms(rsi_qryGOParamsFrameRcv *rsp,
+                                   uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_QUERY_GO_PARAMS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.qryGoParamsFrameRcv,
+                sizeof(rsi_qryGOParamsFrameRcv));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_multicast_mac_filter()                            */
+/*      rsi_multicast_mac_filterコマンドのレスポンスを待つ              */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_multicast_mac_filter(uint16 *err_code,
+                                         int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_MULTICAST_FILTER;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_multicast()                                       */
+/*      rsi_multicastコマンドのレスポンスを待つ                         */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_multicast(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_MULTICAST;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_set_region()                                      */
+/*      rsi_set_regionコマンドのレスポンスを待つ                        */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_set_region(rsi_uSetRegionRsp *rsp, uint16 *err_code,
+                               int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SET_REG_CODE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.setRegFrameRcv,
+                sizeof(rsi_uSetRegionRsp));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_set_region_ap()                                   */
+/*      rsi_set_region_apコマンドのレスポンスを待つ                     */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_set_region_ap(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SET_REG_AP;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_query_conn_status()                               */
+/*      rsi_query_conn_statusコマンドのレスポンスを待つ                 */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_query_conn_status(rsi_conStatusFrameRcv *rsp,
+                                      uint16 *err_code,
+                                      int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_CONNECTION_STATUS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.conStatusFrameRcv,
+                sizeof(rsi_conStatusFrameRcv));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_debug_prints()                                    */
+/*      rsi_debug_printsコマンドのレスポンスを待つ                      */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_debug_prints(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_DEBUG_PRINTS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_rf_current_config()                               */
+/*      rsi_rf_current_configコマンドのレスポンスを待つ                 */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_rf_current_config(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_RF_CURRENT_CONFIG;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_trigger_auto_config()                             */
+/*      rsi_trigger_auto_configコマンドのレスポンスを待つ               */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_trigger_auto_config(uint16 *err_code,
+                                        int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = 0x91;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_cfg_save()                                        */
+/*      rsi_cfg_saveコマンドのレスポンスを待つ                          */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_cfg_save(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_CFG_SAVE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_cfg_enable()                                      */
+/*      rsi_cfg_enableコマンドのレスポンスを待つ                        */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_cfg_enable(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_CFG_ENABLE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_cfg_get()                                         */
+/*      rsi_cfg_getコマンドのレスポンスを待つ                           */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_cfg_get(rsi_cfgGetFrameRcv *rsp, uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_CFG_GET;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.cfgGetFrameRcv,
+                sizeof(rsi_cfgGetFrameRcv));
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_user_store_config()                               */
+/*      rsi_user_store_configコマンドのレスポンスを待つ                 */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_user_store_config(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_USER_STORE_CFG;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_host_rtc_time()                                   */
+/*      Set RTC timeコマンドのレスポンスを待つ                          */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_host_rtc_time(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = 0xE9;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_cmd()                                             */
+/*      レスポンスを待つ                                              */
+/*      input   :  wait_type     待つレスポンスのIDの配列             */
+/*              :  type_len      待ちレスポンスの数                   */
+/*              :  res_type      レスポンスID格納先アドレス            */
+/*              :  tri_auto_flg  Auto Ttiggerフラグ格納先アドレス      */
+/*              :  uCmdRspFrame  レスポンスアドレスの格納先アドレス      */
+/*              :  err_code      エラーコード格納先アドレス             */
+/*              :  timeout       タイムアウト値(-1:FEVER, 0:Poll)      */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_cmd(uint16 *wait_type,
+                        uint16 type_len,
+                        uint16 *res_type,
+                        uint8 *tri_auto_flg,
+                        rsi_uCmdRsp **uCmdRspFrame,
+                        uint16 *err_code,
+                        int32 timeout)
+{
+    int16 retval = WMRP10_ERR_SUCCESS;
+    uint16 type_index;
+    uint16 type_flg;
+    int16 ret;
+    
+    /* レスポンス待ち */
+    ret = wait_for_completion_timeout(&(g_wmrp10_os_prm.comp_rsp_cmd),
+                                      timeout * HZ / 1000);
+                                      
+    if(ret < 0)
+    {
+        retval = WMRP10_ERR_TIMEOUT;
+    }
+    
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        /* レスポンスを受信 */
+        *uCmdRspFrame =&g_wmrp10_os_rsp.response;
+        *err_code = rsi_bytes2R_to_uint16((*uCmdRspFrame)->status);
+        *res_type = rsi_bytes2R_to_uint16((*uCmdRspFrame)->rspCode);
+        *tri_auto_flg = g_wmrp10_os_rsp.trigger_auto_flg;
+        
+   
+        /* レスポンスID判定 */
+        retval = WMRP10_ERR_ABORT;
+        for(type_index = 0; type_index < type_len; type_index++)
+        {
+            if(*res_type == wait_type[type_index])
+            {
+                if(*err_code == 0x0000)
+                {
+                    retval = WMRP10_ERR_SUCCESS;
+                }
+                else
+                {
+                    retval = WMRP10_ERR_CMD;/* IDは正しいがエラー発生 */
+                }
+                break;
+            }
+        }
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_data()                                            */
+/*      受信したデータを取得する                                       */
+/*      input   :  rsp          レスポンス格納先アドレス                */
+/*              :  bytes_recv   受信サイズ格納先アドレス               */
+/*      return  :  0            成功                                */
+/*              :  < 0          失敗                                */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_data(uint8 *rsp, uint16 *bytes_recv,int32 timeout)
+{
+    
+    int16 retval = WMRP10_ERR_SUCCESS;
+    int16 ret;
+    T_MYMSG_MSG *msg;
+    uint16 response_size;
+    
+    /* レスポンス待ち */
+    ret = wait_for_completion_timeout(&(g_wmrp10_os_prm.comp_rsp_cmd),
+                                      timeout * HZ / 1000);
+                                      
+    if(ret < 0)
+    {
+        retval = WMRP10_ERR_TIMEOUT;
+    }
+    
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        /* レスポンスを受信 */
+        response_size = g_wmrp10_os_rsp.size;
+        memcpy(rsp, &g_wmrp10_os_rsp.response, (size_t)(response_size + 2));
+        
+    }
+    return WMRP10_ERR_SUCCESS;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_msg()                                             */
+/*      受信したメッセージを取得する                                    */
+/*      input   :  rsp        メッセージ格納先アドレス                  */
+/*              :  timeout    タイムアウト値(-1:FEVER, 0:Poll)         */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_rsp_msg(T_MYMSG_MSG *rsp, int32 timeout)
+{
+    int16 retval = WMRP10_ERR_SUCCESS;
+    int16 ret;
+    T_MYMSG_MSG *msg;
+    uint16 response_size;
+    
+    /* レスポンス待ち */
+    ret = wait_for_completion_timeout(&(g_wmrp10_os_prm.comp_rsp_cmd),
+                                      timeout * HZ / 1000);
+                                      
+    if(ret < 0)
+    {
+        retval = WMRP10_ERR_TIMEOUT;
+    }
+    
+    if(ret == WMRP10_ERR_SUCCESS)
+    {
+        /* レスポンスを受信 */
+        response_size = g_wmrp10_os_rsp.size;
+        memcpy(rsp, &g_wmrp10_os_rsp.response, (size_t)(response_size + 2));
+        
+    }
+    return WMRP10_ERR_SUCCESS;
+
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_ip_param_set()                                    */
+/*      rsi_ip_param_setコマンドのレスポンスを待つ                      */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_ip_param_set(rsi_ipparamFrameRcv *rsp,
+                                 uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_IPPARAM_CONFIG;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.ipparamFrameRcv,
+                sizeof(rsi_ipparamFrameRcv));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_ipv6_param_set()                                  */
+/*      rsi_ipv6_param_setコマンドのレスポンスを待つ                    */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_ipv6_param_set(rsi_ipconf6FrameRcv *rsp,
+                                   uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_IPCONF6;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.ipconf6FrameRcv,
+                sizeof(rsi_ipconf6FrameRcv));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_snmp_enable()                                     */
+/*      rsi_snmp_enableコマンドのレスポンスを待つ                       */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_snmp_enable(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SNMP_ENABLE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_snmp_get_rsp()                                    */
+/*      rsi_snmp_get_rspコマンドのレスポンスを待つ                      */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_snmp_get_rsp(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SNMP_GET_RSP;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_snmp_get_next_rsp()                               */
+/*      rsi_snmp_get_next_rspコマンドのレスポンスを待つ                 */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_snmp_get_next_rsp(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SNMP_GETNEXT_RSP;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_snmp_trap()                                       */
+/*      rsi_snmp_trapコマンドのレスポンスを待つ                         */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_snmp_trap(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SNMP_TRAP;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_socket()                                          */
+/*      rsi_socketコマンドのレスポンスを待つ                            */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_socket(rsi_socketFrameRcv *rsp, uint16 *err_code,
+                           int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SOCKET_CREATE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv,
+                sizeof(rsi_socketFrameRcv));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_socket_close()                                    */
+/*      rsi_socket_closeコマンドのレスポンスを待つ                      */
+/*      input   :  rsp        レスポンス格納先アドレス                 */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_socket_close(rsi_socketCloseFrameRcv *rsp,
+                                 uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_CLOSE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.socketCloseFrameRcv,
+                sizeof(rsi_socketCloseFrameRcv));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_ltcp_conn_status()                                */
+/*      ltcp_conn_statusコマンドのレスポンスを待つ                      */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_ltcp_conn_status(rsi_LtcpConnStatusFrameRcv *rsp,
+                                     uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_TCP_CONN_STATUS_QUERY;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.LtcpConnStatRcv,
+                sizeof(rsi_LtcpConnStatusFrameRcv));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_dns_server()                                      */
+/*      rsi_dns_serverコマンドのレスポンスを待つ                        */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_dns_server(rsi_dnsserverResponse *rsp,
+                               uint16 *err_code,
+                               int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_DNS_SERVER;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.dnsserverresponse,
+                sizeof(rsi_dnsserverResponse));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_dns_query()                                       */
+/*      rsi_dns_queryコマンドのレスポンスを待つ                         */
+/*      input   :  rsp        レスポンス格納先アドレス                 */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_dns_query(TCP_EVT_DNS_Query_Resp *rsp,
+                              uint16 *err_code,
+                              int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_DNS_QRY;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.dnsqryresponse,
+                sizeof(TCP_EVT_DNS_Query_Resp));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_http_get()                                        */
+/*      rsi_http_getコマンドのレスポンスを待つ                          */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_http_get(rsi_uHttpRsp *rsp, uint16 *err_code,
+                             int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_HTTP_GET;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.httpFrameRcv,
+                sizeof(rsi_uHttpRsp));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_http_post()                                       */
+/*      rsi_http_postコマンドのレスポンスを待つ                         */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_http_post(rsi_uHttpRsp *rsp, uint16 *err_code,
+                              int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_HTTP_POST;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.httpFrameRcv,
+                sizeof(rsi_uHttpRsp));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_http_post_data()                                  */
+/*      rsi_http_post_dataコマンドのレスポンスを待つ                    */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_http_post_data(rsi_uHttpRsp *rsp, uint16 *err_code,
+                                   int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_HTTP_POST_DATA;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.httpFrameRcv,
+                sizeof(rsi_uHttpRsp));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_ping_request()                                    */
+/*      rsi_ping_requestコマンドのレスポンスを待つ                      */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_ping_request(rsi_uPingRsp *rsp, uint16 *err_code,
+                                 int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_PING_PACKET;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.rsi_pingFrameRcv,
+                sizeof(rsi_uPingRsp));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_load_web_page()                                   */
+/*      rsi_load_web_pageコマンドのレスポンスを待つ                     */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_load_web_page(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_GET_WEBPAGE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_json_create()                                     */
+/*      rsi_json_createコマンドのレスポンスを待つ                       */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_json_create(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_CREATE_JSON;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_webpage_erase_file()                              */
+/*      rsi_webpage_erase_fileコマンドのレスポンスを待つ                */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_webpage_erase_file(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_ERASE_FILE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_json_erase_file()                                 */
+/*      rsi_json_erase_fileコマンドのレスポンスを待つ                   */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_json_erase_file(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_ERASE_JSON;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_webpage_clear_files()                             */
+/*      rsi_webpage_clear_filesコマンドのレスポンスを待つ               */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_webpage_clear_files(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_CLEAR_FILES;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_send_url_rsp()                                    */
+/*      Web Page Bypassコマンドのレスポンスを待つ                       */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_send_url_rsp(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_HOST_WEBPAGE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_bytes_sent_count()                                */
+/*      rsi_bytes_sent_countコマンドのレスポンスを待つ                  */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_bytes_sent_count(rsi_sentBytesRsp *rsp,
+                                     uint16 *err_code,
+                                     int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = 0xB2;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.SentBytes,
+                sizeof(rsi_sentBytesRsp));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_socket_config()                                   */
+/*      rsi_socket_configコマンドのレスポンスを待つ                     */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_socket_config(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SOCKET_CONFIG;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_http_abort()                                      */
+/*      rsi_http_abortコマンドのレスポンスを待つ                        */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_http_abort(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_HTTP_ABORT;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_http_credentials()                                */
+/*      rsi_http_credentialsコマンドのレスポンスを待つ                  */
+/*      input   :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_http_credentials(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_HTTP_CREDENTIALS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_ftp_client()                                      */
+/*      rsi_ftp_clienttコマンドのレスポンスを待つ                       */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_ftp_client(rsi_ftp_rsp_t *rsp, uint16 *err_code,
+                               int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_FTP;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.ftpFrameRcv,
+                sizeof(rsi_ftp_rsp_t));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_ftp_file_write_content()                          */
+/*      rsi_ftp_file_write_contentコマンドのレスポンスを待つ            */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_ftp_file_write_content(rsi_ftp_rsp_t *rsp,
+                                           uint16 *err_code,
+                                           int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_FTP;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.ftpFrameRcv,
+                sizeof(rsi_ftp_rsp_t));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_sntp_client()                                     */
+/*      rsi_sntp_clientコマンドのレスポンスを待つ                       */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  server_rsp レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_sntp_client(rsi_sntp_rsp_t *rsp,
+                                rsi_sntp_server_rsp_t *server_rsp,
+                                uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 response_type;
+    uint16 wait_type[2];
+    uint8 tri_auto_flg;
+    
+    wait_type[0] = RSI_RSP_SNTP;
+    wait_type[1] = RSI_RSP_SNTP_SERVER;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(wait_type, 2, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        if(response_type == RSI_RSP_SNTP)
+        {
+            memcpy((uint8 *)rsp,
+                   (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.sntpFrameRcv,
+                   sizeof(rsi_sntp_rsp_t));
+        }
+        else if(response_type == RSI_RSP_SNTP_SERVER)
+        {
+            memcpy((uint8 *)server_rsp,
+                   (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.sntp_ServerFrameRcv,
+                   sizeof(rsi_sntp_server_rsp_t));
+        }
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_mdns_req()                                        */
+/*      rsi_mdns_reqコマンドのレスポンスを待つ                          */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_mdns_req(rsi_mdns_rsp_t *rsp, uint16 *err_code,
+                             int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_MDNS;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.mdnsFrameRcv,
+                sizeof(rsi_mdns_rsp_t));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_smtp_client()                                     */
+/*      rsi_smtp_clientコマンドのレスポンスを待つ                       */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_smtp_client(rsi_smtp_rsp_t *rsp, uint16 *err_code,
+                                int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type = RSI_RSP_SMTP;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(&wait_type, 1, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        memcpy((uint8 *)rsp,
+               (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.smtpFrameRcv,
+                sizeof(rsi_smtp_rsp_t));
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_rsp_pop3_client()                                     */
+/*      rsi_pop3_clientコマンドのレスポンスを待つ                       */
+/*      input   :  rsp        レスポンス格納先アドレス                  */
+/*              :  mail_rsp   レスポンス格納先アドレス                  */
+/*              :  err_code   エラーコード格納先アドレス                */
+/*              :  timeout    タイムアウト値                           */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_os_rsp_pop3_client(rsi_pop3_rsp_t *rsp,
+                                rsi_pop3_mail_data_resp_t *mail_rsp,
+                                uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    rsi_uCmdRsp *uCmdRspFrame;
+    uint16 wait_type[2];
+    uint16 response_type;
+    uint8 tri_auto_flg;
+    
+    wait_type[0] = RSI_RSP_POP3;
+    wait_type[1] = RSI_RSP_POP3_REMOTE_TERMINATE;
+    
+    /* レスポンス待ち */
+    retval = wmrp10_os_wait_rsp(wait_type, 2, &response_type,
+                                &tri_auto_flg, &uCmdRspFrame,
+                                err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        if(response_type == RSI_RSP_POP3)
+        {
+            memcpy((uint8 *)rsp,
+                   (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.pop3CmdFrameRcv,
+                   sizeof(rsi_pop3_rsp_t));
+        }
+        else if(response_type == RSI_RSP_POP3_REMOTE_TERMINATE)
+        {
+            memcpy((uint8 *)mail_rsp,
+                   (uint8 *)&uCmdRspFrame->uCmdRspPayLoad.pop3MailContentRcv,
+                   sizeof(rsi_pop3_mail_data_resp_t));
+        }
+    }
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_os_wait_rsp()                                            */
+/*      レスポンスを待つ                                              */
+/*      input   :  wait_type     待つレスポンスのIDの配列             */
+/*              :  type_len      待ちレスポンスの数                   */
+/*              :  res_type      レスポンスID格納先アドレス            */
+/*              :  tri_auto_flg  Auto Ttiggerフラグ格納先アドレス      */
+/*              :  uCmdRspFrame  レスポンスアドレスの格納先アドレス      */
+/*              :  err_code      エラーコード格納先アドレス             */
+/*              :  timeout       タイムアウト値                        */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+int16 wmrp10_os_wait_rsp(uint16 *wait_type,
+                                uint16 type_len,
+                                uint16 *res_type,
+                                uint8 *tri_auto_flg,
+                                rsi_uCmdRsp **uCmdRspFrame,
+                                uint16 *err_code,
+                                int32 timeout)
+{
+    int16 retval = WMRP10_ERR_SUCCESS;
+    uint16 type_index;
+    uint16 type_flg;
+    int16 ret;
+    
+    /* レスポンス待ち */
+    ret = wait_for_completion_timeout(&(g_wmrp10_os_prm.comp_rsp_cmd),
+                                      timeout * HZ / 1000);
+    if(ret < 0)
+    {
+        retval = WMRP10_ERR_TIMEOUT;
+    }
+    
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        /* レスポンスを受信 */
+        *uCmdRspFrame = (rsi_uCmdRsp *)&g_wmrp10_os_rsp.response;
+        *err_code = rsi_bytes2R_to_uint16((uint8 *)g_wmrp10_os_rsp.response.status);
+        *res_type = rsi_bytes2R_to_uint16((uint8 *)g_wmrp10_os_rsp.response.rspCode);
+        *tri_auto_flg = g_wmrp10_os_rsp.trigger_auto_flg;
+        
+        /* 待ちレスポンスIDの確認 */
+	for(type_index = 0; type_index < type_len; type_index++)
+        {
+            if(*res_type == wait_type[type_index])
+            {
+                if(*err_code == 0x0000)
+                {
+                    retval = WMRP10_ERR_SUCCESS;
+                }
+                else
+                {
+                    retval = WMRP10_ERR_CMD;/* IDは正しいがエラー発生 */
+                }
+                break;
+            }
+        }
+    }
+    return retval;
+}
+
+/* End of File */
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_os.h b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_os.h
new file mode 100755
index 0000000..75a2827
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_os.h
@@ -0,0 +1,185 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_os.h                                                    */
+/*   WLAN OS依存部                                                  */
+/*                                                                  */
+/*   2019/07/19 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#ifndef _WMRP10_OS_H_
+#define _WMRP10_OS_H_
+
+#include <linux/module.h>
+
+#include "rsi_global.h"
+#include "wmrp10_rsi.h"
+
+/***** 初期化 *****/
+int16 wmrp10_os_init(void);
+
+/***** 終了処理 *****/
+int16 wmrp10_os_exit(void);
+
+/***** 排他制御 *****/
+int16 wmrp10_os_spi_lock(void);
+int16 wmrp10_os_spi_unlock(void);
+int16 wmrp10_os_cmd_lock(void);
+int16 wmrp10_os_cmd_unlock(void);
+
+
+/***** 受信したものを振り分ける *****/
+int16 wmrp10_os_fr_cmd(rsi_uCmdRsp *rsp,
+                       uint8 trigger_auto_flg);
+int16 wmrp10_os_fr_data(uint8 *read_packet_buffer, rsi_uCmdRsp *rsp);
+int16 wmrp10_os_fr_msg(uint8 *read_packet_buffer, rsi_uCmdRsp *rsp);
+
+
+/***** レスポンスを受ける *****/
+/* コマンド同期 */
+int16 wmrp10_os_rsp_select_option(uint8 *rsp, uint16 *err_code,
+                                  int32 timeout);
+int16 wmrp10_os_rsp_oper_mode(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_band(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_set_mac_addr(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_init(rsi_initResponse *rsp, uint16 *err_code,
+                         int32 timeout);
+int16 wmrp10_os_rsp_per_mode(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_select_antenna(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_p2p_config(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_set_ap_config(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_wps_method(rsi_wpsMethodFrameRcv *rsp,
+                               uint16 *err_code,
+                               int32 timeout);
+int16 wmrp10_os_rsp_scan(rsi_scanResponse *rsp, uint16 *err_code,
+                         int32 timeout);
+int16 wmrp10_os_rsp_join(rsi_joinResponse *rsp, uint16 *err_code,
+                         int32 timeout);
+int16 wmrp10_os_rsp_rejoin_params(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_wmm_ps(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_sleep_timer(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_power_mode(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_psk(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_set_wepkey(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_set_eap(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_set_certificate(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_disconnect(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_bg_scan(rsi_scanResponse *rsp, uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_os_rsp_roam_params(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_ht_caps(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_query_fw_version(rsi_qryFwversionFrameRcv *rsp,
+                                     uint16 *err_code,
+                                     int32 timeout);
+int16 wmrp10_os_rsp_query_rssi(rsi_rssiFrameRcv *rsp, uint16 *err_code,
+                               int32 timeout);
+int16 wmrp10_os_rsp_query_mac_address(rsi_qryMacFrameRcv *rsp,
+                                      uint16 *err_code,
+                                      int32 timeout);
+int16 wmrp10_os_rsp_query_net_parms(rsi_qryNetParmsFrameRcv *rsp,
+                                    uint16 *err_code,
+                                    int32 timeout);
+int16 wmrp10_os_rsp_query_go_parms(rsi_qryGOParamsFrameRcv *rsp,
+                                   uint16 *err_code,
+                                   int32 timeout);
+int16 wmrp10_os_rsp_multicast_mac_filter(uint16 *err_code,
+                                         int32 timeout);
+int16 wmrp10_os_rsp_multicast(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_set_region(rsi_uSetRegionRsp *rsp, uint16 *err_code,
+                               int32 timeout);
+int16 wmrp10_os_rsp_set_region_ap(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_query_conn_status(rsi_conStatusFrameRcv *rsp,
+                                      uint16 *err_code,
+                                      int32 timeout);
+int16 wmrp10_os_rsp_debug_prints(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_rf_current_config(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_trigger_auto_config(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_cfg_save(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_cfg_enable(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_cfg_get(rsi_cfgGetFrameRcv *rsp, uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_os_rsp_user_store_config(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_host_rtc_time(uint16 *err_code, int32 timeout);
+
+/* コマンド同期 */
+int16 wmrp10_os_rsp_cmd(uint16 *wait_type,uint16 type_len,
+                        uint16 *res_type,uint8 *tri_auto_flg,
+                        rsi_uCmdRsp **uCmdRspFrame,uint16 *err_code,
+                        int32 timeout);
+int16 wmrp10_os_wait_rsp(uint16 *wait_type,
+                                uint16 type_len,
+                                uint16 *res_type,
+                                uint8 *tri_auto_flg,
+                                rsi_uCmdRsp **uCmdRspFrame,
+                                uint16 *err_code,
+                                int32 timeout);
+/* コマンド非同期 */
+
+int16 wmrp10_os_rsp_data(uint8 *rsp, uint16 *bytes_recv,
+                         int32 timeout);
+int16 wmrp10_os_rsp_msg(T_MYMSG_MSG *rsp, int32 timeout);
+
+#if !WMRP10_TCP_IP_BYPASS
+/* コマンド同期 */
+int16 wmrp10_os_rsp_ip_param_set(rsi_ipparamFrameRcv *rsp,
+                                 uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_ipv6_param_set(rsi_ipconf6FrameRcv *rsp,
+                                   uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_snmp_enable(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_snmp_get_rsp(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_snmp_get_next_rsp(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_snmp_trap(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_socket(rsi_socketFrameRcv *rsp, uint16 *err_code,
+                           int32 timeout);
+int16 wmrp10_os_rsp_socket_close(rsi_socketCloseFrameRcv *rsp,
+                                 uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_ltcp_conn_status(rsi_LtcpConnStatusFrameRcv *rsp,
+                                     uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_dns_server(rsi_dnsserverResponse *rsp,
+                               uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_dns_query(TCP_EVT_DNS_Query_Resp *rsp,
+                              uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_http_get(rsi_uHttpRsp *rsp, uint16 *err_code,
+                             int32 timeout);
+int16 wmrp10_os_rsp_http_post(rsi_uHttpRsp *rsp, uint16 *err_code,
+                              int32 timeout);
+int16 wmrp10_os_rsp_http_post_data(rsi_uHttpRsp *rsp, uint16 *err_code,
+                                   int32 timeout);
+int16 wmrp10_os_rsp_ping_request(rsi_uPingRsp *rsp, uint16 *err_code,
+                                 int32 timeout);
+int16 wmrp10_os_rsp_load_web_page(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_json_create(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_webpage_erase_file(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_json_erase_file(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_webpage_clear_files(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_send_url_rsp(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_bytes_sent_count(rsi_sentBytesRsp *rsp,
+                                     uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_socket_config(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_http_abort(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_http_credentials(uint16 *err_code, int32 timeout);
+int16 wmrp10_os_rsp_ftp_client(rsi_ftp_rsp_t *rsp, uint16 *err_code,
+                               int32 timeout);
+int16 wmrp10_os_rsp_ftp_file_write_content(rsi_ftp_rsp_t *rsp,
+                                           uint16 *err_code,
+                                           int32 timeout);
+int16 wmrp10_os_rsp_sntp_client(rsi_sntp_rsp_t *rsp,
+                                rsi_sntp_server_rsp_t *server_rsp,
+                                uint16 *err_code,
+                                int32 timeout);
+int16 wmrp10_os_rsp_mdns_req(rsi_mdns_rsp_t *rsp, uint16 *err_code,
+                             int32 timeout);
+int16 wmrp10_os_rsp_smtp_client(rsi_smtp_rsp_t *rsp, uint16 *err_code,
+                                int32 timeout);
+int16 wmrp10_os_rsp_pop3_client(rsi_pop3_rsp_t *rsp,
+                                rsi_pop3_mail_data_resp_t *mail_rsp,
+                                uint16 *err_code,
+                                int32 timeout);
+
+
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+
+#endif /* _WMRP10_OS_H_ */
+
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_rsi.c b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_rsi.c
new file mode 100755
index 0000000..1a96dc1
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_rsi.c
@@ -0,0 +1,5140 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_rsi.c                                                   */
+/*   WLANコマンド                                                   */
+/*                                                                  */
+/*   2019/05/23 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+/*
+ コマンドを発行し、そのレスポンスを取得する関数群。
+ このファイルの内容は処理系に依存しません。
+*/
+
+#include "wmrp10_rsi.h"
+#include "wmrp10_os.h"
+
+static uint8 *wmrp10_rsi_wrapper_to_rsp(uint8 *rsp, uint8 rsp_type);
+
+rsi_app_cb_t rsi_app_cb;
+unsigned char wmrp10_rsicmd_flg = 0x00;
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_frame_read()                                         */
+/*      レスポンスまたはデータまたはメッセージを受信して仕分ける。  */
+/*      input   :  なし                                             */
+/*      return  :  WMRP10_ERR_SUCCESS   成功                        */
+/*              :  その他               失敗                        */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_frame_read(void)
+{
+    int16  ret;
+    int16  retval = WMRP10_ERR_NON_RECV;
+    int16  os_retval;
+    uint16 response_type;
+    uint8  int_status = 0;
+    uint8  trigger_auto_flg;
+    
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    
+    rsi_device_interrupt_status(&int_status);
+    if(int_status & 0x08)
+    {
+        ret = rsi_frame_read(rsi_app_cb.read_packet_buffer);
+	trigger_auto_flg = rsi_app_cb.read_packet_buffer[15];
+        rsi_app_cb.uCmdRspFrame = wmrp10_rsi_parse_response(rsi_app_cb.read_packet_buffer);
+
+        if(ret == RSI_SUCCESS)
+        {
+            response_type = rsi_bytes2R_to_uint16(rsi_app_cb.uCmdRspFrame->rspCode);
+            switch(response_type)
+            {
+            /***** コマンド発行後のレスポンス */
+            case RSI_RSP_OPERMODE:             /* rsi_oper_mode */
+            case RSI_RSP_BAND:                      /* rsi_band */
+            case RSI_RSP_INIT:                      /* rsi_init */
+            case RSI_RSP_SCAN:                      /* rsi_scan */
+            case RSI_RSP_PWRMODE:             /* rsi_power_mode */
+            case RSI_RSP_SLEEP_TIMER:        /* rsi_sleep_timer */
+            case RSI_RSP_MACADDRESS_SET:    /* rsi_set_mac_addr */
+            case RSI_RSP_NETWORK_PARAMS: /* rsi_query_net_parms */
+            case RSI_RSP_DISCONNECT:          /* rsi_disconnect */
+            case RSI_RSP_ANTENNA_SEL:     /* rsi_select_antenna */
+            case RSI_RSP_SET_REG_CODE:        /* rsi_set_region */
+            case RSI_RSP_CFG_SAVE:              /* rsi_cfg_save */
+            case RSI_RSP_CFG_ENABLE:          /* rsi_cfg_enable */
+            case RSI_RSP_CFG_GET:                /* rsi_cfg_get */
+            case RSI_RSP_USER_STORE_CFG:/*rsi_user_store_config */
+            case RSI_RSP_APCONFIG:         /* rsi_set_ap_config */
+            case RSI_RSP_SET_WEP_KEY:         /* rsi_set_wepkey */
+            case RSI_RSP_DEBUG_PRINTS:      /* rsi_debug_prints */
+            case RSI_RSP_PING_PACKET:       /* rsi_ping_request */
+            case RSI_RSP_RSSI_QUERY:          /* rsi_query_rssi */
+            case RSI_RSP_MULTICAST_FILTER:/*rsi_multicast_mac_filter*/
+            case RSI_RSP_SOCKET_CREATE:           /* rsi_socket */
+            case RSI_RSP_CLOSE:             /* rsi_socket_close */
+            case RSI_RSP_DNS_QRY:              /* rsi_dns_query */
+            case RSI_RSP_TCP_CONN_STATUS_QUERY:/* rsi_ltcp_conn_status */
+            case RSI_RSP_CONNECTION_STATUS: /* rsi_query_conn_status */
+            case RSI_RSP_FWVERSION_QUERY:/*rsi_query_fw_version */
+            case RSI_RSP_MAC_QUERY:    /* rsi_query_mac_address */
+            case RSI_RSP_CFG_P2P:             /* rsi_p2p_config */
+            case RSI_RSP_SET_EAP_CFG:            /* rsi_set_eap */
+            case RSI_RSP_SET_CERT:       /* rsi_set_certificate */
+            case RSI_RSP_QUERY_GO_PARAMS: /* rsi_query_go_parms */
+            case RSI_RSP_GET_WEBPAGE:      /* rsi_load_web_page */
+            case RSI_RSP_HTTP_GET:              /* rsi_http_get */
+            case RSI_RSP_HTTP_POST:            /* rsi_http_post */
+            case RSI_RSP_HOST_WEBPAGE:          /* URL response */
+            case RSI_RSP_BG_SCAN:                /* rsi_bg_scan */
+            case RSI_RSP_AP_HT_CAPS:             /* rsi_ht_caps */
+            case RSI_RSP_REJOIN_PARAMS:    /* rsi_rejoin_params */
+            case RSI_RSP_WPS_METHOD:          /* rsi_wps_method */
+            case RSI_RSP_ROAM_PARAMS:        /* rsi_roam_params */
+            case RSI_RSP_DNS_SERVER:          /* rsi_dns_server */
+            case RSI_RSP_DNS_UPDATE:          /* rsi_dns_update */
+            case RSI_RSP_PER_PARAMS:            /* rsi_per_mode */
+            case RSI_RSP_CLEAR_FILES:/* rsi_webpage_clear_files */
+            case RSI_RSP_CARD_READY:       /* rsi_select_option */
+            case 0x91:               /* rsi_trigger_auto_config */
+            case RSI_RSP_WMM_PS:                  /* rsi_wmm_ps */
+            case RSI_RSP_ERASE_FILE:  /* rsi_webpage_erase_file */
+            case RSI_RSP_ERASE_JSON:     /* rsi_json_erase_file */
+            case RSI_RSP_CREATE_JSON:        /* rsi_json_create */
+            case RSI_RSP_IPCONF6:         /* rsi_ipv6_param_set */
+            case RSI_RSP_HOST_PSK:                   /* rsi_psk */
+            case RSI_RSP_SOCKET_CONFIG:    /* rsi_socket_config */
+            case RSI_RSP_RF_CURRENT_CONFIG:/*rsi_rf_current_config*/
+            case RSI_RSP_MULTICAST:            /* rsi_multicast */
+            case RSI_RSP_SENT_BYTES:    /* rsi_bytes_sent_count */
+            case RSI_RSP_HTTP_ABORT:          /* rsi_http_abort */
+            case RSI_RSP_HTTP_CREDENTIALS:/*rsi_http_credentials*/
+            case RSI_RSP_SET_REG_AP:       /* rsi_set_region_ap */
+            case RSI_RSP_MDNS:                  /* rsi_mdns_req */
+            case RSI_RSP_FTP:                 /* rsi_ftp_client */
+                                  /* rsi_ftp_file_write_content */
+            case RSI_RSP_SNTP:               /* rsi_sntp_client */
+            case RSI_RSP_SNTP_SERVER:        /* rsi_sntp_client */
+            case RSI_RSP_SNMP_GET_RSP:      /* rsi_snmp_get_rsp */
+            case RSI_RSP_SNMP_GETNEXT_RSP:/*rsi_snmp_get_next_rsp*/
+            case RSI_RSP_SNMP_ENABLE:        /* rsi_snmp_enable */
+            case RSI_RSP_SNMP_TRAP:            /* rsi_snmp_trap */
+            case RSI_RSP_SNMP_GET_STATS:  /* rsi_snmp_get_stats */
+            case RSI_RSP_SMTP:               /* rsi_smtp_client */
+            case RSI_RSP_POP3:               /* rsi_pop3_client */
+            case RSI_RSP_POP3_REMOTE_TERMINATE:
+            case 0xE9:                     /* rsi_host_rtc_time */
+            case RSI_RSP_HTTP_POST_DATA:  /* rsi_http_post_data */
+            case RSI_RSP_HTTP_CLIENT_PUT:/* rsi_http_client_put */
+            case RSI_RSP_TIMEOUT:                /* rsi_timeout */
+            case RSI_RSP_OTA_FW_UP:            /* rsi_ota_fw_up */
+            case RSI_RSP_CONFIG:                  /* rsi_config */
+                retval = wmrp10_os_fr_cmd(rsi_app_cb.uCmdRspFrame,
+                                          trigger_auto_flg);
+                break;
+            case RSI_RSP_JOIN:                      /* rsi_join */
+            case RSI_RSP_IPPARAM_CONFIG:    /* rsi_ip_param_set */
+                if(wmrp10_rsicmd_flg == 0x00)
+                {
+                    retval = wmrp10_os_fr_msg(rsi_app_cb.read_packet_buffer,
+                                              rsi_app_cb.uCmdRspFrame);
+                }
+                else
+                {
+                    retval = wmrp10_os_fr_cmd(rsi_app_cb.uCmdRspFrame,
+                                              trigger_auto_flg);
+                    wmrp10_rsicmd_flg = 0x00;
+                }
+                break;
+            /***** データ *****/
+            case RSI_RSP_DATA_RECEIVE:
+                retval = wmrp10_os_fr_data(rsi_app_cb.read_packet_buffer,
+                                           rsi_app_cb.uCmdRspFrame);
+                break;
+            /***** 非同期メッセージ *****/
+            case RSI_RSP_P2P_CONNREQ:
+            case RSI_RESP_WFD_DEV:
+            case RSI_FWUP_RSP:                /* Wireless Firmware Upgrade(要求) */
+            case RSI_FWUP_OK:                 /* Wireless Firmware Upgrade(完了) */
+            case RSI_RSP_CONN_ESTABLISH:      /* TCP Socket Connection Established */
+            case RSI_RSP_REMOTE_TERMINATE:    /* Remote socket Closure */
+            case 0x64:                        /* URL request */
+            case RSI_RSP_MODULE_STATE:        /* Asynchronous message for connection state notification */
+            case RSI_REQ_SNMP_GET:            /* SNMP Get */
+            case RSI_REQ_SNMP_GETNEXT:        /* SNMP Get Next */
+            case RSI_REQ_SNMP_SET:            /* SNMP Set */
+            case RSI_RSP_PER_STATS:           /* rsi_per_stats */
+            case RSI_RSP_IPCHANGE_NOTIFY:     /* IP Change Notification */
+            case RSI_RSP_CLIENT_CONNECTED:    /* Station connect indication in AP mode */
+            case RSI_RSP_CLIENT_DISCONNECTED: /* Station disconnect indication in AP mode */
+                retval = wmrp10_os_fr_msg(rsi_app_cb.read_packet_buffer,
+                                          rsi_app_cb.uCmdRspFrame);
+                break;
+            default:
+                retval = WMRP10_ERR_ABORT;
+                break;
+            }
+        }
+        else
+        {
+            /* frame readが失敗するとここに来る */
+            retval = WMRP10_ERR_ABORT;
+        }
+    }
+    
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_parse_response()                                     */
+/*      レスポンスバッファの解析                                    */
+/*      input   :  rsp  レスポンスバッファ                          */
+/*      return  :  レスポンスフレームへのポインタ                   */
+/*                 (ID+エラーコード+ペイロード)                     */
+/*------------------------------------------------------------------*/
+rsi_uCmdRsp *wmrp10_rsi_parse_response(uint8 *rsp)
+{
+    rsi_uCmdRsp *temp_uCmdRspPtr = NULL;
+    uint8 temp_rspCode;
+    uint16 temp_status;
+    uint8 *descPtr = rsp;
+    uint8 *payloadPtr = rsp + RSI_FRAME_DESC_LEN;
+    
+    /* In Response received First 24 bytes are header.
+     * And then Desc and Payload of the response is present.
+     * 2nd byte of the Desc is status and 14th byte of the Desc is RspType.
+     */
+    
+    /* Retrieve response code from the received packet */
+    temp_status = rsi_bytes2R_to_uint16(descPtr + RSI_STATUS_OFFSET);
+    temp_rspCode = rsi_bytes2R_to_uint16(descPtr + RSI_RSP_TYPE_OFFSET);
+    
+    /* this function does re arrange of the reponse
+     for the responses where the response structures are padded in between
+     */
+    if(!temp_status)
+    {
+        rsp = wmrp10_rsi_wrapper_to_rsp(rsp, temp_rspCode);
+    }
+    
+    /* Copy the response type and status to payloadPtr-4, payloadPtr-2
+     * locations respectively.
+     */
+    rsi_uint16_to_2bytes((payloadPtr - 2), temp_status);
+    rsi_uint16_to_2bytes((payloadPtr - 4), temp_rspCode);
+    
+    temp_uCmdRspPtr = (rsi_uCmdRsp *)(payloadPtr - 4);
+    
+    return temp_uCmdRspPtr;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_wrapper_to_rsp()                                     */
+/*      レスポンスフレームの再組み立て                              */
+/*      input   :  rsp       レスポンスバッファ                     */
+/*              :  rsp_type  レスポンスID                           */
+/*      return  :  レスポンスフレームへのポインタ                   */
+/*                 (ID+エラーコード+ペイロード)                     */
+/*------------------------------------------------------------------*/
+static uint8 *wmrp10_rsi_wrapper_to_rsp(uint8 *rsp, uint8 rsp_type)
+{
+    uint8 *descPtr = rsp;
+    uint8 *payloadPtr;
+    uint8 *temp_payloadPtr;
+    uint8 i;
+    uint8 scanInfo_size;
+    rsi_scanResponse scanRsp;
+    rsi_wfdDevResponse wfdDevResp;
+    
+    switch(rsp_type)
+    {
+        case RSI_RSP_SCAN:
+            scanInfo_size = 46;
+            /* 1 + 1 + 1 + 1 + 34 + 6 + 1 + 1 = 46 */
+            /* (sizeof scaninfo structure without padding bytes */
+            memset(&scanRsp, 0, sizeof(rsi_scanResponse));
+            descPtr = rsp;
+            temp_payloadPtr = payloadPtr = descPtr + RSI_FRAME_DESC_LEN;
+            scanRsp.scanCount[0] = *(payloadPtr);
+            if(scanRsp.scanCount[0] != 0)
+            {
+                payloadPtr += 8; /* move to  (scan count + reserved bytes) */
+                
+                for(i = 0; i < scanRsp.scanCount[0]; i++)
+                {
+                    memcpy(&scanRsp.strScanInfo[i], payloadPtr,
+                           scanInfo_size);
+                    payloadPtr += scanInfo_size;
+                }
+                memcpy(temp_payloadPtr, (uint8 *)&scanRsp,
+                       sizeof(rsi_scanResponse));
+            }
+            break;
+        case RSI_RESP_WFD_DEV:
+            memset(&wfdDevResp, 0, sizeof(rsi_wfdDevResponse));
+            descPtr = rsp ;
+            temp_payloadPtr = payloadPtr = descPtr + RSI_FRAME_DESC_LEN;
+            wfdDevResp.devCount = (descPtr[0] | ((descPtr[1] & 0x0f) << 8))/41;
+            /* 1byte(devState) + 32byte(devName) + 6byte(macAddress) + 2byte(devtype)*/
+            for(i = 0; i < wfdDevResp.devCount; i++)
+            {
+                wfdDevResp.strWfdDevInfo[i].devState = *(payloadPtr);
+                payloadPtr += 1;
+                memcpy(wfdDevResp.strWfdDevInfo[i].devName, payloadPtr, 32);
+                payloadPtr += 32;
+                memcpy(wfdDevResp.strWfdDevInfo[i].macAddress, payloadPtr, 6);
+                payloadPtr += 6;
+                memcpy(wfdDevResp.strWfdDevInfo[i].devtype, payloadPtr, 2);
+                payloadPtr += 2;
+            }
+            memcpy(temp_payloadPtr, (uint8 *)&wfdDevResp, sizeof(rsi_wfdDevResponse));
+            break;
+        default:
+            break;
+    }
+    
+    return rsp;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_sys_init()                                           */
+/*      初期化                                                      */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_sys_init(void)
+{
+    int16 ret;
+    int16 os_retval;
+    int16 retval = WMRP10_ERR_SUCCESS;
+    
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+
+    ret = rsi_sys_init();
+    if(ret != RSI_SUCCESS)
+    {
+        retval = WMRP10_ERR_ABORT;
+    }
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_waitfor_boardready()                                 */
+/*      boardready待ち                                              */
+/*      input   :  なし                                             */
+/*      return  :  0     成功                                       */
+/*              :  1     boardready待ち                             */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_waitfor_boardready(void)
+{
+    int16 ret;
+    int16 retval;
+    int16 os_retval;
+    
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    ret = rsi_waitfor_boardready();
+    
+    switch(ret)
+    {
+        case 0:
+            retval = WMRP10_ERR_SUCCESS;
+            break;
+        case -3:
+            retval = WMRP10_ERR_NOT_READY;
+            break;
+        default:
+            retval = WMRP10_ERR_ABORT;
+            break;
+    }
+    /* 0  = SUCCESS                                     */
+    /* -3 = Board ready not received                    */
+    /* -4 = Bootup options last configuration not saved */
+    /* -5 = Bootup options checksum failed              */
+    /* -6 = Bootloader version mismatch                 */
+    
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_upgrade_fw()                                         */
+/*      Firmware upgrade                                            */
+/*      input   :  image_type      type of firmware image           */
+/*              :  fw_image        pointer to firmware image        */
+/*              :  fw_image_size   size of firmware image           */
+/*      return  :  0               成功                             */
+/*              :  < 0             失敗                             */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_upgrade_fw(uint8 image_type, uint8 *fw_image,
+                            uint32 fw_image_size)
+{
+    int16 ret;
+    int16 os_retval;
+    int16 retval = WMRP10_ERR_SUCCESS;
+    
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    ret = rsi_upgrade_fw(image_type, fw_image, fw_image_size);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(ret != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();           /* コマンド排他制御(終了) */
+        retval = WMRP10_ERR_ABORT;
+    }
+    
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_select_option()                                      */
+/*      Bootload Process                                            */
+/*      input   :  cmd           RSI_LOAD_IMAGE_I_FW                */
+/*              :  tri_auto_flg                                     */
+/*              :  err_code      エラーコード格納先アドレス         */
+/*              :  timeout       タイムアウト値(-1:FEVER)           */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_select_option(uint8 cmd, uint8 *tri_auto_flg,
+                               uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_select_option(cmd);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CARD_READY;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_oper_mode()                                          */
+/*      Set Operating Modeコマンドを発行しレスポンスを待つ          */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_oper_mode(rsi_uOperMode *req, uint16 *err_code,
+                           int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_oper_mode(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_OPERMODE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_band()                                               */
+/*      Bandコマンドを発行しレスポンスを待つ                        */
+/*      input   :  band       RSI_BAND_2P4GHZ                       */
+/*              :             RSI_BAND_5GHZ                         */
+/*              :             RSI_DUAL_BAND                         */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_band(uint8 band, uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_band(band);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_BAND;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_config()                                             */
+/*      WLAN Configコマンドを発行しレスポンスを待つ                 */
+/*      input   :  config_type   1:To configure RTS threshold value */
+/*              :  config_value  RTS threshold value(256～2346)     */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_config(uint16 config_type, uint16 config_value,
+                        uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_config(config_type, config_value);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CONFIG;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_set_mac_addr()                                       */
+/*      Set MAC Addressコマンドを発行しレスポンスを待つ             */
+/*      input   :  macAddress                                       */
+/*              :  err_code     エラーコード格納先アドレス          */
+/*              :  timeout      タイムアウト値(-1:FEVER)            */
+/*      return  :  0            成功                                */
+/*              :  < 0          失敗                                */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_set_mac_addr(uint8 *macAddress, uint16 *err_code,
+                              int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_set_mac_addr(macAddress);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_MACADDRESS_SET;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_init()                                               */
+/*      Initコマンドを発行しレスポンスを待つ                        */
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_init(rsi_initResponse *rsp, uint16 *err_code,
+                      int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_init();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_INIT;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.initResponse;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_per_mode()                                           */
+/*      PER Modeコマンドを発行しレスポンスを待つ                    */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_per_mode(rsi_uPerMode *req, uint16 *err_code,
+                          int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_per_mode(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_PER_PARAMS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                           &tri_auto_flg, &uCmdRspFrame,
+                           err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_select_antenna()                                     */
+/*      Antenna Selectionコマンドを発行しレスポンスを待つ           */
+/*      input   :  antenna_val   0:Internal 1:uFL connector         */
+/*              :  gain_2g                                          */
+/*              :  gain_5g                                          */
+/*              :  antenna_path                                     */
+/*              :  antenna_type                                     */
+/*              :  err_code      エラーコード格納先アドレス         */
+/*              :  timeout       タイムアウト値(-1:FEVER)           */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_select_antenna(uint8 antenna_val, uint8 gain_2g, uint8 gain_5g,
+                                uint8 antenna_path, uint8 antenna_type,
+                                uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_select_antenna(antenna_val, gain_2g, gain_5g,
+                                antenna_path, antenna_type);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_ANTENNA_SEL;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_p2p_config()                                         */
+/*      Configure Wi-Fi Direct Peer-to-Peerコマンドを発行し         */
+/*      レスポンスを待つ                                            */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_p2p_config(rsi_uConfigP2p *req, uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_p2p_config(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CFG_P2P;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_set_ap_config()                                      */
+/*      Configure AP Modeコマンドを発行しレスポンスを待つ           */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_set_ap_config(rsi_apconfig *req, uint16 *err_code,
+                               int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_set_ap_config(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_APCONFIG;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_wps_method()                                         */
+/*      WPS PIN Methodコマンドを発行しレスポンスを待つ              */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_wps_method(rsi_uWpsMethod *req,
+                            rsi_wpsMethodFrameRcv *rsp,
+                            uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_wps_method(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_WPS_METHOD;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.wpsMethodFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_scan()                                               */
+/*      Scanコマンドを発行しレスポンスを待つ                        */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_scan(rsi_uScan *req, rsi_scanResponse *rsp,
+                      uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_scan(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SCAN;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.scanResponse;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_join()                                               */
+/*      Joinコマンドを発行しレスポンスを待つ                        */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_join(rsi_uJoin *req, rsi_joinResponse *rsp,
+                      uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    wmrp10_rsicmd_flg = 0x01;
+    retval = rsi_join(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_JOIN;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.joinResponse;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_timeout()                                            */
+/*      Request timeoutコマンドを発行しレスポンスを待つ             */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_timeout(rsi_utimeout *req, uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_timeout(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_TIMEOUT;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_rejoin_params()                                      */
+/*      Re-Joinコマンドを発行しレスポンスを待つ                     */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_rejoin_params(rsi_rejoin_params_t *req,
+                               uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_rejoin_params(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_REJOIN_PARAMS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_wmm_ps()                                             */
+/*      WMM PSコマンドを発行しレスポンスを待つ                      */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_wmm_ps(rsi_uWmmPs *req, uint16 *err_code,
+                        int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_wmm_ps(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_WMM_PS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_sleep_timer()                                        */
+/*      Set Sleep Timerコマンドを発行しレスポンスを待つ             */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_sleep_timer(rsi_uSleepTimer *req, uint16 *err_code,
+                             int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_sleep_timer(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SLEEP_TIMER;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_power_mode()                                         */
+/*      Power Modeコマンドを発行しレスポンスを待つ                  */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_power_mode(rsi_uPower *req, uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_power_mode(req->powerFrameSnd.powerVal,
+                            req->powerFrameSnd.ulp_mode_enable,
+                            req->powerFrameSnd.listen_interval_dtim,
+                            req->powerFrameSnd.rsi_psp_type,
+                            req->powerFrameSnd.monitor_interval);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_PWRMODE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_psk()                                                */
+/*      PSKコマンドを発行しレスポンスを待つ                         */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_psk(rsi_uPsk *req, uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_psk(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_HOST_PSK;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_set_wepkey()                                         */
+/*      Set WEP Keysコマンドを発行しレスポンスを待つ                */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_set_wepkey(rsi_wepkey *req, uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_set_wepkey(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SET_WEP_KEY;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_set_eap()                                            */
+/*      Set EAP Configurationコマンドを発行しレスポンスを待つ       */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_set_eap(rsi_uSetEap *req, uint16 *err_code,
+                         int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_set_eap(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SET_EAP_CFG;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_set_certificate()                                    */
+/*      Set Certificateコマンドを発行しレスポンスを待つ             */
+/*      input   :  certificate_type                                 */
+/*              :  buffer                                           */
+/*              :  certificate_length                               */
+/*              :  SetChunkPtr                                      */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_set_certificate(uint8 certificate_type,
+                                 uint8 *buffer,
+                                 uint32 certificate_length,
+                                 struct SET_CHUNK_S *SetChunkPtr,
+                                 uint16 *err_code,
+                                 int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_set_certificate(certificate_type, buffer,
+                                 certificate_length, SetChunkPtr);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SET_CERT;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_disconnect()                                         */
+/*      Disassociateコマンドを発行しレスポンスを待つ                */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_disconnect(rsi_disassoc_t *req, uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_disconnect(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_DISCONNECT;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_wireless_fwupgrade()                                 */
+/*      Wireless Firmware Upgradeコマンドを発行する                 */
+/*      input   :  なし                                             */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_wireless_fwupgrade(void)
+{
+    int16 retval;
+    int16 os_retval;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_wireless_fwupgrade();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* 非同期レスポンスを他で待つ */
+    
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bg_scan()                                            */
+/*      Back ground scan(BG scan)コマンドを発行しレスポンスを待つ   */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_bg_scan(rsi_ubgScan *req, rsi_scanResponse *rsp,
+                         uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bg_scan(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_BG_SCAN;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.scanResponse;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_roam_params()                                        */
+/*      Roam Parametersコマンドを発行しレスポンスを待つ             */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_roam_params(rsi_uRoamParams *req, uint16 *err_code,
+                             int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_roam_params(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_ROAM_PARAMS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ht_caps()                                            */
+/*      HT Capsコマンドを発行しレスポンスを待つ                     */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_ht_caps(rsi_uHtCaps *req, uint16 *err_code,
+                         int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ht_caps(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_AP_HT_CAPS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_query_fw_version()                                   */
+/*      Query Firmware Versionコマンドを発行しレスポンスを待つ      */
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_query_fw_version(rsi_qryFwversionFrameRcv *rsp,
+                                  uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_query_fw_version();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_FWVERSION_QUERY;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.qryFwversionFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_query_rssi()                                         */
+/*      Query RSSI Valueコマンドを発行しレスポンスを待つ            */
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_query_rssi(rsi_rssiFrameRcv *rsp, uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_query_rssi();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_RSSI_QUERY;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.rssiFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_query_mac_address()                                  */
+/*      Query MAC Addressコマンドを発行しレスポンスを待つ           */
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_query_mac_address(rsi_qryMacFrameRcv *rsp,
+                                   uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_query_mac_address();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_MAC_QUERY;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.qryMacaddress;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_query_net_parms()                                    */
+/*      Query Network Parametersコマンドを発行しレスポンスを待つ    */
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_query_net_parms(rsi_qryNetParmsFrameRcv *rsp,
+                                 uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_query_net_parms();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_NETWORK_PARAMS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.qryNetParmsFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_query_go_parms()                                     */
+/*      Query Group Owner Parametersコマンドを発行しレスポンスを待つ*/
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_query_go_parms(rsi_qryGOParamsFrameRcv *rsp,
+                                uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_query_go_parms();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_QUERY_GO_PARAMS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.qryGoParamsFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_multicast_mac_filter()                               */
+/*      Set/Reset multicast filterコマンドを発行しレスポンスを待つ  */
+/*      input   :  cmd        コマンドタイプ                        */
+/*              :  MAC        マルチキャストMACアドレス             */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_multicast_mac_filter(uint8 cmd, uint8 MAC[6],
+                                      uint16 *err_code,
+                                      int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_multicast_mac_filter(cmd, MAC);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_MULTICAST_FILTER;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_multicast()                                          */
+/*      rsi_multicastコマンドを発行しレスポンスを待つ               */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_multicast(rsi_uMulticast *req, uint16 *err_code,
+                           int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_multicast(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_MULTICAST;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_set_region()                                         */
+/*      Set Regionコマンドを発行しレスポンスを待つ                  */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_set_region(rsi_usetregion *req,
+                            rsi_uSetRegionRsp *rsp,
+                            uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_set_region(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SET_REG_CODE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.setRegFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_set_region_ap()                                      */
+/*      Set Region of Access pointコマンドを発行しレスポンスを待つ  */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_set_region_ap(rsi_usetregion_ap_t *req,
+                               uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_set_region_ap(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SET_REG_AP;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_per_stats()                                          */
+/*      PER statistics of the moduleコマンドを発行する              */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_per_stats(rsi_uPerStats *req, uint16 *err_code)
+{
+    int16 retval;
+    int16 os_retval;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_per_stats(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンスは来ない */
+    
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_query_conn_status()                                  */
+/*      Query WLAN Connection Statusコマンドを発行しレスポンスを待つ*/
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_query_conn_status(rsi_conStatusFrameRcv *rsp,
+                                   uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_query_conn_status();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CONNECTION_STATUS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.conStatusFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_debug_prints()                                       */
+/*      Debug prints on UART2コマンドを発行しレスポンスを待つ       */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_debug_prints(rsi_uDebug *req, uint16 *err_code,
+                              int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_debug_prints(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_DEBUG_PRINTS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_rf_current_config()                                  */
+/*      RF Current mode Configurationコマンドを発行しレスポンスを待つ*/
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_rf_current_config(rsi_rf_current_config_t *req,
+                                   uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_rf_current_config(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_RF_CURRENT_CONFIG;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_trigger_auto_config()                                */
+/*      Trigger Auto Configurationコマンドを発行する                */
+/*      input   :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_trigger_auto_config(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    /*
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;*/
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_trigger_auto_config();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンスは来ない */
+    
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_cfg_save()                                           */
+/*      Store Configuration in Flash Memoryコマンドを発行し         */
+/*      レスポンスを待つ                                            */
+/*      input   :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_cfg_save(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_cfg_save();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CFG_SAVE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_cfg_enable()                                         */
+/*      Enable auto-join AP or auto-create APコマンドを発行し       */
+/*      レスポンスを待つ                                            */
+/*      input   :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_cfg_enable(uint8 cfg_enable_val, uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_cfg_enable(cfg_enable_val);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CFG_ENABLE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_cfg_get()                                            */
+/*      Get Information about Stored Configurationコマンドを発行し  */
+/*      レスポンスを待つ                                            */
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_cfg_get(rsi_cfgGetFrameRcv *rsp, uint16 *err_code,
+                         int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_cfg_get();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CFG_GET;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.cfgGetFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_user_store_config()                                  */
+/*      Store configuration from Userコマンドを発行しレスポンスを待つ*/
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_user_store_config(rsi_user_store_config_t *req,
+                                   uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_user_store_config(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_USER_STORE_CFG;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_host_rtc_time()                                      */
+/*      Set RTC timeコマンドを発行しレスポンスを待つ                */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_host_rtc_time(module_rtc_time_t *req,
+                               uint16 *err_code,
+                               int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_host_rtc_time(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = 0xE9;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ip_param_set()                                       */
+/*      Set IP Parametersコマンドを発行しレスポンスを待つ           */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_ip_param_set(rsi_uIpparam *req,
+                              rsi_ipparamFrameRcv *rsp,
+                              uint16 *err_code,
+                              int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    wmrp10_rsicmd_flg = 0x01;
+    retval = rsi_ip_param_set(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_IPPARAM_CONFIG;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.ipparamFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ipv6_param_set()                                     */
+/*      Set IPv6 Parametersコマンドを発行しレスポンスを待つ         */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_ipv6_param_set(rsi_uIPconf6 *req,
+                                rsi_ipconf6FrameRcv *rsp,
+                                uint16 *err_code,
+                                int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ipv6_param_set(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_IPCONF6;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.ipconf6FrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_snmp_enable()                                        */
+/*      SNMPコマンドを発行しレスポンスを待つ                        */
+/*      input   :  snmpEnable disable or enable                     */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_snmp_enable(uint8 snmpEnable, uint16 *err_code,
+                             int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_snmp_enable(snmpEnable);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SNMP_ENABLE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_snmp_get_rsp()                                       */
+/*      SNMP Get Responseコマンドを発行しレスポンスを待つ           */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_snmp_get_rsp(rsi_uSnmp *req, uint16 *err_code,
+                              int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_snmp_get_rsp(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SNMP_GET_RSP;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_snmp_get_next_rsp()                                  */
+/*      SNMP Get Next Responseコマンドを発行しレスポンスを待つ      */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_snmp_get_next_rsp(rsi_uSnmp *req, uint16 *err_code,
+                                   int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_snmp_get_next_rsp(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SNMP_GETNEXT_RSP;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_snmp_get_stats()                                     */
+/*      SNMP Get Statsコマンドを発行しレスポンスを待つ              */
+/*      input   :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_snmp_get_stats(rsi_snmp_stats_t *rsp, uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_snmp_get_stats();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SNMP_GET_STATS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.snmpStats;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_snmp_trap()                                          */
+/*      SNMP trapコマンドを発行しレスポンスを待つ                   */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  snmp_len   snmp trapフレームのサイズ             */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_snmp_trap(rsi_uSnmptrap *req, int snmp_len,
+                           uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_snmp_trap(req, snmp_len);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SNMP_TRAP;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_socket()                                             */
+/*      Open Socketコマンドを発行しレスポンスを待つ                 */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンスの格納先アドレス            */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_socket(rsi_uSocket *req, rsi_socketFrameRcv *rsp,
+                        uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_socket(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SOCKET_CREATE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.socketFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ltcp_conn_status()                                   */
+/*      Query LTCP Connection Statusコマンドを発行しレスポンスを待つ*/
+/*      input   :  socketDescriptor                                 */
+/*              :  rsp        レスポンス格納先アドレス              */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_ltcp_conn_status(uint16 socketDescriptor,
+                                  rsi_LtcpConnStatusFrameRcv *rsp,
+                                  uint16 *err_code,
+                                  int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ltcp_conn_status(socketDescriptor);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_TCP_CONN_STATUS_QUERY;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.LtcpConnStatRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_socket_close()                                       */
+/*      Close Socketコマンドを発行しレスポンスを待つ                */
+/*      input   :  socketDescriptor   ディスクリプタ                */
+/*              :  port_number        ポート番号                    */
+/*              :  rsp                レスポンス格納先アドレス      */
+/*              :  err_code           エラーコード格納先アドレス    */
+/*              :  timeout            タイムアウト値(-1:FEVER)      */
+/*      return  :  0                  成功                          */
+/*              :  < 0                失敗                          */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_socket_close(uint16 socketDescriptor,
+                              uint16 port_number,
+                              rsi_socketCloseFrameRcv *rsp,
+                              uint16 *err_code,
+                              int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_socket_close(socketDescriptor, port_number);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CLOSE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.socketCloseFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_read_data()                                          */
+/*      Read Dataコマンドを発行しレスポンスを待つ                   */
+/*      input   :  socketDescriptor                                 */
+/*              :  dataLength    受信データ数指定                   */
+/*              :  time_out      コマンドに指定するタイムアウト     */
+/*              :  rsp           レスポンスの格納先アドレス         */
+/*              :  timeout       タイムアウト値(-1:FEVER, 0:Poll)   */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_read_data(uint16 socketDescriptor, uint32 dataLength, uint16 time_out,
+                           uint8 *rsp, int32 timeout)
+{
+    rsi_uSocketRead uSocketReadFrame;
+    uint16 dummy;
+    int16 retval;
+    int16 os_retval;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_read_data(&uSocketReadFrame, socketDescriptor, dataLength, time_out);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンスを受ける(受信したデータを取得) */
+    retval = wmrp10_os_rsp_cmd_data(rsp, &dummy, timeout);
+    
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_dns_server()                                         */
+/*      DNS Serverコマンドを発行しレスポンスを待つ                  */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンスの格納先アドレス            */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_dns_server(rsi_uDnsServer *req,
+                            rsi_dnsserverResponse *rsp,
+                            uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_dns_server(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_DNS_SERVER;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.dnsserverresponse;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_dns_query()                                          */
+/*      DNS Resolutionコマンドを発行しレスポンスを待つ              */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンスの格納先アドレス            */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_dns_query(rsi_uDnsQry *req,
+                           TCP_EVT_DNS_Query_Resp *rsp,
+                           uint16 *err_code,
+                           int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_dns_query(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_DNS_QRY;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.dnsqryresponse;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_dns_update()                                         */
+/*      DNS UPDATEコマンドを発行しレスポンスを待つ                  */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_dns_update(rsi_uDnsUpdate *req, uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_dns_update(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_DNS_UPDATE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_http_get()                                           */
+/*      HTTP GETコマンドを発行しレスポンスを待つ                    */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンスの格納先アドレス            */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_http_get(rsi_uHttpReq *req, rsi_uHttpRsp *rsp,
+                          uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_http_get(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_HTTP_GET;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.httpFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_http_post()                                          */
+/*      HTTP POSTコマンドを発行しレスポンスを待つ                   */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンスの格納先アドレス            */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_http_post(rsi_uHttpReq *req, rsi_uHttpRsp *rsp,
+                           uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_http_post(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_HTTP_POST;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.httpFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_http_post_data()                                     */
+/*      HTTP POST DATAコマンドを発行しレスポンスを待つ              */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  data       HTTPデータ                            */
+/*              :  length     HTTPデータのサイズ                    */
+/*              :  offset                                           */
+/*              :  rsp        レスポンスの格納先アドレス            */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_http_post_data(rsi_uHttpPostDataReq *req,
+                                uint8 *data, uint16 length,
+                                uint32 offset, rsi_uHttpRsp *rsp,
+                                uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_http_post_data(req, data, length, offset);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_HTTP_POST_DATA;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.httpFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ping_request()                                       */
+/*      Ping From Moduleコマンドを発行しレスポンスを待つ            */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンスの格納先アドレス            */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_ping_request(rsi_ping_request_t *req,
+                              rsi_uPingRsp *rsp,
+                              uint16 *err_code,
+                              int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ping_request(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_PING_PACKET;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.rsi_pingFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_load_web_page()                                      */
+/*      Loading the static webpageコマンドを発行しレスポンスを待つ  */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  webpage_file                                     */
+/*              :  webpage_load_done                                */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_load_web_page(rsi_uWebServer *req,
+                               uint8 *webpage_file,
+                               uint8 *webpage_load_done,
+                               uint16 *err_code,
+                               int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_load_web_page(req, webpage_file, webpage_load_done);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_GET_WEBPAGE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_json_create()                                        */
+/*      Loadint the dynamic webpage(Create JSON)コマンドを発行し    */
+/*      レスポンスを待つ                                            */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  json_string_buffer                               */
+/*              :  json_load_done                                   */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_json_create(rsi_jsonCreateObject_t *req,
+                             uint8 *json_string_buffer,
+                             uint8 *json_load_done,
+                             uint16 *err_code,
+                             int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_json_create(req, json_string_buffer, json_load_done);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CREATE_JSON;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_webpage_erase_file()                                 */
+/*      Erasing the webpageコマンドを発行しレスポンスを待つ         */
+/*      input   :  file                                             */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_webpage_erase_file(rsi_tfs_erase_file_t *file,
+                                    uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_webpage_erase_file(file);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_ERASE_FILE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_json_erase_file()                                    */
+/*      Erasing the JSON Dataコマンドを発行しレスポンスを待つ       */
+/*      input   :  file                                             */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_json_erase_file(rsi_tfs_erase_file_t *file,
+                                 uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_json_erase_file(file);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_ERASE_JSON;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_webpage_clear_files()                                */
+/*      Clear all the WebPagesコマンドを発行しレスポンスを待つ      */
+/*      input   :  file                                             */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_webpage_clear_files(rsi_tfs_clear_files_t *file,
+                                     uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_webpage_clear_files(file);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_CLEAR_FILES;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_send_url_rsp()                                       */
+/*      Clear all the WebPagesコマンドを発行しレスポンスを待つ      */
+/*      input   :  sUrlRsp                                          */
+/*              :  webpage_morechunks                               */
+/*              :  webpage_file                                     */
+/*              :  file_size                                        */
+/*              :  first_chunk                                      */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_send_url_rsp(HostWebpageSnd_t *uUrlRsp,
+                              uint8 *webpage_morechunks,
+                              uint8 *webpage_file,
+                              uint32 file_size,
+                              uint8 first_chunk,
+                              uint16 *err_code,
+                              int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_send_url_rsp(uUrlRsp, webpage_morechunks, webpage_file,
+                              file_size, first_chunk);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_HOST_WEBPAGE;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_bytes_sent_count()                                   */
+/*      Bytes Transmitted Count On Socketコマンドを発行しレスポンス */
+/*      を待つ                                                      */
+/*      input   :  Descriptor                                       */
+/*              :  rsp        レスポンスの格納先アドレス            */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_bytes_sent_count(uint16 Descriptor,
+                                  rsi_sentBytesRsp *rsp,
+                                  uint16 *err_code,
+                                  int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_bytes_sent_count(Descriptor);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SENT_BYTES;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.SentBytes;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_socket_config()                                      */
+/*      Socket Configuration Parametersコマンドを発行しレスポンスを */
+/*      待つ                                                        */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_socket_config(rsi_socket_config_t *req,
+                               uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_socket_config(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SOCKET_CONFIG;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_http_abort()                                         */
+/*      Http Abortコマンドを発行しレスポンスを待つ                  */
+/*      input   :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_http_abort(uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_http_abort();
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_HTTP_ABORT;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_http_credentials()                                   */
+/*      HTTP Server Credenialsコマンドを発行しレスポンスを待つ      */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_http_credentials(rsi_uhttpCredentials *req,
+                                  uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_http_credentials(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_HTTP_CREDENTIALS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ftp_client()                                         */
+/*      FTP clientコマンドを発行しレスポンスを待つ                  */
+/*      input   :  type       FTPコマンド                           */
+/*              :  req        コマンドパラメータ                    */
+/*              :  rsp        レスポンスの格納先アドレス            */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_ftp_client(uint8 type, rsi_ftp_client_t *req,
+                            rsi_ftp_rsp_t *rsp, uint16 *err_code,
+                            int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ftp_client(type, req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_FTP;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.ftpFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ftp_file_write_content()                             */
+/*      FTP clientコマンドを発行しレスポンスを待つ                  */
+/*      input   :  req           コマンドパラメータ                 */
+/*              :  file_content  コンテンツ                         */
+/*              :  file_size                                        */
+/*              :  ip_version                                       */
+/*              :  rsp           レスポンスの格納先アドレス         */
+/*              :  err_code      エラーコード格納先アドレス         */
+/*              :  timeout       タイムアウト値(-1:FEVER)           */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_ftp_file_write_content(rsi_ftp_file_write_t *req,
+                                        uint8 *file_content,
+                                        uint32 file_size,
+                                        uint8 ip_version,
+                                        rsi_ftp_rsp_t *rsp,
+                                        uint16 *err_code,
+                                        int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ftp_file_write_content(req, file_content, file_size,
+                                        ip_version);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_FTP;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.ftpFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_sntp_client()                                        */
+/*      SNTP clientコマンドを発行しレスポンスを待つ                 */
+/*      input   :  type          SNTPコマンド                       */
+/*              :  req           コマンドパラメータ                 */
+/*              :  rsp           レスポンスの格納先アドレス         */
+/*              :  server_rsp    レスポンスの格納先アドレス         */
+/*              :  err_code      エラーコード格納先アドレス         */
+/*              :  timeout       タイムアウト値(-1:FEVER)           */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_sntp_client(uint8 type, rsi_sntp_client_t *req,
+                             rsi_sntp_rsp_t *rsp,
+                             rsi_sntp_server_rsp_t *server_rsp,
+                             uint16 *err_code,
+                             int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type[2];
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_sntp_client(type, req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type[0] = RSI_RSP_SNTP;
+    wait_type[1] = RSI_RSP_SNTP_SERVER;
+    retval = wmrp10_os_rsp_cmd(wait_type, 2, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        if(response_type == RSI_RSP_SNTP)
+        {
+            *rsp = uCmdRspFrame->uCmdRspPayLoad.sntpFrameRcv;
+        }
+        else if(response_type == RSI_RSP_SNTP_SERVER)
+        {
+            *server_rsp = uCmdRspFrame->uCmdRspPayLoad.sntp_ServerFrameRcv;
+        }
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_mdns_req()                                           */
+/*      MDNS and DNS-SDコマンドを発行しレスポンスを待つ             */
+/*      input   :  type                                             */
+/*              :  req           コマンドパラメータ                 */
+/*              :  rsp           レスポンスの格納先アドレス         */
+/*              :  err_code      エラーコード格納先アドレス         */
+/*              :  timeout       タイムアウト値(-1:FEVER)           */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_mdns_req(uint8 type, rsi_mdns_t *req,
+                          rsi_mdns_rsp_t *rsp, uint16 *err_code,
+                          int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_mdns_req(type, req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_MDNS;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.mdnsFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_smtp_client()                                        */
+/*      SMTP Clientコマンドを発行しレスポンスを待つ                 */
+/*      input   :  type          SMTPコマンド                       */
+/*              :  req           コマンドパラメータ                 */
+/*              :  rsp           レスポンスの格納先アドレス         */
+/*              :  err_code      エラーコード格納先アドレス         */
+/*              :  timeout       タイムアウト値(-1:FEVER)           */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_smtp_client(uint8 type, rsi_smtp_client_t *req,
+                             rsi_smtp_rsp_t *rsp, uint16 *err_code,
+                             int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_smtp_client(type, req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_SMTP;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.smtpFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_pop3_client()                                        */
+/*      POP3 Clientコマンドを発行しレスポンスを待つ                 */
+/*      input   :  type          POP3コマンド                       */
+/*              :  req           コマンドパラメータ                 */
+/*              :  rsp           レスポンスの格納先アドレス         */
+/*              :  mail_rsp      レスポンスの格納先アドレス         */
+/*              :  err_code      エラーコード格納先アドレス         */
+/*              :  timeout       タイムアウト値(-1:FEVER)           */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_pop3_client(uint8 type, rsi_pop3_client_t *req,
+                             rsi_pop3_rsp_t *rsp,
+                             rsi_pop3_mail_data_resp_t *mail_rsp,
+                             uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type[2];
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_pop3_client(type, req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type[0] = RSI_RSP_POP3;
+    wait_type[1] = RSI_RSP_POP3_REMOTE_TERMINATE;
+    retval = wmrp10_os_rsp_cmd(wait_type, 2, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        if(response_type == RSI_RSP_POP3)
+        {
+            *rsp = uCmdRspFrame->uCmdRspPayLoad.pop3CmdFrameRcv;
+        }
+        else if(response_type == RSI_RSP_POP3_REMOTE_TERMINATE)
+        {
+            *mail_rsp = uCmdRspFrame->uCmdRspPayLoad.pop3MailContentRcv;
+        }
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_http_client_put()                                    */
+/*      HTTP PUTコマンドを発行しレスポンスを待つ                    */
+/*      input   :  type          HTTP PUTコマンド                   */
+/*              :  req           コマンドパラメータ                 */
+/*              :  rsp           レスポンスの格納先アドレス         */
+/*              :  err_code      エラーコード格納先アドレス         */
+/*              :  timeout       タイムアウト値(-1:FEVER)           */
+/*      return  :  0             成功                               */
+/*              :  < 0           失敗                               */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_http_client_put(uint8 type, rsi_http_client_put_req_t *req,
+                                 rsi_http_client_put_rsp_t *rsp,
+                                 uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_http_client_put(type, req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_HTTP_CLIENT_PUT;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    
+    /* レスポンスを格納 */
+    if(retval == WMRP10_ERR_SUCCESS)
+    {
+        *rsp = uCmdRspFrame->uCmdRspPayLoad.httpClientPutFrameRcv;
+    }
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_ota_fw_up()                                          */
+/*      Over The Air Firmware Upコマンドを発行しレスポンスを待つ    */
+/*      input   :  req        コマンドパラメータ                    */
+/*              :  err_code   エラーコード格納先アドレス            */
+/*              :  timeout    タイムアウト値(-1:FEVER)              */
+/*      return  :  0          成功                                  */
+/*              :  < 0        失敗                                  */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_ota_fw_up(rsi_uOtafReq *req, uint16 *err_code, int32 timeout)
+{
+    int16 retval;
+    int16 os_retval;
+    uint16 wait_type;
+    uint16 response_type;
+    uint8  tri_auto_flg;
+    rsi_uCmdRsp *uCmdRspFrame;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_cmd_lock();     /* コマンド排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return os_retval;
+    }
+    
+    retval = rsi_ota_fw_up(req);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    if(retval != RSI_SUCCESS)
+    {
+        wmrp10_os_cmd_unlock();
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンス待ち */
+    wait_type = RSI_RSP_OTA_FW_UP;
+    retval = wmrp10_os_rsp_cmd(&wait_type, 1, &response_type,
+                               &tri_auto_flg, &uCmdRspFrame,
+                               err_code, timeout);
+    wmrp10_os_cmd_unlock();               /* コマンド排他制御(終了) */
+    
+    return retval;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_data()                                               */
+/*      受信したデータを取得する                                    */
+/*      input   :  rsp          レスポンスの格納先アドレス          */
+/*              :  bytes_recv   受信サイズ格納先アドレス            */
+/*              :  timeout      タイムアウト値(-1:FEVER, 0:Poll)    */
+/*      return  :  0            成功                                */
+/*              :  < 0          失敗                                */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_data(uint8 *rsp, uint16 *bytes_recv, int32 timeout)
+{
+    int16 retval;
+    
+    /* 非同期に来るレスポンスのため発行するコマンドはない */
+    
+    /* レスポンスを受ける(受信したデータを取得) */
+    retval = wmrp10_os_rsp_data(rsp, bytes_recv, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_msg()                                                */
+/*      レスポンスを受ける                                          */
+/*      input   :  rsp      レスポンスの格納先アドレス              */
+/*              :  timeout  タイムアウト値(-1:FEVER, 0:Poll)        */
+/*      return  :  0        成功                                    */
+/*              :  < 0      失敗                                    */
+/*------------------------------------------------------------------*/
+int16 wmrp10_rsi_msg(T_MYMSG_MSG *rsp, int32 timeout)
+{
+    int16 retval;
+    
+    /* レスポンスを受ける */
+    retval = wmrp10_os_rsp_msg(rsp, timeout);
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_send_raw_data()                                      */
+/*      データ送信(TCP/IP Bypassモード時)                           */
+/*      input   :  payload      ペイロードのアドレス                */
+/*              :  payloadLen   ペイロードサイズ                    */
+/*              :  bytes_sent   送信サイズ格納先アドレス            */
+/*      return  :  0            成功                                */
+/*              :  < 0          失敗                                */
+/*------------------------------------------------------------------*/
+#if WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_send_raw_data(uint8 *payload, uint32 payloadLen,
+                               uint32 *bytes_sent)
+{
+    int16 retval;
+    int16 os_retval;
+    
+    *bytes_sent = 0;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    
+    retval = rsi_send_raw_data(payload, payloadLen, bytes_sent);
+    
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    
+    if(retval != RSI_SUCCESS)
+    {
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンスは来ない */
+    
+    return WMRP10_ERR_SUCCESS;
+}
+#endif /* WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_send_data()                                          */
+/*      データ送信(TCP/IP スタック使用時)                           */
+/*      input   :  socketDescriptor                                 */
+/*              :  payload      ペイロード                          */
+/*              :  payloadLen   送信サイズ                          */
+/*              :  protocol     RSI_PROTOCOL_TCP_V4                 */
+/*              :  bytes_sent   送信サイズ格納先アドレス            */
+/*      return  :  0            成功                                */
+/*              :  < 0          失敗                                */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_send_data(uint16 socketDescriptor, uint8 *payload,
+                           uint32 payloadLen, uint8 protocol,
+                           uint32 *bytes_sent)
+{
+    int16 retval;
+    int16 os_retval;
+    
+    *bytes_sent = 0;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    
+    retval = rsi_send_data(socketDescriptor, payload, payloadLen,
+                           protocol, bytes_sent);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    
+    if(retval != RSI_SUCCESS)
+    {
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンスは来ない */
+    
+    return WMRP10_ERR_SUCCESS;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_send_websocket_data()                                */
+/*      データ送信(TCP/IP スタック使用時)                           */
+/*      input   :  socketDescriptor                                 */
+/*              :  payload      ペイロード                          */
+/*              :  payloadLen   送信サイズ                          */
+/*              :  protocol     RSI_PROTOCOL_TCP_V4                 */
+/*              :  opcode                                           */
+/*              :  bytes_sent   送信サイズ格納先アドレス            */
+/*      return  :  0            成功                                */
+/*              :  < 0          失敗                                */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_send_websocket_data(uint16 socketDescriptor, uint8 *payload,
+                           uint32 payloadLen, uint8 protocol,
+                           uint8 opcode, uint32 *bytes_sent)
+
+{
+    int16 retval;
+    int16 os_retval;
+    
+    *bytes_sent = 0;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    
+    retval = rsi_send_websocket_data(socketDescriptor, payload, payloadLen,
+                           opcode ,protocol, bytes_sent);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    
+    if(retval != RSI_SUCCESS)
+    {
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンスは来ない */
+    
+    return WMRP10_ERR_SUCCESS;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_rsi_send_ludp_data()                                     */
+/*      データ送信(TCP/IP スタック使用時)                           */
+/*      input   :  socketDescriptor                                 */
+/*              :  payload      ペイロード                          */
+/*              :  payloadLen   送信サイズ格納先アドレス            */
+/*              :  protocol     RSI_PROTOCOL_UDP_V4                 */
+/*              :  destIp       送信先IPアドレス                    */
+/*              :  destPort     送信先ポート番号                    */
+/*              :  bytes_sent   送信サイズ格納先アドレス            */
+/*      return  :  0            成功                                */
+/*              :  < 0          失敗                                */
+/*------------------------------------------------------------------*/
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_send_ludp_data(uint16 socketDescriptor,
+                                uint8 *payload, uint32 payloadLen,
+                                uint8 protocol, uint8 *destIp,
+                                uint16 destPort, uint32 *bytes_sent)
+{
+    int16 retval;
+    int16 os_retval;
+    
+    *bytes_sent = 0;
+    
+    /* コマンド発行 */
+    os_retval = wmrp10_os_spi_lock();          /* SPI排他制御(開始) */
+    if(os_retval != WMRP10_ERR_SUCCESS)
+    {
+        return os_retval;
+    }
+    
+    retval = rsi_send_ludp_data(socketDescriptor, payload, payloadLen,
+                                protocol, destIp, destPort, bytes_sent);
+    wmrp10_os_spi_unlock();                    /* SPI排他制御(終了) */
+    
+    if(retval != RSI_SUCCESS)
+    {
+        return WMRP10_ERR_ABORT;
+    }
+    
+    /* レスポンスは来ない */
+    
+    return WMRP10_ERR_SUCCESS;
+}
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+/* End of File */
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_rsi.h b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_rsi.h
new file mode 100755
index 0000000..bc7ae84
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_apis/wmrp10_rsi.h
@@ -0,0 +1,302 @@
+/********************************************************************/
+/*                                                                  */
+/*   wmrp10_rsi.h                                                   */
+/*   WLANコマンド                                                   */
+/*                                                                  */
+/*   2019/05/22 Create(AlphaProject)                                */
+/*                                                                  */
+/********************************************************************/
+
+#ifndef _WMRP10_RSI_H_
+#define _WMRP10_RSI_H_
+
+#include "rsi_global.h"
+#include "rsi_app.h"
+#include "rsi_app_util.h"
+#include "rsi_api.h"
+#include "rsi_spi_cmd.h"
+#include "wmrp10_err.h"
+#include "wmrp10_def.h"
+
+#define WMRP10_TIMEOUT_FEVR  -1
+#define WMRP10_TIMEOUT_POLL  0
+
+/* メッセージ用構造体定義 */
+typedef struct t_wmrp10_msg
+{
+    uint16 response_type;
+    union
+    {
+        uint8 mac_addr[6];
+        rsi_wfdDevResponse      wfdDevResponse; /* WFD DevInfoレスポンス用 */
+        rsi_ConnAcceptRcv       ConnAcceptRcv;  /* WFD ConnAcceptRcvレスポンス用 */
+        rsi_uPerStatsRsp        uPerStatsRsp;   /* PERレスポンス用 */
+        rsi_state_notificaton_t stateFrameRcv;  /* 状態通知レスポンス用 */
+        
+        rsi_joinResponse    joinResponse;    /* Auto時の通知 */
+        rsi_ipparamFrameRcv ipparamFrameRcv; /* Auto時の通知 */
+        
+#if !WMRP10_TCP_IP_BYPASS
+        rsi_recvLtcpEst         recvLtcpEst;         /* ソケット確立レスポンス用 */
+        rsi_socketCloseFrameRcv socketCloseFrameRcv; /* ソケット切断レスポンス用 */
+        rsi_recvIpChange        recvIpchange;        /* IPアドレス変更通知レスポンス用 */
+        rsi_snmp_set            snmp_set;            /* SNMP Setレスポンス用 */
+        rsi_urlReqFrameRcv      urlReqRcv;           /* Web Page Bypass(URL request)用 */
+#endif
+        uint8 uCmdRspBuf;
+    }msg;
+    
+}T_MYMSG_MSG;
+
+
+/***** 受信したものを振り分ける *****/
+int16 wmrp10_rsi_frame_read(void);
+rsi_uCmdRsp *wmrp10_rsi_parse_response(uint8 *rsp);
+
+
+/***** コマンドを発行してレスポンスを受ける *****/
+int16 wmrp10_rsi_sys_init(void);
+int16 wmrp10_rsi_waitfor_boardready(void);
+int16 wmrp10_rsi_upgrade_fw(uint8 image_type, uint8 *fw_image,
+                            uint32 fw_image_size);
+int16 wmrp10_rsi_select_option(uint8 cmd, uint8 *tri_auto_flg,
+                               uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_oper_mode(rsi_uOperMode *req, uint16 *err_code,
+                           int32 timeout);
+int16 wmrp10_rsi_band(uint8 band, uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_config(uint16 config_type, uint16 config_value,
+                        uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_set_mac_addr(uint8 *macAddress, uint16 *err_code,
+                              int32 timeout);
+int16 wmrp10_rsi_init(rsi_initResponse *rsp, uint16 *err_code,
+                      int32 timeout);
+int16 wmrp10_rsi_per_mode(rsi_uPerMode *req, uint16 *err_code,
+                          int32 timeout);
+int16 wmrp10_rsi_select_antenna(uint8 antenna_val, uint8 gain_2g, uint8 gain_5g,
+                                uint8 antenna_path, uint8 antenna_type,
+                                uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_p2p_config(rsi_uConfigP2p *req, uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_set_ap_config(rsi_apconfig *req, uint16 *err_code,
+                               int32 timeout);
+int16 wmrp10_rsi_wps_method(rsi_uWpsMethod *req,
+                            rsi_wpsMethodFrameRcv *rsp,
+                            uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_scan(rsi_uScan *req, rsi_scanResponse *rsp,
+                      uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_join(rsi_uJoin *req, rsi_joinResponse *rsp,
+                      uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_timeout(rsi_utimeout *req, uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_rejoin_params(rsi_rejoin_params_t *req,
+                               uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_wmm_ps(rsi_uWmmPs *req, uint16 *err_code,
+                        int32 timeout);
+int16 wmrp10_rsi_sleep_timer(rsi_uSleepTimer *req, uint16 *err_code,
+                             int32 timeout);
+int16 wmrp10_rsi_power_mode(rsi_uPower *req, uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_psk(rsi_uPsk *req, uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_set_wepkey(rsi_wepkey *req, uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_set_eap(rsi_uSetEap *req, uint16 *err_code,
+                         int32 timeout);
+int16 wmrp10_rsi_set_certificate(uint8 certificate_type,
+                                 uint8 *buffer,
+                                 uint32 certificate_length,
+                                 struct SET_CHUNK_S *SetChunkPtr,
+                                 uint16 *err_code,
+                                 int32 timeout);
+int16 wmrp10_rsi_disconnect(rsi_disassoc_t *req, uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_wireless_fwupgrade(void);
+int16 wmrp10_rsi_bg_scan(rsi_ubgScan *req, rsi_scanResponse *rsp,
+                         uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_roam_params(rsi_uRoamParams *req, uint16 *err_code,
+                             int32 timeout);
+int16 wmrp10_rsi_ht_caps(rsi_uHtCaps *req, uint16 *err_code,
+                         int32 timeout);
+int16 wmrp10_rsi_query_fw_version(rsi_qryFwversionFrameRcv *rsp,
+                                  uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_query_rssi(rsi_rssiFrameRcv *rsp, uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_query_mac_address(rsi_qryMacFrameRcv *rsp,
+                                   uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_query_net_parms(rsi_qryNetParmsFrameRcv *rsp,
+                                 uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_query_go_parms(rsi_qryGOParamsFrameRcv *rsp,
+                                uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_set_region(rsi_usetregion *req,
+                            rsi_uSetRegionRsp *rsp,
+                            uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_set_region_ap(rsi_usetregion_ap_t *req,
+                               uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_per_stats(rsi_uPerStats *req, uint16 *err_code);
+int16 wmrp10_rsi_query_conn_status(rsi_conStatusFrameRcv *rsp,
+                                   uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_debug_prints(rsi_uDebug *req, uint16 *err_code,
+                              int32 timeout);
+int16 wmrp10_rsi_rf_current_config(rsi_rf_current_config_t *req,
+                                   uint16 *err_code,
+                                   int32 timeout);
+int16 wmrp10_rsi_trigger_auto_config(uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_cfg_save(uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_cfg_enable(uint8 cfg_enable_val, uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_cfg_get(rsi_cfgGetFrameRcv *rsp, uint16 *err_code,
+                         int32 timeout);
+int16 wmrp10_rsi_user_store_config(rsi_user_store_config_t *req,
+                                   uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_host_rtc_time(module_rtc_time_t *req,
+                               uint16 *err_code,
+                               int32 timeout);
+
+#if !WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_ip_param_set(rsi_uIpparam *req,
+                              rsi_ipparamFrameRcv *rsp,
+                              uint16 *err_code,
+                              int32 timeout);
+int16 wmrp10_rsi_ipv6_param_set(rsi_uIPconf6 *req,
+                                rsi_ipconf6FrameRcv *rsp,
+                                uint16 *err_code,
+                                int32 timeout);
+int16 wmrp10_rsi_snmp_enable(uint8 snmpEnable, uint16 *err_code,
+                             int32 timeout);
+int16 wmrp10_rsi_snmp_get_rsp(rsi_uSnmp *req, uint16 *err_code,
+                              int32 timeout);
+int16 wmrp10_rsi_snmp_get_next_rsp(rsi_uSnmp *req, uint16 *err_code,
+                                   int32 timeout);
+int16 wmrp10_rsi_snmp_get_stats(rsi_snmp_stats_t *rsp, uint16 *err_code,
+                                int32 timeout);
+int16 wmrp10_rsi_snmp_trap(rsi_uSnmptrap *req, int snmp_len,
+                           uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_socket(rsi_uSocket *req, rsi_socketFrameRcv *rsp,
+                        uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_ltcp_conn_status(uint16 socketDescriptor,
+                                  rsi_LtcpConnStatusFrameRcv *rsp,
+                                  uint16 *err_code,
+                                  int32 timeout);
+int16 wmrp10_rsi_socket_close(uint16 socketDescriptor,
+                              uint16 port_number,
+                              rsi_socketCloseFrameRcv *rsp,
+                              uint16 *err_code,
+                              int32 timeout);
+int16 wmrp10_rsi_read_data(uint16 socketDescriptor, uint32 dataLength,
+                           uint16 time_out, uint8 *rsp, int32 timeout);
+int16 wmrp10_rsi_dns_server(rsi_uDnsServer *req,
+                            rsi_dnsserverResponse *rsp,
+                            uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_dns_query(rsi_uDnsQry *req,
+                           TCP_EVT_DNS_Query_Resp *rsp,
+                           uint16 *err_code,
+                           int32 timeout);
+int16 wmrp10_rsi_dns_update(rsi_uDnsUpdate *req,
+                            uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_http_get(rsi_uHttpReq *req, rsi_uHttpRsp *rsp,
+                          uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_http_post(rsi_uHttpReq *req, rsi_uHttpRsp *rsp,
+                           uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_http_post_data(rsi_uHttpPostDataReq *req,
+                                uint8 *data, uint16 length,
+                                uint32 offset, rsi_uHttpRsp *rsp,
+                                uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_http_client_put(uint8 type,
+                                 rsi_http_client_put_req_t *req,
+                                 rsi_http_client_put_rsp_t *rsp,
+                                 uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_multicast_mac_filter(uint8 cmd, uint8 MAC[6],
+                                      uint16 *err_code,
+                                      int32 timeout);
+int16 wmrp10_rsi_multicast(rsi_uMulticast *req, uint16 *err_code,
+                           int32 timeout);
+int16 wmrp10_rsi_ping_request(rsi_ping_request_t *req,
+                              rsi_uPingRsp *rsp,
+                              uint16 *err_code,
+                              int32 timeout);
+int16 wmrp10_rsi_load_web_page(rsi_uWebServer *req,
+                               uint8 *webpage_file,
+                               uint8 *webpage_load_done,
+                               uint16 *err_code,
+                               int32 timeout);
+int16 wmrp10_rsi_json_create(rsi_jsonCreateObject_t *req,
+                             uint8 *json_string_buffer,
+                             uint8* json_load_done,
+                             uint16 *err_code,
+                             int32 timeout);
+int16 wmrp10_rsi_webpage_erase_file(rsi_tfs_erase_file_t *file,
+                                    uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_json_erase_file(rsi_tfs_erase_file_t *file,
+                                 uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_webpage_clear_files(rsi_tfs_clear_files_t *file,
+                                     uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_send_url_rsp(HostWebpageSnd_t *uUrlRsp,
+                              uint8 *webpage_morechunks,
+                              uint8 *webpage_file,
+                              uint32 file_size,
+                              uint8 first_chunk,
+                              uint16 *err_code,
+                              int32 timeout);
+int16 wmrp10_rsi_bytes_sent_count(uint16 Descriptor,
+                                  rsi_sentBytesRsp *rsp,
+                                  uint16 *err_code,
+                                  int32 timeout);
+int16 wmrp10_rsi_socket_config(rsi_socket_config_t *req,
+                               uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_http_abort(uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_http_credentials(rsi_uhttpCredentials *req,
+                                  uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_ftp_client(uint8 type, rsi_ftp_client_t *req,
+                            rsi_ftp_rsp_t *rsp, uint16 *err_code,
+                            int32 timeout);
+int16 wmrp10_rsi_ftp_file_write_content(rsi_ftp_file_write_t *req,
+                                        uint8 *file_content,
+                                        uint32 file_size,
+                                        uint8 ip_version,
+                                        rsi_ftp_rsp_t *rsp,
+                                        uint16 *err_code,
+                                        int32 timeout);
+int16 wmrp10_rsi_sntp_client(uint8 type, rsi_sntp_client_t *req,
+                             rsi_sntp_rsp_t *rsp,
+                             rsi_sntp_server_rsp_t *server_rsp,
+                             uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_mdns_req(uint8 type, rsi_mdns_t *req,
+                          rsi_mdns_rsp_t *rsp, uint16 *err_code,
+                          int32 timeout);
+int16 wmrp10_rsi_smtp_client(uint8 type, rsi_smtp_client_t *req,
+                             rsi_smtp_rsp_t *rsp, uint16 *err_code,
+                             int32 timeout);
+int16 wmrp10_rsi_pop3_client(uint8 type, rsi_pop3_client_t *req,
+                             rsi_pop3_rsp_t *rsp,
+                             rsi_pop3_mail_data_resp_t *mail_rsp,
+                             uint16 *err_code, int32 timeout);
+int16 wmrp10_rsi_ota_fw_up(rsi_uOtafReq *req, uint16 *err_code, int32 timeout);
+#endif /* !WMRP10_TCP_IP_BYPASS */
+
+
+/***** コマンドのない非同期のレスポンスを受ける *****/
+int16 wmrp10_rsi_data(uint8 *rsp, uint16 *bytes_recv, int32 timeout);
+int16 wmrp10_rsi_msg(T_MYMSG_MSG *rsp, int32 timeout);
+
+
+/***** 送信 *****/
+#if WMRP10_TCP_IP_BYPASS
+int16 wmrp10_rsi_send_raw_data(uint8 *payload, uint32 payloadLen,
+                               uint32 *bytes_sent);
+#else
+int16 wmrp10_rsi_send_data(uint16 socketDescriptor, uint8 *payload,
+                           uint32 payloadLen, uint8 protocol,
+                           uint32 *bytes_sent);
+int16 wmrp10_rsi_send_websocket_data(uint16 socketDescriptor, uint8 *payload,
+                           uint32 payloadLen, uint8 protocol,
+                           uint8 opcode, uint32 *bytes_sent);
+int16 wmrp10_rsi_send_ludp_data(uint16 socketDescriptor,
+                                uint8 *payload, uint32 payloadLen,
+                                uint8 protocol, uint8 *destIp,
+                                uint16 destPort, uint32 *bytes_sent);
+#endif /* WMRP10_TCP_IP_BYPASS */
+
+
+#endif /* _WMRP10_RSI_H_ */
diff --git a/drivers/net/wireless/wmrp10/wmrp10_ioctl.c b/drivers/net/wireless/wmrp10/wmrp10_ioctl.c
new file mode 100644
index 0000000..30f509b
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_ioctl.c
@@ -0,0 +1,1239 @@
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <asm/current.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include "wmrp10.h"
+#include "wmrp10_ioctl.h"
+#include "wmrp10_rsi.h"
+#include "wmrp10_os.h"
+
+#define DRIVER_NAME "wmrp10_btle"
+
+#define WMRP10_DEBUG 0
+
+static unsigned int wmrp10_major = 0;
+module_param(wmrp10_major, uint, 0);
+static unsigned int wmrp10_minor = 0;
+
+static struct class *wmrp10_class = NULL;
+static dev_t wmrp10_btle_dev;
+
+static int wmrp10_btle_app_init(void);
+static int wmrp10_btle_app_exit(void);
+static int wmrp10_btle_bt_oper_mode(unsigned long arg);
+static int wmrp10_btle_bt_set_local_name(unsigned long arg);
+static int wmrp10_btle_bt_set_profile_mode(unsigned long arg);
+static int wmrp10_btle_bt_set_connectability_mode(unsigned long arg);
+static int wmrp10_btle_bt_set_discovery_mode(unsigned long arg);
+static int wmrp10_btle_bt_inquiry(unsigned long arg);
+static int wmrp10_btle_bt_inquiry_cancel(unsigned long arg);
+static int wmrp10_btle_bt_bond(unsigned long arg);
+static int wmrp10_btle_bt_pincode_reply(unsigned long arg);
+static int wmrp10_btle_bt_linkkey_reply(unsigned long arg);
+static int wmrp10_btle_bt_spp_connect(unsigned long arg);
+static int wmrp10_btle_bt_spp_disconnect(unsigned long arg);
+static int wmrp10_btle_bt_spp_transfer(unsigned long arg);
+static int wmrp10_btle_bt_event(unsigned long arg);
+static int wmrp10_btle_ble_set_random_address(unsigned long arg);
+static int wmrp10_btle_ble_scan(unsigned long arg);
+static int wmrp10_btle_ble_connect(unsigned long arg);
+static int wmrp10_btle_ble_disconnect(unsigned long arg);
+static int wmrp10_btle_ble_query_device_state(unsigned long arg);
+static int wmrp10_btle_ble_set_advertise_data(unsigned long arg);
+static int wmrp10_btle_ble_advertise(unsigned long arg);
+static int wmrp10_btle_ble_device_AddService(unsigned long arg);
+static int wmrp10_btle_ble_device_AddServiceAttribute(unsigned long arg);
+static int wmrp10_btle_ble_device_ChangeLocalAttValue(unsigned long arg);
+static int wmrp10_btle_ble_query_profile(unsigned long arg);
+static int wmrp10_btle_ble_read_char_value_by_UUID(unsigned long arg);
+static int wmrp10_btle_ble_event(unsigned long arg);
+
+extern int g_wmrp10_os_init_flg;
+extern int g_oper_flag;
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ioctl()                                             */
+/*      ioctl コマンド動作                                            */
+/*      input   :  ファイルポインタ,ioctlコマンド,引数ポインタ             */
+/*      return  :  0         成功                                   */
+/*              :  -EFAULT   失敗                                   */
+/*------------------------------------------------------------------*/
+long wmrp10_btle_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int16 retval;
+    
+    retval = 0x55;
+    
+    switch (cmd)
+    {
+        case WMRP10_IOCTL_APP_INIT:
+            retval = wmrp10_btle_app_init();
+            break;
+        case WMRP10_IOCTL_APP_EXIT:
+            retval = wmrp10_btle_app_exit();
+            break;
+        case WMRP10_IOCTL_BT_OPER_MODE:
+            retval = wmrp10_btle_bt_oper_mode(arg);
+            break;
+        case WMRP10_IOCTL_BT_SET_LOCAL_NAME:
+            retval = wmrp10_btle_bt_set_local_name(arg);
+            break;
+        case WMRP10_IOCTL_BT_SET_PROFILE_MODE:
+            retval = wmrp10_btle_bt_set_profile_mode(arg);
+            break;
+        case WMRP10_IOCTL_BT_SET_CONNECTABILITY_MODE:
+            retval = wmrp10_btle_bt_set_connectability_mode(arg);
+            break;
+        case WMRP10_IOCTL_BT_SET_DISCOVERY_MODE:
+            retval = wmrp10_btle_bt_set_discovery_mode(arg);
+            break;
+        case WMRP10_IOCTL_BT_INQUIRY:
+            retval = wmrp10_btle_bt_inquiry(arg);
+            break;
+        case WMRP10_IOCTL_BT_INQUIRY_CANCEL:
+            retval = wmrp10_btle_bt_inquiry_cancel(arg);
+            break;
+        case WMRP10_IOCTL_BT_BOND:
+            retval = wmrp10_btle_bt_bond(arg);
+            break;
+        case WMRP10_IOCTL_BT_PINCODE_REPLY:
+            retval = wmrp10_btle_bt_pincode_reply(arg);
+            break;
+        case WMRP10_IOCTL_BT_LINKKEY_REPLY:
+            retval = wmrp10_btle_bt_linkkey_reply(arg);
+            break;
+        case WMRP10_IOCTL_BT_SPP_CONNECT:
+            retval = wmrp10_btle_bt_spp_connect(arg);
+            break;
+        case WMRP10_IOCTL_BT_SPP_DISCONNECT:
+            retval = wmrp10_btle_bt_spp_disconnect(arg);
+            break;
+        case WMRP10_IOCTL_BT_SPP_TRANSFER:
+            retval = wmrp10_btle_bt_spp_transfer(arg);
+            break;
+        case WMRP10_IOCTL_BT_EVENT:
+            retval = wmrp10_btle_bt_event(arg);
+            break;
+        case WMRP10_IOCTL_BLE_SET_RANDOM_ADDRESS:
+            retval = wmrp10_btle_ble_set_random_address(arg);
+            break;
+        case WMRP10_IOCTL_BLE_SCAN:
+            retval = wmrp10_btle_ble_scan(arg);
+            break;
+        case WMRP10_IOCTL_BLE_CONNECT:
+            retval = wmrp10_btle_ble_connect(arg);
+            break;
+        case WMRP10_IOCTL_BLE_DISCONNECT:
+            retval = wmrp10_btle_ble_disconnect(arg);
+            break;
+        case WMRP10_IOCTL_BLE_QUERY_DEVICE_STATE:
+            retval = wmrp10_btle_ble_query_device_state(arg);
+            break;
+        case WMRP10_IOCTL_BLE_SET_ADVERTISE_DATA:
+            retval = wmrp10_btle_ble_set_advertise_data(arg);
+            break;
+        case WMRP10_IOCTL_BLE_ADVERTISE:
+            retval = wmrp10_btle_ble_advertise(arg);
+            break;
+        case WMRP10_IOCTL_BLE_DEVICE_ADDSERVICE:
+            retval = wmrp10_btle_ble_device_AddService(arg);
+            break;
+        case WMRP10_IOCTL_BLE_DEVICE_ADDSERVICEATTRIBUTE:
+            retval = wmrp10_btle_ble_device_AddServiceAttribute(arg);
+            break;
+        case WMRP10_IOCTL_BLE_DEVICE_CHANGELOCALATTVALUE:
+            retval = wmrp10_btle_ble_device_ChangeLocalAttValue(arg);
+            break;
+        case WMRP10_IOCTL_BLE_QUERY_PROFILE:
+            retval = wmrp10_btle_ble_query_profile(arg);
+            break;
+        case WMRP10_IOCTL_BLE_READ_CHAR_VALUE_BY_UUID:
+            retval = wmrp10_btle_ble_read_char_value_by_UUID(arg);
+            break;
+        case WMRP10_IOCTL_BLE_EVENT:
+            retval = wmrp10_btle_ble_event(arg);
+            break;
+        default:
+#if WMRP10_DEBUG
+            printk(KERN_WARNING "unsupported command %d\n", cmd);
+#endif
+            return -EFAULT;
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_app_init()                                          */
+/*      WLANモジュール初期化                                          */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_app_init(void)
+{
+    int retval;
+    
+    g_frame_read_type = WMRP10_WLAN_FRAME;
+#if WMRP10_DEBUG
+    printk("%s: APP_INIT\n", __func__);
+#endif
+    g_wmrp10_os_init_flg=0;
+    
+    retval = wmrp10_app_init();
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_app_init()                                          */
+/*      WLANモジュール終了                                            */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*              :  < 0   失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_app_exit(void)
+{
+    int retval=0;
+    
+    g_frame_read_type = WMRP10_WLAN_FRAME;
+#if WMRP10_DEBUG
+    printk("%s: APP_EXIT\n", __func__);
+#endif
+    retval = wmrp10_app_exit();
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_oper_mode()                                      */
+/*      wmrp10_rsi_bt_oper_mode()の実行                             */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_oper_mode(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_OPER_PRM oper = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&oper, (void __user *)arg, sizeof(oper));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    
+    /* rsi_app 実行 */
+    oper.os_err_code = wmrp10_rsi_bt_oper_mode(&oper.req,&oper.rsi_err_code,oper.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &oper, sizeof(oper));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    
+    /* operation_mode設定 flagを有効に */
+    g_oper_flag = 1;
+    
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_set_local_name()                                 */
+/*      wmrp10_rsi_bt_set_local_name()の実行                        */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_set_local_name(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_LOCAL_NAME_PRM local_name = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&local_name, (void __user *)arg, sizeof(local_name));
+    
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    local_name.os_err_code = wmrp10_rsi_bt_set_local_name(&local_name.req,&local_name.rsi_err_code,local_name.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &local_name, sizeof(local_name));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_set_profile_mode()                               */
+/*      wmrp10_rsi_bt_set_profile_mode()の実行                      */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_set_profile_mode(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_SET_PROFILE_MODE_PRM profile = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&profile, (void __user *)arg, sizeof(profile));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    profile.os_err_code = wmrp10_rsi_bt_set_profile_mode(&profile.req,&profile.rsi_err_code,profile.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &profile, sizeof(profile));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_set_connectability_mode()                        */
+/*      wmrp10_rsi_bt_set_connectability_mode()の実行               */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_set_connectability_mode(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_SET_CONNECTABILITY_MODE_PRM connectability = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&connectability, (void __user *)arg, sizeof(connectability));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    connectability.os_err_code = wmrp10_rsi_bt_set_connectability_mode(&connectability.req,&connectability.rsi_err_code,connectability.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &connectability, sizeof(connectability));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_set_discovery_mode()                             */
+/*      wmrp10_rsi_bt_set_discovery_mode()の実行                    */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_set_discovery_mode(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_SET_DISCOVERY_MODE_PRM discovery = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&discovery, (void __user *)arg, sizeof(discovery));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    discovery.os_err_code = wmrp10_rsi_bt_set_discovery_mode(&discovery.req,&discovery.rsi_err_code,discovery.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &discovery, sizeof(discovery));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_inquiry()                                        */
+/*      wmrp10_rsi_bt_inquiry()の実行                               */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_inquiry(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_INQUIRY_PRM inquiry = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&inquiry, (void __user *)arg, sizeof(inquiry));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    inquiry.os_err_code = wmrp10_rsi_bt_inquiry(&inquiry.req,&inquiry.rsi_err_code,inquiry.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &inquiry, sizeof(inquiry));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_inquiry_cancel()                                 */
+/*      wmrp10_rsi_bt_inquiry_cancel()の実行                        */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_inquiry_cancel(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_INQUIRY_CANCEL_PRM inquiry_cancel = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&inquiry_cancel, (void __user *)arg, sizeof(inquiry_cancel));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    inquiry_cancel.os_err_code = wmrp10_rsi_bt_inquiry_cancel(&inquiry_cancel.rsi_err_code,inquiry_cancel.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &inquiry_cancel, sizeof(inquiry_cancel));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return 0;
+}
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_bond()                                           */
+/*      wmrp10_rsi_bt_bond()の実行                                  */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_bond(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_BOND_PRM bond = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&bond, (void __user *)arg, sizeof(bond));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    bond.os_err_code = wmrp10_rsi_bt_bond(&bond.req,&bond.rsi_err_code,bond.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &bond, sizeof(bond));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_pincode_reply()                                  */
+/*      wmrp10_rsi_bt_pincode_reply()の実行                         */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_pincode_reply(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_PINCODE_REPLY_PRM pincode_reply = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&pincode_reply, (void __user *)arg, sizeof(pincode_reply));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    pincode_reply.os_err_code = wmrp10_rsi_bt_pincode_reply(&pincode_reply.req,&pincode_reply.rsi_err_code,pincode_reply.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &pincode_reply, sizeof(pincode_reply));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_linkkey_reply()                                  */
+/*      wmrp10_rsi_bt_linkkey_reply()の実行                         */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_linkkey_reply(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_LINKKEY_REPLY_PRM linkkey_reply = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&linkkey_reply, (void __user *)arg, sizeof(linkkey_reply));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    linkkey_reply.os_err_code = wmrp10_rsi_bt_linkkey_reply(&linkkey_reply.req,&linkkey_reply.rsi_err_code,linkkey_reply.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &linkkey_reply, sizeof(linkkey_reply));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_spp_connect()                                    */
+/*      wmrp10_rsi_bt_spp_connect()の実行                           */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_spp_connect(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_SPP_CONNECT_PRM spp_connect = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&spp_connect, (void __user *)arg, sizeof(spp_connect));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    spp_connect.os_err_code = wmrp10_rsi_bt_spp_connect(&spp_connect.req,&spp_connect.rsi_err_code,spp_connect.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &spp_connect, sizeof(spp_connect));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_spp_disconnect()                                 */
+/*      wmrp10_rsi_bt_spp_disconnect()の実行                        */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_spp_disconnect(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_SPP_DISCONNECT_PRM spp_disconnect = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&spp_disconnect, (void __user *)arg, sizeof(spp_disconnect));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    spp_disconnect.os_err_code = wmrp10_rsi_bt_spp_disconnect(&spp_disconnect.req,&spp_disconnect.rsi_err_code,spp_disconnect.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &spp_disconnect, sizeof(spp_disconnect));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_spp_transfer()                                   */
+/*      wmrp10_rsi_bt_spp_transfer()の実行                          */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_spp_transfer(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_SPP_TRANSFER_PRM spp_transfer = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&spp_transfer, (void __user *)arg, sizeof(spp_transfer));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    spp_transfer.os_err_code = wmrp10_rsi_bt_spp_transfer(&spp_transfer.req,&spp_transfer.rsi_err_code,spp_transfer.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &spp_transfer, sizeof(spp_transfer));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_bt_event()                                          */
+/*      wmrp10_btle_bt_event()の実行                                */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_bt_event(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BT_EVENT_PRM bt_event = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BT_FRAME;
+    
+    retval = copy_from_user(&bt_event, (void __user *)arg, sizeof(bt_event));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    bt_event.os_err_code = wmrp10_rsi_bt_event(&bt_event.val, bt_event.timeout);
+    
+    retval = copy_to_user((void __user *)arg , &bt_event, sizeof(bt_event));
+    
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_set_random_address()                            */
+/*      wmrp10_rsi_ble_set_random_address()の実行                   */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_set_random_address(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_SET_RANDOM_ADDRESS_PRM random_addr = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&random_addr, (void __user *)arg, sizeof(random_addr));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    random_addr.os_err_code = wmrp10_rsi_ble_set_random_address(&random_addr.req,&random_addr.rsi_err_code,random_addr.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &random_addr, sizeof(random_addr));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_scan()                                          */
+/*      wmrp10_rsi_ble_scan()の実行                                 */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_scan(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_SCAN_PRM scan = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&scan, (void __user *)arg, sizeof(scan));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    scan.os_err_code = wmrp10_rsi_ble_scan(&scan.req,&scan.rsi_err_code,scan.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &scan, sizeof(scan));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_connect()                                       */
+/*      wmrp10_rsi_ble_connect()の実行                              */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_connect(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_CONNECT_PRM ble_connect = {0};
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&ble_connect, (void __user *)arg, sizeof(ble_connect));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    ble_connect.os_err_code = wmrp10_rsi_ble_connect(&ble_connect.req,&ble_connect.rsi_err_code,ble_connect.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &ble_connect, sizeof(ble_connect));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_disconnect()                                    */
+/*      wmrp10_rsi_ble_disconnect()の実行                           */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_disconnect(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_DISCONNECT_PRM ble_disconnect = {0};
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&ble_disconnect, (void __user *)arg, sizeof(ble_disconnect));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    ble_disconnect.os_err_code = wmrp10_rsi_ble_disconnect(&ble_disconnect.req,&ble_disconnect.rsi_err_code,ble_disconnect.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &ble_disconnect, sizeof(ble_disconnect));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_query_device_state()                            */
+/*      wmrp10_rsi_ble_query_device_stateの実行                     */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_query_device_state(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_QUERY_DEVICE_STATE_PRM query_device_state = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&query_device_state, (void __user *)arg, sizeof(query_device_state));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    query_device_state.os_err_code = wmrp10_rsi_ble_query_device_state(&query_device_state.rsp,&query_device_state.rsi_err_code,query_device_state.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &query_device_state, sizeof(query_device_state));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_set_advertise_data()                            */
+/*      wmrp10_rsi_ble_set_advertise_dataの実行                     */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_set_advertise_data(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_SET_ADVERTISE_DATA_PRM set_advertise_data = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&set_advertise_data, (void __user *)arg, sizeof(set_advertise_data));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    set_advertise_data.os_err_code = wmrp10_rsi_ble_set_advertise_data(&set_advertise_data.req,&set_advertise_data.rsi_err_code,set_advertise_data.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &set_advertise_data, sizeof(set_advertise_data));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_advertise()                                     */
+/*      wmrp10_rsi_ble_advertiseの実行                              */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_advertise(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_ADVERTISE_PRM advertise = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&advertise, (void __user *)arg, sizeof(advertise));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    advertise.os_err_code = wmrp10_rsi_ble_advertise(&advertise.req, &advertise.rsi_err_code, advertise.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &advertise, sizeof(advertise));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_device_AddService()                             */
+/*      wmrp10_rsi_ble_device_AddService()の実行                    */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_device_AddService(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_DEVICE_ADDSERVICE_PRM AddService = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&AddService, (void __user *)arg, sizeof(AddService));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    AddService.os_err_code = wmrp10_rsi_ble_device_AddService(&AddService.req, &AddService.rsp, &AddService.rsi_err_code, AddService.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &AddService, sizeof(AddService));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_device_AddServicAttribute()                     */
+/*      wmrp10_rsi_ble_device_AddServicAttributeの実行              */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_device_AddServiceAttribute(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_DEVICE_ADDSERVICEATTRIBUTE_PRM AddServiceAttribute = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&AddServiceAttribute, (void __user *)arg, sizeof(AddServiceAttribute));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    AddServiceAttribute.os_err_code = wmrp10_rsi_ble_device_AddServiceAttribute(&AddServiceAttribute.req, &AddServiceAttribute.rsi_err_code, AddServiceAttribute.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &AddServiceAttribute, sizeof(AddServiceAttribute));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_device_ChangeLocalAttValue()                     */
+/*      wmrp10_rsi_ble_device_ChangeLocalAttValueの実行              */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_device_ChangeLocalAttValue(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_DEVICE_CHANGELOCALATTVALUE_PRM ChangeLocalAttValue = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&ChangeLocalAttValue, (void __user *)arg, sizeof(ChangeLocalAttValue));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    ChangeLocalAttValue.os_err_code = wmrp10_rsi_ble_device_ChangeLocalAttValue(&ChangeLocalAttValue.req, &ChangeLocalAttValue.rsi_err_code, ChangeLocalAttValue.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &ChangeLocalAttValue, sizeof(ChangeLocalAttValue));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    
+    return retval;
+}
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_query_profile()                                 */
+/*      wmrp10_rsi_ble_query_profileの実行                          */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_query_profile(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_QUERY_PROFILE_PRM query_profile = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&query_profile, (void __user *)arg, sizeof(query_profile));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    query_profile.os_err_code = wmrp10_rsi_ble_query_profile(&query_profile.req,&query_profile.rsp,&query_profile.rsi_err_code,query_profile.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &query_profile, sizeof(query_profile));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_read_char_value_by_UUID()                       */
+/*      wmrp10_rsi_ble_read_char_value_by_UUIDの実行                */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_read_char_value_by_UUID(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_READ_CHAR_VALUE_BY_UUID_PRM read_char_value_by_uuid = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&read_char_value_by_uuid, (void __user *)arg, sizeof(read_char_value_by_uuid));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    read_char_value_by_uuid.os_err_code = wmrp10_rsi_ble_read_char_value_by_UUID(&read_char_value_by_uuid.req, &read_char_value_by_uuid.rsp, &read_char_value_by_uuid.rsi_err_code, read_char_value_by_uuid.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &read_char_value_by_uuid, sizeof(read_char_value_by_uuid));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_ble_event()                                         */
+/*      wmrp10_rsi_ble_eventの実行                                  */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*              :  -1    失敗                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_ble_event(unsigned long arg)
+{
+    int retval = 0;
+    WMRP10_IOCTL_BLE_EVENT_PRM ble_event = {0};
+    
+#if WMRP10_DEBUG
+    printk("%s\n", __func__);
+#endif
+    g_frame_read_type = WMRP10_BLE_FRAME;
+    
+    retval = copy_from_user(&ble_event, (void __user *)arg, sizeof(ble_event));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    /* rsi_app 実行 */
+    ble_event.os_err_code = wmrp10_rsi_ble_event(&ble_event.val, ble_event.timeout);
+    
+    retval = copy_to_user((void __user *)arg, &ble_event, sizeof(ble_event));
+    if(retval < 0)
+    {
+        return -EFAULT;
+    }
+    return retval;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_open()                                              */
+/*      ioctl Open時の処理                                           */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_open(struct inode *inode, struct file *filp)
+{
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_close()                                             */
+/*      ioctl Close時の処理                                         */
+/*      input   :  引数ポインタ                                      */
+/*      return  :  0     成功                                       */
+/*------------------------------------------------------------------*/
+static int wmrp10_btle_close(struct inode *inode, struct file *filp)
+{
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_read()                                              */
+/*      ioctl Read処理                                              */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*------------------------------------------------------------------*/
+ssize_t wmrp10_btle_read(struct file *flip, char __user *usr, size_t sz, loff_t *of)
+{
+    return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_btle_write()                                             */
+/*      ioctl Write処理                                             */
+/*      input   :  引数ポインタ                                       */
+/*      return  :  0     成功                                       */
+/*------------------------------------------------------------------*/
+ssize_t wmrp10_btle_write(struct file *flip, const char __user *usr, size_t sz, loff_t *of)
+{
+    return 0;
+}
+
+/* 各種システムコールに対応するハンドラテーブル */
+struct file_operations ioctl_fops = {
+    .owner   = THIS_MODULE,
+    .open    = wmrp10_btle_open,
+    .release = wmrp10_btle_close,
+    .read    = wmrp10_btle_read,
+    .write   = wmrp10_btle_write,
+    .unlocked_ioctl = wmrp10_btle_ioctl,
+    .compat_ioctl   = wmrp10_btle_ioctl,   // for 32-bit App
+};
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_driver_init()                                            */
+/*      ioctl ドライバの初期化処理                                    */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*------------------------------------------------------------------*/
+int __init wmrp10_driver_init(void)
+{
+    int major;
+    int ret = 0;
+    
+    major = register_chrdev(wmrp10_btle_dev,DRIVER_NAME,&ioctl_fops);
+    
+    if((wmrp10_major > 0 && major != 0) ||
+    (wmrp10_major == 0 && major < 0) ||
+    (major < 0))
+    {
+        pr_err("%s driver registration error\n", DRIVER_NAME);
+        ret = major;
+            goto error;
+    }
+    if(wmrp10_major == 0)
+    {
+        wmrp10_major = major;
+    }
+    
+    wmrp10_class = class_create(THIS_MODULE, DRIVER_NAME);
+    if(IS_ERR(wmrp10_class))
+    {
+        goto error1;
+    }
+    wmrp10_btle_dev = MKDEV(wmrp10_major, wmrp10_major);
+    device_create(wmrp10_class,
+                  NULL,
+                  wmrp10_btle_dev,
+                  NULL,
+                  "btle%d",
+                  wmrp10_minor);
+                  
+    pr_info("%s driver(major %d) installed.\n",
+            DRIVER_NAME, wmrp10_major);
+
+    return 0;
+error1:
+    unregister_chrdev(wmrp10_major, DRIVER_NAME);
+error:
+    return ret;
+    
+}
+
+/*------------------------------------------------------------------*/
+/*  wmrp10_driver_exit()                                            */
+/*      ioctl ドライバの終了処理                                      */
+/*      input   :  なし                                              */
+/*      return  :  0     成功                                       */
+/*------------------------------------------------------------------*/
+void wmrp10_driver_exit(void)
+{
+    device_destroy(wmrp10_class, wmrp10_btle_dev);
+    class_destroy(wmrp10_class);
+    unregister_chrdev(wmrp10_major, DRIVER_NAME);
+    pr_info("driver " DRIVER_NAME " removed\n");
+}
+
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/wireless/wmrp10/wmrp10_ioctl.h b/drivers/net/wireless/wmrp10/wmrp10_ioctl.h
new file mode 100644
index 0000000..32ebed7
--- /dev/null
+++ b/drivers/net/wireless/wmrp10/wmrp10_ioctl.h
@@ -0,0 +1,278 @@
+#ifndef _IOCTL_H_
+#define _IOCTL_H_
+
+#include "wmrp10_bt_rsi.h"
+#include "wmrp10_ble_rsi.h"
+#include "wmrp10_bt_os.h"
+#include "wmrp10_ble_os.h"
+#include "rsi_bt_global.h"
+#include "rsi_ble_global.h"
+
+int wmrp10_driver_init(void);
+void wmrp10_driver_exit(void);
+
+#define MYDEVICE_IOC_TYPE 'M'
+
+typedef struct wmrp10_ioctl_bt_oper
+{
+    rsi_uOperMode req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_OPER_PRM;
+
+typedef struct wmrp10_ioctl_bt_local_name
+{
+    RSI_BT_CMD_SET_LOCAL_NAME req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_LOCAL_NAME_PRM;
+
+typedef struct wmrp10_ioctl_bt_query_local_bd_address
+{
+    RSI_BT_RESP_QUERY_LOCAL_BD_ADDRESS *rsp;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_QUERY_LOCAL_BD_ADDRESS_PRM;
+
+typedef struct wmrp10_ioctl_bt_set_profile_mode
+{
+    RSI_BT_CMD_SET_PROFILE_MODE req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_SET_PROFILE_MODE_PRM;
+
+typedef struct wmrp10_ioctl_bt_set_connectability_mode
+{
+    RSI_BT_CMD_SET_CONNECTABILITY_MODE req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_SET_CONNECTABILITY_MODE_PRM;
+
+typedef struct wmrp10_ioctl_bt_set_discovery_mode
+{
+    RSI_BT_CMD_SET_DISCV_MODE req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_SET_DISCOVERY_MODE_PRM;
+
+typedef struct wmrp10_ioctl_bt_inquiry
+{
+    RSI_BT_CMD_INQUIRY req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_INQUIRY_PRM;
+
+typedef struct wmrp10_ioctl_bt_inquiry_cancel
+{
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_INQUIRY_CANCEL_PRM;
+
+typedef struct wmrp10_ioctl_bt_bond
+{
+    RSI_BT_CMD_BOND req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_BOND_PRM;
+
+typedef struct wmrp10_ioctl_bt_pincode_reply
+{
+    RSI_BT_CMD_PINCODE_REPLY req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_PINCODE_REPLY_PRM;
+
+typedef struct wmrp10_ioctl_bt_linkkey_reply
+{
+    RSI_BT_CMD_LINKKEY_REPLY req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_LINKKEY_REPLY_PRM;
+
+typedef struct wmrp10_ioctl_bt_spp_connect
+{
+    RSI_BT_CMD_SPP_CONNECT req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_SPP_CONNECT_PRM;
+
+typedef struct wmrp10_ioctl_bt_spp_disconnect
+{
+    RSI_BT_CMD_SPP_DISCONNECT req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_SPP_DISCONNECT_PRM;
+
+typedef struct wmrp10_ioctl_bt_spp_transfer
+{
+    RSI_BT_CMD_SPP_TRANSFER req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_SPP_TRANSFER_PRM;
+
+typedef struct wmrp10_ioctl_bt_event
+{
+    T_WMRP10_BT_EVENT val;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BT_EVENT_PRM;
+
+typedef struct wmrp10_ioctl_ble_set_random_address
+{
+    RSI_BLE_CMD_SET_RANDOM_ADDRESS req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_SET_RANDOM_ADDRESS_PRM;
+
+typedef struct wmrp10_ioctl_ble_scan
+{
+    RSI_BLE_CMD_SCAN req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_SCAN_PRM;
+
+typedef struct wmrp10_ioctl_ble_connect
+{
+    RSI_BLE_CMD_CONNECT req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_CONNECT_PRM;
+
+typedef struct wmrp10_ioctl_ble_disconnect
+{
+    RSI_BLE_CMD_DISCONNECT req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_DISCONNECT_PRM;
+
+typedef struct wmrp10_ioctl_ble_query_device_state
+{
+    RSI_BLE_RESP_QUERY_DEVICE_STATE rsp;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_QUERY_DEVICE_STATE_PRM;
+
+typedef struct wmrp10_ioctl_ble_set_advertise_data
+{
+    RSI_BLE_CMD_SET_ADVERTISE_DATA req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_SET_ADVERTISE_DATA_PRM;
+
+typedef struct wmrp10_ioctl_ble_advertise
+{
+    RSI_BLE_CMD_ADVERTISE req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_ADVERTISE_PRM;
+
+typedef struct wmrp10_ioctl_ble_device_AddService
+{
+    RSI_BLE_CMD_ADD_GATT_SERVICE req;
+    RSI_BLE_RESP_ADD_GATT_SERVICE rsp;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_DEVICE_ADDSERVICE_PRM;
+
+typedef struct wmrp10_ioctl_ble_device_AddServiceAttribute
+{
+    RSI_BLE_CMD_ADD_GATT_ATTRIBUTE req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_DEVICE_ADDSERVICEATTRIBUTE_PRM;
+
+typedef struct wmrp10_ioctl_ble_device_ChangeLocalAttValue
+{
+    RSI_BLE_CMD_SET_LOCAL_ATT_VALUE req;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_DEVICE_CHANGELOCALATTVALUE_PRM;
+
+typedef struct wmrp10_ioctl_ble_query_profile
+{
+    RSI_BLE_CMD_QUERY_PROFILE req;
+    RSI_BLE_RESP_QUERY_PROFILE_DESCRIPTOR rsp;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_QUERY_PROFILE_PRM;
+
+typedef struct wmrp10_ioctl_ble_read_char_value_by_uuid
+{
+    RSI_BLE_CMD_READ_CHAR_VALUE_BY_UUID  req;
+    RSI_BLE_RESP_READ_CHAR_VALUE_BY_UUID rsp;
+    UINT16 rsi_err_code;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_READ_CHAR_VALUE_BY_UUID_PRM;
+
+typedef struct wmrp10_ioctl_ble_event
+{
+    T_WMRP10_BLE_EVENT val;
+    UINT16 os_err_code;
+    INT32 timeout;
+}WMRP10_IOCTL_BLE_EVENT_PRM;
+
+
+extern int g_oper_flag;
+extern int g_prm_flag;
+
+
+/* fixing */
+#define WMRP10_IOCTL_APP_INIT                          _IO (MYDEVICE_IOC_TYPE, 1)
+#define WMRP10_IOCTL_APP_EXIT                          _IO (MYDEVICE_IOC_TYPE, 2)
+#define WMRP10_IOCTL_BT_OPER_MODE                      _IOW(MYDEVICE_IOC_TYPE, 3 , struct wmrp10_ioctl_bt_oper)
+#define WMRP10_IOCTL_BT_SET_LOCAL_NAME                 _IOW(MYDEVICE_IOC_TYPE, 4 , struct wmrp10_ioctl_bt_local_name)
+#define WMRP10_IOCTL_BT_QUERY_LOCAL_BD_ADDRESS         _IOW(MYDEVICE_IOC_TYPE, 5 , struct wmrp10_ioctl_bt_query_local_bd_address)
+#define WMRP10_IOCTL_BT_SET_PROFILE_MODE               _IOW(MYDEVICE_IOC_TYPE, 6 , struct wmrp10_ioctl_bt_set_profile_mode)
+#define WMRP10_IOCTL_BT_SET_CONNECTABILITY_MODE        _IOW(MYDEVICE_IOC_TYPE, 7 , struct wmrp10_ioctl_bt_set_connectability_mode)
+#define WMRP10_IOCTL_BT_SET_DISCOVERY_MODE             _IOW(MYDEVICE_IOC_TYPE, 8 , struct wmrp10_ioctl_bt_set_discovery_mode)
+#define WMRP10_IOCTL_BT_INQUIRY                        _IOW(MYDEVICE_IOC_TYPE, 9 , struct wmrp10_ioctl_bt_inquiry)
+#define WMRP10_IOCTL_BT_INQUIRY_CANCEL                 _IOW(MYDEVICE_IOC_TYPE, 10 , struct wmrp10_ioctl_bt_inquiry_cancel)
+#define WMRP10_IOCTL_BT_BOND                           _IOW(MYDEVICE_IOC_TYPE, 11 , struct wmrp10_ioctl_bt_bond)
+#define WMRP10_IOCTL_BT_PINCODE_REPLY                  _IOW(MYDEVICE_IOC_TYPE, 12 , struct wmrp10_ioctl_bt_pincode_reply)
+#define WMRP10_IOCTL_BT_LINKKEY_REPLY                  _IOW(MYDEVICE_IOC_TYPE, 13 , struct wmrp10_ioctl_bt_linkkey_reply)
+#define WMRP10_IOCTL_BT_SPP_CONNECT                    _IOW(MYDEVICE_IOC_TYPE, 14 , struct wmrp10_ioctl_bt_spp_connect)
+#define WMRP10_IOCTL_BT_SPP_DISCONNECT                 _IOW(MYDEVICE_IOC_TYPE, 15 , struct wmrp10_ioctl_bt_spp_disconnect)
+#define WMRP10_IOCTL_BT_SPP_TRANSFER                   _IOW(MYDEVICE_IOC_TYPE, 16 , struct wmrp10_ioctl_bt_spp_transfer)
+#define WMRP10_IOCTL_BT_EVENT                          _IOW(MYDEVICE_IOC_TYPE, 17 , struct wmrp10_ioctl_bt_event)
+#define WMRP10_IOCTL_BLE_SET_RANDOM_ADDRESS            _IOW(MYDEVICE_IOC_TYPE, 18 , struct wmrp10_ioctl_ble_set_random_address)
+#define WMRP10_IOCTL_BLE_SCAN                          _IOW(MYDEVICE_IOC_TYPE, 19 , struct wmrp10_ioctl_ble_scan)
+#define WMRP10_IOCTL_BLE_CONNECT                       _IOW(MYDEVICE_IOC_TYPE, 20 , struct wmrp10_ioctl_ble_connect)
+#define WMRP10_IOCTL_BLE_DISCONNECT                    _IOW(MYDEVICE_IOC_TYPE, 21 , struct wmrp10_ioctl_ble_disconnect)
+#define WMRP10_IOCTL_BLE_QUERY_DEVICE_STATE            _IOW(MYDEVICE_IOC_TYPE, 22 , struct wmrp10_ioctl_ble_query_device_state)
+#define WMRP10_IOCTL_BLE_SET_ADVERTISE_DATA            _IOW(MYDEVICE_IOC_TYPE, 23 , struct wmrp10_ioctl_ble_set_advertise_data)
+#define WMRP10_IOCTL_BLE_ADVERTISE                     _IOW(MYDEVICE_IOC_TYPE, 24 , struct wmrp10_ioctl_ble_advertise)
+#define WMRP10_IOCTL_BLE_DEVICE_ADDSERVICE             _IOW(MYDEVICE_IOC_TYPE, 25 , struct wmrp10_ioctl_ble_device_AddService)
+#define WMRP10_IOCTL_BLE_DEVICE_ADDSERVICEATTRIBUTE    _IOW(MYDEVICE_IOC_TYPE, 26 , struct wmrp10_ioctl_ble_device_AddServiceAttribute)
+#define WMRP10_IOCTL_BLE_DEVICE_CHANGELOCALATTVALUE    _IOW(MYDEVICE_IOC_TYPE, 27 , struct wmrp10_ioctl_ble_device_ChangeLocalAttValue)
+#define WMRP10_IOCTL_BLE_QUERY_PROFILE                 _IOW(MYDEVICE_IOC_TYPE, 28 , struct wmrp10_ioctl_ble_query_profile)
+#define WMRP10_IOCTL_BLE_READ_CHAR_VALUE_BY_UUID       _IOW(MYDEVICE_IOC_TYPE, 29 , struct wmrp10_ioctl_ble_read_char_value_by_uuid)
+#define WMRP10_IOCTL_BLE_EVENT                         _IOW(MYDEVICE_IOC_TYPE, 30 , struct wmrp10_ioctl_ble_event)
+
+
+#endif
