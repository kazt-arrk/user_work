diff --git a/arch/arm/boot/dts/r8a7745-aprzg0a.dts b/arch/arm/boot/dts/r8a7745-aprzg0a.dts
new file mode 100644
index 0000000..ea49e74
--- /dev/null
+++ b/arch/arm/boot/dts/r8a7745-aprzg0a.dts
@@ -0,0 +1,524 @@
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "r8a7745.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/* LCDKIT */
+// #define LCD_KIT_B01
+// #define LCD_KIT_C01
+// #define LCD_KIT_D01
+// #define LCD_KIT_D02
+
+/* USB */
+// #define USB0_HOSTMODE
+
+/ {
+	model = "AP-RZG-0A Board (BSP : Ver2.0)";
+	compatible = "ap,aprzg0a", "renesas,r8a7745";
+
+	aliases {
+		serial0 = &scif0;
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0 0x40000000 0 0x20000000>;
+	};
+
+	lbsc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		led1 {
+			gpios = <&gpio6 24 GPIO_ACTIVE_HIGH>;
+		};
+		led2 {
+			gpios = <&gpio6 25 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	reg_3p3v: 3p3v {
+		compatible = "regulator-fixed";
+		regulator-name = "3P3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	reg_0p0v: 0p0v {
+		compatible = "regulator-fixed";
+		regulator-name = "0P0V";
+		regulator-min-microvolt = <0000000>;
+		regulator-max-microvolt = <0000000>;
+		regulator-always-on;
+	};
+
+
+	fixedregulator3v3: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "fixed-3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	lcd@0 {
+#if defined(LCD_KIT_B01) || defined(LCD_KIT_C01)
+		compatible = "apj,lcdkit", "simple-panel";
+#endif
+#if defined(LCD_KIT_D01) || defined(LCD_KIT_D02)
+		compatible = "apj,lcdkit_d", "simple-panel";
+#endif
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				reg = <0>;
+				lcd_in: endpoint {
+					reg = <0>;
+					remote-endpoint = <&du_out_rgb0>;
+				};
+			};
+		};
+	};
+
+	x2_clk: x2-clock {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <10800000>;
+	};
+
+	sound {
+		compatible = "simple-audio-card";
+
+		simple-audio-card,format = "i2s";
+		simple-audio-card,bitclock-master = <&soundcodec>;
+		simple-audio-card,frame-master = <&soundcodec>;
+
+		sndcpu: simple-audio-card,cpu {
+			sound-dai = <&rcar_sound>;
+		};
+
+		soundcodec: simple-audio-card,codec {
+			sound-dai = <&max9867>;
+			bitclock-master;
+			frame-master;
+			system-clock-frequency = <12187500>;
+		};
+	};
+};
+
+&extal_clk {
+	clock-frequency = <20000000>;
+};
+
+&i2c3 {
+	status = "okay";
+	clock-frequency = <100000>;
+
+#if defined(LCD_KIT_B01)
+	lcdkitb01: lcdkitb01@0x42 {
+		pinctrl-0 = <&lcdkit_pins>;
+		pinctrl-names = "default";
+		compatible = "apj,lcdkitb01";
+		reg = <0x42>;
+		interrupt-parent = <&irqc0>;
+		interrupts = <9 IRQ_TYPE_LEVEL_HIGH>;
+		
+		status = "okay";
+	};
+#endif
+
+#if defined(LCD_KIT_C01)
+	lcdkitc01: lcdkitc01@0x42 {
+		pinctrl-0 = <&lcdkit_pins>;
+		pinctrl-names = "default";
+		compatible = "apj,lcdkitc01";
+		reg = <0x42>;
+		interrupt-parent = <&irqc0>;
+		interrupts = <9 IRQ_TYPE_LEVEL_HIGH>;
+		
+		status = "okay";
+	};
+#endif
+
+#if defined(LCD_KIT_D01)
+	lcdkitd01: lcdkitd01@0x42 {
+		pinctrl-0 = <&lcdkit_pins>;
+		pinctrl-names = "default";
+		compatible = "apj,lcdkitd01";
+		reg = <0x42>;
+		interrupt-parent = <&irqc0>;
+		interrupts = <9 IRQ_TYPE_LEVEL_HIGH>;
+
+		status = "okay";
+	};
+#endif
+
+#if defined(LCD_KIT_D02)
+	lcdkitd02: lcdkitd02@0x42 {
+		pinctrl-0 = <&lcdkit_pins>;
+		pinctrl-names = "default";
+		compatible = "apj,lcdkitd02";
+		reg = <0x42>;
+		interrupt-parent = <&irqc0>;
+		interrupts = <9 IRQ_TYPE_LEVEL_HIGH>;
+
+		status = "okay";
+	};
+#endif
+
+	vscam01: vscam01@0x70 {
+		compatible = "apj,vscam01";
+		reg = <0x70>;
+		remote = <&vin0>;
+	
+		gpio_vscam_pwdn  = <&gpio3 30 GPIO_ACTIVE_HIGH>;
+		gpio_vscam_reset = <&gpio3 31 GPIO_ACTIVE_HIGH>;
+		gpio_vscam_xclk  = <&gpio3 29 GPIO_ACTIVE_HIGH>;
+
+		status = "okay";
+
+		port {
+			vscam01_ep: endpoint {
+				bus-width = <8>;
+				pclk-sample = <1>;
+				remote-endpoint = <&vin0_ep>;
+			};
+		};
+	};
+};
+
+
+&i2c7 {
+	status = "okay";
+	clock-frequency = <400000>;
+	
+	s35390a: s35390a@30 {
+		compatible = "s35390a";
+		reg = <0x30>;
+	};
+
+	max9867: max9867@0x18 {
+		#sound-dai-cells = <0>;
+		compatible = "maxim,max9867";
+		reg = <0x18>;
+	};
+	
+	eeprom@50 {
+		compatible = "renesas,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+};
+
+
+&pfc {
+	scif0_pins: serial0 {
+		renesas,groups = "scif0_data_d";
+		renesas,function = "scif0";
+	};	
+
+	du0_pins: du0 {
+		renesas,groups = "du0_rgb888", "du0_sync", "du0_disp",
+				"du0_clk0_out";
+		renesas,function = "du0";
+	};
+
+	ether_pins: ether {
+		renesas,groups = "eth_link", "eth_mdio", "eth_rmii";
+		renesas,function = "eth";
+	};
+
+	phy1_pins: phy1 {
+		renesas,groups = "intc_irq8";
+		renesas,function = "intc";
+	};
+
+	qspi_pins: spi0 {
+		renesas,groups = "qspi_ctrl", "qspi_data4";
+		renesas,function = "qspi";
+	};
+	
+	msiof0_pins: spi1 {
+		renesas,groups = "msiof0_clk", "msiof0_ss1", 
+				 "msiof0_rx", "msiof0_tx";
+		renesas,function = "msiof0";
+	};
+
+	usb0_pins: usb0 {
+		renesas,groups = "usb0";
+		renesas,function = "usb0";
+	};
+
+	usb1_pins: usb1 {
+		renesas,groups = "usb1";
+		renesas,function = "usb1";
+	};
+
+	vin0_pins: vin0 {
+		renesas,groups = "vin0_data8", "vin0_sync", "vin0_clk";
+		renesas,function = "vin0";
+	};
+
+	sound_pins: sound {
+		renesas,groups = "ssi0129_ctrl", "ssi0_data", "ssi1_data";
+		renesas,function = "ssi";
+	};
+
+
+	sound_clk_out_pins: sound_clk {
+		renesas,groups = "audio_clkout";
+		renesas,function = "audio_clk";
+	};
+
+	sdhi1_pins: sd1 {
+		renesas,groups = "sdhi1_data4", "sdhi1_ctrl", "sdhi1_cd";
+		renesas,function = "sdhi1";
+		power-source = <3300>;
+	};
+
+	sdhi2_pins: sd2 {
+		renesas,groups = "sdhi2_data4", "sdhi2_ctrl";
+		renesas,function = "sdhi2";
+		power-source = <3300>;
+	};
+
+	
+	lcdkit_pins: lcdkit {
+		renesas,groups = "intc_irq9";
+		renesas,function = "intc";
+	};
+
+	wmrp_pins: wmrp {
+		renesas,groups = "intc_irq5";
+		renesas,function = "intc";
+	};
+};
+
+&ether {
+	phy-handle = <&phy1>;
+	renesas,ether-link-active-low;
+	status = "ok";
+
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+		interrupt-parent = <&irqc0>;
+		interrupts = <8 IRQ_TYPE_LEVEL_LOW>;
+		micrel,led-mode = <1>;
+	};
+};
+
+&scif0 {
+	pinctrl-0 = <&scif0_pins>;
+	pinctrl-names = "default";
+
+	status = "okay";
+};
+
+&qspi {
+	status = "okay";
+
+	flash: flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spansion,s25fl512s";
+		reg = <0>;
+		spi-max-frequency = <30000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+		m25p,fast-read;
+		spi-cpol;
+		spi-cpha;
+
+		partition@0 {
+			label = "loader";
+			reg = <0x00000000 0x00040000>;
+			read-only;
+		};
+		partition@40000 {
+			label = "tfrinfo";
+			reg = <0x00040000 0x00040000>;
+		};
+		partition@80000 {
+			label = "u-boot";
+			reg = <0x00080000 0x00580000>;
+		};
+		partition@600000 {
+			label = "data";
+			reg = <0x00600000 0x03a00000>;
+		};
+	};
+};
+
+&sdhi1 {
+	pinctrl-0 = <&sdhi1_pins>;
+	pinctrl-names = "default";
+
+	vmmc-supply = <&reg_3p3v>;
+	vqmmc-supply = <&reg_3p3v>;
+	gpio = <&gpio6 15 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+};
+
+&sdhi2 {
+	pinctrl-0 = <&sdhi2_pins>;
+	pinctrl-names = "default";
+
+
+	vmmc-supply = <&reg_3p3v>;
+	vqmmc-supply = <&reg_3p3v>;
+	gpio = <&gpio6 22 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+};
+
+&rcar_sound {
+	pinctrl-0 = <&sound_pins &sound_clk_out_pins>;
+	pinctrl-names = "default";
+
+	#sound-dai-cells = <0>;
+
+	status = "okay";
+
+	rcar_sound,dai {
+		dai0 {
+			playback = <&ssi0 &src1 &dvc0>;
+			capture  = <&ssi1 &src2 &dvc1>;
+		};
+	};
+};
+
+&ssi1 {
+	shared-pin;
+};
+
+&can0 {
+	renesas,can-clock-select = <0x0>;
+	status = "okay";
+};
+
+&du {
+	pinctrl-0 = <&du0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+
+	clocks = <&mstp7_clks R8A7745_CLK_DU0>,
+		<&mstp7_clks R8A7745_CLK_DU1>;
+	clock-names = "du.0","du.1";
+
+	ports {
+		port@0 {
+			endpoint {
+				remote-endpoint = <&lcd_in>;
+			};
+		};
+	};
+};
+
+#if defined(USB0_HOSTMODE)
+&pci0 {
+	status = "okay";
+	pinctrl-0 = <&usb0_pins>;
+	pinctrl-names = "default";
+};
+#endif
+
+&pci1 {
+	status = "okay";
+	pinctrl-0 = <&usb1_pins>;
+	pinctrl-names = "default";
+};
+
+&hsusb {
+	status = "okay";
+};
+
+&usbphy {
+	status = "okay";
+};
+
+&msiof0 {
+	pinctrl-0 = <&msiof0_pins &wmrp_pins>;
+	pinctrl-names = "default";
+
+	status = "okay";
+
+	renesas,tx-fifo-size = <256>;
+	renesas,rx-fifo-size = <256>;
+	renesas,dtdl = <50>;
+	renesas,syncdl = <50>;
+
+	wmrp0x_spi: wmrp0x_spi@0 {
+    		compatible = "apj,wmrp0x_spi";
+		reg = <0>;		
+		spi-max-frequency = <25000000>;
+		/* spi-cpha; */
+		/* spi-cpol; */
+
+		interrupt-parent = <&irqc0>;
+		interrupts = <5 IRQ_TYPE_LEVEL_HIGH>;
+		gpio_power = <&gpio2 26 GPIO_ACTIVE_HIGH>;
+		gpio_reset = <&gpio4 7 GPIO_ACTIVE_HIGH>;
+
+		status = "okay";
+	};
+};
+
+&vin0 {
+	status = "okay";
+	pinctrl-0 = <&vin0_pins>;
+	pinctrl-names = "default";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vin0_ep: endpoint {
+			remote-endpoint = <&vscam01_ep>;
+			bus-width = <8>;
+
+			/* If hsync-active/vsync-active are missing,
+			   embedded BT.656 sync is used */
+			hsync-active = <1>;	/* Active high */
+			vsync-active = <0>;	/* Active low */
+			data-active = <1>;	/* Active high */
+			pclk-sample = <1>;	/* Rising */
+		};
+	};
+};
+
+&gpio5 {
+	usb0_host_func-gpio {
+		gpio-hog;
+		gpios = <9 GPIO_ACTIVE_HIGH>;
+#if defined(USB0_HOSTMODE)
+		output-high;
+#else
+		output-low;
+#endif
+		line-name = "USB0 Host/Func";
+	};
+};
+
+
diff --git a/arch/arm/boot/dts/r8a7745.dtsi b/arch/arm/boot/dts/r8a7745.dtsi
index 4385223..6416816 100644
--- a/arch/arm/boot/dts/r8a7745.dtsi
+++ b/arch/arm/boot/dts/r8a7745.dtsi
@@ -1437,18 +1437,19 @@
 		mstp1_clks: mstp1_clks@e6150134 {
 			compatible = "renesas,r8a7745-mstp-clocks", "renesas,cpg-mstp-clocks";
 			reg = <0 0xe6150134 0 4>, <0 0xe6150038 0 4>;
-			clocks = <&zs_clk>, <&zs_clk>, <&p_clk>, <&zg_clk>, <&zs_clk>,
-				 <&zs_clk>, <&p_clk>, <&p_clk>, <&rclk_clk>, <&cp_clk>,
-				 <&zs_clk>, <&zs_clk>;
+			clocks = <&zs_clk>, <&zs_clk>, <&m2_clk>, <&p_clk>, <&zg_clk>,
+				 <&zs_clk>, <&zs_clk>, <&p_clk>, <&p_clk>, <&rclk_clk>,
+				 <&cp_clk>, <&zs_clk>, <&zs_clk>;
 			#clock-cells = <1>;
 			clock-indices = <
-				R8A7745_CLK_VCP0 R8A7745_CLK_VPC0 R8A7745_CLK_TMU1
-				R8A7745_CLK_3DG R8A7745_CLK_2DDMAC R8A7745_CLK_FDP1_0
-				R8A7745_CLK_TMU3 R8A7745_CLK_TMU2 R8A7745_CLK_CMT0
-				R8A7745_CLK_TMU0 R8A7745_CLK_VSP1_DU0 R8A7745_CLK_VSP1_S
+				R8A7745_CLK_VCP0 R8A7745_CLK_VPC0 R8A7745_CLK_ADG 
+				R8A7745_CLK_TMU1 R8A7745_CLK_3DG R8A7745_CLK_2DDMAC 
+				R8A7745_CLK_FDP1_0 R8A7745_CLK_TMU3 R8A7745_CLK_TMU2 
+				R8A7745_CLK_CMT0 R8A7745_CLK_TMU0 R8A7745_CLK_VSP1_DU0 
+				R8A7745_CLK_VSP1_S
 			>;
 			clock-output-names =
-				"vcp0", "vpc0", "tmu1", "3dg", "2ddmac", "fdp1-0",
+				"vcp0", "vpc0", "adg", "tmu1", "3dg", "2ddmac", "fdp1-0",
 				"tmu3", "tmu2", "cmt0", "tmu0", "vsp1-du0", "vsp1-sy";
 		};
 		mstp2_clks: mstp2_clks@e6150138 {
diff --git a/arch/arm/configs/aprzg0a_defconfig b/arch/arm/configs/aprzg0a_defconfig
new file mode 100644
index 0000000..8811b1b
--- /dev/null
+++ b/arch/arm/configs/aprzg0a_defconfig
@@ -0,0 +1,275 @@
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SLAB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_ARCH_SHMOBILE_MULTI=y
+CONFIG_ARCH_EMEV2=y
+CONFIG_ARCH_R7S72100=y
+CONFIG_ARCH_R8A73A4=y
+CONFIG_ARCH_R8A7740=y
+CONFIG_ARCH_R8A7743=y
+CONFIG_ARCH_R8A7745=y
+CONFIG_ARCH_R8A77470=y
+CONFIG_ARCH_R8A7778=y
+CONFIG_ARCH_R8A7779=y
+CONFIG_ARCH_R8A7790=y
+CONFIG_ARCH_R8A7742=y
+CONFIG_ARCH_R8A7791=y
+CONFIG_ARCH_R8A7744=y
+CONFIG_ARCH_R8A7793=y
+CONFIG_ARCH_R8A7794=y
+CONFIG_ARCH_SH73A0=y
+CONFIG_MACH_APRZG0A=y
+CONFIG_ARM_LPAE=y
+CONFIG_PL310_ERRATA_588369=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_PCI=y
+CONFIG_PCI_RCAR_GEN2=y
+CONFIG_PCI_RCAR_GEN2_PCIE=y
+CONFIG_PCI_HOST_GENERIC=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_NR_CPUS=8
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_CMA=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_KEXEC=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_CAN=y
+CONFIG_CAN_RCAR=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_EXTRA_FIRMWARE="r8a779x_usb3_v1.dlmem"
+CONFIG_EXTRA_FIRMWARE_DIR="firmware"
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=128
+CONFIG_SIMPLE_PM_BUS=y
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=102400
+CONFIG_EEPROM_AT24=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_ATA=y
+CONFIG_SATA_RCAR=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HP is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+CONFIG_SH_ETH=y
+CONFIG_RAVB=y
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_SMSC_PHY=y
+CONFIG_MICREL_PHY=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ST1232=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_ADXL34X=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_EM=y
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_NR_UARTS=20
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_RIIC=y
+CONFIG_I2C_SH_MOBILE=y
+CONFIG_I2C_RCAR=y
+CONFIG_SPI=y
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_RSPI=y
+CONFIG_SPI_SH_MSIOF=y
+CONFIG_SPI_SH_HSPI=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_EM=y
+CONFIG_GPIO_RCAR=y
+CONFIG_GPIO_PCF857X=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_RMOBILE=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_CPU_THERMAL=y
+CONFIG_RCAR_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_DA9063_WATCHDOG=y
+CONFIG_RENESAS_WDT=y
+CONFIG_MFD_AS3711=y
+CONFIG_MFD_DA9063=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_AS3711=y
+CONFIG_REGULATOR_DA9210=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_MAX8973=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_PLATFORM=y
+CONFIG_VIDEO_RCAR_VIN=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_RENESAS_VSP1=y
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+# CONFIG_VGA_ARB is not set
+CONFIG_DRM=y
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_RCAR_DU=y
+CONFIG_DRM_RCAR_HDMI=y
+CONFIG_DRM_RCAR_LVDS=y
+CONFIG_DRM_RCAR_VSP=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_FB_SH_MOBILE_LCDC=y
+CONFIG_FB_SH_MOBILE_HDMI=y
+CONFIG_FB_SH_MOBILE_MERAM=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_AS3711=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_SND_SOC_SH4_FSI=y
+CONFIG_SND_SOC_RCAR=y
+CONFIG_SND_SOC_RSRC_CARD=y
+CONFIG_SND_SOC_AK4642=y
+CONFIG_SND_SOC_SGTL5000=y
+CONFIG_SND_SOC_WM8978=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_RCAR=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_R8A66597_HCD=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_RCAR_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS_UDC=y
+CONFIG_USB_G_SERIAL=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHI=y
+CONFIG_MMC_SH_MMCIF=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_S35390A=y
+CONFIG_DMADEVICES=y
+CONFIG_SH_DMAE=y
+CONFIG_RCAR_DMAC=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_IIO=y
+CONFIG_AK8975=y
+CONFIG_PWM=y
+CONFIG_PWM_RCAR=y
+CONFIG_PWM_RENESAS_TPU=y
+CONFIG_GENERIC_PHY=y
+CONFIG_PHY_RCAR_GEN2=y
+CONFIG_EXT3_FS=y
+# CONFIG_DNOTIFY is not set
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_ARM_UNWIND is not set
diff --git a/arch/arm/mach-shmobile/Kconfig b/arch/arm/mach-shmobile/Kconfig
index 7c10b1a..3b9c81b 100644
--- a/arch/arm/mach-shmobile/Kconfig
+++ b/arch/arm/mach-shmobile/Kconfig
@@ -122,5 +122,15 @@ config ARCH_SH73A0
 	select ARCH_RMOBILE
 	select RENESAS_INTC_IRQPIN
 
+comment "Renesas ARM SoCs Board Type"
+
+config MACH_APRZG0A
+	bool "AP-RZG-0A board"
+	depends on ARCH_R8A7745
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	select SND_SOC_MAX9867 if SND_SIMPLE_CARD
+
+
 comment "Renesas ARM SoCs System Configuration"
 endif
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index f553f43..2bde5ae 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -371,6 +371,58 @@ static void panel_simple_shutdown(struct device *dev)
 	panel_simple_unprepare(&panel->base);
 }
 
+#if CONFIG_MACH_APRZG0A
+static const struct drm_display_mode apj_lcdkit_mode = {
+	.clock = 33260,
+	.hdisplay = 800,
+	.hsync_start = 800 + 0,
+	.hsync_end = 800 + 0 + 256,
+	.htotal = 800 + 0 + 256 + 0,
+	.vdisplay = 480,
+	.vsync_start = 480 + 0,
+	.vsync_end = 480 + 0 + 45,
+	.vtotal = 480 + 0 + 45 + 0,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,
+};
+
+static const struct panel_desc apj_lcdkit = {
+	.modes = &apj_lcdkit_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode apj_lcdkit_d_mode = {
+	.clock = 15000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 2,
+	.hsync_end = 480 + 2 + 41,
+	.htotal = 480 + 2 + 41 + 0,
+	.vdisplay = 272,
+	.vsync_start = 272 + 2,
+	.vsync_end = 272 + 2 + 10,
+	.vtotal = 272 + 2 + 10 + 0,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,
+};
+
+static const struct panel_desc apj_lcdkit_d = {
+	.modes = &apj_lcdkit_d_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+#endif
+
 static const struct drm_display_mode ampire_am800480r3tmqwa1h_mode = {
 	.clock = 33333,
 	.hdisplay = 800,
@@ -1125,6 +1177,15 @@ static const struct panel_desc shelly_sca07010_bfn_lnn = {
 };
 
 static const struct of_device_id platform_of_match[] = {
+//#if CONFIG_MACH_APRZG0A
+	{
+		.compatible = "apj,lcdkit",
+		.data = &apj_lcdkit,
+	}, {
+		.compatible = "apj,lcdkit_d",
+		.data = &apj_lcdkit_d,
+	},
+//#endif
 	{
 		.compatible = "ampire,am800480r3tmqwa1h",
 		.data = &ampire_am800480r3tmqwa1h,
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 3f1c987..ba2917f 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -11,6 +11,55 @@ menuconfig INPUT_TOUCHSCREEN
 
 if INPUT_TOUCHSCREEN
 
+config TOUCHSCREEN_LCDKIT
+	bool "LCD-KIT based touchscreens"
+
+if TOUCHSCREEN_LCDKIT
+
+choice
+	prompt "select LCD-KIT"
+	default TOUCHSCREEN_LCDKITB01
+
+config TOUCHSCREEN_LCDKITB01
+	bool "LCD-KIT-B01"
+	depends on TOUCHSCREEN_LCDKIT
+	depends on I2C
+	help
+	  Say Y here if you have a ALPHAPROJECT LCD-KIT-B01 based touchscreen.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_LCDKITC01
+	bool "LCD-KIT-C01"
+	depends on TOUCHSCREEN_LCDKIT
+	depends on I2C
+	help
+	  Say Y here if you have a ALPHAPROJECT LCD-KIT-C01 based touchscreen.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_LCDKITD01
+	bool "LCD-KIT-D01"
+	depends on TOUCHSCREEN_LCDKIT
+	depends on I2C
+	help
+	  Say Y here if you have a ALPHAPROJECT LCD-KIT-D01 based touchscreen.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_LCDKITD02
+	bool "LCD-KIT-D02"
+	depends on TOUCHSCREEN_LCDKIT
+	depends on I2C
+	help
+	  Say Y here if you have a ALPHAPROJECT LCD-KIT-D02 based touchscreen.
+
+	  If unsure, say N.
+
+endchoice
+
+endif # TOUCHSCREEN_LCDKIT
+
 config TOUCHSCREEN_PROPERTIES
 	def_tristate INPUT
 	depends on INPUT
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index cbaa6ab..4bcfc9f 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -91,3 +91,8 @@ obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
 obj-$(CONFIG_TOUCHSCREEN_COLIBRI_VF50)	+= colibri-vf50-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
+obj-$(CONFIG_TOUCHSCREEN_LCDKITB01)	+= lcdkitb01.o
+obj-$(CONFIG_TOUCHSCREEN_LCDKITC01)	+= lcdkitc01.o
+obj-$(CONFIG_TOUCHSCREEN_LCDKITD01)	+= lcdkitd01.o
+obj-$(CONFIG_TOUCHSCREEN_LCDKITD02)	+= lcdkitd02.o
+
diff --git a/drivers/input/touchscreen/lcdkitb01.c b/drivers/input/touchscreen/lcdkitb01.c
new file mode 100644
index 0000000..1d2f75d
--- /dev/null
+++ b/drivers/input/touchscreen/lcdkitb01.c
@@ -0,0 +1,939 @@
+/*
+ * LCD-KIT-B01 touchscreen
+ * Based on tsc2007.c
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ */
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/kthread.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/leds.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+
+#include <linux/gpio.h>
+#ifdef CONFIG_USE_OF
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#endif
+#include <linux/platform_data/gpio-rcar.h>
+
+/* Multi touch enable */
+//#define MULTI_TOUCH_ENABLE
+
+/* マウス仕様 */
+#define USE_MOUSE		0
+
+/* タッチ情報読み込みコマンド */
+#define CMD_TOUCH_INFO	0x10
+
+/* パネル情報読み込みコマンド */
+#define CMD_PANEL_INFO	0x20
+
+/* ファームウェア情報読み込みコマンド */
+#define CMD_FURM_INFO	0x40
+
+/* ファームウェア情報データサイズ */
+#define FURM_INFO_LEN	4
+
+/* パネル情報データサイズ */
+#define PANEL_INFO_LEN	6
+
+/* タッチ情報データサイズ */
+#define TOUCH_INFO_SIZE	9
+
+/* 最大読み込みデータサイズ */
+#define MAX_BLKSIZE		9
+
+/* タッチ検出用ビットマスク */
+#define T1_BITMASK		0x01
+#define T2_BITMASK		0x02
+
+#define STATUS_SW3		(1 << 4)
+#define STATUS_SW2		(1 << 3)
+#define STATUS_SW1		(1 << 2)
+#define STATUS_TP1		(1 << 1)
+#define STATUS_TP0		(1 << 0)
+
+#define READ_MSECS		5
+
+/* GPIO入力検出 */
+#define gic_spi(nr)		((nr) + 32)
+/* External IRQ pins */
+#define IRQPIN_BASE		2000
+#define irq_pin(nr)		((nr) + IRQPIN_BASE)
+
+/* 割り込みステータス */
+#define CMD_R8C_INTSTAT	0x01
+
+/* 割り込みマスク */
+#define CMD_R8C_INTMASK	0x02
+
+/* ペンアップ/ダウン検出 */
+#define CHECK_PENUPDOWN	3
+#define POS_AVG			5
+
+/* タッチフラグ */
+#define NOTOUCH			0
+#define TOUCHED			1
+
+/* デバッグメッセージ */
+//#define LCDKITB01_DEBUG
+#ifdef LCDKITB01_DEBUG
+#define dbg(format, arg...) printk(KERN_INFO __FILE__ ": "  format "\n", ## arg);
+#else
+#define dbg(format, arg...) do{} while(0);
+#endif
+
+struct led_classdev *g_sleepled_cdev = NULL; /* Backlight on/off Only */
+
+/* スクリーン情報構造体 */
+struct lcdkitb01_panel_info {
+	int xmax_low;	/* X下限値 */
+	int xmax_high;	/* X上限値 */
+	int ymax_low;	/* Y下限値 */
+	int ymax_high;	/* Y上限値 */
+	int x_cnum;		/* Xチャンネル数 */
+	int y_cnum;		/* Yチャンネル数 */
+};
+
+/* タッチ情報構造体 */
+struct lcdkitb01_touch_info{
+	int p1_x;		/* X1 */
+	int p1_y;		/* Y1 */
+	int p2_x;		/* X2 */
+	int p2_y;		/* Y1 */
+	bool p1_enable;	/* X1 Y1タッチ状態フラグ */
+	bool p2_enable;	/* X2 Y2タッチ状態フラグ */
+};
+
+/* タッチパネル情報構造体 */
+struct lcdkitb01 {
+	struct input_dev *input;			/* インプットデバイス */
+	struct i2c_client *client;			/* I2Cクライアント */
+	struct i2c_client *tp_client;		/* I2Cクライアント */
+	struct delayed_work work;			/* ワークキュー */
+	u8 ver[FURM_INFO_LEN];				/* ファームウェアバージョン */
+	struct lcdkitb01_panel_info p_info;	/* スクリーン情報 */
+	struct lcdkitb01_touch_info t_info;	/* タッチ情報 */
+	int irq;							/* IRQ */
+	u8 status;
+	spinlock_t lock;					/* スピンロック */
+	struct led_classdev led;
+	struct miscdevice buzzer;
+	int pendown;
+	int pendown_init;
+
+	struct timer_list timer;
+	int irq_pin_state;
+
+	struct lcdkitb01_platform_data *pdata;
+
+	enum led_brightness led_value;
+};
+
+static int g_up_count = 0;
+static int g_down_count = 0;
+
+static int g_pos1x_total;
+static int g_pos1x_min;
+static int g_pos1x_max;
+static int g_pos1y_total;
+static int g_pos1y_min;
+static int g_pos1y_max;
+static int g_pos1_count;
+
+static int g_pos2x_total;
+static int g_pos2x_min;
+static int g_pos2x_max;
+static int g_pos2y_total;
+static int g_pos2y_min;
+static int g_pos2y_max;
+static int g_pos2_count;
+
+static int g_pos1x;
+static int g_pos1y;
+static int g_pos1_enable;
+static int g_pos2x;
+static int g_pos2y;
+static int g_pos2_enable;
+
+#ifdef CONFIG_PM
+/*
+ * サスペンド
+ */
+static int lcdkitb01_i2c_suspend(struct i2c_client *client,
+					  pm_message_t message)
+{
+	dbg("**** %s ****\n", __func__);
+
+	return 0;
+}
+
+/*
+ * レジューム
+ */
+static int lcdkitb01_i2c_resume(struct i2c_client *client)
+{
+	dbg("**** %s ****\n", __func__);
+
+	return 0;
+}
+#endif
+
+/*
+ * I2C読み込み(1ワード)
+ */
+__attribute__((unused))
+static int lcdkitb01_i2c_read(struct i2c_client *client, u8 reg)
+{
+	return 0;
+}
+
+/*
+ * I2C読み込み(マルチワード)
+ */
+#define MEASURE_TIME 0
+#if MEASURE_TIME
+static struct timeval tv0 = {}, tv1 = {};
+#endif
+static int lcdkitb01_i2c_multi_read(struct i2c_client *client,
+				 u8 first_reg, u8 count, u8 *buf)
+{
+	u8  rcv[MAX_BLKSIZE];	/* 受信用バッファ */
+	int ret;		/* 受信バイト数 */
+
+	/* 受信サイズチェック */
+	if (MAX_BLKSIZE < count) {
+		pr_warning("%s overflow size %d\n", __func__, count);
+	}
+
+	/* 受信 */
+#if MEASURE_TIME
+	do_gettimeofday(&tv1);
+	printk(KERN_DEBUG "MR %8d\n",
+	       (tv1.tv_sec - tv0.tv_sec) * 1000000 +
+	       (tv1.tv_usec - tv0.tv_usec));
+	tv0 = tv1;
+#endif
+	ret = i2c_smbus_read_i2c_block_data(client, first_reg, count, rcv);
+	if (ret < 0 || count > ret) {
+		pr_warning("%s i2c_smbus_read_i2c_block_data fail %d\n", __func__, ret);
+		return -1;
+	}
+	memcpy(buf, rcv, count);
+
+	return ret;
+}
+
+/*
+ * 書き込み
+ */
+__attribute__((unused))
+static int lcdkitb01_i2c_write(struct i2c_client *client, u8 reg, u8 val)
+{
+	dbg("**** %s ****\n", __func__);
+
+	return 0;
+}
+
+static void lcdkitb01_penup(struct lcdkitb01 *ts)
+{
+	/* ペンアップ通知 */
+
+	if (ts->pendown == 0)
+		goto end;
+
+	if (g_up_count < CHECK_PENUPDOWN) {
+		schedule_delayed_work(&ts->work, msecs_to_jiffies(READ_MSECS));
+		g_up_count++;
+
+		goto end;
+	} else {
+		g_up_count = 0;
+	}
+
+	ts->pendown = 0;
+	ts->pendown_init = 0;
+
+	dbg("******************************Pen Up");
+
+#ifdef MULTI_TOUCH_ENABLE
+	input_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, 0);
+#endif
+	input_report_abs(ts->input, ABS_PRESSURE, 0);
+	input_report_key(ts->input, BTN_TOUCH, 0);
+	input_sync(ts->input);
+end:
+	;
+}
+
+static void tp_process(struct lcdkitb01 *ts)
+{
+	u8 rcv[MAX_BLKSIZE];	/* 受信用バッファ */
+	int tmp_x, tmp_y;		/* ポイントテンポラリ */
+	int major = 70;
+
+	if (0 > lcdkitb01_i2c_multi_read(ts->tp_client,
+				      CMD_TOUCH_INFO,
+				      TOUCH_INFO_SIZE,
+				      rcv)) {
+		pr_warning("%s panel info read fail\n", __func__);
+		goto end;
+	}
+
+	/* タッチ情報の読み込み */
+	ts->t_info.p1_enable = rcv[0] & T1_BITMASK;
+	ts->t_info.p2_enable = (rcv[0] & T2_BITMASK) >> 1;
+
+	if (!ts->t_info.p1_enable && !ts->t_info.p2_enable) {
+		
+		lcdkitb01_penup(ts);
+		g_down_count = 0;
+
+		goto end;
+	} else	{
+		g_up_count = 0;
+	}
+
+	if (ts->pendown == 0) {
+		if (g_down_count < CHECK_PENUPDOWN) {
+			schedule_delayed_work(&ts->work, msecs_to_jiffies(READ_MSECS));
+			g_down_count++;
+			
+			goto end;
+		} else	{
+			g_down_count = 0;
+			ts->pendown = 1;
+			ts->pendown_init = 1;
+
+			/* 誤差低減処理用 の 初期化 */
+			g_pos1x_total = 0;
+			g_pos1y_total = 0;
+			g_pos1_count = 0;
+			g_pos1x_min = ts->p_info.xmax_high;
+			g_pos1x_max = ts->p_info.xmax_low;
+			g_pos1y_min = ts->p_info.ymax_high;
+			g_pos1y_max = ts->p_info.ymax_low;
+
+			g_pos1x = 0;
+			g_pos1y = 0;
+			g_pos1_enable = 0;
+
+			g_pos2x_total = 0;
+			g_pos2y_total = 0;
+			g_pos2_count = 0;
+			g_pos2x_min = ts->p_info.xmax_high;
+			g_pos2x_max = ts->p_info.xmax_low;
+			g_pos2y_min = ts->p_info.ymax_high;
+			g_pos2y_max = ts->p_info.ymax_low;
+
+			g_pos2x = 0;
+			g_pos2y = 0;
+			g_pos2_enable = 0;
+		}
+	}
+
+	if (ts->t_info.p1_enable) {
+		
+		/* タッチポイントの取得 */
+		
+		tmp_x = rcv[1] | rcv[2] << 8;
+		tmp_y = rcv[3] | rcv[4] << 8;
+		if (tmp_x < ts->p_info.xmax_low) {
+			tmp_x = ts->p_info.xmax_low;
+		} else if (tmp_x > ts->p_info.xmax_high) {
+			tmp_x = ts->p_info.xmax_high;
+		}
+		if (tmp_y < ts->p_info.ymax_low) {
+			tmp_y = ts->p_info.ymax_low;
+		} else if (tmp_y > ts->p_info.ymax_high) {
+			tmp_y = ts->p_info.ymax_high;
+		}
+
+		g_pos1x_total += tmp_x;
+		g_pos1y_total += tmp_y;
+			
+		if (tmp_x < g_pos1x_min) {
+			g_pos1x_min = tmp_x;
+		}
+		if (tmp_x > g_pos1x_max) {
+			g_pos1x_max = tmp_x;
+		}
+		if (tmp_y < g_pos1y_min) {
+			g_pos1y_min = tmp_y;
+		}
+		if (tmp_y > g_pos1y_max) {
+			g_pos1y_max = tmp_y;
+		}
+		g_pos1_count++;
+
+		if (g_pos1_count >= POS_AVG) {
+			g_pos1x_total -= g_pos1x_min;
+			g_pos1x_total -= g_pos1x_max;
+			g_pos1y_total -= g_pos1y_min;
+			g_pos1y_total -= g_pos1y_max;
+
+			g_pos1x = g_pos1x_total / (POS_AVG - 2);
+			g_pos1y = g_pos1y_total / (POS_AVG - 2);
+			g_pos1_enable = 1;
+
+			g_pos1x_total = 0;
+			g_pos1y_total = 0;
+			g_pos1_count = 0;
+			g_pos1x_min = ts->p_info.xmax_high;
+			g_pos1x_max = ts->p_info.xmax_low;
+			g_pos1y_min = ts->p_info.ymax_high;
+			g_pos1y_max = ts->p_info.ymax_low;
+		}
+
+		if (g_pos1_enable == 1) {
+			ts->t_info.p1_x = g_pos1x;
+			ts->t_info.p1_y = g_pos1y;
+		}
+	}
+
+	if (ts->t_info.p2_enable) {
+		
+		/* タッチポイントの取得 */
+
+		tmp_x = rcv[5] | rcv[6] << 8;
+		tmp_y = rcv[7] | rcv[8] << 8;
+		if (tmp_x < ts->p_info.xmax_low) {
+			tmp_x = ts->p_info.xmax_low;
+		} else if (tmp_x > ts->p_info.xmax_high) {
+			tmp_x = ts->p_info.xmax_high;
+		}
+		if (tmp_y < ts->p_info.ymax_low) {
+			tmp_y = ts->p_info.ymax_low;
+		} else if (tmp_y > ts->p_info.ymax_high) {
+			tmp_y = ts->p_info.ymax_high;
+		}
+
+		/* 誤検出の低減処理 */
+		g_pos2x_total += tmp_x;
+		g_pos2y_total += tmp_y;
+		
+		if (tmp_x < g_pos2x_min) {
+			g_pos2x_min = tmp_x;
+		}
+		if (tmp_x > g_pos2x_max) {
+			g_pos2x_max = tmp_x;
+		}
+		if (tmp_y < g_pos2y_min) {
+			g_pos2y_min = tmp_y;
+		}
+		if (tmp_y > g_pos2y_max) {
+			g_pos2y_max = tmp_y;
+		}
+		g_pos2_count++;
+
+		if (g_pos2_count >= POS_AVG) {
+			g_pos2x_total -= g_pos2x_min;
+			g_pos2x_total -= g_pos2x_max;
+			g_pos2y_total -= g_pos2y_min;
+			g_pos2y_total -= g_pos2y_max;
+
+			g_pos2x = g_pos2x_total / (POS_AVG - 2);
+			g_pos2y = g_pos2y_total / (POS_AVG - 2);
+			g_pos2_enable = 1;
+
+			g_pos2x_total = 0;
+			g_pos2y_total = 0;
+			g_pos2_count = 0;
+			g_pos2x_min = ts->p_info.xmax_high;
+			g_pos2x_max = ts->p_info.xmax_low;
+			g_pos2y_min = ts->p_info.ymax_high;
+			g_pos2y_max = ts->p_info.ymax_low;
+		}
+
+		if (g_pos2_enable == 1) {
+			ts->t_info.p2_x = g_pos2x;
+			ts->t_info.p2_y = g_pos2y;
+		}
+	}
+
+	/* 通知処理 */
+	if (ts->t_info.p1_enable &&
+	    ts->t_info.p2_enable) {
+		
+#ifdef MULTI_TOUCH_ENABLE
+		if (g_pos2_enable) {
+			
+			/* マルチタッチ通知(p1) */
+			input_report_abs(ts->input,
+					 ABS_MT_POSITION_X,
+					 g_pos1x);
+			input_report_abs(ts->input,
+					 ABS_MT_POSITION_Y,
+					 g_pos1y);
+			input_report_abs(ts->input,
+					 ABS_MT_TOUCH_MAJOR,
+					 major);
+			input_mt_sync(ts->input);
+			
+			/* マルチタッチ通知(p2) */
+			input_report_abs(ts->input,
+					 ABS_MT_POSITION_X,
+					 g_pos2x);
+			input_report_abs(ts->input,
+					 ABS_MT_POSITION_Y,
+					 g_pos2y);
+			input_report_abs(ts->input,
+					 ABS_MT_TOUCH_MAJOR,
+					 major);
+			input_mt_sync(ts->input);
+	
+			g_pos2_enable = 0;
+
+			dbg("moulti(2) touch x1=%d y1=%d : x2=%d y2=%d", 
+			    g_pos1x, g_pos1y,
+			    g_pos2x, g_pos2y);
+		}
+#endif
+
+	} else {
+		if (g_pos1_enable) {
+			/* シングルタッチ通知 */
+#ifdef MULTI_TOUCH_ENABLE
+			input_report_abs(ts->input,
+					 ABS_MT_POSITION_X,
+					 g_pos1x);
+			input_report_abs(ts->input,
+					 ABS_MT_POSITION_Y,
+					 g_pos1y);
+			input_report_abs(ts->input,
+					 ABS_MT_TOUCH_MAJOR,
+					 major);
+			input_mt_sync(ts->input);
+
+			dbg("moulti(1) touch x1=%d y1=%d", 
+			    g_pos1x, g_pos1y);
+#endif
+
+			g_pos1_enable = 0;
+
+			/* 通知(シングルタッチ) */
+			input_report_abs(ts->input, ABS_X, ts->t_info.p1_x);
+			input_report_abs(ts->input, ABS_Y, ts->t_info.p1_y);
+
+			if (ts->pendown_init == 1) {
+				input_report_key(ts->input, BTN_TOUCH, 1);
+
+				dbg("******************************Pen Down");
+				ts->pendown_init = 0;
+			}
+		}
+	}
+
+	input_sync(ts->input);
+
+end:
+	;
+}
+
+static void lcdkitb01_read(struct work_struct *work)
+{
+	struct lcdkitb01 *ts;	/* タッチパネル情報 */
+	u32 ret;
+
+	ts = container_of(to_delayed_work(work), struct lcdkitb01, work);
+	
+	ret = i2c_smbus_read_byte_data(ts->client, 0x01);
+	
+	tp_process(ts);
+
+#if USE_MOUSE
+	if ((ts->status & STATUS_SW1) != (ret & STATUS_SW1))
+		input_report_key(ts->input, BTN_LEFT, ret & STATUS_SW1);
+	if ((ts->status & STATUS_SW2) != (ret & STATUS_SW2))
+		input_report_key(ts->input, BTN_MIDDLE, ret & STATUS_SW2);
+	if ((ts->status & STATUS_SW3) != (ret & STATUS_SW3))
+		input_report_key(ts->input, BTN_RIGHT, ret & STATUS_SW3);
+#else
+	if ((ts->status & STATUS_SW1) != (ret & STATUS_SW1))
+		input_report_key(ts->input, KEY_MENU, ret & STATUS_SW1);
+	if ((ts->status & STATUS_SW2) != (ret & STATUS_SW2))
+		input_report_key(ts->input, KEY_HOME, ret & STATUS_SW2);
+	if ((ts->status & STATUS_SW3) != (ret & STATUS_SW3))
+		input_report_key(ts->input, KEY_ESC, ret & STATUS_SW3);
+#endif
+	input_sync(ts->input);
+
+	ts->status = ret;
+
+	if (ret)
+		schedule_delayed_work(&ts->work, msecs_to_jiffies(READ_MSECS));
+}
+
+/*
+ * タッチパネル割り込み
+ */
+static irqreturn_t lcdkitb01_irq(int irq, void *handle)
+{
+	struct lcdkitb01 *ts = handle;
+	int	retval;
+
+	retval = schedule_delayed_work(&ts->work, 0);
+	if( retval == false ) {
+		printk("%s: schedule_delayed_work Failed!\n", __func__, retval );
+	}
+	return IRQ_HANDLED;
+}
+
+int lcdkitb01_gpio;
+unsigned long *gpio_addr;
+
+static void lcdkitb01_poll_irq(unsigned long arg)
+{
+	struct lcdkitb01 *ts = (struct lcdkitb01 *)arg;
+	
+	schedule_delayed_work(&ts->work, 0);
+
+	mod_timer(&ts->timer, jiffies + 100);
+}
+
+static struct i2c_board_info tp_i2c_info = {
+	I2C_BOARD_INFO("LCD-KIT-B01 TP", 0x41),
+};
+
+static void lcdkitb01_led_set(struct led_classdev *led_cdev,
+			      enum led_brightness value)
+{
+	struct lcdkitb01 *ts;
+
+	ts = container_of(led_cdev, struct lcdkitb01, led);
+	value = value * 100 / 255;
+	i2c_smbus_write_byte_data(ts->client, 0x03, value);	
+
+	ts->led_value = value;
+}
+
+void lcdkitb01_led_on(void)
+{
+	struct lcdkitb01 *ts;
+
+	if (g_sleepled_cdev == NULL) {
+		printk("lcdkitb01_led_on() error\n");
+		return;
+	}
+
+	ts = container_of(g_sleepled_cdev, struct lcdkitb01, led);
+
+	i2c_smbus_write_byte_data(ts->client, 0x03, ts->led_value);	
+}
+
+void lcdkitb01_led_off(void)
+{
+	struct lcdkitb01 *ts;
+
+	if (g_sleepled_cdev == NULL) {
+		printk("lcdkitb01_led_off() error\n");
+		return;
+	}
+
+	ts = container_of(g_sleepled_cdev, struct lcdkitb01, led);
+
+	i2c_smbus_write_byte_data(ts->client, 0x03, 0);	
+}
+
+static struct led_classdev lcdkitb01_led = {
+	.name		= "lcdkitb01_backlight",
+	.brightness_set	= lcdkitb01_led_set,
+};
+
+static ssize_t lcdkitb01_buzzer_read(struct file *filp, char __user *buf,
+				    size_t count, loff_t *pos)
+{
+	return -EINVAL;
+}
+
+static ssize_t lcdkitb01_buzzer_write(struct file *filp,
+				      const char __user *buf,
+				      size_t count, loff_t *pos)
+{
+	struct lcdkitb01 *ts =
+		container_of(filp->private_data, struct lcdkitb01, buzzer);
+	u8 data;
+
+	get_user(data, buf);
+	i2c_smbus_write_byte_data(ts->client, 0x04, data);
+
+	return count;
+}
+
+static struct file_operations lcdkitb01_buzzer_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.read = lcdkitb01_buzzer_read,
+	.write = lcdkitb01_buzzer_write,
+	.open = nonseekable_open,
+};
+
+static struct miscdevice lcdkitb01_buzzer_device = {
+	MISC_DYNAMIC_MINOR,
+	"lcdkitb01_buzzer",
+	&lcdkitb01_buzzer_fops,
+};
+
+/*
+ * ドライバ初期化
+ */
+static int lcdkitb01_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	struct lcdkitb01_platform_data *pdata = client->dev.platform_data;
+	struct lcdkitb01 *ts;		/* タッチパネル情報 */
+	struct input_dev *input_dev;	/* インプットデバイス情報 */
+	u8 rcv[MAX_BLKSIZE];		/* 受信用バッファ */
+	int err = 0;			/* 戻り値 */
+#ifdef  CONFIG_USE_OF
+	struct device_node *np;
+#endif
+
+	printk("LCD-KIT-B01 TouchPanel Driver.\n");
+
+	/* I2Cファンクションチェック */
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_READ_WORD_DATA)){
+		printk("%s i2c_check_functionality fail\n", __func__);
+		return -EIO;
+	}
+	/* デバイス用メモリ確保 */
+	ts = kzalloc(sizeof(struct lcdkitb01), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!ts || !input_dev) {
+		printk("%s kzalloc fail\n", __func__);
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	ts->client = client;
+
+#ifdef  CONFIG_USE_OF
+	np = of_find_node_by_path("/i2c@e6540000/lcdkitb01@0x42");
+	if( np ) {
+		ts->irq = irq_of_parse_and_map(np, 0);
+	} else {
+		ts->irq = 0;
+		dev_err(&client->dev, "irq_of_parse_and_map failed\n" ); 
+	}	 
+#else
+	ts->irq = client->irq;
+#endif
+	ts->pdata = pdata;
+	ts->input = input_dev;
+	ts->pendown_init = 0;
+
+	spin_lock_init(&ts->lock);
+
+	INIT_DELAYED_WORK(&ts->work, lcdkitb01_read);
+
+	ts->tp_client = i2c_new_device(client->adapter, &tp_i2c_info);
+
+	if (0 > lcdkitb01_i2c_multi_read(ts->tp_client,
+				      CMD_FURM_INFO, FURM_INFO_LEN, rcv)) {
+		pr_warning("%s fail get furm version\n", __func__);
+		err = -EIO;
+		goto err_free_mem;
+	}
+	memcpy(ts->ver, rcv, FURM_INFO_LEN);
+	/* パネル情報読み込み */
+	if (0 > lcdkitb01_i2c_multi_read(ts->tp_client, CMD_PANEL_INFO, PANEL_INFO_LEN, rcv)){
+		pr_warning("%s fail get panel info\n", __func__);
+		err = -EIO;
+		goto err_free_mem;
+	}
+	ts->status = 0;
+	ts->p_info.xmax_low  = 0;
+	ts->p_info.ymax_low  = 0;
+	ts->p_info.xmax_high =  rcv[0] | rcv[1] << 8;
+	ts->p_info.ymax_high =  rcv[2] | rcv[3] << 8;
+	ts->p_info.x_cnum    =  rcv[4];
+	ts->p_info.y_cnum    =  rcv[5];
+
+	/* パネル情報表示 */
+#if 0
+	dbg("%s panel info \n", __func__);
+	dbg("furm ver 0x%02X:0x%02X:0x%02X\n", *(ts->ver+1), *(ts->ver+2), *(ts->ver+3));
+	printk("xmax low %d\n", ts->p_info.xmax_low);
+	printk("xmax high %d\n", ts->p_info.xmax_high);
+	printk("ymax low %d\n", ts->p_info.ymax_low);
+	printk("ymax high %d\n", ts->p_info.ymax_high);
+	printk("x channel num %d\n", ts->p_info.x_cnum);
+	printk("y channel num %d\n", ts->p_info.y_cnum);
+#endif
+	
+	/* タッチパネルデバイス初期化 */
+	input_dev->name = "LCD-KIT-B01";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+
+	/* IRQ初期化 */
+	if (ts->irq != NO_IRQ) {
+		err = request_irq(ts->irq, lcdkitb01_irq,
+				  IRQF_TRIGGER_FALLING,
+				  input_dev->name, ts);
+		if (err) {
+			pr_warning("lcdkitb01 irq request fail %d\n", err);
+			err = -EIO;
+			goto err_free_gpio;
+		}
+	} else {
+		ts->irq_pin_state = -1;
+		init_timer(&ts->timer);
+		ts->timer.expires = jiffies + /* ts->pdata->poll_period */ 100;
+		setup_timer(&ts->timer, lcdkitb01_poll_irq, ts);
+		add_timer(&ts->timer);
+	}
+	/* デバイス登録 */
+	input_set_abs_params(input_dev, ABS_X,
+			     ts->p_info.xmax_low, ts->p_info.xmax_high, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y,
+			     ts->p_info.xmax_low, ts->p_info.ymax_high, 0, 0);
+
+#ifdef MULTI_TOUCH_ENABLE	
+	input_set_abs_params(input_dev,
+			     ABS_MT_TOUCH_MAJOR,
+			     0, ts->p_info.xmax_high, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X,
+			     ts->p_info.xmax_low, ts->p_info.xmax_high, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y,
+			     ts->p_info.xmax_low, ts->p_info.ymax_high, 0, 0);
+#endif
+
+#if USE_MOUSE
+	input_set_capability(input_dev, EV_KEY, BTN_LEFT);
+	input_set_capability(input_dev, EV_KEY, BTN_MIDDLE);
+	input_set_capability(input_dev, EV_KEY, BTN_RIGHT);
+#else
+	input_set_capability(input_dev, EV_KEY, KEY_MENU);
+	input_set_capability(input_dev, EV_KEY, KEY_HOME);
+	input_set_capability(input_dev, EV_KEY, KEY_ESC);
+#endif
+	input_set_capability(input_dev, EV_KEY, BTN_TOUCH);
+
+	input_set_drvdata(input_dev, ts);	
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_free_irq;
+
+	/* Backlight Add */
+	ts->led = lcdkitb01_led;
+	ts->led_value = 255;
+	g_sleepled_cdev = &ts->led;
+	led_classdev_register(&client->dev, &ts->led);
+
+	/* Buzzer Add */
+	lcdkitb01_buzzer_device.parent = &input_dev->dev;
+	ts->buzzer = lcdkitb01_buzzer_device;
+	misc_register(&ts->buzzer);
+
+	/* Backlight ON */
+	lcdkitb01_led_set(&ts->led, 255);
+
+	return err;
+
+/* 初期化失敗 */
+err_free_irq:
+	free_irq(ts->irq, ts);
+
+err_free_gpio:
+
+err_free_mem:
+	input_free_device(input_dev);
+	kfree(ts);
+
+	return err;
+}
+
+/*
+ * ドライバ破棄
+ */
+static int lcdkitb01_remove(struct i2c_client *client)
+{
+	struct lcdkitb01 *ts = i2c_get_clientdata(client);
+
+	led_classdev_unregister(&ts->led);
+
+	if (ts->irq != NO_IRQ)
+		free_irq(ts->irq, ts);
+	else
+		del_timer_sync(&ts->timer);
+
+	input_unregister_device(ts->input);
+	kfree(ts);
+
+	return 0;
+}
+
+/* I2Cデバイステーブル */
+static const struct i2c_device_id lcdkitb01_idtable[] = {
+	{ "LCD-KIT-B01", 0 },
+	{ }
+};
+
+static const struct of_device_id lcdkitb01_of_match[] = {
+	{ .compatible = "apj,lcdkitb01", },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, lcdkitb01_idtable);
+
+/* I2Cドライバ情報 */
+static struct i2c_driver lcdkitb01_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(lcdkitb01_of_match),
+		.name	= "LCD-KIT-B01"
+	},
+	.id_table	= lcdkitb01_idtable,
+	.probe		= lcdkitb01_probe,
+	.remove		= lcdkitb01_remove,
+/*
+#ifdef CONFIG_PM
+	.suspend	= lcdkitb01_i2c_suspend,
+	.resume		= lcdkitb01_i2c_resume,
+#endif
+*/
+};
+
+static int __init lcdkitb01_init(void)
+{
+	/* ドライバ登録 */
+	return i2c_add_driver(&lcdkitb01_driver);
+}
+
+static void __exit lcdkitb01_exit(void)
+{
+	i2c_del_driver(&lcdkitb01_driver);
+}
+
+module_init(lcdkitb01_init);
+module_exit(lcdkitb01_exit);
+
+MODULE_AUTHOR("Alpha Project Co., LTD");
+MODULE_DESCRIPTION("LCD-KIT-B01 TouchScreen Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/lcdkitc01.c b/drivers/input/touchscreen/lcdkitc01.c
new file mode 100644
index 0000000..6df12f9
--- /dev/null
+++ b/drivers/input/touchscreen/lcdkitc01.c
@@ -0,0 +1,630 @@
+/*
+ * LCD-KIT-C01 touchscreen
+ * Based on tsc2007.c
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ */
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/kthread.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/leds.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+
+#include <linux/gpio.h>
+#ifdef CONFIG_USE_OF
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#endif
+#include <linux/platform_data/gpio-rcar.h>
+
+/* マウス仕様 */
+#define USE_MOUSE	0
+
+#define STATUS_SW3	(1 << 4)
+#define STATUS_SW2	(1 << 3)
+#define STATUS_SW1	(1 << 2)
+#define STATUS_TP1	(1 << 1)
+#define STATUS_TP0	(1 << 0)
+
+#define READ_MSECS	20
+
+/* ペンアップ検出 */
+#define CHECK_PENUP	3
+
+/* タッチフラグ */
+#define NOTOUCH		0
+#define TOUCHED		1
+
+/* デバッグメッセージ */
+//#define LCDKITC01_DEBUG
+#ifdef LCDKITC01_DEBUG
+#define dbg(format, arg...) printk(KERN_INFO __FILE__ ": "  format "\n", ## arg);
+#else
+#define dbg(format, arg...) do{} while(0);
+#endif
+
+struct led_classdev *g_sleepled_cdev = NULL; /* Backlight on/off Only */
+
+/* タッチパネル情報構造体 */
+struct lcdkitc01 {
+	struct input_dev *input;		/* インプットデバイス */
+	struct i2c_client *client;		/* I2Cクライアント */
+	struct i2c_client *tp_client;	/* I2Cクライアント */
+	struct delayed_work work;		/* ワークキュー */
+	int irq;						/* IRQ */
+	u8 status;
+	spinlock_t lock;				/* スピンロック */
+	struct led_classdev led;
+	struct miscdevice buzzer;
+	int pendown;
+
+	struct timer_list timer;
+	int irq_pin_state;
+
+	struct lcdkitc01_platform_data *pdata;
+
+	/* TSC2007 */
+	u16 x_plate_ohms;
+	u16 max_rt;
+
+	enum led_brightness led_value;
+};
+
+/* *** TSC2007 *** */
+#define TSC2007_MEASURE_TEMP0	(0x0 << 4)
+#define TSC2007_MEASURE_AUX		(0x2 << 4)
+#define TSC2007_MEASURE_TEMP1	(0x4 << 4)
+#define TSC2007_ACTIVATE_XN		(0x8 << 4)
+#define TSC2007_ACTIVATE_YN		(0x9 << 4)
+#define TSC2007_ACTIVATE_YP_XN	(0xa << 4)
+#define TSC2007_SETUP			(0xb << 4)
+#define TSC2007_MEASURE_X		(0xc << 4)
+#define TSC2007_MEASURE_Y		(0xd << 4)
+#define TSC2007_MEASURE_Z1		(0xe << 4)
+#define TSC2007_MEASURE_Z2		(0xf << 4)
+
+#define TSC2007_POWER_OFF_IRQ_EN	(0x0 << 2)
+#define TSC2007_ADC_ON_IRQ_DIS0		(0x1 << 2)
+#define TSC2007_ADC_OFF_IRQ_EN		(0x2 << 2)
+#define TSC2007_ADC_ON_IRQ_DIS1		(0x3 << 2)
+
+#define TSC2007_12BIT	(0x0 << 1)
+#define TSC2007_8BIT	(0x1 << 1)
+
+#define	MAX_12BIT	((1 << 12) - 1)
+
+#define ADC_ON_12BIT	(TSC2007_12BIT | TSC2007_ADC_ON_IRQ_DIS0)
+
+#define READ_Y		(ADC_ON_12BIT | TSC2007_MEASURE_Y)
+#define READ_Z1		(ADC_ON_12BIT | TSC2007_MEASURE_Z1)
+#define READ_Z2		(ADC_ON_12BIT | TSC2007_MEASURE_Z2)
+#define READ_X		(ADC_ON_12BIT | TSC2007_MEASURE_X)
+#define PWRDOWN		(TSC2007_12BIT | TSC2007_POWER_OFF_IRQ_EN)
+
+struct ts_event {
+	u16	x;
+	u16	y;
+	u16	z1, z2;
+};
+
+static inline int tsc2007_xfer(struct lcdkitc01 *tsc, u8 cmd)
+{
+	s32 data;
+	u16 val;
+
+	data = i2c_smbus_read_word_data(tsc->tp_client, cmd);
+	if (data < 0) {
+		dev_err(&tsc->client->dev, "i2c io error: %d\n", data);
+		return data;
+	}
+
+	/* The protocol and raw data format from i2c interface:
+	 * S Addr Wr [A] Comm [A] S Addr Rd [A] [DataLow] A [DataHigh] NA P
+	 * Where DataLow has [D11-D4], DataHigh has [D3-D0 << 4 | Dummy 4bit].
+	 */
+	val = swab16(data) >> 4;
+
+	dev_dbg(&tsc->client->dev, "data: 0x%x, val: 0x%x\n", data, val);
+
+	return val;
+}
+
+static void tsc2007_read_values(struct lcdkitc01 *tsc, struct ts_event *tc)
+{
+	/* y- still on; turn on only y+ (and ADC) */
+	tc->y = tsc2007_xfer(tsc, READ_Y);
+
+	/* turn y- off, x+ on, then leave in lowpower */
+	tc->x = tsc2007_xfer(tsc, READ_X);
+
+	/* turn y+ off, x- on; we'll use formula #1 */
+	tc->z1 = tsc2007_xfer(tsc, READ_Z1);
+	tc->z2 = tsc2007_xfer(tsc, READ_Z2);
+
+	/* Prepare for next touch reading - power down ADC, enable PENIRQ */
+	tsc2007_xfer(tsc, PWRDOWN);
+}
+
+static u32 tsc2007_calculate_pressure(struct lcdkitc01 *tsc, struct ts_event *tc)
+{
+	u32 rt = 0;
+
+	/* range filtering */
+	if (tc->x == MAX_12BIT)
+		tc->x = 0;
+
+	if (likely(tc->x && tc->z1)) {
+		/* compute touch pressure resistance using equation #1 */
+		rt = tc->z2 - tc->z1;
+		rt *= tc->x;
+		rt *= tsc->x_plate_ohms;
+		rt /= tc->z1;
+		rt = (rt + 2047) >> 12;
+	}
+
+	return rt;
+}
+/* *** TSC2007 - end *** */
+
+
+#ifdef CONFIG_PM
+/*
+ * サスペンド
+ */
+static int lcdkitc01_i2c_suspend(struct i2c_client *client,
+			         pm_message_t message)
+{
+	dbg("**** %s ****\n", __func__);
+
+	return 0;
+}
+
+/*
+ * レジューム
+ */
+static int lcdkitc01_i2c_resume(struct i2c_client *client)
+{
+	dbg("**** %s ****\n", __func__);
+
+	return 0;
+}
+#endif
+
+/*
+ * I2C読み込み(1ワード)
+ */
+__attribute__((unused))
+static int lcdkitc01_i2c_read(struct i2c_client *client, u8 reg)
+{
+	return 0;
+}
+
+/*
+ * I2C読み込み(マルチワード)
+ */
+#define MEASURE_TIME 0
+#if MEASURE_TIME
+static struct timeval tv0 = {}, tv1 = {};
+#endif
+
+static void tp_process(struct lcdkitc01 *ts, int status)
+{
+	struct input_dev *input = ts->input;
+	struct ts_event tc;
+	u32 rt;
+
+	if (!(status & STATUS_TP1)) {
+		if (ts->pendown == 1) {
+			ts->pendown = 0;
+			input_report_key(input, BTN_TOUCH, 0);
+			input_sync(input);
+		}
+		return;
+	}
+
+	tsc2007_read_values(ts, &tc);
+	
+	rt = tsc2007_calculate_pressure(ts, &tc);
+
+	if (0 <= rt && rt <= MAX_12BIT) {
+		input_report_abs(input, ABS_X, tc.x);
+		input_report_abs(input, ABS_Y, tc.y);
+
+		if (ts->pendown == 0) {
+			ts->pendown = 1;
+			input_report_key(input, BTN_TOUCH, 1);
+		}
+
+		input_sync(input);
+	}
+}
+
+static int tsc2007_open(struct input_dev *input_dev)
+{
+	struct lcdkitc01 *ts = input_get_drvdata(input_dev);
+	int err;
+
+	/* Prepare for touch readings - power down ADC and enable PENIRQ */
+	err = tsc2007_xfer(ts, PWRDOWN);
+	if (err < 0) {
+		return err;
+	}
+
+	return 0;
+}
+
+static void tsc2007_close(struct input_dev *input_dev)
+{
+}
+
+static void lcdkitc01_read(struct work_struct *work)
+{
+	struct lcdkitc01 *ts;	/* タッチパネル情報 */
+	u32 ret;
+
+	ts = container_of(to_delayed_work(work), struct lcdkitc01, work);
+	
+	ret = i2c_smbus_read_byte_data(ts->client, 0x01);
+	
+	tp_process(ts, ret);
+
+#if USE_MOUSE
+	if ((ts->status & STATUS_SW1) != (ret & STATUS_SW1))
+		input_report_key(ts->input, BTN_LEFT, ret & STATUS_SW1);
+	if ((ts->status & STATUS_SW2) != (ret & STATUS_SW2))
+		input_report_key(ts->input, BTN_MIDDLE, ret & STATUS_SW2);
+	if ((ts->status & STATUS_SW3) != (ret & STATUS_SW3))
+		input_report_key(ts->input, BTN_RIGHT, ret & STATUS_SW3);
+#else
+	if ((ts->status & STATUS_SW1) != (ret & STATUS_SW1))
+		input_report_key(ts->input, KEY_MENU, ret & STATUS_SW1);
+	if ((ts->status & STATUS_SW2) != (ret & STATUS_SW2))
+		input_report_key(ts->input, KEY_HOME, ret & STATUS_SW2);
+	if ((ts->status & STATUS_SW3) != (ret & STATUS_SW3))
+		input_report_key(ts->input, KEY_ESC, ret & STATUS_SW3);
+#endif
+	input_sync(ts->input);
+
+	ts->status = ret;
+
+	if (ret)
+		schedule_delayed_work(&ts->work, msecs_to_jiffies(READ_MSECS));
+}
+
+/*
+ * タッチパネル割り込み
+ */
+static irqreturn_t lcdkitc01_irq(int irq, void *handle)
+{
+	struct lcdkitc01 *ts = handle;
+
+dbg("**** %s ****", __func__);
+
+	schedule_delayed_work(&ts->work, 0);
+
+	return IRQ_HANDLED;
+}
+
+static void lcdkitc01_poll_irq(unsigned long arg)
+{
+	struct lcdkitc01 *ts = (struct lcdkitc01 *)arg;
+	struct lcdkitc01_platform_data *pdata = ts->pdata;
+	int pin_state = 0;
+
+dbg("**** %s ****", __func__);
+
+	if (ts->irq_pin_state == -1)
+		ts->irq_pin_state = pin_state;
+	else if (ts->irq_pin_state != pin_state) {
+		ts->irq_pin_state = pin_state;
+		schedule_delayed_work(&ts->work, 0);
+	}
+
+	mod_timer(&ts->timer, jiffies + 100);
+}
+
+static struct i2c_board_info tp_i2c_info = {
+	I2C_BOARD_INFO("LCD-KIT-C01 TP", 0x48),
+};
+
+static void lcdkitc01_led_set(struct led_classdev *led_cdev,
+			      enum led_brightness value)
+{
+	struct lcdkitc01 *ts;
+
+	ts = container_of(led_cdev, struct lcdkitc01, led);
+	value = value * 100 / 255;
+	i2c_smbus_write_byte_data(ts->client, 0x03, value);	
+
+	ts->led_value = value;
+}
+
+void lcdkitc01_led_on(void)
+{
+	struct lcdkitc01 *ts;
+
+	if (g_sleepled_cdev == NULL) {
+		printk("lcdkitc01_led_on() error\n");
+		return;
+	}
+
+	ts = container_of(g_sleepled_cdev, struct lcdkitc01, led);
+
+	i2c_smbus_write_byte_data(ts->client, 0x03, ts->led_value);	
+}
+
+void lcdkitc01_led_off(void)
+{
+	struct lcdkitc01 *ts;
+
+	if (g_sleepled_cdev == NULL) {
+		printk("lcdkitc01_led_off() error\n");
+		return;
+	}
+
+	ts = container_of(g_sleepled_cdev, struct lcdkitc01, led);
+
+	i2c_smbus_write_byte_data(ts->client, 0x03, 0);	
+}
+
+static struct led_classdev lcdkitc01_led = {
+	.name			= "lcdkitc01_backlight",
+	.brightness_set	= lcdkitc01_led_set,
+};
+
+static ssize_t lcdkitc01_buzzer_read(struct file *filp, char __user *buf,
+				     size_t count, loff_t *pos)
+{
+	return -EINVAL;
+}
+
+static ssize_t lcdkitc01_buzzer_write(struct file *filp,
+				      const char __user *buf,
+				      size_t count, loff_t *pos)
+{
+	struct lcdkitc01 *ts =
+		container_of(filp->private_data, struct lcdkitc01, buzzer);
+	u8 data;
+
+	get_user(data, buf);
+	i2c_smbus_write_byte_data(ts->client, 0x04, data);
+
+	return count;
+}
+
+static struct file_operations lcdkitc01_buzzer_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.read = lcdkitc01_buzzer_read,
+	.write = lcdkitc01_buzzer_write,
+	.open = nonseekable_open,
+};
+
+static struct miscdevice lcdkitc01_buzzer_device = {
+	MISC_DYNAMIC_MINOR,
+	"lcdkitc01_buzzer",
+	&lcdkitc01_buzzer_fops,
+};
+
+/*
+ * ドライバ初期化
+ */
+static int lcdkitc01_probe(struct i2c_client *client,
+				     const struct i2c_device_id *id)
+{
+	struct lcdkitc01_platform_data *pdata =
+		client->dev.platform_data;
+	struct lcdkitc01 *ts;			/* タッチパネル情報 */
+	struct input_dev *input_dev;	/* インプットデバイス情報 */
+	int err = 0;					/* 戻り値 */
+#ifdef  CONFIG_USE_OF
+	struct device_node *np;
+#endif
+
+	printk("LCD-KIT-C01 TouchPanel Driver.\n");
+
+	/* I2Cファンクションチェック */
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_READ_WORD_DATA)) {
+		printk("%s i2c_check_functionality fail\n", __func__);
+		return -EIO;
+	}
+	/* デバイス用メモリ確保 */
+	ts = kzalloc(sizeof(struct lcdkitc01), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!ts || !input_dev) {
+		printk("%s kzalloc fail\n", __func__);
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	ts->client = client;
+
+#ifdef CONFIG_USE_OF
+	np = of_find_node_by_path("/i2c@e6540000/lcdkitc01@0x42");
+    if( np ) {
+	    ts->irq = irq_of_parse_and_map(np, 0);
+    } else {
+		ts->irq = 0;
+        dev_err(&client->dev, "irq_of_parse_and_map failed\n"); 
+    }	 
+#else
+	ts->irq = client->irq;
+#endif
+	ts->pdata = pdata;
+	ts->input = input_dev;
+
+	spin_lock_init(&ts->lock);
+
+	INIT_DELAYED_WORK(&ts->work, lcdkitc01_read);
+
+	ts->tp_client = i2c_new_device(client->adapter, &tp_i2c_info);
+	ts->x_plate_ohms = 500;
+	
+	/* タッチパネルデバイス初期化 */
+	input_dev->name = "LCD-KIT-C01";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->open = tsc2007_open;
+	input_dev->close = tsc2007_close;
+
+	/* IRQ初期化 */
+	if (ts->irq != NO_IRQ) {
+		err = request_irq(ts->irq, lcdkitc01_irq,
+				  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
+				  IRQF_SHARED,
+				  input_dev->name, ts);
+		if (err) {
+			pr_warning("lcdkitc01 irq request fail %d\n", err);
+			err = -EIO;
+			goto err_free_gpio;
+		}
+	} else {
+		ts->irq_pin_state = -1;
+		init_timer(&ts->timer);
+		ts->timer.expires = jiffies + /* ts->pdata->poll_period */ 100;
+		setup_timer(&ts->timer, lcdkitc01_poll_irq, ts);
+		add_timer(&ts->timer);
+	}
+
+	/* デバイス登録 */
+	input_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);
+
+#if USE_MOUSE
+	input_set_capability(input_dev, EV_KEY, BTN_LEFT);
+	input_set_capability(input_dev, EV_KEY, BTN_RIGHT);
+	input_set_capability(input_dev, EV_KEY, BTN_MIDDLE);
+#else
+	input_set_capability(input_dev, EV_KEY, KEY_MENU);
+	input_set_capability(input_dev, EV_KEY, KEY_HOME);
+	input_set_capability(input_dev, EV_KEY, KEY_ESC);
+#endif
+	input_set_capability(input_dev, EV_KEY, BTN_TOUCH);
+
+	input_set_drvdata(input_dev, ts);	
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_free_irq;
+
+	/* Backlight Add */
+	ts->led = lcdkitc01_led;
+	led_classdev_register(&client->dev, &ts->led);
+
+	ts->led_value = 255;
+	g_sleepled_cdev = &ts->led;
+
+	/* Buzzer Add */
+	lcdkitc01_buzzer_device.parent = &input_dev->dev;
+	ts->buzzer = lcdkitc01_buzzer_device;
+	printk("%s: %p\n", __func__, &ts->buzzer);
+	misc_register(&ts->buzzer);
+
+	/* Backlight ON */
+	lcdkitc01_led_set(&ts->led, 255);
+
+	return err;
+
+/* 初期化失敗 */
+err_free_irq:
+	free_irq(ts->irq, ts);
+
+err_free_gpio:
+
+err_free_mem:
+	input_free_device(input_dev);
+	kfree(ts);
+
+	return err;
+}
+
+/*
+ * ドライバ破棄
+ */
+static int lcdkitc01_remove(struct i2c_client *client)
+{
+	struct lcdkitc01 *ts = i2c_get_clientdata(client);
+
+	led_classdev_unregister(&ts->led);
+
+	if (ts->irq != NO_IRQ)
+		free_irq(ts->irq, ts);
+	else
+		del_timer_sync(&ts->timer);
+
+	input_unregister_device(ts->input);
+	kfree(ts);
+
+	return 0;
+}
+
+/* I2Cデバイステーブル */
+static const struct i2c_device_id lcdkitc01_idtable[] = {
+	{ "LCD-KIT-C01", 0 },
+	{ }
+};
+
+static const struct of_device_id lcdkitc01_of_match[] = {
+	{ .compatible = "apj,lcdkitc01", },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, lcdkitc01_idtable);
+
+/* I2Cドライバ情報 */
+static struct i2c_driver lcdkitc01_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(lcdkitc01_of_match),
+		.name	= "LCD-KIT-C01"
+	},
+	.id_table	= lcdkitc01_idtable,
+	.probe		= lcdkitc01_probe,
+	.remove		= lcdkitc01_remove,
+/*
+#ifdef CONFIG_PM
+	.suspend	= lcdkitc01_i2c_suspend,
+	.resume		= lcdkitc01_i2c_resume,
+#endif
+*/
+};
+
+static int __init lcdkitc01_init(void)
+{
+	return i2c_add_driver(&lcdkitc01_driver);
+}
+
+static void __exit lcdkitc01_exit(void)
+{
+	i2c_del_driver(&lcdkitc01_driver);
+}
+
+module_init(lcdkitc01_init);
+module_exit(lcdkitc01_exit);
+
+MODULE_AUTHOR("Alpha Project Co., LTD");
+MODULE_DESCRIPTION("LCD-KIT-C01 TouchScreen Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/lcdkitd01.c b/drivers/input/touchscreen/lcdkitd01.c
new file mode 100644
index 0000000..1dbf40f
--- /dev/null
+++ b/drivers/input/touchscreen/lcdkitd01.c
@@ -0,0 +1,1722 @@
+/*
+ * LCD-KIT-D01 touchscreen
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ */
+
+/* Include */
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/leds.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/ioctl.h>
+
+#include <linux/gpio.h>
+#ifdef CONFIG_USE_OF
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#endif
+#include <linux/platform_data/gpio-rcar.h>
+
+#include "lcdkitd01.h"
+
+/* Define */
+
+/* Multi touch enable */
+//#define MULTI_TOUCH_ENABLE
+
+/* LCD-KIT-D01 Touchscreen initialize command. */
+#define TCHPNL_END	(0)
+#define TCHPNL_WR	(1)
+#define TCHPNL_2WR	(2)
+#define TCHPNL_DLY	(3)
+
+/* LCD-KIT-D01 Controller command */
+#define LCD_KIT_D01_CMD_FIRM_WARE			(0x00)
+#define LCD_KIT_D01_CMD_INT_STATUS			(0x01)
+#define LCD_KIT_D01_CMD_INT_MASK			(0x02)
+#define LCD_KIT_D01_CMD_BACKLIGHT			(0x03)
+#define LCD_KIT_D01_CMD_DISPLAY_DIRECTION	(0x04)
+#define LCD_KIT_D01_CMD_TP_RESET			(0x05)
+#define LCD_KIT_D01_CMD_SOUND				(0x06)
+
+/* Speaker packet max size */
+#define LCD_KIT_D01_SPEAKER_DATA_MAX	(100)
+
+#define LCD_KIT_D01_SPEAKER_MAX_SIZE	(LCD_KIT_D01_SPEAKER_DATA_MAX + 7)
+
+
+/* LCD-KIT-D01 controller interrupt status */
+#define LCD_KIT_D01_INTSTA_SPK_NOSEND	(0x20)
+
+/* Toucpanel Event */
+#define TP_EVENT_F0		(0x01)
+#define TP_EVENT_F1		(0x02)
+#define TP_EVENT_F2		(0x04)
+#define TP_EVENT_F3		(0x08)
+#define TP_EVENT_FING	(TP_EVENT_F0 | TP_EVENT_F1 | TP_EVENT_F2 | TP_EVENT_F3)
+#define TP_EVENT_FNE	(0x10)
+#define TP_EVENT_FOF	(0x20)
+#define TP_EVENT_LOBJ	(0x40)
+
+/* LCD-KIT-D01 interrupt status */
+#define STATUS_SPK	(1 << 5)
+#define STATUS_SW3	(1 << 4)
+#define STATUS_SW2	(1 << 3)
+#define STATUS_SW1	(1 << 2)
+#define STATUS_TP0	(1 << 0)
+
+/* Touchscreen status */
+#define TS_STA_PENDOWN	(0x00010000)
+#define TS_STA_PENUP	(0x00000000)
+#define TS_STA_PENMASK	(TS_STA_PENDOWN | TS_STA_PENUP)
+
+/* LCD-KIT-D01 interrupt mask */
+#define IMASK_TP_MSK	(1 << 0)
+#define IMASK_SW1MSK	(1 << 2)
+#define IMASK_SW2MSK	(1 << 3)
+#define IMASK_SW3MSK	(1 << 4)
+#define IMASK_SNDMSK	(1 << 5)
+
+/* Read delay */
+#define READ_MSECS	20
+
+/* Debug Code */
+//#define LCDKITD01_DEBUG
+
+#ifdef LCDKITD01_DEBUG
+#define dbg(format, arg...) printk(KERN_INFO __FILE__ ": "  format "\n", ## arg);
+#else
+#define dbg(format, arg...) do{} while(0);
+#endif
+
+/* LCD display direction */
+//#define LCD_KIT_D01_DISPLAY_HREVERSE	/* Horizonal undefined: normal, defined: reverse */
+//#define LCD_KIT_D01_DISPLAY_VREVERSE	/* Virtical  undefined: normal, defined: reverse */
+#if !defined(LCD_KIT_D01_DISPLAY_HREVERSE)
+	#define LCD_KIT_D01_DISPLAY_HORIZONAL	(1)
+#else
+	#define LCD_KIT_D01_DISPLAY_HORIZONAL	(0)
+#endif
+#if !defined(LCD_KIT_D01_DISPLAY_VREVERSE)
+	#define LCD_KIT_D01_DISPLAY_VERTICAL	(1)
+#else
+	#define LCD_KIT_D01_DISPLAY_VERTICAL	(0)
+#endif
+#define LCD_KIT_D01_DISPLAY_DIRECTION	((LCD_KIT_D01_DISPLAY_HORIZONAL << 1) | LCD_KIT_D01_DISPLAY_VERTICAL)
+
+#define USE_MOUSE 0
+
+/* Touch screen controller command list */
+#define TS_CMD_SOFTWARE_RESET	(0x01)
+#define TS_CMD_EVENT_STATUS		(0x79)
+#define TS_CMD_EVENT_MASK		(0x7A)
+#define TS_CMD_IRQ_MASK			(0x7B)
+#define TS_CMD_FING01_INFO		(0x7C)
+#define TS_CMD_FING02_INFO		(0x7D)
+#define TS_CMD_FING03_INFO		(0x7E)
+#define TS_CMD_FING04_INFO		(0x7F)
+
+/* Touch screen pen control. */
+#define PEN_CHECK_COUNT (5)
+#define PEN_CHECK_DELAY	(10)
+
+/* LCDKITD01 BUZZER */
+
+#define SAMPLERATE		11025
+#define BEEP_PERIOD		(24*60*60)
+
+#ifdef LCDKITD01_DEBUG
+#define BUZZER_VOL		0x03ff
+#else
+#define BUZZER_VOL		5000
+#endif
+
+struct led_classdev *g_sleepled_cdev = NULL; /* Backlight on/off Only */
+
+/**
+ * struct lcdkitd01_platform_data - internal struct of LCD-KIT-D01 driver
+ * @get_irq_pin_state: Callback for getting status of IRQ pin
+ * @poll_period: Polling cycle
+ */
+struct lcdkitd01_platform_data {
+	int (*get_irq_pin_state)(void);
+	int poll_period;
+};
+
+/**
+ * struct touch_point_info - internal structure of touch panel information
+ * @reg_no: Register(command) number to get finger touch point
+ * @point_bit: Bit mask of event status register for target finger event
+ * @pos_x: X point
+ * @pos_y: Y point
+ */
+struct touch_point_info {
+	unsigned char reg_no;
+	unsigned char point_bit;
+	unsigned short pos_x;
+	unsigned short pos_y;
+};
+
+/**
+ * struct lcdkitd01 - internal structure of LCD-KIT-D01 driver
+ * @input: Input device
+ * @client: I2C client of control cpu on LCD-KIT-D01
+ * @tp_client: I2C client of touch panel
+ * @*pdata: Plat form data pointer
+ * @work: Work que
+ * @spk_player_work: Work que for speaker playing
+ * @buzzer_work: Work que for buzzer
+ * @check_pen_work: Work que for checking touch screen pen status
+ * @led: LED class deice of LCD-KIT-D01
+ * @speaker: Device structure of speaker
+ * @timer: Event polling timer
+ * @point[]: Touch screen point information with 4 fingers
+ * @player: LCD-KIT-D01 speaker information
+ * @irq_pin_state: Status of IRQ pin
+ * @irq: IRQ number
+ * @status: Status
+ */
+struct lcdkitd01 {
+	struct input_dev *input;
+	struct i2c_client *client;
+	struct i2c_client *tp_client;
+	struct lcdkitd01_platform_data *pdata;
+	struct delayed_work work;
+	struct delayed_work buzzer_work;
+	struct delayed_work check_pen_work;
+	struct led_classdev led;
+	struct miscdevice buzzer;
+	struct timer_list timer;
+	struct touch_point_info point[4];
+	struct touch_point_info old_point[4];
+	struct lcdkitd01_beeper beeper;
+	int irq_pin_state;
+	int irq;
+	unsigned long status;
+	enum led_brightness led_value;
+};
+
+/* I2C Board Information */
+static struct i2c_board_info tp_i2c_info = {
+	I2C_BOARD_INFO("AMP-480272HBTMQW", 0x5C),
+};
+
+/* I2C device table on LCD-KIT-D01 */
+static const struct i2c_device_id lcdkitd01_idtable[] = {
+	{ "LCD-KIT-D01", 0 },
+	{ }
+};
+
+static const struct of_device_id lcdkitd01_of_match[] = {
+	{ .compatible = "apj,lcdkitd01", },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, lcdkitd01_idtable);
+
+/**
+ * struct amp_command - Internal structure combination of I2C format
+ * @type: Work type(byte write, word write or delay)
+ * @command: Register address (command value)
+ * @val1: First byte data of writing or delay type
+ * @val2: Second byte data of writing
+ */
+struct amp_command{
+	unsigned char type;
+	unsigned char command;
+	unsigned char val1;
+	unsigned char val2;
+};
+
+/* AMP-480272HBTMQW initialization command */
+static struct amp_command g_tagTcInitTbl[] = {
+	{TCHPNL_WR,  0x23, 0x00, 0x00},
+	{TCHPNL_DLY, 0x01, 0x00, 0x00},
+	{TCHPNL_WR,  0x2B, 0x03, 0x00},
+	{TCHPNL_WR,  0xD4, 0x00, 0x00},
+	{TCHPNL_WR,  0x06, 0x0D, 0x00},
+	{TCHPNL_WR,  0x07, 0x05, 0x00},
+	{TCHPNL_WR,  0x08, 0x00, 0x00},
+	{TCHPNL_WR,  0x09, 0x01, 0x00},
+	{TCHPNL_WR,  0x0A, 0x02, 0x00},
+	{TCHPNL_WR,  0x0B, 0x03, 0x00},
+	{TCHPNL_WR,  0x0C, 0x04, 0x00},
+	{TCHPNL_WR,  0x0D, 0x05, 0x00},
+	{TCHPNL_WR,  0x0E, 0x06, 0x00},
+	{TCHPNL_WR,  0x0F, 0x07, 0x00},
+	{TCHPNL_WR,  0x10, 0x08, 0x00},
+	{TCHPNL_WR,  0x11, 0x09, 0x00},
+	{TCHPNL_WR,  0x12, 0x0A, 0x00},
+	{TCHPNL_WR,  0x13, 0x0B, 0x00},
+	{TCHPNL_WR,  0x14, 0x0C, 0x00},
+	{TCHPNL_WR,  0x15, 0x0D, 0x00},
+	{TCHPNL_WR,  0x16, 0x0E, 0x00},
+	{TCHPNL_WR,  0x17, 0x0F, 0x00},
+	{TCHPNL_WR,  0x18, 0x10, 0x00},
+	{TCHPNL_WR,  0x19, 0x11, 0x00},
+	{TCHPNL_WR,  0x1A, 0x12, 0x00},
+	{TCHPNL_WR,  0x1B, 0x13, 0x00},
+	{TCHPNL_WR,  0x1C, 0x14, 0x00},
+	{TCHPNL_WR,  0x2A, 0x03, 0x00},
+	{TCHPNL_WR,  0x8D, 0x01, 0x00},
+	{TCHPNL_DLY, 0x02, 0x00, 0x00},
+	{TCHPNL_WR,  0x8D, 0x00, 0x00},
+	{TCHPNL_WR,  0x25, 0x0C, 0x00},
+	{TCHPNL_DLY, 0x02, 0x00, 0x00},
+	{TCHPNL_WR,  0xC1, 0x02, 0x00},
+	{TCHPNL_WR,  0xD5, 0x0C, 0x00},
+	{TCHPNL_DLY, 0x03, 0x00, 0x00},
+	{TCHPNL_WR,  0x38, 0x00, 0x00},
+	{TCHPNL_WR,  0x33, 0x01, 0x00},
+	{TCHPNL_WR,  0x34, 0x3A, 0x00},
+	{TCHPNL_2WR, 0x35, 0x00, 0x40},
+	{TCHPNL_WR,  0x36, 0x1E, 0x00},
+	{TCHPNL_WR,  0x37, 0x03, 0x00},
+	{TCHPNL_WR,  0x39, 0x01, 0x00},
+	{TCHPNL_WR,  0x56, 0x01, 0x00},
+	{TCHPNL_2WR, 0x51, 0x00, 0xFF},
+	{TCHPNL_2WR, 0x52, 0x00, 0xFF},
+	{TCHPNL_WR,  0x53, 0x20, 0x00},
+	{TCHPNL_WR,  0x54, 0x40, 0x00},
+	{TCHPNL_WR,  0x55, 0x40, 0x00},
+	{TCHPNL_WR,  0xD9, 0x01, 0x00},
+	{TCHPNL_WR,  0xD8, 0x03, 0x00},
+	{TCHPNL_WR,  0xD7, 0x04, 0x00},
+	{TCHPNL_WR,  0x2C, 0x02, 0x00},
+	{TCHPNL_WR,  0x3D, 0x01, 0x00},
+	{TCHPNL_WR,  0xD6, 0x01, 0x00},
+	{TCHPNL_WR,  0xA2, 0x00, 0x00},
+	{TCHPNL_WR,  0x2C, 0x02, 0x00},
+	{TCHPNL_WR,  0x66, 0x35, 0x00},
+	{TCHPNL_WR,  0x67, 0x36, 0x00},
+	{TCHPNL_END, 0x00, 0x00, 0x00},
+};
+
+
+enum buzz_speaker_mode { bsmIdling, bsmBuzzer, bsmSpeaker } bs_mode;
+
+static const unsigned short stepsizeTable[] = {
+      5,     6,     7,     8,     9,    10,    11,    12,    14,    15,
+     17,    18,    20,    22,    25,    27,    30,    33,    37,    40,
+     44,    49,    54,    59,    65,    72,    79,    87,    95,   105,
+    116,   127,   140,   154,   170,   187,   205,   226,   248,   273,
+    301,   331,   364,   400,   440,   485,   533,   586,   645,   710,
+    781,   859,   945,  1039,  1143,  1258,  1384,  1522,  1674,  1842,
+   2026,  2228,  2451,  2697,  2966,  3263,  3589,  3948,  4343,  4777,
+   5255,  5781,  6359,  6995,  7694,  8464,  9310, 10242, 11266, 12392,
+  13632, 14995, 16494, 18144, 19958, 21954, 24150, 26565
+};
+
+static const int stepmoveTable[] = {
+     -1, -1, -1, -1,  2,  4,  6,  8
+};
+
+const unsigned char sample_ref_table[] = {
+// No[hex]  FreqIdeal -->  Freq Real
+/*   0[00]       0.00 -->      0.00 */   0,
+/*   1[01]     185.00 -->    183.75 */  60,
+/*   2[02]     196.00 -->    190.09 */  58,
+/*   3[03]     207.65 -->    204.17 */  54,
+/*   4[04]     220.00 -->    212.02 */  52,
+/*   5[05]     233.08 -->    229.69 */  48,
+/*   6[06]     246.94 -->    239.67 */  46,
+/*   7[07]     261.63 -->    250.57 */  44,
+/*   8[08]     277.18 -->    275.63 */  40,
+/*   9[09]     293.66 -->    290.13 */  38,
+/*  10[0A]     311.13 -->    306.25 */  36,
+/*  11[0B]     329.63 -->    324.26 */  34,
+/*  12[0C]     349.23 -->    344.53 */  32,
+/*  13[0D]     369.99 -->    367.50 */  30,
+/*  14[0E]     392.00 -->    367.50 */  30,
+/*  15[0F]     415.30 -->    393.75 */  28,
+/*  16[10]     440.00 -->    424.04 */  26,
+/*  17[11]     466.16 -->    459.38 */  24,
+/*  18[12]     493.88 -->    459.38 */  24,
+/*  19[13]     523.25 -->    501.14 */  22,
+/*  20[14]     554.37 -->    551.25 */  20,
+/*  21[15]     587.33 -->    551.25 */  20,
+/*  22[16]     622.25 -->    612.50 */  18,
+/*  23[17]     659.26 -->    612.50 */  18,
+/*  24[18]     698.46 -->    689.06 */  16,
+/*  25[19]     739.99 -->    689.06 */  16,
+/*  26[1A]     783.99 -->    689.06 */  16,
+/*  27[1B]     830.61 -->    787.50 */  14,
+/*  28[1C]     880.00 -->    787.50 */  14,
+/*  29[1D]     932.33 -->    918.75 */  12,
+/*  30[1E]     987.77 -->    918.75 */  12,
+/*  31[1F]    1046.50 -->    918.75 */  12,
+/*  32[20]    1108.73 -->   1102.50 */  10,
+/*  33[21]    1174.66 -->   1102.50 */  10,
+/*  34[22]    1244.51 -->   1102.50 */  10,
+/*  35[23]    1318.51 -->   1102.50 */  10,
+/*  36[24]    1396.91 -->   1378.13 */   8,
+/*  37[25]    1479.98 -->   1378.13 */   8,
+/*  38[26]    1567.98 -->   1378.13 */   8,
+/*  39[27]    1661.22 -->   1378.13 */   8,
+/*  40[28]    1760.00 -->   1378.13 */   8,
+/*  41[29]    1864.65 -->   1837.50 */   6,
+/*  42[2A]    1975.53 -->   1837.50 */   6,
+/*  43[2B]    2093.00 -->   1837.50 */   6,
+/*  44[2C]    2217.46 -->   1837.50 */   6,
+/*  45[2D]    2349.32 -->   1837.50 */   6,
+/*  46[2E]    2489.02 -->   1837.50 */   6,
+/*  47[2F]    2637.02 -->   1837.50 */   6,
+/*  48[30]    2793.83 -->   2756.25 */   4,
+/*  49[31]    2959.96 -->   2756.25 */   4,
+/*  50[32]    3135.96 -->   2756.25 */   4,
+/*  51[33]    3322.44 -->   2756.25 */   4,
+/*  52[34]    3520.00 -->   2756.25 */   4,
+/*  53[35]    3729.31 -->   2756.25 */   4,
+/*  54[36]    3951.07 -->   2756.25 */   4,
+/*  55[37]    4186.01 -->   2756.25 */   4,
+/*  56[38]    4434.92 -->   2756.25 */   4,
+/*  57[39]    4698.64 -->   2756.25 */   4,
+/*  58[3A]    4978.03 -->   2756.25 */   4,
+/*  59[3B]    5274.04 -->   2756.25 */   4,
+/*  60[3C]    5587.65 -->   5512.50 */   2,
+/*  61[3D]    5919.91 -->   5512.50 */   2,
+/*  62[3E]    6271.93 -->   5512.50 */   2,
+/*  63[3F]    6644.88 -->   5512.50 */   2,
+/*  64[40]    7040.00 -->   5512.50 */   2,
+/*  65[41]    7458.62 -->   5512.50 */   2,
+/*  66[42]    7902.13 -->   5512.50 */   2,
+/*  67[43]    8372.02 -->   5512.50 */   2,
+/*  68[44]    8869.85 -->   5512.50 */   2,
+/*  69[45]    9397.27 -->   5512.50 */   2,
+/*  70[46]    9956.06 -->   5512.50 */   2,
+/*  71[47]   10548.08 -->   5512.50 */   2,
+/*  72[48]   11175.30 -->   5512.50 */   2,
+/*  73[49]   11839.82 -->   5512.50 */   2,
+/*  74[4A]   12543.86 -->   5512.50 */   2,
+/*  75[4B]   13289.75 -->   5512.50 */   2,
+/*  76[4C]   14080.00 -->   5512.50 */   2,
+/*  77[4D]   14080.00 -->   5512.50 */   2,
+/*  78[4E]   14080.00 -->   5512.50 */   2,
+/*  79[4F]   14080.00 -->   5512.50 */   2,
+/*  80[50]   14080.00 -->   5512.50 */   2,
+/*  81[51]   14080.00 -->   5512.50 */   2,
+/*  82[52]   14080.00 -->   5512.50 */   2,
+/*  83[53]   14080.00 -->   5512.50 */   2,
+/*  84[54]   14080.00 -->   5512.50 */   2,
+/*  85[55]   14080.00 -->   5512.50 */   2,
+/*  86[56]   14080.00 -->   5512.50 */   2,
+/*  87[57]   14080.00 -->   5512.50 */   2,
+/*  88[58]   14080.00 -->   5512.50 */   2,
+/*  89[59]   14080.00 -->   5512.50 */   2,
+/*  90[5A]   14080.00 -->   5512.50 */   2,
+/*  91[5B]   14080.00 -->   5512.50 */   2,
+/*  92[5C]   14080.00 -->   5512.50 */   2,
+/*  93[5D]   14080.00 -->   5512.50 */   2,
+/*  94[5E]   14080.00 -->   5512.50 */   2,
+/*  95[5F]   14080.00 -->   5512.50 */   2,
+/*  96[60]   14080.00 -->   5512.50 */   2,
+/*  97[61]   14080.00 -->   5512.50 */   2,
+/*  98[62]   14080.00 -->   5512.50 */   2,
+/*  99[63]   14080.00 -->   5512.50 */   2,
+/* 100[64]   14080.00 -->   5512.50 */   2,
+/* 101[65]   14080.00 -->   5512.50 */   2,
+/* 102[66]   14080.00 -->   5512.50 */   2,
+/* 103[67]   14080.00 -->   5512.50 */   2,
+/* 104[68]   14080.00 -->   5512.50 */   2,
+/* 105[69]   14080.00 -->   5512.50 */   2,
+/* 106[6A]   14080.00 -->   5512.50 */   2,
+/* 107[6B]   14080.00 -->   5512.50 */   2,
+/* 108[6C]   14080.00 -->   5512.50 */   2,
+/* 109[6D]   14080.00 -->   5512.50 */   2,
+/* 110[6E]   14080.00 -->   5512.50 */   2,
+/* 111[6F]   14080.00 -->   5512.50 */   2,
+/* 112[70]   14080.00 -->   5512.50 */   2,
+/* 113[71]   14080.00 -->   5512.50 */   2,
+/* 114[72]   14080.00 -->   5512.50 */   2,
+/* 115[73]   14080.00 -->   5512.50 */   2,
+/* 116[74]   14080.00 -->   5512.50 */   2,
+/* 117[75]   14080.00 -->   5512.50 */   2,
+/* 118[76]   14080.00 -->   5512.50 */   2,
+/* 119[77]   14080.00 -->   5512.50 */   2,
+/* 120[78]   14080.00 -->   5512.50 */   2,
+/* 121[79]   14080.00 -->   5512.50 */   2,
+/* 122[7A]   14080.00 -->   5512.50 */   2,
+/* 123[7B]   14080.00 -->   5512.50 */   2,
+/* 124[7C]   14080.00 -->   5512.50 */   2,
+/* 125[7D]   14080.00 -->   5512.50 */   2,
+/* 126[7E]   14080.00 -->   5512.50 */   2,
+/* 127[7F]   14080.00 -->   5512.50 */   2,
+/* 128[80]   14080.00 -->   5512.50 */   2,
+/* 129[81]   14080.00 -->   5512.50 */   2,
+/* 130[82]   14080.00 -->   5512.50 */   2,
+/* 131[83]   14080.00 -->   5512.50 */   2,
+/* 132[84]   14080.00 -->   5512.50 */   2,
+/* 133[85]   14080.00 -->   5512.50 */   2,
+/* 134[86]   14080.00 -->   5512.50 */   2,
+/* 135[87]   14080.00 -->   5512.50 */   2,
+/* 136[88]   14080.00 -->   5512.50 */   2,
+/* 137[89]   14080.00 -->   5512.50 */   2,
+/* 138[8A]   14080.00 -->   5512.50 */   2,
+/* 139[8B]   14080.00 -->   5512.50 */   2,
+/* 140[8C]   14080.00 -->   5512.50 */   2,
+/* 141[8D]   14080.00 -->   5512.50 */   2,
+/* 142[8E]   14080.00 -->   5512.50 */   2,
+/* 143[8F]   14080.00 -->   5512.50 */   2,
+/* 144[90]   14080.00 -->   5512.50 */   2,
+/* 145[91]   14080.00 -->   5512.50 */   2,
+/* 146[92]   14080.00 -->   5512.50 */   2,
+/* 147[93]   14080.00 -->   5512.50 */   2,
+/* 148[94]   14080.00 -->   5512.50 */   2,
+/* 149[95]   14080.00 -->   5512.50 */   2,
+/* 150[96]   14080.00 -->   5512.50 */   2,
+/* 151[97]   14080.00 -->   5512.50 */   2,
+/* 152[98]   14080.00 -->   5512.50 */   2,
+/* 153[99]   14080.00 -->   5512.50 */   2,
+/* 154[9A]   14080.00 -->   5512.50 */   2,
+/* 155[9B]   14080.00 -->   5512.50 */   2,
+/* 156[9C]   14080.00 -->   5512.50 */   2,
+/* 157[9D]   14080.00 -->   5512.50 */   2,
+/* 158[9E]   14080.00 -->   5512.50 */   2,
+/* 159[9F]   14080.00 -->   5512.50 */   2,
+/* 160[A0]   14080.00 -->   5512.50 */   2,
+/* 161[A1]   14080.00 -->   5512.50 */   2,
+/* 162[A2]   14080.00 -->   5512.50 */   2,
+/* 163[A3]   14080.00 -->   5512.50 */   2,
+/* 164[A4]   14080.00 -->   5512.50 */   2,
+/* 165[A5]   14080.00 -->   5512.50 */   2,
+/* 166[A6]   14080.00 -->   5512.50 */   2,
+/* 167[A7]   14080.00 -->   5512.50 */   2,
+/* 168[A8]   14080.00 -->   5512.50 */   2,
+/* 169[A9]   14080.00 -->   5512.50 */   2,
+/* 170[AA]   14080.00 -->   5512.50 */   2,
+/* 171[AB]   14080.00 -->   5512.50 */   2,
+/* 172[AC]   14080.00 -->   5512.50 */   2,
+/* 173[AD]   14080.00 -->   5512.50 */   2,
+/* 174[AE]   14080.00 -->   5512.50 */   2,
+/* 175[AF]   14080.00 -->   5512.50 */   2,
+/* 176[B0]   14080.00 -->   5512.50 */   2,
+/* 177[B1]   14080.00 -->   5512.50 */   2,
+/* 178[B2]   14080.00 -->   5512.50 */   2,
+/* 179[B3]   14080.00 -->   5512.50 */   2,
+/* 180[B4]   14080.00 -->   5512.50 */   2,
+/* 181[B5]   14080.00 -->   5512.50 */   2,
+/* 182[B6]   14080.00 -->   5512.50 */   2,
+/* 183[B7]   14080.00 -->   5512.50 */   2,
+/* 184[B8]   14080.00 -->   5512.50 */   2,
+/* 185[B9]   14080.00 -->   5512.50 */   2,
+/* 186[BA]   14080.00 -->   5512.50 */   2,
+/* 187[BB]   14080.00 -->   5512.50 */   2,
+/* 188[BC]   14080.00 -->   5512.50 */   2,
+/* 189[BD]   14080.00 -->   5512.50 */   2,
+/* 190[BE]   14080.00 -->   5512.50 */   2,
+/* 191[BF]   14080.00 -->   5512.50 */   2,
+/* 192[C0]   14080.00 -->   5512.50 */   2,
+/* 193[C1]   14080.00 -->   5512.50 */   2,
+/* 194[C2]   14080.00 -->   5512.50 */   2,
+/* 195[C3]   14080.00 -->   5512.50 */   2,
+/* 196[C4]   14080.00 -->   5512.50 */   2,
+/* 197[C5]   14080.00 -->   5512.50 */   2,
+/* 198[C6]   14080.00 -->   5512.50 */   2,
+/* 199[C7]   14080.00 -->   5512.50 */   2,
+/* 200[C8]   14080.00 -->   5512.50 */   2,
+/* 201[C9]   14080.00 -->   5512.50 */   2,
+/* 202[CA]   14080.00 -->   5512.50 */   2,
+/* 203[CB]   14080.00 -->   5512.50 */   2,
+/* 204[CC]   14080.00 -->   5512.50 */   2,
+/* 205[CD]   14080.00 -->   5512.50 */   2,
+/* 206[CE]   14080.00 -->   5512.50 */   2,
+/* 207[CF]   14080.00 -->   5512.50 */   2,
+/* 208[D0]   14080.00 -->   5512.50 */   2,
+/* 209[D1]   14080.00 -->   5512.50 */   2,
+/* 210[D2]   14080.00 -->   5512.50 */   2,
+/* 211[D3]   14080.00 -->   5512.50 */   2,
+/* 212[D4]   14080.00 -->   5512.50 */   2,
+/* 213[D5]   14080.00 -->   5512.50 */   2,
+/* 214[D6]   14080.00 -->   5512.50 */   2,
+/* 215[D7]   14080.00 -->   5512.50 */   2,
+/* 216[D8]   14080.00 -->   5512.50 */   2,
+/* 217[D9]   14080.00 -->   5512.50 */   2,
+/* 218[DA]   14080.00 -->   5512.50 */   2,
+/* 219[DB]   14080.00 -->   5512.50 */   2,
+/* 220[DC]   14080.00 -->   5512.50 */   2,
+/* 221[DD]   14080.00 -->   5512.50 */   2,
+/* 222[DE]   14080.00 -->   5512.50 */   2,
+/* 223[DF]   14080.00 -->   5512.50 */   2,
+/* 224[E0]   14080.00 -->   5512.50 */   2,
+/* 225[E1]   14080.00 -->   5512.50 */   2,
+/* 226[E2]   14080.00 -->   5512.50 */   2,
+/* 227[E3]   14080.00 -->   5512.50 */   2,
+/* 228[E4]   14080.00 -->   5512.50 */   2,
+/* 229[E5]   14080.00 -->   5512.50 */   2,
+/* 230[E6]   14080.00 -->   5512.50 */   2,
+/* 231[E7]   14080.00 -->   5512.50 */   2,
+/* 232[E8]   14080.00 -->   5512.50 */   2,
+/* 233[E9]   14080.00 -->   5512.50 */   2,
+/* 234[EA]   14080.00 -->   5512.50 */   2,
+/* 235[EB]   14080.00 -->   5512.50 */   2,
+/* 236[EC]   14080.00 -->   5512.50 */   2,
+/* 237[ED]   14080.00 -->   5512.50 */   2,
+/* 238[EE]   14080.00 -->   5512.50 */   2,
+/* 239[EF]   14080.00 -->   5512.50 */   2,
+/* 240[F0]   14080.00 -->   5512.50 */   2,
+/* 241[F1]   14080.00 -->   5512.50 */   2,
+/* 242[F2]   14080.00 -->   5512.50 */   2,
+/* 243[F3]   14080.00 -->   5512.50 */   2,
+/* 244[F4]   14080.00 -->   5512.50 */   2,
+/* 245[F5]   14080.00 -->   5512.50 */   2,
+/* 246[F6]   14080.00 -->   5512.50 */   2,
+/* 247[F7]   14080.00 -->   5512.50 */   2,
+/* 248[F8]   14080.00 -->   5512.50 */   2,
+/* 249[F9]   14080.00 -->   5512.50 */   2,
+/* 250[FA]   14080.00 -->   5512.50 */   2,
+/* 251[FB]   14080.00 -->   5512.50 */   2,
+/* 252[FC]   14080.00 -->   5512.50 */   2,
+/* 253[FD]   14080.00 -->   5512.50 */   2,
+/* 254[FE]   14080.00 -->   5512.50 */   2,
+/* 255[FF]   14080.00 -->   5512.50 */   2,
+};
+
+/* Prototype */
+static int lcdkitd01_touchscreen_init(struct i2c_client *client);
+static int lcdkitd01_probe(struct i2c_client *client,
+                           const struct i2c_device_id *id);
+static int lcdkitd01_remove(struct i2c_client *client);
+static void lcdkitd01_touchscreen_task(struct lcdkitd01 *ts, unsigned long st, int valid );
+static int lcdkitd01_touchscreen_get_info(struct touch_point_info *info,
+                                          struct lcdkitd01 *ts);
+static int lcdkitd01_speaker_send_packet(struct i2c_client *client,
+                                         struct lcdkitd01_beeper *pb);
+static int lcdkitd01_speaker_terminate(struct i2c_client *client);
+static void lcdkitd01_touchscreen_wake(struct lcdkitd01 *ts);
+
+static long lcdkitd01_buzzer_ioctl(struct file *filp,
+                                   unsigned int cmd,
+                                   unsigned long arg);
+static int lcdkitd01_speaker_reset(struct lcdkitd01 *ts);
+
+/* I2C driver information of LCD-KIT-D01 */
+static struct i2c_driver lcdkitd01_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(lcdkitd01_of_match),
+		.name	= "LCD-KIT-D01"
+	},
+	.id_table	= lcdkitd01_idtable,
+	.probe		= lcdkitd01_probe,
+	.remove		= lcdkitd01_remove,
+};
+
+
+/**
+ * lcdkitd01_touchscreen_check_pen() - Check touching touch screen.
+ * @*work: Work structure pointe.r
+ *
+ * Check pen touch or release.
+ */
+static void lcdkitd01_touchscreen_check_pen(struct work_struct *work)
+{
+	static int count = 0;
+	struct lcdkitd01 *ts = container_of(to_delayed_work(work),
+	                                    struct lcdkitd01,
+	                                    check_pen_work);
+	int status;
+	int i;
+
+	/* Check event. */
+	status = i2c_smbus_read_byte_data(ts->tp_client, TS_CMD_EVENT_STATUS);
+
+	if (status >= 0) {
+
+		/* Report touch status. */
+		lcdkitd01_touchscreen_task(ts, (unsigned long)status, 1);
+
+		if ((ts->status & TS_STA_PENMASK) == TS_STA_PENDOWN) {
+			/* Check pen release. */
+			if (!(status & TP_EVENT_FING)) {
+				count += 1;
+				if (count >= PEN_CHECK_COUNT) {
+					count = 0;
+
+					/* Pen released. */
+					ts->status &= ~TS_STA_PENMASK;
+					ts->status |=  TS_STA_PENUP;
+
+					/* Report. */
+					input_report_key(ts->input, BTN_TOUCH, 0);
+					input_sync(ts->input);
+
+					for (i = 0; i < 4; i++) {
+						ts->old_point[i].pos_x = 0x0FFF;
+						ts->old_point[i].pos_y = 0x0FFF;
+					}
+				}
+			}
+		} else {
+			/* Check pen holding. */
+			if (status & TP_EVENT_FING) {
+				count += 1;
+				if (count >= PEN_CHECK_COUNT) {
+					count = 0;
+
+					/* Pen down. */
+					ts->status &= ~TS_STA_PENMASK;
+					ts->status |=  TS_STA_PENDOWN;
+
+					/* Report. */
+					input_report_key(ts->input, BTN_TOUCH, 1);
+					input_sync(ts->input);
+				}
+			}
+		}
+
+	} else {
+		printk("Touchscreen get information failed.\n");
+	}
+
+	/* Continue. */
+	if ((count) || ((ts->status & TS_STA_PENMASK) == TS_STA_PENDOWN)) {
+		schedule_delayed_work(&ts->check_pen_work,
+		                      msecs_to_jiffies(PEN_CHECK_DELAY));
+	}
+}
+
+/**
+ * lcdkitd01_touchscreen_task() - Touch panel process, getting touch point
+ * @ts: LCD-KIT-D01 information structure pointer
+ * @status: Status
+ * 
+ * This function gets AMP touch screen event. If got
+ * finger touch event, this send MT protocol report.
+ * 
+ */
+
+static void lcdkitd01_touchscreen_task(struct lcdkitd01 *ts, unsigned long st, int valid )
+{
+	struct input_dev *input = ts->input;
+	struct touch_point_info *info, *old_info;
+	int i;
+	unsigned char get_st = 0;
+
+	/* Clear event stack. */
+	i2c_smbus_write_byte(ts->tp_client, 0x81);
+
+	if( valid )  {
+		for (i = 0; i < 4; i++) {
+			info = &ts->point[i];
+			if ((st & info->point_bit) != 0) {
+				if (lcdkitd01_touchscreen_get_info(info, ts) == 0) {
+					get_st |= (unsigned char)(1 << i);
+				}
+			}
+		}
+
+		/* Report to upper layer. */
+		for (i = 0; i < 4; i++) {
+			if ((get_st & (unsigned char)(1 << i)) != 0) {
+				info = &ts->point[i];
+				old_info = &ts->old_point[i];
+#ifdef MULTI_TOUCH_ENABLE
+				if ((info->pos_x != old_info->pos_x) ||
+				    (info->pos_y != old_info->pos_y)) {
+					input_report_abs(input, ABS_MT_POSITION_X, info->pos_x);
+					input_report_abs(input, ABS_MT_POSITION_Y, info->pos_y);
+					input_report_abs(input, ABS_MT_TOUCH_MAJOR, 35);
+					input_mt_sync(input);
+
+					old_info->pos_x = info->pos_x;
+					old_info->pos_y = info->pos_y;
+				}
+#endif	
+				if ((get_st & ~(1 << i)) == 0) {
+					if ((info->pos_x != old_info->pos_x) ||
+					    (info->pos_y != old_info->pos_y)) {
+						input_report_abs(input, ABS_X, info->pos_x);
+						input_report_abs(input, ABS_Y, info->pos_y);
+
+						old_info->pos_x = info->pos_x;
+						old_info->pos_y = info->pos_y;
+					}
+				}
+			}
+		}
+		input_sync(input);
+	}
+}
+
+/**
+ * lcdkitd01_touchscreen_open() - LCD-KIT-D01 touch panel driver open.
+ * @*input_dev: Input device structure pointer.
+ *
+ * LCD-KIT-D01 touchscreen (input device) open system call.
+ *
+ */
+static int lcdkitd01_touchscreen_open(struct input_dev *input_dev)
+{
+	struct lcdkitd01 *ts = input_get_drvdata(input_dev);
+	int err;
+	int i;
+
+	/* Prepare for touch readings - power down ADC and enable PENIRQ */
+	err = i2c_smbus_write_byte_data(ts->client, 0x05, 0x00);
+	if (err < 0) {
+		return err;
+	} else {
+		mdelay(500);
+		while (1) {
+			if (lcdkitd01_touchscreen_init(ts->tp_client) == 0) {
+				break;
+			}
+		}
+
+		/* Set display direction. */
+		i2c_smbus_write_byte_data(ts->client,
+		                          LCD_KIT_D01_CMD_DISPLAY_DIRECTION,
+		                          LCD_KIT_D01_DISPLAY_DIRECTION);
+
+		/* Mask speaker interrupt. */
+		i2c_smbus_write_byte_data(ts->client,
+		                          LCD_KIT_D01_CMD_INT_MASK,
+		                          LCD_KIT_D01_INTSTA_SPK_NOSEND);
+
+		/* Initialize information of touch pannel. */
+		for (i = 0; i < 4; i++) {
+			ts->point[i].reg_no = 0x7C + i;
+			ts->point[i].point_bit = (unsigned char)(1 << i);
+
+			ts->old_point[i].pos_x = 0x0FFF;
+			ts->old_point[i].pos_y = 0x0FFF;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * lcdkitd01_ts_close() - LCD-KIT-D01 touch panel driver close.
+ *
+ * LCD-KIT-D01 touchscreen (input device) close system call.
+ * Kernel holds this driver on building, so this driver never closed.
+ *
+ */
+static void lcdkitd01_ts_close(struct input_dev *input_dev)
+{
+	/* DO NOTHING */
+}
+
+/**
+ * lcdkitd01_read() - LCD-KIT-D01 driver read.
+ * @work: Work structure
+ *
+ * Read event status register of touch screen, and if
+ * latch finger event, system call lcdkitd01_touchscreen_task() and
+ * get each finger point. And get status of switches
+ * on LCD-KIT-D01.
+ *
+ */
+static void lcdkitd01_read(struct work_struct *work)
+{
+	struct lcdkitd01 *ts;
+	u32 ret = 0;
+
+	ts = container_of(to_delayed_work(work), struct lcdkitd01, work);
+
+	/* Get LCD-KIT-D01 controller interrupt status */
+	ret = i2c_smbus_read_byte_data(ts->client, 0x01);
+
+#if USE_MOUSE
+	if ((ts->status & STATUS_SW1) != (ret & STATUS_SW1))
+		input_report_key(ts->input, BTN_LEFT, ret & STATUS_SW1);
+	if ((ts->status & STATUS_SW2) != (ret & STATUS_SW2))
+		input_report_key(ts->input, BTN_MIDDLE, ret & STATUS_SW2);
+	if ((ts->status & STATUS_SW3) != (ret & STATUS_SW3))
+		input_report_key(ts->input, BTN_RIGHT, ret & STATUS_SW3);
+#else
+	if ((ts->status & STATUS_SW1) != (ret & STATUS_SW1))
+		input_report_key(ts->input, KEY_MENU, ret & STATUS_SW1);
+	if ((ts->status & STATUS_SW2) != (ret & STATUS_SW2))
+		input_report_key(ts->input, KEY_HOME, ret & STATUS_SW2);
+	if ((ts->status & STATUS_SW3) != (ret & STATUS_SW3))
+		input_report_key(ts->input, KEY_ESC, ret & STATUS_SW3);
+#endif
+	input_sync(ts->input);
+
+	if (ret > 0) {
+		ts->status &= ~(STATUS_SW1 | STATUS_SW2 | STATUS_SW3);
+		ts->status |= (unsigned long)(ret & (STATUS_SW1 | STATUS_SW2 | STATUS_SW3));
+		schedule_delayed_work(&ts->work, msecs_to_jiffies(READ_MSECS));
+	} else {
+		ts->status &= ~(STATUS_SW1 | STATUS_SW2 | STATUS_SW3);
+	}
+	
+	/* Pen check */
+	ret = i2c_smbus_read_byte_data(ts->tp_client, TS_CMD_EVENT_STATUS);
+	if (ret >= 0) {
+		if (((ts->status & TS_STA_PENMASK) == TS_STA_PENDOWN) || 
+		    (((ts->status & TS_STA_PENMASK) == TS_STA_PENUP) &&
+		     (ret & (TP_EVENT_FING | TP_EVENT_FNE) ))) {
+			schedule_delayed_work(&ts->check_pen_work, 0);
+		}
+	}
+}
+
+/**
+ * lcdkitd01_irq() - Touch screen interrupt
+ * @irq: 
+ * @handle:
+ */
+static irqreturn_t lcdkitd01_irq(int irq, void *handle)
+{
+	struct lcdkitd01 *ts = handle;
+
+	schedule_delayed_work(&ts->work, 0);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * lcdkitd01_poll_irq() - LCD-KIT-D01 driver irq polling
+ * @arg:
+ */
+static void lcdkitd01_poll_irq(unsigned long arg)
+{
+	struct lcdkitd01 *ts = (struct lcdkitd01 *)arg;
+	struct lcdkitd01_platform_data *pdata = ts->pdata;
+	int pin_state = pdata->get_irq_pin_state();
+
+	/* Wake up display. */
+
+	lcdkitd01_touchscreen_wake(ts);
+
+	if (ts->irq_pin_state == -1)
+		ts->irq_pin_state = pin_state;
+	else if (ts->irq_pin_state != pin_state) {
+		ts->irq_pin_state = pin_state;
+		schedule_delayed_work(&ts->work, 0);
+	}
+
+	mod_timer(&ts->timer, jiffies + pdata->poll_period);
+}
+
+/**
+ * lcdkitd01_led_set() - Set brightness of LCD-KIT-D01 backlight LED
+ * @led_cdev: LED class
+ * @value: LED brightness
+ *
+ * This function sets LED backlight brightness of Display.
+ *
+ */
+static void lcdkitd01_led_set(struct led_classdev *led_cdev,
+                              enum led_brightness value)
+{
+	struct lcdkitd01 *ts;
+
+	ts = container_of(led_cdev, struct lcdkitd01, led);
+
+	value = value * 100 / 255;
+	i2c_smbus_write_byte_data(ts->client, 0x03, value);	
+
+	ts->led_value = value;
+}
+
+void lcdkitd01_led_on(void)
+{
+	struct lcdkitd01 *ts;
+
+	if (g_sleepled_cdev == NULL) {
+		printk("lcdkitd01_led_on() error\n");
+		return;
+	}
+
+	ts = container_of(g_sleepled_cdev, struct lcdkitd01, led);
+
+	i2c_smbus_write_byte_data(ts->client, 0x03, ts->led_value);	
+}
+
+void lcdkitd01_led_off(void)
+{
+	struct lcdkitd01 *ts;
+
+	if (g_sleepled_cdev == NULL) {
+		printk("lcdkitd01_led_off() error\n");
+		return;
+	}
+
+	ts = container_of(g_sleepled_cdev, struct lcdkitd01, led);
+
+	i2c_smbus_write_byte_data(ts->client, 0x03, 0);	
+}
+
+/* LED class devices struction */
+static struct led_classdev lcdkitd01_led = {
+	.name		= "lcdkitd01_backlight",
+	.brightness_set	= lcdkitd01_led_set,
+};
+
+
+/* Buzzer B01/C01 Buzzer emuration */
+
+
+short int GetNextBuzzData( struct lcdkitd01_beeper *pb )
+{
+	--(pb->DownCounter);
+	if( pb->DownCounter == 0 ) {
+		pb->DownCounter = pb->HalfPeriod;
+		pb->Value = ( pb->Value != pb->Vol ) ? pb->Vol : -pb->Vol;
+	}
+	return pb->Value;
+}
+
+unsigned char GetNextADPCMData( struct lcdkitd01_beeper *pb )
+{
+	short rawval;
+	int   diff, delta, newdelta, lastrawval, laststepsizepos;
+	int   lastb0_b2, newb0_b2;
+	int   b3;
+	int   stepsize;
+	unsigned char retval;
+
+	rawval = GetNextBuzzData( pb );
+	lastrawval = pb->RawValue;
+	diff = rawval - lastrawval;
+	if( diff < 0 ) {
+		b3 = 0x08;
+		delta = -diff;
+	} else {
+		b3 = 0x00;
+		delta = diff;
+	}
+	laststepsizepos = pb->StepSizePos;
+	pb->StepSizePos = pb->StepSizePos + stepmoveTable[ pb->B0_B2 ];
+	if( pb->StepSizePos < 0 ) pb->StepSizePos = 0;
+	if( pb->StepSizePos > 87 ) pb->StepSizePos = 87;
+	stepsize = stepsizeTable[ pb->StepSizePos ];
+	lastb0_b2 = pb->B0_B2;
+	newb0_b2 = ( delta * 8 / stepsize - 1 ) / 2;
+	pb->B0_B2 = ( newb0_b2 > 0x07) ? 0x07 : newb0_b2;
+	retval = b3 | pb->B0_B2;
+	newdelta = stepsize * (pb->B0_B2 * 2 + 1 ) / 8;
+	if( b3 == 0x00) {
+		pb->RawValue = pb->RawValue + newdelta;
+		if( pb->RawValue > 32767 ) // 0x7fff
+			pb->RawValue = 32767;
+		} else {
+		pb->RawValue = pb->RawValue - newdelta;
+		if( pb->RawValue < -32768 ) // 0x8000
+			pb->RawValue = -32768;
+	}
+
+	return retval;
+}
+
+static void lcdkitd01_buzzer_task(struct work_struct *work)
+{
+	struct lcdkitd01 *ts = container_of(to_delayed_work(work),
+	                                    struct lcdkitd01,
+	                                    buzzer_work);
+	struct lcdkitd01_beeper  *beeper = &ts->beeper;
+	int err = 0;
+
+	if (beeper->info.status & SPKF_STA_RESET) {
+		err = i2c_smbus_read_byte_data(ts->client, LCD_KIT_D01_CMD_INT_STATUS);
+		if ((err >= 0) && (!(err & STATUS_SPK))) {
+			/* Reset */
+			err = lcdkitd01_speaker_terminate(ts->client);
+			if (!err) {
+				beeper->info.status &= ~(SPKF_STA_RESET | SPKF_STA_PLAY | SPKF_STA_PLAYING);
+			}
+		} else {
+			schedule_delayed_work(&ts->buzzer_work, msecs_to_jiffies(20));
+			return;
+		}
+	}
+
+	if ((beeper->info.status & (SPKF_STA_PLAY | SPKF_STA_PAUSE)) == SPKF_STA_PLAY) {
+		/* Playing.. */
+		err = i2c_smbus_read_byte_data(ts->client, LCD_KIT_D01_CMD_INT_STATUS);
+		if ((err >= 0) && (!(err & STATUS_SPK))) {
+			schedule_delayed_work(&ts->buzzer_work, msecs_to_jiffies(10));
+			lcdkitd01_speaker_send_packet(ts->client, beeper );
+		} else {
+			schedule_delayed_work(&ts->buzzer_work, msecs_to_jiffies(5));
+		}
+		beeper->info.status |= SPKF_STA_PLAYING;
+	}
+
+	/* Complete */
+	if( beeper->info.data_size <= beeper->info.send_size ) {
+		beeper->info.status &= ~(SPKF_STA_PLAY | SPKF_STA_PLAYING);
+		beeper->info.status |= SPKF_STA_COMPLETE;
+		bs_mode = bsmIdling;
+	}
+
+	/* Delay */
+	if ( (beeper->info.status & SPKF_STA_PLAYING) == 0 ) {
+		cancel_delayed_work( &ts->buzzer_work );
+	}
+}
+
+
+static ssize_t lcdkitd01_buzzer_read(struct file *filp, char __user *buf,
+                                     size_t count, loff_t *pos)
+{
+	return -EINVAL;
+}
+
+static void change_freq( struct lcdkitd01 *ts, int freq_no )
+{
+	struct lcdkitd01_beeper  *beeper = &ts->beeper;
+
+	beeper->HalfPeriod = sample_ref_table[ freq_no ] / 2; //SAMPLERATE / freq / 2;
+}
+
+static ssize_t  start_buzzer( struct lcdkitd01 *ts, int freq_no )
+{
+	struct lcdkitd01_beeper *beeper = &ts->beeper;
+	ssize_t retval = 0;
+
+	if( (freq_no <= 0) || (255 < freq_no) ) {
+		freq_no = 16;
+	}
+	beeper->RawValue = 0; //32bit
+	beeper->HalfPeriod = sample_ref_table[ freq_no ] / 2; //SAMPLERATE / freq / 2;
+	beeper->DownCounter = beeper->HalfPeriod;
+	beeper->Value = beeper->Vol;
+	beeper->StepSizePos = 0;
+	beeper->B0_B2 = 0;
+
+	beeper->info.status = 0;
+	beeper->info.data_size = SAMPLERATE * BEEP_PERIOD / 2;
+	beeper->info.send_size = 0;
+
+	dbg( "Vol=%d", beeper->Vol );
+	dbg( "%s(%p, FreqNo=%d, SamplesOfHalfPeriod=%ld )",
+	     __func__, ts, freq_no, beeper->HalfPeriod );
+
+	ts->beeper.info.status &= ~(SPKF_STA_PLAY | SPKF_STA_PAUSE);
+	ts->beeper.info.status |= SPKF_STA_PLAY;
+	bs_mode = bsmBuzzer;
+	schedule_delayed_work(&ts->buzzer_work, msecs_to_jiffies(0));
+	retval = 1;
+
+	return retval;
+}
+
+
+static ssize_t lcdkitd01_buzzer_write(struct file *filp,
+                                      const char __user *buf,
+                                      size_t count, loff_t *pos)
+{
+	struct lcdkitd01 *ts = container_of(filp->private_data, struct lcdkitd01, buzzer);
+	u8 data = 0;
+	ssize_t retval = 1;
+
+	dbg( "%s(%p, %p, %d, %p", __func__, filp, buf, count, pos );
+
+	if( ! get_user(data, buf) ) {
+		dbg( "data=%X", data );
+		if( data == 0 ) { // buzzer stop
+			dbg( "Stop buzzer" );
+			lcdkitd01_speaker_reset(ts);
+			schedule_delayed_work(&ts->buzzer_work, 0);
+			bs_mode = bsmIdling;
+		} else {
+			if( (0 < data) && (data <=0x3f) ) {
+				dbg( "Start buzzer" );
+				if( bs_mode != bsmIdling ) {
+					change_freq( ts, data );
+					retval = 1;
+				} else {
+					retval = start_buzzer( ts, data );
+				}
+			} else {
+				retval = -EINVAL;
+			}
+		}
+	} else {
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+static int lcdkitd01_set_buzzer_vol(int vol, struct lcdkitd01 *ts)
+{
+	struct lcdkitd01_beeper *beeper = &ts->beeper;
+	int retval = 0;
+
+	if( 0 <= vol && vol < 32768 ) {
+		beeper->Vol = vol;
+	} else {
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+
+static struct file_operations lcdkitd01_buzzer_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.read = lcdkitd01_buzzer_read,
+	.write = lcdkitd01_buzzer_write,
+	.open = nonseekable_open,
+	.unlocked_ioctl = lcdkitd01_buzzer_ioctl,
+};
+
+static struct miscdevice lcdkitd01_buzzer_device = {
+	MISC_DYNAMIC_MINOR,
+	"lcdkitd01_buzzer",
+	&lcdkitd01_buzzer_fops,
+};
+
+/**
+ * lcdkitd01_buzzer_ioctl() - LCD-KIT-D01 speaker driver IOCTL system call
+ * @inode: Node
+ * @filp: File pointer
+ * @cmd: IOCTL command
+ * @arg: Argument
+ *
+ * LCD-KIT-D01 buzzer iocontrol system call.
+ *
+ */
+static long lcdkitd01_buzzer_ioctl(struct file *filp,
+                                   unsigned int cmd,
+                                   unsigned long arg)
+{
+	long err = 0;
+	struct lcdkitd01 *ts =
+		container_of(filp->private_data, struct lcdkitd01, buzzer);
+	unsigned char *temp;
+
+	if (_IOC_DIR(cmd) & _IOC_WRITE) {
+		if (!access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd))) {
+			printk("  accessable error.\n");
+			err = -EFAULT;
+		}
+	} else if (_IOC_DIR(cmd) & _IOC_READ) {
+		if (!access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd))) {
+			printk("  accessable error.\n");
+			err = -EFAULT;
+		}
+	}
+
+	if (err == 0) {
+		temp = (unsigned char *)kzalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+		if (!temp) {
+			printk("  kzalloc() failed.\n");
+			err = -EFAULT;
+		}
+	}
+
+	if (err == 0) {
+		switch (cmd) {
+			case LCD_KIT_D01_CMD_BUZZER_VOL:
+				if (!copy_from_user(temp, (int *)arg, _IOC_SIZE(cmd))) {
+					err = lcdkitd01_set_buzzer_vol((*((int *)temp)), ts);
+				} else {
+					err = -EFAULT;
+				}
+				break;
+			default:
+				printk("%s: cmd: 0x%08X is not supported.\n", __func__, _IOC_NR(cmd));
+				err = -ENOTTY;
+				break;
+		}
+	} else {
+		printk("  %s: %d: param error.\n", __func__, _IOC_NR(cmd));
+	}
+
+	if (temp) {
+		kfree(temp);
+	}
+
+	return err;
+}
+
+/**
+ * lcdkitd01_speaker_reset() - Reset speaker file sending
+ * @*ts: LCD-KIT-D01 driver information structure pointer
+ *
+ * Set reset flag on player.
+ *
+ */
+static int lcdkitd01_speaker_reset(struct lcdkitd01 *ts)
+{
+	struct lcdkitd01_beeper *beeper = &ts->beeper;
+
+	beeper->info.status |= SPKF_STA_RESET;
+
+	return 0;
+}
+
+/**
+ * lcdkitd01_speaker_send_packet() - Send packet data to LCD-KIT-D01 speaker
+ * @*client: I2C client pointer to LCD-KIT-D01 controller
+ * @*player: Player information pointer
+ *
+ * Send packet data to LCD-KIT-D01 controller(= speaker).
+ *
+ */
+static int lcdkitd01_speaker_send_packet(struct i2c_client *client,
+                                         struct lcdkitd01_beeper *beeper)
+{
+	int err = 0;
+	unsigned long i;
+	unsigned long len = 0;
+	unsigned long size = 0;
+	unsigned char pack_buf[LCD_KIT_D01_SPEAKER_MAX_SIZE];
+	unsigned char *pack_data = NULL;
+	unsigned char val1, val2;
+
+	len = beeper->info.data_size - beeper->info.send_size;
+	if ((len >= LCD_KIT_D01_SPEAKER_DATA_MAX) ||
+	    (len >= (beeper->info.data_size - beeper->info.send_size))) {
+
+		if (len > LCD_KIT_D01_SPEAKER_DATA_MAX) {
+			len = LCD_KIT_D01_SPEAKER_DATA_MAX;
+		}
+
+		/* Make packet header */
+		pack_buf[0] = 0x06;
+		if (!beeper->info.send_size) {
+			/* First packet */
+			pack_buf[1] = 0x01;
+			pack_buf[2] = (unsigned char)((beeper->info.data_size >> 24) & 0x000000FF);
+			pack_buf[3] = (unsigned char)((beeper->info.data_size >> 16) & 0x000000FF);
+			pack_buf[4] = (unsigned char)((beeper->info.data_size >>  8) & 0x000000FF);
+			pack_buf[5] = (unsigned char)((beeper->info.data_size >>  0) & 0x000000FF);
+			pack_buf[6] = len;
+			pack_data   = &pack_buf[7];
+			size = len + 7;
+		} else {
+			/* Secondary packet */
+			pack_buf[1] = 0x02;
+			pack_buf[2] = len;
+			pack_data   = &pack_buf[3];
+			size = len + 3;
+		}
+
+		/* Set data */
+		for (i = 0; i < len; i++) {
+			val1 = GetNextADPCMData( beeper );
+			val2 = GetNextADPCMData( beeper );
+			pack_data[i] = (val1 << 4) + val2;
+		}
+
+		err = i2c_master_send(client, pack_buf, size);
+		if (err == size) {
+			/* I2C success */
+			beeper->info.send_size += len;
+			err = len;
+		} else {
+			printk("  %s: I2C error.\n", __func__);
+		}
+
+	}
+
+	return err;
+}
+
+/**
+ * lcdkitd01_speaker_terminate() - Terminate speaker output
+ * @client: I2C client pointer to LCD-KIT-D01 controller
+ *
+ * Send terminate command packet to LCD-KIT-D01 controller(= speaker).
+ *
+ */
+static int lcdkitd01_speaker_terminate(struct i2c_client *client)
+{
+	unsigned char buf[4];
+	int err = 0;
+
+	buf[0] = 0x06;
+	buf[1] = 0x03;	/* Termination */
+	buf[2] = 0x00;	/* Reserved */
+	buf[3] = 0x00;	/* Reserved */
+
+	if (i2c_master_send(client, buf, 4) >= 0) {
+		err = 0;
+	} else {
+		err = -1;
+	}
+
+	return err;
+}
+
+
+/**
+ * lcdkitd01_touchscreen_wake() - LCD-KIT-D01 wake up display.
+ * @ts: lcdkitd01 structrue pointer
+ *
+ * Wake up LCD-KIT-D01 LCD display.
+ */
+static void lcdkitd01_touchscreen_wake(struct lcdkitd01 *ts)
+{
+	/* Send system enable command to touch panel. */
+	i2c_smbus_write_byte_data(ts->tp_client, 0x23, 0x00);
+}
+
+
+/**
+ * lcdkitd01_probe() - LCD-KIT-D01 driver probe.
+ * @client: I2C client pointer(for LCD-KIT-D01 controller)
+ * @id: I2C device id
+ *
+ * I2C driver probe system call.
+ *
+ */
+static int lcdkitd01_probe(struct i2c_client *client,
+                           const struct i2c_device_id *id)
+{
+	struct lcdkitd01_platform_data *pdata = client->dev.platform_data;
+	struct lcdkitd01 *ts;
+	struct input_dev *input_dev;
+	int err = 0;
+#ifdef  CONFIG_USE_OF
+	struct device_node *np;
+#endif
+
+	printk("LCD-KIT-D01 TouchPanel Driver.\n");
+
+	/* Check I2C functions. */
+	if (!i2c_check_functionality(client->adapter,
+	                             I2C_FUNC_SMBUS_READ_WORD_DATA  |
+	                             I2C_FUNC_SMBUS_WRITE_WORD_DATA |
+	                             I2C_FUNC_SMBUS_READ_BYTE_DATA  |
+	                             I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {
+		printk("%s i2c_check_functionality failed\n", __func__);
+		return -EIO;
+	}
+
+
+	/* Allocate memory for LCD-KIT-D01 */
+	ts = kzalloc(sizeof(struct lcdkitd01), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!ts || !input_dev) {
+		printk("%s kzalloc failed\n", __func__);
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	ts->client = client;
+
+#ifdef  CONFIG_USE_OF
+	np = of_find_node_by_path("/i2c@e6540000/lcdkitd01@0x42");
+	if( np ) {
+		ts->irq = irq_of_parse_and_map(np, 0);
+	} else {
+		ts->irq = 0;
+		dev_err(&client->dev, "irq_of_parse_and_map failed\n"); 
+	}	 
+#else
+	ts->irq = client->irq;
+#endif
+
+
+	ts->pdata = pdata;
+	ts->input = input_dev;
+
+	INIT_DELAYED_WORK(&ts->work, lcdkitd01_read);
+
+	ts->tp_client = i2c_new_device(client->adapter, &tp_i2c_info);
+	if (!ts->tp_client) {
+		printk("%s: tp_client create failed.\n", __func__);
+	}
+
+	/* Initialize LCD-KIT-D01 touch panel device. */
+	input_dev->name = "LCD-KIT-D01";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->open = lcdkitd01_touchscreen_open;
+	input_dev->close = lcdkitd01_ts_close;
+	INIT_DELAYED_WORK(&ts->check_pen_work, lcdkitd01_touchscreen_check_pen);
+
+	/* Initialize Buzzer device */
+	INIT_DELAYED_WORK(&ts->buzzer_work, lcdkitd01_buzzer_task);
+
+	/* Initialize IRQ. */
+	if (ts->irq != NO_IRQ) {
+		err = request_irq(ts->irq, lcdkitd01_irq,
+		                  IRQF_TRIGGER_FALLING,
+		                  input_dev->name, ts);
+		if (err) {
+			pr_warning("lcdkitd01 irq request fail %d\n", err);
+			err = -EIO;
+			goto err_free_gpio;
+		}
+	} else {
+		ts->irq_pin_state = -1;
+		init_timer(&ts->timer);
+		ts->timer.expires = jiffies + ts->pdata->poll_period;
+		setup_timer(&ts->timer, lcdkitd01_poll_irq, (unsigned long)ts);
+		add_timer(&ts->timer);
+	}
+
+	/* Register device. */
+	input_set_abs_params(input_dev, ABS_X,
+	                     0, LCD_KIT_D01_DISPLAY_WIDTH,
+	                     0, 0);
+	input_set_abs_params(input_dev, ABS_Y,
+	                     0, LCD_KIT_D01_DISPLAY_HEIGHT,
+	                     0, 0);
+#ifdef MULTI_TOUCH_ENABLE
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
+	                     0, LCD_KIT_D01_DISPLAY_WIDTH,
+	                     0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X,
+	                     0, LCD_KIT_D01_DISPLAY_WIDTH,
+	                     0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y,
+	                     0, LCD_KIT_D01_DISPLAY_HEIGHT,
+	                     0, 0);
+#endif
+#if USE_MOUSE
+	input_set_capability(input_dev, EV_KEY, BTN_LEFT);
+	input_set_capability(input_dev, EV_KEY, BTN_RIGHT);
+	input_set_capability(input_dev, EV_KEY, BTN_MIDDLE);
+#else
+	input_set_capability(input_dev, EV_KEY, KEY_MENU);
+	input_set_capability(input_dev, EV_KEY, KEY_HOME);
+	input_set_capability(input_dev, EV_KEY, KEY_ESC);
+#endif
+	input_set_capability(input_dev, EV_KEY, BTN_TOUCH);
+
+	input_set_drvdata(input_dev, ts);	
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_free_irq;
+
+	/* Register backlight led. */
+	ts->led = lcdkitd01_led;
+	led_classdev_register(&client->dev, &ts->led);
+
+	ts->led_value = 255;
+	g_sleepled_cdev = &ts->led;
+
+	bs_mode = bsmIdling;
+	lcdkitd01_buzzer_device.parent = &input_dev->dev;
+	ts->buzzer = lcdkitd01_buzzer_device;
+	ts->beeper.Vol = BUZZER_VOL;
+	misc_register(&ts->buzzer);
+
+	/* Backlight ON */
+	lcdkitd01_led_set(&ts->led, 255);
+
+	return err;
+
+	/* Error code. */
+err_free_irq:
+	free_irq(ts->irq, ts);
+
+err_free_gpio:
+
+err_free_mem:
+	input_free_device(input_dev);
+	kfree(ts);
+
+	return err;
+}
+
+/**
+ * lcdkitd01_remove() - LCD-KIT-D01 driver remove
+ * @client: I2C client pointer
+ *
+ * LCD-KIT-D01 driver remove system call.
+ *
+ */
+static int lcdkitd01_remove(struct i2c_client *client)
+{
+	struct lcdkitd01 *ts = i2c_get_clientdata(client);
+
+	led_classdev_unregister(&ts->led);
+
+	if (ts->irq != NO_IRQ)
+		free_irq(ts->irq, ts);
+	else
+		del_timer_sync(&ts->timer);
+
+	input_unregister_device(ts->input);
+	kfree(ts);
+
+	return 0;
+}
+
+/**
+ * lcdkitd01_touchscreen_init() - AMP-480272HBTMQW initialization
+ * @client: pointer of I2C to AMP-480272HBTMQW
+ *
+ * This function sends initialization code of AMP-480272HBTMQW.
+ * Call this just onece.
+ *
+ */
+static int lcdkitd01_touchscreen_init(struct i2c_client *client)
+{
+	int i = 0;
+	int iRes = 0;
+	struct amp_command *tagpInit;
+	unsigned short usWData;
+	unsigned long ulDelay;
+
+	while (1) {
+		/* Get initialize code pointer */
+		tagpInit = &g_tagTcInitTbl[i];
+
+		if (tagpInit->type == TCHPNL_END) {
+			/* 終了 */
+			break;
+		} else {
+			switch (tagpInit->type) {
+				case TCHPNL_WR:
+					/* Write byte data */
+					iRes = i2c_smbus_write_byte_data(client, tagpInit->command, tagpInit->val1);
+					break;
+				case TCHPNL_2WR:
+					/* Write word data */
+					usWData = (((unsigned short)tagpInit->val1 & 0x00FF) << 16) |
+					          (((unsigned short)tagpInit->val2 & 0x00FF) <<  0);
+					iRes = i2c_smbus_write_word_data(client, tagpInit->command, usWData);
+					break;
+				case TCHPNL_DLY:
+					/* Delay */
+					if (tagpInit->command == 0x01) {
+						ulDelay = 50;
+					} else if (tagpInit->command == 0x02) {
+						ulDelay = 100;
+					} else if (tagpInit->command == 0x03) {
+						ulDelay = 300;
+					} else {
+						ulDelay = 0;
+					}
+					mdelay(ulDelay);
+					break;
+			}
+
+			if (iRes == 0) {
+				i++;
+			} else {
+				break;
+			}
+		}
+	}
+
+	if (iRes < 0) {
+		iRes = i2c_smbus_read_word_data(client, 0x02);
+		iRes = i2c_smbus_write_byte_data(client, 0x25, 0x0F);
+		iRes = -1;
+	} else {
+		/* Clear event stack. */
+		iRes = i2c_smbus_write_byte_data(client, 0x81, 0x00);
+	}
+
+	return iRes;
+}
+
+/**
+ * lcdkitd01_touchscreen_get_info() - Get finger point
+ * @info: touch point structure pointer
+ * @ts: LCD-KIT-D01 infomation structure pointer
+ *
+ * Get finger point with *info setting(reg_no, point_bit).
+ *
+ */
+static int lcdkitd01_touchscreen_get_info(struct touch_point_info *info, struct lcdkitd01 *ts)
+{
+	int res;
+	unsigned short x, y;
+	unsigned char rx_buf[4];
+
+	res = i2c_smbus_read_i2c_block_data(ts->tp_client, info->reg_no, 4, rx_buf);
+	if (res == 4) {
+		y = (unsigned short)(rx_buf[0] & 0x00FF) |
+		    ((unsigned short)(rx_buf[2] & 0xF0) << 4);
+		x = (unsigned short)(rx_buf[1] & 0x00FF) |
+		    ((unsigned short)(rx_buf[2] & 0x0F) << 8);
+
+		/* Check X, Y Error */
+		if(x >= 0x0FFF) {
+			res = -1;
+		}
+		if(y >= 0x0FFF) {
+			res = -1;
+		}
+
+		/* Direction fillter */
+#if defined(LCD_KIT_D01_DISPLAY_HREVERSE)
+		if (x >= LCD_KIT_D01_DISPLAY_WIDTH) {
+			x = LCD_KIT_D01_DISPLAY_WIDTH - 1;
+		}
+		/* Flip horizonal parameter. */
+		x = (LCD_KIT_D01_DISPLAY_WIDTH - 1) - x;
+#endif	/* LCD_KIT_D01_DISPLAY_HREVERSE */
+
+#if !defined(LCD_KIT_D01_DISPLAY_VREVERSE)
+		if (y >= LCD_KIT_D01_DISPLAY_HEIGHT) {
+			y = LCD_KIT_D01_DISPLAY_HEIGHT - 1;
+		}
+		/* Flip virtical parameter. */
+		y = (LCD_KIT_D01_DISPLAY_HEIGHT - 1) - y;
+#endif	/* LCD_KIT_D01_DISPLAY_VREVERSE */
+
+		if (res != -1) {
+			info->pos_x = x;
+			info->pos_y = y;
+			res = 0;
+		}
+	} else {
+		printk("_%s: %d: i2c_smbus_read_i2c_block_data() error: %d", __func__, __LINE__, res);
+	}
+
+	return res;
+}
+
+
+/**
+ * lcdkitd01_init() - LCD-KIT-D01 initialize
+ *
+ * LCD-KIT-D01 driver init system call.
+ *
+ */
+static int __init lcdkitd01_init(void)
+{
+	printk("%s: %d\n", __func__, __LINE__);
+	return i2c_add_driver(&lcdkitd01_driver);
+}
+
+/**
+ * lcdkitd01_exit() - LCD-KIT-D01 exit
+ *
+ * LCD-KIT-D01 driver exit system call.
+ *
+ */
+static void __exit lcdkitd01_exit(void)
+{
+	printk("%s: %d\n", __func__, __LINE__);
+	i2c_del_driver(&lcdkitd01_driver);
+}
+
+/* Module macros */
+module_init(lcdkitd01_init);
+module_exit(lcdkitd01_exit);
+
+/* Module infomation */
+MODULE_AUTHOR("Alpha Project Co., LTD");
+MODULE_DESCRIPTION("LCD-KIT-D01 TouchScreen Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/lcdkitd01.h b/drivers/input/touchscreen/lcdkitd01.h
new file mode 100644
index 0000000..976c131
--- /dev/null
+++ b/drivers/input/touchscreen/lcdkitd01.h
@@ -0,0 +1,102 @@
+/*
+ * include/linux/input/lcdkitd01.h
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ */
+
+#ifndef __LINUX_INPUT_LCD_KIT_D01_H__
+#define __LINUX_INPUT_LCD_KIT_D01_H__
+
+/* Include */
+#include <linux/ioctl.h>
+
+/* Define */
+/* LCD-KIT-D01 Display size */
+#define LCD_KIT_D01_DISPLAY_WIDTH	(480)
+#define LCD_KIT_D01_DISPLAY_HEIGHT	(272)
+
+#define BUZZER
+
+
+/* Speaker file status */
+#define SPKF_STA_COMPLETE		(0x00000002)
+#define SPKF_STA_PLAY			(0x00000004)
+#define SPKF_STA_PAUSE			(0x00000008)
+#define SPKF_STA_PLAYING		(0x00000010)
+#define SPKF_STA_DELETE			(0x00000020)
+#define SPKF_STA_RESET			(0x80000000)
+
+/* Struct */
+/**
+ * struct lcdkitd01_speaker_setting - Structure to setting speaker
+ * @data_size: File size to send.
+ * @send_size: File size driver send.
+ * @status: File status
+ * @buf_size: Internal buffer size.
+ */
+struct lcdkitd01_speaker_info {
+	unsigned long data_size;
+	unsigned long send_size;
+	unsigned long status;
+	//unsigned long buf_size;
+};
+
+
+#ifdef BUZZER
+/**
+ * struct lcdkitd01_buzzer_setting - Structure to setting buzzer
+ * @SeqNo: Sequence Na
+ * @WaveLength: WaveLength
+ * @Value: ADPCM value?
+ * @RawValue: PCM value
+ * @HalfPeriod: Half length of wave
+ * @DownCounter:
+ * @Vol: wave volume
+ * @StepsizePos: step size table position
+ * @B0_B2: ADCPM B0,B1,B2 Value
+ */
+struct lcdkitd01_beeper {
+    unsigned short     Value; // 16bit unsgined
+    long               RawValue; //32bit
+    long               HalfPeriod;
+    long               DownCounter;
+    int                Vol;
+    int                StepSizePos;
+    long               B0_B2;
+	struct lcdkitd01_speaker_info info;
+};
+#endif
+
+/* IOCTL command */
+/* Magic number */
+#define LCD_KIT_D01_CMD_MAGIC		(0x40)
+
+/* Number enum */
+enum {
+	CMD_RESET = 0x00,
+	CMD_BUZ_VOL,
+};
+
+/* IOCTL Command macro */
+#define LCD_KIT_D01_CMD_RESET		_IO(LCD_KIT_D01_CMD_MAGIC, CMD_RESET)
+#define LCD_KIT_D01_CMD_NEW			_IOWR(LCD_KIT_D01_CMD_MAGIC, CMD_NEW, struct lcdkitd01_speaker_info)
+#define LCD_KIT_D01_CMD_PLAY		_IO(LCD_KIT_D01_CMD_MAGIC, CMD_PLAY)
+#define LCD_KIT_D01_CMD_PAUSE		_IO(LCD_KIT_D01_CMD_MAGIC, CMD_PAUSE)
+#define LCD_KIT_D01_CMD_CHANGE_BUF	_IOW(LCD_KIT_D01_CMD_MAGIC, CMD_CBUF, unsigned long)
+#define LCD_KIT_D01_CMD_GET_INFO	_IOR(LCD_KIT_D01_CMD_MAGIC, CMD_GET_INFO, struct lcdkitd01_speaker_info)
+#ifdef BUZZER
+#define LCD_KIT_D01_CMD_BUZZER_VOL	_IOW(LCD_KIT_D01_CMD_MAGIC, CMD_BUZ_VOL, int )
+#endif
+
+#endif	/* __LINUX_INPUT_LCD_KIT_D01_H__ */
diff --git a/drivers/input/touchscreen/lcdkitd02.c b/drivers/input/touchscreen/lcdkitd02.c
new file mode 100644
index 0000000..bd35080
--- /dev/null
+++ b/drivers/input/touchscreen/lcdkitd02.c
@@ -0,0 +1,1553 @@
+/*
+ * LCD-KIT-D02 touchscreen
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
+ */
+
+/* Include */
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/leds.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/ioctl.h>
+
+#include <linux/gpio.h>
+#ifdef CONFIG_USE_OF
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#endif
+#include <linux/platform_data/gpio-rcar.h>
+
+/* LCD-KIT-D02 Display size */
+#define LCD_KIT_D02_DISPLAY_WIDTH	(480)
+#define LCD_KIT_D02_DISPLAY_HEIGHT	(272)
+
+#define BUZZER
+
+
+/* Speaker file status */
+#define SPKF_STA_COMPLETE		(0x00000002)
+#define SPKF_STA_PLAY			(0x00000004)
+#define SPKF_STA_PAUSE			(0x00000008)
+#define SPKF_STA_PLAYING		(0x00000010)
+#define SPKF_STA_DELETE			(0x00000020)
+#define SPKF_STA_RESET			(0x80000000)
+
+/* Struct */
+/**
+ * struct lcdkitd02_speaker_setting - Structure to setting speaker
+ * @data_size: File size to send.
+ * @send_size: File size driver send.
+ * @status: File status
+ * @buf_size: Internal buffer size.
+ */
+struct lcdkitd02_speaker_info {
+	unsigned long data_size;
+	unsigned long send_size;
+	unsigned long status;
+};
+
+
+#ifdef BUZZER
+/**
+ * struct lcdkitd02_buzzer_setting - Structure to setting buzzer
+ * @SeqNo: Sequence Na
+ * @WaveLength: WaveLength
+ * @Value: ADPCM value?
+ * @RawValue: PCM value
+ * @HalfPeriod: Half length of wave
+ * @DownCounter:
+ * @Vol: wave volume
+ * @StepsizePos: step size table position
+ * @B0_B2: ADCPM B0,B1,B2 Value
+ */
+struct lcdkitd02_beeper {
+	unsigned short                Value;
+	long                          RawValue;
+	long                          HalfPeriod;
+	long                          DownCounter;
+	int                           Vol;
+	int                           StepSizePos;
+	long                          B0_B2;
+	struct lcdkitd02_speaker_info info;
+};
+#endif
+
+/* IOCTL command */
+/* Magic number */
+#define LCD_KIT_D02_CMD_MAGIC		(0x40)
+
+/* Number enum */
+enum {
+	CMD_RESET = 0x00,
+	CMD_BUZ_VOL,
+};
+
+/* IOCTL Command macro */
+#define LCD_KIT_D02_CMD_RESET		_IO(LCD_KIT_D02_CMD_MAGIC, CMD_RESET)
+#define LCD_KIT_D02_CMD_NEW			_IOWR(LCD_KIT_D02_CMD_MAGIC, CMD_NEW, struct lcdkitd02_speaker_info)
+#define LCD_KIT_D02_CMD_PLAY		_IO(LCD_KIT_D02_CMD_MAGIC, CMD_PLAY)
+#define LCD_KIT_D02_CMD_PAUSE		_IO(LCD_KIT_D02_CMD_MAGIC, CMD_PAUSE)
+#define LCD_KIT_D02_CMD_CHANGE_BUF	_IOW(LCD_KIT_D02_CMD_MAGIC, CMD_CBUF, unsigned long)
+#define LCD_KIT_D02_CMD_GET_INFO	_IOR(LCD_KIT_D02_CMD_MAGIC, CMD_GET_INFO, struct lcdkitd02_speaker_info)
+#ifdef BUZZER
+#define LCD_KIT_D02_CMD_BUZZER_VOL	_IOW(LCD_KIT_D02_CMD_MAGIC, CMD_BUZ_VOL, int )
+#endif
+
+/* Multi touch enable */
+//#define MULTI_TOUCH_ENABLE
+
+#define MAX_FINGER_POS_COUNT 5
+
+/* LCD-KIT-D02 Controller command */
+#define LCD_KIT_D02_CMD_FIRM_WARE			(0x00)
+#define LCD_KIT_D02_CMD_INT_STATUS			(0x01)
+#define LCD_KIT_D02_CMD_INT_MASK			(0x02)
+#define LCD_KIT_D02_CMD_BACKLIGHT			(0x03)
+#define LCD_KIT_D02_CMD_DISPLAY_DIRECTION	(0x04)
+#define LCD_KIT_D02_CMD_TP_RESET			(0x05)
+#define LCD_KIT_D02_CMD_SOUND				(0x06)
+
+/* Speaker packet max size */
+#define LCD_KIT_D02_SPEAKER_DATA_MAX	(100)
+#define LCD_KIT_D02_SPEAKER_MAX_SIZE	(LCD_KIT_D02_SPEAKER_DATA_MAX + 7)
+
+/* LCD-KIT-D02 controller interrupt status */
+#define LCD_KIT_D02_INTSTA_SPK_NOSEND	(0x20)
+
+/* Toucpanel Event */
+#define TP_EVENT_F0		(0x01)
+#define TP_EVENT_F1		(0x02)
+#define TP_EVENT_F2		(0x04)
+#define TP_EVENT_F3		(0x08)
+#define TP_EVENT_FING	(TP_EVENT_F0 | TP_EVENT_F1 | TP_EVENT_F2 | TP_EVENT_F3)
+#define TP_EVENT_FNE	(0x10)
+#define TP_EVENT_FOF	(0x20)
+#define TP_EVENT_LOBJ	(0x40)
+
+/* LCD-KIT-D02 interrupt status */
+#define STATUS_SPK	(1 << 5)
+#define STATUS_SW3	(1 << 4)
+#define STATUS_SW2	(1 << 3)
+#define STATUS_SW1	(1 << 2)
+#define STATUS_TP0	(1 << 0)
+
+/* Read delay */
+#define READ_MSECS	20
+
+/* Debug Code */
+//#define LCDKITD02_DEBUG
+
+#ifdef LCDKITD02_DEBUG
+#define dbg(format, arg...) printk(KERN_INFO __FILE__ ": "  format "\n", ## arg);
+#else
+#define dbg(format, arg...) do{} while(0);
+#endif
+
+/* LCD display direction */
+//#define LCD_KIT_D02_DISPLAY_HREVERSE	/* Horizonal undefined: normal, defined: reverse */
+//#define LCD_KIT_D02_DISPLAY_VREVERSE	/* Virtical  undefined: normal, defined: reverse */
+#if !defined(LCD_KIT_D02_DISPLAY_HREVERSE)
+	#define LCD_KIT_D02_DISPLAY_HORIZONAL	(1)
+#else
+	#define LCD_KIT_D02_DISPLAY_HORIZONAL	(0)
+#endif
+#if !defined(LCD_KIT_D02_DISPLAY_VREVERSE)
+	#define LCD_KIT_D02_DISPLAY_VERTICAL	(1)
+#else
+	#define LCD_KIT_D02_DISPLAY_VERTICAL	(0)
+#endif
+#define LCD_KIT_D02_DISPLAY_DIRECTION	((LCD_KIT_D02_DISPLAY_HORIZONAL << 1) | LCD_KIT_D02_DISPLAY_VERTICAL)
+
+#define USE_MOUSE 0
+
+#define TP_CONTROL_REG		0x10
+
+/* Touch screen pen control. */
+#define PEN_CHECK_DELAY	(10)
+
+/* LCDKITD02 BUZZER */
+#define SAMPLERATE	11025
+#define BEEP_PERIOD	(24*60*60)
+
+#ifdef LCDKITD02_DEBUG
+#define BUZZER_VOL		0x03ff
+#else
+#define BUZZER_VOL		5000
+#endif
+
+struct led_classdev *g_sleepled_cdev = NULL; /* Backlight on/off Only */
+
+/**
+ * struct lcdkitd02_platform_data - internal struct of LCD-KIT-D02 driver
+ * @get_irq_pin_state: Callback for getting status of IRQ pin
+ * @poll_period: Polling cycle
+ */
+struct lcdkitd02_platform_data {
+	int (*get_irq_pin_state)(void);
+	int poll_period;
+};
+
+/**
+ * struct touch_point_info - internal structure of touch panel information
+ * @valid: valid point data flag
+ * @pos_x: X point
+ * @pos_y: Y point
+ */
+typedef struct TouchPositionType {
+	unsigned char  valid;
+	unsigned short x, y;
+} TouchPos;
+
+struct touch_point_info {
+	unsigned short finger_count;
+	TouchPos pos[MAX_FINGER_POS_COUNT];
+	TouchPos last_pos[MAX_FINGER_POS_COUNT];
+};
+
+/**
+ * struct lcdkitd02 - internal structure of LCD-KIT-D02 driver
+ * @input: Input device
+ * @client: I2C client of control cpu on LCD-KIT-D02
+ * @tp_client: I2C client of touch panel
+ * @*pdata: Plat form data pointer
+ * @work: Work que
+ * @spk_player_work: Work que for speaker playing
+ * @buzzer_work: Work que for buzzer
+ * @check_pen_work: Work que for checking touch screen pen status
+ * @led: LED class deice of LCD-KIT-D02
+ * @speaker: Device structure of speaker
+ * @timer: Event polling timer
+ * @point[]: Touch screen point information with 4 fingers
+ * @player: LCD-KIT-D02 speaker information
+ * @irq_pin_state: Status of IRQ pin
+ * @irq: IRQ number
+ * @status: Status
+ */
+struct lcdkitd02 {
+	struct input_dev *input;
+	struct i2c_client *client;
+	struct i2c_client *tp_client;
+	struct lcdkitd02_platform_data *pdata;
+	struct delayed_work work;
+	struct delayed_work buzzer_work;
+	struct delayed_work check_pen_work;
+	struct led_classdev led;
+	struct miscdevice buzzer;
+	struct timer_list timer;
+	struct touch_point_info touch_info;
+	struct lcdkitd02_beeper beeper;
+	int irq_pin_state;
+	int irq;
+	unsigned long status;
+	enum led_brightness led_value;
+};
+
+/* I2C Board Information */
+static struct i2c_board_info tp_i2c_info = {
+	I2C_BOARD_INFO("AM-480272HBTMQW-T62H", 0x5C),
+};
+
+/* I2C device table on LCD-KIT-D02 */
+static const struct i2c_device_id lcdkitd02_idtable[] = {
+	{ "LCD-KIT-D02", 0 },
+	{ }
+};
+
+static const struct of_device_id lcdkitd02_of_match[] = {
+	{ .compatible = "apj,lcdkitd02", },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, lcdkitd02_idtable);
+
+
+enum buzz_speaker_mode { bsmIdling, bsmBuzzer, bsmSpeaker } bs_mode;
+
+static const unsigned short stepsizeTable[] = {
+      5,     6,     7,     8,     9,    10,    11,    12,    14,    15,
+     17,    18,    20,    22,    25,    27,    30,    33,    37,    40,
+     44,    49,    54,    59,    65,    72,    79,    87,    95,   105,
+    116,   127,   140,   154,   170,   187,   205,   226,   248,   273,
+    301,   331,   364,   400,   440,   485,   533,   586,   645,   710,
+    781,   859,   945,  1039,  1143,  1258,  1384,  1522,  1674,  1842,
+   2026,  2228,  2451,  2697,  2966,  3263,  3589,  3948,  4343,  4777,
+   5255,  5781,  6359,  6995,  7694,  8464,  9310, 10242, 11266, 12392,
+  13632, 14995, 16494, 18144, 19958, 21954, 24150, 26565
+};
+
+static const int stepmoveTable[] = {
+     -1, -1, -1, -1,  2,  4,  6,  8
+};
+
+const unsigned char sample_ref_table[] = {
+// No[hex]  FreqIdeal -->  Freq Real
+/*   0[00]       0.00 -->      0.00 */   0,
+/*   1[01]     185.00 -->    183.75 */  60,
+/*   2[02]     196.00 -->    190.09 */  58,
+/*   3[03]     207.65 -->    204.17 */  54,
+/*   4[04]     220.00 -->    212.02 */  52,
+/*   5[05]     233.08 -->    229.69 */  48,
+/*   6[06]     246.94 -->    239.67 */  46,
+/*   7[07]     261.63 -->    250.57 */  44,
+/*   8[08]     277.18 -->    275.63 */  40,
+/*   9[09]     293.66 -->    290.13 */  38,
+/*  10[0A]     311.13 -->    306.25 */  36,
+/*  11[0B]     329.63 -->    324.26 */  34,
+/*  12[0C]     349.23 -->    344.53 */  32,
+/*  13[0D]     369.99 -->    367.50 */  30,
+/*  14[0E]     392.00 -->    367.50 */  30,
+/*  15[0F]     415.30 -->    393.75 */  28,
+/*  16[10]     440.00 -->    424.04 */  26,
+/*  17[11]     466.16 -->    459.38 */  24,
+/*  18[12]     493.88 -->    459.38 */  24,
+/*  19[13]     523.25 -->    501.14 */  22,
+/*  20[14]     554.37 -->    551.25 */  20,
+/*  21[15]     587.33 -->    551.25 */  20,
+/*  22[16]     622.25 -->    612.50 */  18,
+/*  23[17]     659.26 -->    612.50 */  18,
+/*  24[18]     698.46 -->    689.06 */  16,
+/*  25[19]     739.99 -->    689.06 */  16,
+/*  26[1A]     783.99 -->    689.06 */  16,
+/*  27[1B]     830.61 -->    787.50 */  14,
+/*  28[1C]     880.00 -->    787.50 */  14,
+/*  29[1D]     932.33 -->    918.75 */  12,
+/*  30[1E]     987.77 -->    918.75 */  12,
+/*  31[1F]    1046.50 -->    918.75 */  12,
+/*  32[20]    1108.73 -->   1102.50 */  10,
+/*  33[21]    1174.66 -->   1102.50 */  10,
+/*  34[22]    1244.51 -->   1102.50 */  10,
+/*  35[23]    1318.51 -->   1102.50 */  10,
+/*  36[24]    1396.91 -->   1378.13 */   8,
+/*  37[25]    1479.98 -->   1378.13 */   8,
+/*  38[26]    1567.98 -->   1378.13 */   8,
+/*  39[27]    1661.22 -->   1378.13 */   8,
+/*  40[28]    1760.00 -->   1378.13 */   8,
+/*  41[29]    1864.65 -->   1837.50 */   6,
+/*  42[2A]    1975.53 -->   1837.50 */   6,
+/*  43[2B]    2093.00 -->   1837.50 */   6,
+/*  44[2C]    2217.46 -->   1837.50 */   6,
+/*  45[2D]    2349.32 -->   1837.50 */   6,
+/*  46[2E]    2489.02 -->   1837.50 */   6,
+/*  47[2F]    2637.02 -->   1837.50 */   6,
+/*  48[30]    2793.83 -->   2756.25 */   4,
+/*  49[31]    2959.96 -->   2756.25 */   4,
+/*  50[32]    3135.96 -->   2756.25 */   4,
+/*  51[33]    3322.44 -->   2756.25 */   4,
+/*  52[34]    3520.00 -->   2756.25 */   4,
+/*  53[35]    3729.31 -->   2756.25 */   4,
+/*  54[36]    3951.07 -->   2756.25 */   4,
+/*  55[37]    4186.01 -->   2756.25 */   4,
+/*  56[38]    4434.92 -->   2756.25 */   4,
+/*  57[39]    4698.64 -->   2756.25 */   4,
+/*  58[3A]    4978.03 -->   2756.25 */   4,
+/*  59[3B]    5274.04 -->   2756.25 */   4,
+/*  60[3C]    5587.65 -->   5512.50 */   2,
+/*  61[3D]    5919.91 -->   5512.50 */   2,
+/*  62[3E]    6271.93 -->   5512.50 */   2,
+/*  63[3F]    6644.88 -->   5512.50 */   2,
+/*  64[40]    7040.00 -->   5512.50 */   2,
+/*  65[41]    7458.62 -->   5512.50 */   2,
+/*  66[42]    7902.13 -->   5512.50 */   2,
+/*  67[43]    8372.02 -->   5512.50 */   2,
+/*  68[44]    8869.85 -->   5512.50 */   2,
+/*  69[45]    9397.27 -->   5512.50 */   2,
+/*  70[46]    9956.06 -->   5512.50 */   2,
+/*  71[47]   10548.08 -->   5512.50 */   2,
+/*  72[48]   11175.30 -->   5512.50 */   2,
+/*  73[49]   11839.82 -->   5512.50 */   2,
+/*  74[4A]   12543.86 -->   5512.50 */   2,
+/*  75[4B]   13289.75 -->   5512.50 */   2,
+/*  76[4C]   14080.00 -->   5512.50 */   2,
+/*  77[4D]   14080.00 -->   5512.50 */   2,
+/*  78[4E]   14080.00 -->   5512.50 */   2,
+/*  79[4F]   14080.00 -->   5512.50 */   2,
+/*  80[50]   14080.00 -->   5512.50 */   2,
+/*  81[51]   14080.00 -->   5512.50 */   2,
+/*  82[52]   14080.00 -->   5512.50 */   2,
+/*  83[53]   14080.00 -->   5512.50 */   2,
+/*  84[54]   14080.00 -->   5512.50 */   2,
+/*  85[55]   14080.00 -->   5512.50 */   2,
+/*  86[56]   14080.00 -->   5512.50 */   2,
+/*  87[57]   14080.00 -->   5512.50 */   2,
+/*  88[58]   14080.00 -->   5512.50 */   2,
+/*  89[59]   14080.00 -->   5512.50 */   2,
+/*  90[5A]   14080.00 -->   5512.50 */   2,
+/*  91[5B]   14080.00 -->   5512.50 */   2,
+/*  92[5C]   14080.00 -->   5512.50 */   2,
+/*  93[5D]   14080.00 -->   5512.50 */   2,
+/*  94[5E]   14080.00 -->   5512.50 */   2,
+/*  95[5F]   14080.00 -->   5512.50 */   2,
+/*  96[60]   14080.00 -->   5512.50 */   2,
+/*  97[61]   14080.00 -->   5512.50 */   2,
+/*  98[62]   14080.00 -->   5512.50 */   2,
+/*  99[63]   14080.00 -->   5512.50 */   2,
+/* 100[64]   14080.00 -->   5512.50 */   2,
+/* 101[65]   14080.00 -->   5512.50 */   2,
+/* 102[66]   14080.00 -->   5512.50 */   2,
+/* 103[67]   14080.00 -->   5512.50 */   2,
+/* 104[68]   14080.00 -->   5512.50 */   2,
+/* 105[69]   14080.00 -->   5512.50 */   2,
+/* 106[6A]   14080.00 -->   5512.50 */   2,
+/* 107[6B]   14080.00 -->   5512.50 */   2,
+/* 108[6C]   14080.00 -->   5512.50 */   2,
+/* 109[6D]   14080.00 -->   5512.50 */   2,
+/* 110[6E]   14080.00 -->   5512.50 */   2,
+/* 111[6F]   14080.00 -->   5512.50 */   2,
+/* 112[70]   14080.00 -->   5512.50 */   2,
+/* 113[71]   14080.00 -->   5512.50 */   2,
+/* 114[72]   14080.00 -->   5512.50 */   2,
+/* 115[73]   14080.00 -->   5512.50 */   2,
+/* 116[74]   14080.00 -->   5512.50 */   2,
+/* 117[75]   14080.00 -->   5512.50 */   2,
+/* 118[76]   14080.00 -->   5512.50 */   2,
+/* 119[77]   14080.00 -->   5512.50 */   2,
+/* 120[78]   14080.00 -->   5512.50 */   2,
+/* 121[79]   14080.00 -->   5512.50 */   2,
+/* 122[7A]   14080.00 -->   5512.50 */   2,
+/* 123[7B]   14080.00 -->   5512.50 */   2,
+/* 124[7C]   14080.00 -->   5512.50 */   2,
+/* 125[7D]   14080.00 -->   5512.50 */   2,
+/* 126[7E]   14080.00 -->   5512.50 */   2,
+/* 127[7F]   14080.00 -->   5512.50 */   2,
+/* 128[80]   14080.00 -->   5512.50 */   2,
+/* 129[81]   14080.00 -->   5512.50 */   2,
+/* 130[82]   14080.00 -->   5512.50 */   2,
+/* 131[83]   14080.00 -->   5512.50 */   2,
+/* 132[84]   14080.00 -->   5512.50 */   2,
+/* 133[85]   14080.00 -->   5512.50 */   2,
+/* 134[86]   14080.00 -->   5512.50 */   2,
+/* 135[87]   14080.00 -->   5512.50 */   2,
+/* 136[88]   14080.00 -->   5512.50 */   2,
+/* 137[89]   14080.00 -->   5512.50 */   2,
+/* 138[8A]   14080.00 -->   5512.50 */   2,
+/* 139[8B]   14080.00 -->   5512.50 */   2,
+/* 140[8C]   14080.00 -->   5512.50 */   2,
+/* 141[8D]   14080.00 -->   5512.50 */   2,
+/* 142[8E]   14080.00 -->   5512.50 */   2,
+/* 143[8F]   14080.00 -->   5512.50 */   2,
+/* 144[90]   14080.00 -->   5512.50 */   2,
+/* 145[91]   14080.00 -->   5512.50 */   2,
+/* 146[92]   14080.00 -->   5512.50 */   2,
+/* 147[93]   14080.00 -->   5512.50 */   2,
+/* 148[94]   14080.00 -->   5512.50 */   2,
+/* 149[95]   14080.00 -->   5512.50 */   2,
+/* 150[96]   14080.00 -->   5512.50 */   2,
+/* 151[97]   14080.00 -->   5512.50 */   2,
+/* 152[98]   14080.00 -->   5512.50 */   2,
+/* 153[99]   14080.00 -->   5512.50 */   2,
+/* 154[9A]   14080.00 -->   5512.50 */   2,
+/* 155[9B]   14080.00 -->   5512.50 */   2,
+/* 156[9C]   14080.00 -->   5512.50 */   2,
+/* 157[9D]   14080.00 -->   5512.50 */   2,
+/* 158[9E]   14080.00 -->   5512.50 */   2,
+/* 159[9F]   14080.00 -->   5512.50 */   2,
+/* 160[A0]   14080.00 -->   5512.50 */   2,
+/* 161[A1]   14080.00 -->   5512.50 */   2,
+/* 162[A2]   14080.00 -->   5512.50 */   2,
+/* 163[A3]   14080.00 -->   5512.50 */   2,
+/* 164[A4]   14080.00 -->   5512.50 */   2,
+/* 165[A5]   14080.00 -->   5512.50 */   2,
+/* 166[A6]   14080.00 -->   5512.50 */   2,
+/* 167[A7]   14080.00 -->   5512.50 */   2,
+/* 168[A8]   14080.00 -->   5512.50 */   2,
+/* 169[A9]   14080.00 -->   5512.50 */   2,
+/* 170[AA]   14080.00 -->   5512.50 */   2,
+/* 171[AB]   14080.00 -->   5512.50 */   2,
+/* 172[AC]   14080.00 -->   5512.50 */   2,
+/* 173[AD]   14080.00 -->   5512.50 */   2,
+/* 174[AE]   14080.00 -->   5512.50 */   2,
+/* 175[AF]   14080.00 -->   5512.50 */   2,
+/* 176[B0]   14080.00 -->   5512.50 */   2,
+/* 177[B1]   14080.00 -->   5512.50 */   2,
+/* 178[B2]   14080.00 -->   5512.50 */   2,
+/* 179[B3]   14080.00 -->   5512.50 */   2,
+/* 180[B4]   14080.00 -->   5512.50 */   2,
+/* 181[B5]   14080.00 -->   5512.50 */   2,
+/* 182[B6]   14080.00 -->   5512.50 */   2,
+/* 183[B7]   14080.00 -->   5512.50 */   2,
+/* 184[B8]   14080.00 -->   5512.50 */   2,
+/* 185[B9]   14080.00 -->   5512.50 */   2,
+/* 186[BA]   14080.00 -->   5512.50 */   2,
+/* 187[BB]   14080.00 -->   5512.50 */   2,
+/* 188[BC]   14080.00 -->   5512.50 */   2,
+/* 189[BD]   14080.00 -->   5512.50 */   2,
+/* 190[BE]   14080.00 -->   5512.50 */   2,
+/* 191[BF]   14080.00 -->   5512.50 */   2,
+/* 192[C0]   14080.00 -->   5512.50 */   2,
+/* 193[C1]   14080.00 -->   5512.50 */   2,
+/* 194[C2]   14080.00 -->   5512.50 */   2,
+/* 195[C3]   14080.00 -->   5512.50 */   2,
+/* 196[C4]   14080.00 -->   5512.50 */   2,
+/* 197[C5]   14080.00 -->   5512.50 */   2,
+/* 198[C6]   14080.00 -->   5512.50 */   2,
+/* 199[C7]   14080.00 -->   5512.50 */   2,
+/* 200[C8]   14080.00 -->   5512.50 */   2,
+/* 201[C9]   14080.00 -->   5512.50 */   2,
+/* 202[CA]   14080.00 -->   5512.50 */   2,
+/* 203[CB]   14080.00 -->   5512.50 */   2,
+/* 204[CC]   14080.00 -->   5512.50 */   2,
+/* 205[CD]   14080.00 -->   5512.50 */   2,
+/* 206[CE]   14080.00 -->   5512.50 */   2,
+/* 207[CF]   14080.00 -->   5512.50 */   2,
+/* 208[D0]   14080.00 -->   5512.50 */   2,
+/* 209[D1]   14080.00 -->   5512.50 */   2,
+/* 210[D2]   14080.00 -->   5512.50 */   2,
+/* 211[D3]   14080.00 -->   5512.50 */   2,
+/* 212[D4]   14080.00 -->   5512.50 */   2,
+/* 213[D5]   14080.00 -->   5512.50 */   2,
+/* 214[D6]   14080.00 -->   5512.50 */   2,
+/* 215[D7]   14080.00 -->   5512.50 */   2,
+/* 216[D8]   14080.00 -->   5512.50 */   2,
+/* 217[D9]   14080.00 -->   5512.50 */   2,
+/* 218[DA]   14080.00 -->   5512.50 */   2,
+/* 219[DB]   14080.00 -->   5512.50 */   2,
+/* 220[DC]   14080.00 -->   5512.50 */   2,
+/* 221[DD]   14080.00 -->   5512.50 */   2,
+/* 222[DE]   14080.00 -->   5512.50 */   2,
+/* 223[DF]   14080.00 -->   5512.50 */   2,
+/* 224[E0]   14080.00 -->   5512.50 */   2,
+/* 225[E1]   14080.00 -->   5512.50 */   2,
+/* 226[E2]   14080.00 -->   5512.50 */   2,
+/* 227[E3]   14080.00 -->   5512.50 */   2,
+/* 228[E4]   14080.00 -->   5512.50 */   2,
+/* 229[E5]   14080.00 -->   5512.50 */   2,
+/* 230[E6]   14080.00 -->   5512.50 */   2,
+/* 231[E7]   14080.00 -->   5512.50 */   2,
+/* 232[E8]   14080.00 -->   5512.50 */   2,
+/* 233[E9]   14080.00 -->   5512.50 */   2,
+/* 234[EA]   14080.00 -->   5512.50 */   2,
+/* 235[EB]   14080.00 -->   5512.50 */   2,
+/* 236[EC]   14080.00 -->   5512.50 */   2,
+/* 237[ED]   14080.00 -->   5512.50 */   2,
+/* 238[EE]   14080.00 -->   5512.50 */   2,
+/* 239[EF]   14080.00 -->   5512.50 */   2,
+/* 240[F0]   14080.00 -->   5512.50 */   2,
+/* 241[F1]   14080.00 -->   5512.50 */   2,
+/* 242[F2]   14080.00 -->   5512.50 */   2,
+/* 243[F3]   14080.00 -->   5512.50 */   2,
+/* 244[F4]   14080.00 -->   5512.50 */   2,
+/* 245[F5]   14080.00 -->   5512.50 */   2,
+/* 246[F6]   14080.00 -->   5512.50 */   2,
+/* 247[F7]   14080.00 -->   5512.50 */   2,
+/* 248[F8]   14080.00 -->   5512.50 */   2,
+/* 249[F9]   14080.00 -->   5512.50 */   2,
+/* 250[FA]   14080.00 -->   5512.50 */   2,
+/* 251[FB]   14080.00 -->   5512.50 */   2,
+/* 252[FC]   14080.00 -->   5512.50 */   2,
+/* 253[FD]   14080.00 -->   5512.50 */   2,
+/* 254[FE]   14080.00 -->   5512.50 */   2,
+/* 255[FF]   14080.00 -->   5512.50 */   2,
+};
+
+/* Prototype */
+static int lcdkitd02_probe(struct i2c_client *client,
+                           const struct i2c_device_id *id);
+static int lcdkitd02_remove(struct i2c_client *client);
+static int lcdkitd02_touchscreen_task(struct lcdkitd02 *ts);
+static int lcdkitd02_touchscreen_get_info(struct lcdkitd02 *ts);
+static int lcdkitd02_speaker_send_packet(struct i2c_client *client,
+                                         struct lcdkitd02_beeper *pb);
+static int lcdkitd02_speaker_terminate(struct i2c_client *client);
+
+static long lcdkitd02_buzzer_ioctl(struct file *filp,
+                                   unsigned int cmd,
+                                   unsigned long arg);
+static int lcdkitd02_speaker_reset(struct lcdkitd02 *ts);
+
+/* I2C driver information of LCD-KIT-D02 */
+static struct i2c_driver lcdkitd02_driver = {
+	.driver = {
+		.owner			= THIS_MODULE,
+		.of_match_table = of_match_ptr(lcdkitd02_of_match),
+		.name			= "LCD-KIT-D02"
+	},
+	.id_table	= lcdkitd02_idtable,
+	.probe		= lcdkitd02_probe,
+	.remove		= lcdkitd02_remove,
+};
+
+
+/**
+ * lcdkitd02_touchscreen_check_pen() - Check touching touch screen.
+ * @*work: Work structure pointe.r
+ *
+ * Check pen touch or release.
+ */
+static void lcdkitd02_touchscreen_check_pen(struct work_struct *work)
+{
+	struct lcdkitd02 *ts = container_of(to_delayed_work(work),
+	                                    struct lcdkitd02,
+	                                    check_pen_work);
+
+	if( lcdkitd02_touchscreen_task(ts) ) {
+		schedule_delayed_work(&ts->check_pen_work,
+		                      msecs_to_jiffies(PEN_CHECK_DELAY));
+	}
+}
+
+/**
+ * lcdkitd02_touchscreen_task() - Touch panel process, getting touch point
+ * @ts: LCD-KIT-D02 information structure pointer
+ * @status: Status
+ * 
+ * This function gets AMP touch screen event. If got
+ * finger touch event, this send MT protocol report.
+ * 
+ */
+static int lcdkitd02_touchscreen_task(struct lcdkitd02 *ts)
+{
+	struct input_dev *input = ts->input;
+	struct touch_point_info *info = &(ts->touch_info);
+	int i, new_finger_count;
+	int retval;
+
+	new_finger_count = lcdkitd02_touchscreen_get_info( ts );
+	if( 0 <= new_finger_count ) {
+		if( new_finger_count != info->finger_count ) { 
+			if( new_finger_count == 0 ) {
+				input_report_key(ts->input, BTN_TOUCH, 0);
+			} else if( info->finger_count == 0 ) {
+				input_report_key(ts->input, BTN_TOUCH, 1);
+			}
+			info->finger_count = new_finger_count;
+		}
+
+		for (i = 0; i < MAX_FINGER_POS_COUNT; i++) {
+			if ( info->pos[i].valid ) {
+				if ((info->pos[i].x != info->last_pos[i].x) ||
+				    (info->pos[i].y != info->last_pos[i].y)) {
+
+#ifdef MULTI_TOUCH_ENABLE
+					input_report_abs(input, ABS_MT_POSITION_X, info->pos[i].x);
+					input_report_abs(input, ABS_MT_POSITION_Y, info->pos[i].y);
+					input_report_abs(input, ABS_MT_TOUCH_MAJOR, 35);
+					input_mt_sync(input);
+#endif
+
+					if( new_finger_count == 1 ) {
+						input_report_abs(input, ABS_X, info->pos[i].x);
+						input_report_abs(input, ABS_Y, info->pos[i].y);
+						input_sync(input);
+					}
+
+					info->last_pos[i].x = info->pos[i].x;
+					info->last_pos[i].y = info->pos[i].y;
+				}
+			}
+		}
+		retval = new_finger_count;
+	} else {
+		retval = -1;
+	}
+
+	return retval;
+}
+
+/**
+ * lcdkitd02_touchscreen_open() - LCD-KIT-D02 touch panel driver open.
+ * @*input_dev: Input device structure pointer.
+ *
+ * LCD-KIT-D02 touchscreen (input device) open system call.
+ *
+ */
+static int lcdkitd02_touchscreen_open(struct input_dev *input_dev)
+{
+	struct lcdkitd02 *ts = input_get_drvdata(input_dev);
+	int err;
+	int i;
+
+	/* Prepare for touch readings - power down ADC and enable PENIRQ */
+	err = i2c_smbus_write_byte_data(ts->client, 0x05, 0x00);
+	if (err < 0) {
+		return err;
+	} else {
+		mdelay(500);
+
+		/* Set display direction. */
+		i2c_smbus_write_byte_data(ts->client,
+		                          LCD_KIT_D02_CMD_DISPLAY_DIRECTION,
+		                          LCD_KIT_D02_DISPLAY_DIRECTION);
+
+		/* Mask speaker interrupt. */
+		i2c_smbus_write_byte_data(ts->client,
+		                          LCD_KIT_D02_CMD_INT_MASK,
+		                          LCD_KIT_D02_INTSTA_SPK_NOSEND);
+
+		/* Initialize information of touch pannel. */
+		for (i = 0; i < MAX_FINGER_POS_COUNT; i++) {
+			ts->touch_info.pos[i].valid = 0;
+
+			ts->touch_info.last_pos[i].x = 0x0FFF;
+			ts->touch_info.last_pos[i].y = 0x0FFF;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * lcdkitd02_ts_close() - LCD-KIT-D02 touch panel driver close.
+ *
+ * LCD-KIT-D02 touchscreen (input device) close system call.
+ * Kernel holds this driver on building, so this driver never closed.
+ *
+ */
+static void lcdkitd02_ts_close(struct input_dev *input_dev)
+{
+	/* DO NOTHING */
+}
+
+/**
+ * lcdkitd02_read() - LCD-KIT-D02 driver read.
+ * @work: Work structure
+ *
+ * Read event status register of touch screen, and if
+ * latch finger event, system call lcdkitd02_touchscreen_task() and
+ * get each finger point. And get status of switches
+ * on LCD-KIT-D02.
+ *
+ */
+static void lcdkitd02_read(struct work_struct *work)
+{
+	struct lcdkitd02 *ts;
+	u32 ret = 0;
+
+	ts = container_of(to_delayed_work(work), struct lcdkitd02, work);
+
+	/* Get LCD-KIT-D02 controller interrupt status */
+	ret = i2c_smbus_read_byte_data(ts->client, 0x01);
+
+#if USE_MOUSE
+	if ((ts->status & STATUS_SW1) != (ret & STATUS_SW1))
+		input_report_key(ts->input, BTN_LEFT, ret & STATUS_SW1);
+	if ((ts->status & STATUS_SW2) != (ret & STATUS_SW2))
+		input_report_key(ts->input, BTN_MIDDLE, ret & STATUS_SW2);
+	if ((ts->status & STATUS_SW3) != (ret & STATUS_SW3))
+		input_report_key(ts->input, BTN_RIGHT, ret & STATUS_SW3);
+#else
+	if ((ts->status & STATUS_SW1) != (ret & STATUS_SW1))
+		input_report_key(ts->input, KEY_MENU, ret & STATUS_SW1);
+	if ((ts->status & STATUS_SW2) != (ret & STATUS_SW2))
+		input_report_key(ts->input, KEY_HOME, ret & STATUS_SW2);
+	if ((ts->status & STATUS_SW3) != (ret & STATUS_SW3))
+		input_report_key(ts->input, KEY_ESC, ret & STATUS_SW3);
+#endif
+	input_sync(ts->input);
+
+	if (ret > 0) {
+		ts->status &= ~(STATUS_SW1 | STATUS_SW2 | STATUS_SW3);
+		ts->status |= (unsigned long)(ret & (STATUS_SW1 | STATUS_SW2 | STATUS_SW3));
+		schedule_delayed_work(&ts->work, msecs_to_jiffies(READ_MSECS));
+	} else {
+		ts->status &= ~(STATUS_SW1 | STATUS_SW2 | STATUS_SW3);
+	}
+
+	/* Touch Screen check */
+	schedule_delayed_work(&ts->check_pen_work, 0);
+}
+
+/**
+ * lcdkitd02_irq() - Touch screen interrupt
+ * @irq: 
+ * @handle:
+ */
+static irqreturn_t lcdkitd02_irq(int irq, void *handle)
+{
+	struct lcdkitd02 *ts = handle;
+
+	schedule_delayed_work(&ts->work, 0);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * lcdkitd02_poll_irq() - LCD-KIT-D02 driver irq polling
+ * @arg:
+ */
+static void lcdkitd02_poll_irq(unsigned long arg)
+{
+	struct lcdkitd02 *ts = (struct lcdkitd02 *)arg;
+	struct lcdkitd02_platform_data *pdata = ts->pdata;
+	int pin_state = pdata->get_irq_pin_state();
+
+	/* Wake up display. */
+
+	if (ts->irq_pin_state == -1)
+		ts->irq_pin_state = pin_state;
+	else if (ts->irq_pin_state != pin_state) {
+		ts->irq_pin_state = pin_state;
+		schedule_delayed_work(&ts->work, 0);
+	}
+
+	mod_timer(&ts->timer, jiffies + pdata->poll_period);
+}
+
+/**
+ * lcdkitd02_led_set() - Set brightness of LCD-KIT-D02 backlight LED
+ * @led_cdev: LED class
+ * @value: LED brightness
+ *
+ * This function sets LED backlight brightness of Display.
+ *
+ */
+static void lcdkitd02_led_set(struct led_classdev *led_cdev,
+                              enum led_brightness value)
+{
+	struct lcdkitd02 *ts;
+
+	ts = container_of(led_cdev, struct lcdkitd02, led);
+
+	value = value * 100 / 255;
+	i2c_smbus_write_byte_data(ts->client, 0x03, value);	
+
+	ts->led_value = value;
+}
+
+void lcdkitd02_led_on(void)
+{
+	struct lcdkitd02 *ts;
+
+	if (g_sleepled_cdev == NULL) {
+		printk("lcdkitd02_led_on() error\n");
+		return;
+	}
+
+	ts = container_of(g_sleepled_cdev, struct lcdkitd02, led);
+
+	i2c_smbus_write_byte_data(ts->client, 0x03, ts->led_value);	
+}
+
+void lcdkitd02_led_off(void)
+{
+	struct lcdkitd02 *ts;
+
+	if (g_sleepled_cdev == NULL) {
+		printk("lcdkitd02_led_off() error\n");
+		return;
+	}
+
+	ts = container_of(g_sleepled_cdev, struct lcdkitd02, led);
+
+	i2c_smbus_write_byte_data(ts->client, 0x03, 0);	
+}
+
+/* LED class devices struction */
+static struct led_classdev lcdkitd02_led = {
+	.name		= "lcdkitd02_backlight",
+	.brightness_set	= lcdkitd02_led_set,
+};
+
+
+/* Buzzer B01/C01 Buzzer emuration */
+
+
+short int GetNextBuzzData( struct lcdkitd02_beeper *pb )
+{
+	--(pb->DownCounter);
+	if( pb->DownCounter == 0 ) {
+		pb->DownCounter = pb->HalfPeriod;
+		pb->Value = ( pb->Value != pb->Vol ) ? pb->Vol : -pb->Vol;
+	}
+	return pb->Value;
+}
+
+unsigned char GetNextADPCMData( struct lcdkitd02_beeper *pb )
+{
+	short rawval;
+	int   diff, delta, newdelta, lastrawval, laststepsizepos;
+	int   lastb0_b2, newb0_b2;
+	int   b3;
+	int   stepsize;
+	unsigned char retval;
+
+	rawval = GetNextBuzzData( pb );
+	lastrawval = pb->RawValue;
+	diff = rawval - lastrawval;
+	if( diff < 0 ) {
+		b3 = 0x08;
+		delta = -diff;
+	} else {
+		b3 = 0x00;
+		delta = diff;
+	}
+	laststepsizepos = pb->StepSizePos;
+	pb->StepSizePos = pb->StepSizePos + stepmoveTable[ pb->B0_B2 ];
+	if( pb->StepSizePos < 0 ) pb->StepSizePos = 0;
+	if( pb->StepSizePos > 87 ) pb->StepSizePos = 87;
+	stepsize = stepsizeTable[ pb->StepSizePos ];
+	lastb0_b2 = pb->B0_B2;
+	newb0_b2 = ( delta * 8 / stepsize - 1 ) / 2;
+	pb->B0_B2 = ( newb0_b2 > 0x07) ? 0x07 : newb0_b2;
+	retval = b3 | pb->B0_B2;
+	newdelta = stepsize * (pb->B0_B2 * 2 + 1 ) / 8;
+	if( b3 == 0x00) {
+		pb->RawValue = pb->RawValue + newdelta;
+		if( pb->RawValue > 32767 ) // 0x7fff
+			pb->RawValue = 32767;
+	} else {
+		pb->RawValue = pb->RawValue - newdelta;
+		if( pb->RawValue < -32768 ) // 0x8000
+			pb->RawValue = -32768;
+	}
+
+	return retval;
+}
+
+static void lcdkitd02_buzzer_task(struct work_struct *work)
+{
+	struct lcdkitd02 *ts = container_of(to_delayed_work(work), struct lcdkitd02, buzzer_work);
+	struct lcdkitd02_beeper  *beeper = &ts->beeper;
+	int err = 0;
+
+	if (beeper->info.status & SPKF_STA_RESET) {
+		err = i2c_smbus_read_byte_data(ts->client, LCD_KIT_D02_CMD_INT_STATUS);
+		if ((err >= 0) && (!(err & STATUS_SPK))) {
+			/* Reset */
+			err = lcdkitd02_speaker_terminate(ts->client);
+			if (!err) {
+				beeper->info.status &= ~(SPKF_STA_RESET | SPKF_STA_PLAY | SPKF_STA_PLAYING);
+			}
+		} else {
+			schedule_delayed_work(&ts->buzzer_work, msecs_to_jiffies(20));
+			return;
+		}
+	}
+
+	if ((beeper->info.status & (SPKF_STA_PLAY | SPKF_STA_PAUSE)) == SPKF_STA_PLAY) {
+		/* Playing.. */
+		err = i2c_smbus_read_byte_data(ts->client, LCD_KIT_D02_CMD_INT_STATUS);
+		if ((err >= 0) && (!(err & STATUS_SPK))) {
+			schedule_delayed_work(&ts->buzzer_work, msecs_to_jiffies(10));
+			lcdkitd02_speaker_send_packet(ts->client, beeper );
+		} else {
+			schedule_delayed_work(&ts->buzzer_work, msecs_to_jiffies(5));
+		}
+		beeper->info.status |= SPKF_STA_PLAYING;
+	}
+
+	/* Complete */
+	if( beeper->info.data_size <= beeper->info.send_size ) {
+		beeper->info.status &= ~(SPKF_STA_PLAY | SPKF_STA_PLAYING);
+		beeper->info.status |= SPKF_STA_COMPLETE;
+		bs_mode = bsmIdling;
+	}
+
+	/* Delay */
+	if ( (beeper->info.status & SPKF_STA_PLAYING) == 0 ) {
+		cancel_delayed_work( &ts->buzzer_work );
+	}
+}
+
+
+static ssize_t lcdkitd02_buzzer_read(struct file *filp, char __user *buf,
+                                     size_t count, loff_t *pos)
+{
+	return -EINVAL;
+}
+
+static void change_freq( struct lcdkitd02 *ts, int freq_no )
+{
+	struct lcdkitd02_beeper  *beeper = &ts->beeper;
+
+	beeper->HalfPeriod = sample_ref_table[ freq_no ] / 2; //SAMPLERATE / freq / 2;
+}
+
+static ssize_t start_buzzer( struct lcdkitd02 *ts, int freq_no )
+{
+	struct lcdkitd02_beeper  *beeper = &ts->beeper;
+	ssize_t retval = 0;
+
+	if( (freq_no <= 0) || (255 < freq_no) ) {
+		freq_no = 16;
+	}
+	beeper->RawValue = 0; //32bit
+	beeper->HalfPeriod = sample_ref_table[ freq_no ] / 2; //SAMPLERATE / freq / 2;
+	beeper->DownCounter = beeper->HalfPeriod;
+	beeper->Value = beeper->Vol;
+	beeper->StepSizePos = 0;
+	beeper->B0_B2 = 0;
+
+	beeper->info.status = 0;
+	beeper->info.data_size = SAMPLERATE * BEEP_PERIOD / 2;
+	beeper->info.send_size = 0;
+
+	dbg( "Vol=%d", beeper->Vol );
+	dbg( "%s(%p, FreqNo=%d, SamplesOfHalfPeriod=%ld )", __func__, ts, freq_no, beeper->HalfPeriod  );
+
+	ts->beeper.info.status &= ~(SPKF_STA_PLAY | SPKF_STA_PAUSE);
+	ts->beeper.info.status |= SPKF_STA_PLAY;
+	bs_mode = bsmBuzzer;
+	schedule_delayed_work(&ts->buzzer_work, msecs_to_jiffies(0));
+	retval = 1;
+
+	return retval;
+}
+
+
+static ssize_t lcdkitd02_buzzer_write(struct file *filp,
+                                      const char __user *buf,
+                                      size_t count, loff_t *pos)
+{
+	struct lcdkitd02 *ts = container_of(filp->private_data, struct lcdkitd02, buzzer);
+	u8 data = 0;
+	ssize_t retval = 1;
+	dbg( "%s(%p, %p, %d, %p", __func__, filp, buf, count, pos );
+
+	if( ! get_user(data, buf) ) {
+		dbg( "data=%X", data );
+		if( data == 0 ) { // buzzer stop
+			dbg( "Stop buzzer" );
+			lcdkitd02_speaker_reset(ts);
+			schedule_delayed_work(&ts->buzzer_work, 0);
+			bs_mode = bsmIdling;
+		} else {
+			if( (0 < data) && (data <=0x3f) ) {
+				dbg( "Start buzzer" );
+				if( bs_mode != bsmIdling ) {
+					change_freq( ts, data );
+					retval = 1;
+				} else {
+					retval = start_buzzer( ts, data );
+				}
+			} else {
+				retval = -EINVAL;
+			}
+		}
+	} else {
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+static int lcdkitd02_set_buzzer_vol(int vol, struct lcdkitd02 *ts)
+{
+	struct lcdkitd02_beeper *beeper = &ts->beeper;
+	int retval = 0;
+
+	if( 0 <= vol && vol < 32768 ) {
+		beeper->Vol = vol;
+	} else {
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+
+static struct file_operations lcdkitd02_buzzer_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.read = lcdkitd02_buzzer_read,
+	.write = lcdkitd02_buzzer_write,
+	.open = nonseekable_open,
+	.unlocked_ioctl = lcdkitd02_buzzer_ioctl,
+};
+
+static struct miscdevice lcdkitd02_buzzer_device = {
+	MISC_DYNAMIC_MINOR,
+	"lcdkitd02_buzzer",
+	&lcdkitd02_buzzer_fops,
+};
+
+/**
+ * lcdkitd02_buzzer_ioctl() - LCD-KIT-D02 speaker driver IOCTL system call
+ * @inode: Node
+ * @filp: File pointer
+ * @cmd: IOCTL command
+ * @arg: Argument
+ *
+ * LCD-KIT-D02 buzzer iocontrol system call.
+ *
+ */
+static long lcdkitd02_buzzer_ioctl(struct file *filp,
+                                   unsigned int cmd,
+                                   unsigned long arg)
+{
+	long err = 0;
+	struct lcdkitd02 *ts =
+		container_of(filp->private_data, struct lcdkitd02, buzzer);
+	unsigned char *temp;
+
+	if (_IOC_DIR(cmd) & _IOC_WRITE) {
+		if (!access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd))) {
+			printk("  accessable error.\n");
+			err = -EFAULT;
+		}
+	} else if (_IOC_DIR(cmd) & _IOC_READ) {
+		if (!access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd))) {
+			printk("  accessable error.\n");
+			err = -EFAULT;
+		}
+	}
+
+	if (err == 0) {
+		temp = (unsigned char *)kzalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+		if (!temp) {
+			printk("  kzalloc() failed.\n");
+			err = -EFAULT;
+		}
+	}
+
+	if (err == 0) {
+		switch (cmd) {
+			case LCD_KIT_D02_CMD_BUZZER_VOL:
+				if (!copy_from_user(temp, (int *)arg, _IOC_SIZE(cmd))) {
+					err = lcdkitd02_set_buzzer_vol((*((int *)temp)), ts);
+				} else {
+					err = -EFAULT;
+				}
+				break;
+			default:
+				printk("%s: cmd: 0x%08X is not supported.\n", __func__, _IOC_NR(cmd));
+				err = -ENOTTY;
+				break;
+		}
+	} else {
+		printk("  %s: %d: param error.\n", __func__, _IOC_NR(cmd));
+	}
+
+	if (temp) {
+		kfree(temp);
+	}
+
+	return err;
+}
+
+/**
+ * lcdkitd02_speaker_reset() - Reset speaker file sending
+ * @*ts: LCD-KIT-D02 driver information structure pointer
+ *
+ * Set reset flag on player.
+ *
+ */
+static int lcdkitd02_speaker_reset(struct lcdkitd02 *ts)
+{
+	struct lcdkitd02_beeper *beeper = &ts->beeper;
+
+	beeper->info.status |= SPKF_STA_RESET;
+
+	return 0;
+}
+
+/**
+ * lcdkitd02_speaker_send_packet() - Send packet data to LCD-KIT-D02 speaker
+ * @*client: I2C client pointer to LCD-KIT-D02 controller
+ * @*player: Player information pointer
+ *
+ * Send packet data to LCD-KIT-D02 controller(= speaker).
+ *
+ */
+static int lcdkitd02_speaker_send_packet(struct i2c_client *client,
+                                         struct lcdkitd02_beeper *beeper)
+{
+	int err = 0;
+	unsigned long i;
+	unsigned long len = 0;
+	unsigned long size = 0;
+	unsigned char pack_buf[LCD_KIT_D02_SPEAKER_MAX_SIZE];
+	unsigned char *pack_data = NULL;
+	unsigned char val1, val2;
+
+	len = beeper->info.data_size - beeper->info.send_size;
+	if ((len >= LCD_KIT_D02_SPEAKER_DATA_MAX) ||
+	    (len >= (beeper->info.data_size - beeper->info.send_size))) {
+
+		if (len > LCD_KIT_D02_SPEAKER_DATA_MAX) {
+			len = LCD_KIT_D02_SPEAKER_DATA_MAX;
+		}
+
+		/* Make packet header */
+		pack_buf[0] = 0x06;
+		if (!beeper->info.send_size) {
+			/* First packet */
+			pack_buf[1] = 0x01;
+			pack_buf[2] = (unsigned char)((beeper->info.data_size >> 24) & 0x000000FF);
+			pack_buf[3] = (unsigned char)((beeper->info.data_size >> 16) & 0x000000FF);
+			pack_buf[4] = (unsigned char)((beeper->info.data_size >>  8) & 0x000000FF);
+			pack_buf[5] = (unsigned char)((beeper->info.data_size >>  0) & 0x000000FF);
+			pack_buf[6] = len;
+			pack_data   = &pack_buf[7];
+			size = len + 7;
+		} else {
+			/* Secondary packet */
+			pack_buf[1] = 0x02;
+			pack_buf[2] = len;
+			pack_data   = &pack_buf[3];
+			size = len + 3;
+		}
+
+		/* Set data */
+		for (i = 0; i < len; i++) {
+			val1 = GetNextADPCMData( beeper );
+			val2 = GetNextADPCMData( beeper );
+			pack_data[i] = (val1 << 4) + val2;
+		}
+
+		err = i2c_master_send(client, pack_buf, size);
+		if (err == size) {
+			/* I2C success */
+			beeper->info.send_size += len;
+			err = len;
+		} else {
+			printk("  %s: I2C error.\n", __func__);
+		}
+	}
+
+	return err;
+}
+
+/**
+ * lcdkitd02_speaker_terminate() - Terminate speaker output
+ * @client: I2C client pointer to LCD-KIT-D02 controller
+ *
+ * Send terminate command packet to LCD-KIT-D02 controller(= speaker).
+ *
+ */
+static int lcdkitd02_speaker_terminate(struct i2c_client *client)
+{
+	unsigned char buf[4];
+	int err = 0;
+
+	buf[0] = 0x06;
+	buf[1] = 0x03;	/* Termination */
+	buf[2] = 0x00;	/* Reserved */
+	buf[3] = 0x00;	/* Reserved */
+
+	if (i2c_master_send(client, buf, 4) >= 0) {
+		err = 0;
+	} else {
+		err = -1;
+	}
+
+	return err;
+}
+
+/**
+ * lcdkitd02_probe() - LCD-KIT-D02 driver probe.
+ * @client: I2C client pointer(for LCD-KIT-D02 controller)
+ * @id: I2C device id
+ *
+ * I2C driver probe system call.
+ *
+ */
+static int lcdkitd02_probe(struct i2c_client *client,
+                           const struct i2c_device_id *id)
+{
+	struct lcdkitd02_platform_data *pdata = client->dev.platform_data;
+	struct lcdkitd02 *ts;
+	struct input_dev *input_dev;
+	int err = 0;
+#ifdef  CONFIG_USE_OF
+	struct device_node *np;
+#endif
+
+	printk("LCD-KIT-D02 TouchPanel Driver.\n");
+
+	/* Check I2C functions. */
+	if (!i2c_check_functionality(client->adapter,
+	                             I2C_FUNC_SMBUS_READ_WORD_DATA  |
+	                             I2C_FUNC_SMBUS_WRITE_WORD_DATA |
+	                             I2C_FUNC_SMBUS_READ_BYTE_DATA  |
+	                             I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {
+		printk("%s i2c_check_functionality failed\n", __func__);
+		return -EIO;
+	}
+
+
+	/* Allocate memory for LCD-KIT-D02 */
+	ts = kzalloc(sizeof(struct lcdkitd02), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!ts || !input_dev) {
+		printk("%s kzalloc failed\n", __func__);
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	ts->client = client;
+
+#ifdef  CONFIG_USE_OF
+	np = of_find_node_by_path("/i2c@e6540000/lcdkitd02@0x42");
+	if (np) {
+		ts->irq = irq_of_parse_and_map(np, 0);
+	} else {
+		ts->irq = 0;
+		dev_err(&client->dev, "irq_of_parse_and_map failed\n" ); 
+	}	 
+#else
+	ts->irq = client->irq;
+#endif
+
+	ts->pdata = pdata;
+	ts->input = input_dev;
+
+	INIT_DELAYED_WORK(&ts->work, lcdkitd02_read);
+
+	ts->tp_client = i2c_new_device(client->adapter, &tp_i2c_info);
+	if (!ts->tp_client) {
+		printk("%s: tp_client create failed.\n", __func__);
+	}
+
+	/* Initialize LCD-KIT-D02 touch panel device. */
+	input_dev->name = "LCD-KIT-D02";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->open = lcdkitd02_touchscreen_open;
+	input_dev->close = lcdkitd02_ts_close;
+	INIT_DELAYED_WORK(&ts->check_pen_work, lcdkitd02_touchscreen_check_pen);
+
+	/* Initialize Buzzer device */
+	INIT_DELAYED_WORK(&ts->buzzer_work, lcdkitd02_buzzer_task);
+
+	/* Initialize IRQ. */
+	if (ts->irq != NO_IRQ) {
+		err = request_irq(ts->irq, lcdkitd02_irq,
+				  IRQF_TRIGGER_FALLING,
+				  input_dev->name, ts);
+		if (err) {
+			pr_warning("lcdkitd02 irq request fail %d\n", err);
+			err = -EIO;
+			goto err_free_gpio;
+		}
+	} else {
+		ts->irq_pin_state = -1;
+		init_timer(&ts->timer);
+		ts->timer.expires = jiffies + ts->pdata->poll_period;
+		setup_timer(&ts->timer, lcdkitd02_poll_irq, (unsigned long)ts);
+		add_timer(&ts->timer);
+	}
+
+	/* Register device. */
+	input_set_abs_params(input_dev, ABS_X,
+	                     0, LCD_KIT_D02_DISPLAY_WIDTH,
+	                     0, 0);
+	input_set_abs_params(input_dev, ABS_Y,
+	                     0, LCD_KIT_D02_DISPLAY_HEIGHT,
+	                     0, 0);
+#ifdef MULTI_TOUCH_ENABLE
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
+	                     0, LCD_KIT_D02_DISPLAY_WIDTH,
+	                     0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X,
+	                     0, LCD_KIT_D02_DISPLAY_WIDTH,
+	                     0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y,
+	                     0, LCD_KIT_D02_DISPLAY_HEIGHT,
+	                     0, 0);
+#endif
+#if USE_MOUSE
+	input_set_capability(input_dev, EV_KEY, BTN_LEFT);
+	input_set_capability(input_dev, EV_KEY, BTN_RIGHT);
+	input_set_capability(input_dev, EV_KEY, BTN_MIDDLE);
+#else
+	input_set_capability(input_dev, EV_KEY, KEY_MENU);
+	input_set_capability(input_dev, EV_KEY, KEY_HOME);
+	input_set_capability(input_dev, EV_KEY, KEY_ESC);
+#endif
+	input_set_capability(input_dev, EV_KEY, BTN_TOUCH);
+
+	input_set_drvdata(input_dev, ts);	
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_free_irq;
+
+	/* Register backlight led. */
+	ts->led = lcdkitd02_led;
+	led_classdev_register(&client->dev, &ts->led);
+
+	ts->led_value = 255;
+	g_sleepled_cdev = &ts->led;
+
+	bs_mode = bsmIdling;
+	lcdkitd02_buzzer_device.parent = &input_dev->dev;
+	ts->buzzer = lcdkitd02_buzzer_device;
+	ts->beeper.Vol = BUZZER_VOL;
+	misc_register(&ts->buzzer);
+
+	/* Backlight ON */
+	lcdkitd02_led_set(&ts->led, 255);
+
+	return err;
+
+	/* Error code. */
+err_free_irq:
+	free_irq(ts->irq, ts);
+
+err_free_gpio:
+
+err_free_mem:
+	input_free_device(input_dev);
+	kfree(ts);
+
+	return err;
+}
+
+/**
+ * lcdkitd02_remove() - LCD-KIT-D02 driver remove
+ * @client: I2C client pointer
+ *
+ * LCD-KIT-D02 driver remove system call.
+ *
+ */
+static int lcdkitd02_remove(struct i2c_client *client)
+{
+	struct lcdkitd02 *ts = i2c_get_clientdata(client);
+
+	led_classdev_unregister(&ts->led);
+
+	if (ts->irq != NO_IRQ)
+		free_irq(ts->irq, ts);
+	else
+		del_timer_sync(&ts->timer);
+
+	input_unregister_device(ts->input);
+	kfree(ts);
+
+	return 0;
+}
+
+
+/**
+ * lcdkitd02_touchscreen_get_info() - Get finger point
+ * @info: touch point structure pointer
+ * @ts: LCD-KIT-D02 infomation structure pointer
+ *
+ * Get finger point with *info setting(reg_no, point_bit).
+ *
+ */
+
+inline int set_touch_point_one( unsigned char* p,
+                                struct touch_point_info *info,
+                                int n )
+{
+	int retval, x, y;
+
+	if( *p & 0x80 ) {
+		x = ((*p & 0x70) << 4) + *(p+1);
+		y = ((*p & 0x07) << 8) + *(p+2);
+		if( (0 <= x) && (x < LCD_KIT_D02_DISPLAY_WIDTH) &&
+		    (0 <= y) && (y < LCD_KIT_D02_DISPLAY_HEIGHT) ) {
+			retval = 1;
+			info->pos[n].valid = 1;
+			info->pos[n].x = x;
+			info->pos[n].y = y;
+		} else {
+			retval = -1;
+			info->pos[n].valid = 0;
+		}
+	} else {
+		retval = 0;
+		info->pos[n].valid = 0;
+	}
+	return retval;
+}
+
+/**
+ * lcdkitd02_touchscreen_get_info() - Get finger point
+ * @info: touch point structure pointer
+ * @ts: LCD-KIT-D02 infomation structure pointer
+ *
+ * Get finger point with *info setting(reg_no, point_bit).
+ *
+ */
+static int lcdkitd02_touchscreen_get_info( struct lcdkitd02 *ts)
+{
+	int  retval = 0, res;
+	unsigned char rx_buf[ 2 + MAX_FINGER_POS_COUNT*4 ];
+	struct touch_point_info *info = &ts->touch_info;
+
+	res = i2c_smbus_read_i2c_block_data(ts->tp_client,
+	                                    TP_CONTROL_REG,
+	                                    sizeof(rx_buf),
+	                                    rx_buf);
+	if( res == sizeof(rx_buf) ) {
+		switch( set_touch_point_one( &(rx_buf[2+4*0]), info, 0 ) ) {
+			case  0 : break;
+			case  1 : if( 0 <= retval ) retval++; break;
+			case -1 : retval = -1; break;
+		}
+		switch( set_touch_point_one( &(rx_buf[2+4*1]), info, 1 ) ) {
+			case  0 : break;
+			case  1 : if( 0 <= retval ) retval++; break;
+			case -1 : retval = -1; break;
+		}
+		switch( set_touch_point_one( &(rx_buf[2+4*2]), info, 2 ) ) {
+			case  0 : break;
+			case  1 : if( 0 <= retval ) retval++; break;
+			case -1 : retval = -1; break;
+		}
+		switch( set_touch_point_one( &(rx_buf[2+4*3]), info, 3 ) ) {
+			case  0 : break;
+			case  1 : if( 0 <= retval ) retval++; break;
+			case -1 : retval = -1; break;
+		}
+		switch( set_touch_point_one( &(rx_buf[2+4*4]), info, 4 ) ) {
+			case  0 : break;
+			case  1 : if( 0 <= retval ) retval++; break;
+			case -1 : retval = -1; break;
+		}
+	} else {
+		printk("%s: %d: i2c_smbus_read_i2c_block_data() error: %d", __func__, __LINE__, res);
+		retval = -1;
+	}
+
+	return retval;
+}
+
+
+/**
+ * lcdkitd02_init() - LCD-KIT-D02 initialize
+ *
+ * LCD-KIT-D02 driver init system call.
+ *
+ */
+static int __init lcdkitd02_init(void)
+{
+	printk("%s: %d\n", __func__, __LINE__);
+	return i2c_add_driver(&lcdkitd02_driver);
+}
+
+/**
+ * lcdkitd02_exit() - LCD-KIT-D02 exit
+ *
+ * LCD-KIT-D02 driver exit system call.
+ *
+ */
+static void __exit lcdkitd02_exit(void)
+{
+	printk("%s: %d\n", __func__, __LINE__);
+	i2c_del_driver(&lcdkitd02_driver);
+}
+
+/* Module macros */
+module_init(lcdkitd02_init);
+module_exit(lcdkitd02_exit);
+
+/* Module infomation */
+MODULE_AUTHOR("Alpha Project Co., LTD");
+MODULE_DESCRIPTION("LCD-KIT-D02 TouchScreen Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/media/i2c/soc_camera/Kconfig b/drivers/media/i2c/soc_camera/Kconfig
index 23d352f..d5d794b 100644
--- a/drivers/media/i2c/soc_camera/Kconfig
+++ b/drivers/media/i2c/soc_camera/Kconfig
@@ -85,3 +85,10 @@ config SOC_CAMERA_TW9910
 	depends on SOC_CAMERA && I2C
 	help
 	  This is a tw9910 video driver
+
+config SOC_CAMERA_VSCAM01
+	tristate "VS-CAM-01 support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a VS-CAM-01 camera driver
+
diff --git a/drivers/media/i2c/soc_camera/Makefile b/drivers/media/i2c/soc_camera/Makefile
index 58e4eea..8c3d72f 100644
--- a/drivers/media/i2c/soc_camera/Makefile
+++ b/drivers/media/i2c/soc_camera/Makefile
@@ -12,3 +12,5 @@ obj-$(CONFIG_SOC_CAMERA_OV9640)		+= ov9640.o
 obj-$(CONFIG_SOC_CAMERA_OV9740)		+= ov9740.o
 obj-$(CONFIG_SOC_CAMERA_RJ54N1)		+= rj54n1cb0c.o
 obj-$(CONFIG_SOC_CAMERA_TW9910)		+= tw9910.o
+obj-$(CONFIG_SOC_CAMERA_VSCAM01)	+= vscam01.o
+
diff --git a/drivers/media/i2c/soc_camera/vscam01.c b/drivers/media/i2c/soc_camera/vscam01.c
new file mode 100755
index 0000000..45f3aaa
--- /dev/null
+++ b/drivers/media/i2c/soc_camera/vscam01.c
@@ -0,0 +1,860 @@
+/*
+ * vscam01 Camera Driver
+ *
+ * Created by AlphaProject Co.,Ltd.
+ * Based on mt9t112 driver,
+ *
+ * Copyright (C) 2009 Renesas Solutions Corp.
+ *   Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ * Copyright (C) 2008 Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ * Copyright (C) 2008, Robert Jarzmik <robert.jarzmik@free.fr>
+ * Copyright 2006-7 Jonathan Corbet <corbet@lwn.net>
+ * Copyright (C) 2008 Magnus Damm
+ * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG 1
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/videodev2.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/platform_data/camera-rcar.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <media/vscam01.h>
+#include <media/soc_camera.h>
+#include <media/v4l2-clk.h>
+//#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-image-sizes.h>
+
+// RZG0aではUYVYしかサポートしてないが、rcar_vinの内部定義がYUYVになっているため
+// 暫定的にそれに合わせる
+#undef  MEDIA_BUS_FMT_UYVY8_2X8
+#define MEDIA_BUS_FMT_UYVY8_2X8 MEDIA_BUS_FMT_YUYV8_2X8
+
+/***********************************************************************
+     from arch/arm/mach-shmobile/irqs.h
+************************************************************************/
+/* GIC */
+#define gic_spi(nr)		((nr) + 32)
+#define gic_iid(nr)		(nr) /* ICCIAR / interrupt ID */
+
+/************************************************************************
+			macro
+************************************************************************/
+// ステータス
+#define VSCAM_REG_STATUS		0x00
+// 出力モード設定
+#define VSCAM_REG_OUTPUT_MODE		0x01
+// 画面出力サイズ設定
+#define VSCAM_REG_OUTPUT_SIZE		0x02
+// オートホワイトバランス設定
+#define VSCAM_REG_AUTO_WHITE_BALANCE	0x03
+// ホワイトバランス設定値
+#define VSCAM_REG_WHITE_BALANCE		0x04
+// クロック設定
+#define VSCAM_REG_CLOCK			0x05
+// 出力方向設定
+#define VSCAM_REG_OUTPUT_DIR		0x06
+// YUV出力設定
+#define VSCAM_REG_YUV_MODE		0x07
+// テストパターン出力
+#define VSCAM_REG_TEST_PATTERN		0xA0
+// ソフトウェアリセット
+#define VSCAM_REG_SOFTWARE_RESET	0xF0
+// ファームウェアバージョン
+#define VSCAM_REG_FIRMWARE_VERSION	0xF1
+
+// 出力モード設定ビット
+#define VSCAM_REG_MASK_C_EN		0x20
+#define VSCAM_REG_MASK_SCALE		0x10
+// 画面出力サイズ設定ビット
+#define VSCAM_REG_600X480		0x06
+
+/*
+ * frame size
+ */
+#define MAX_WIDTH   640
+#define MAX_HEIGHT  480
+
+#define VGA_WIDTH   640
+#define VGA_HEIGHT  480
+
+/*
+ * Logical address
+ */
+#define _VAR(id, offset, base)	(base | (id & 0x1f) << 10 | (offset & 0x3ff))
+#define VAR(id, offset)  _VAR(id, offset, 0x0000)
+#define VAR8(id, offset) _VAR(id, offset, 0x8000)
+
+
+/************************************************************************
+			struct
+************************************************************************/
+struct vscam01_format {
+	__u32 code;
+	enum v4l2_colorspace colorspace;
+	u16 fmt;
+	u16 order;
+};
+
+struct vscam01_size_info {
+	char           *name;
+	unsigned short  width;
+	unsigned short  height;
+};
+
+struct vscam01_priv {
+	struct v4l2_subdev subdev;
+	struct v4l2_clk	*clk;
+	struct v4l2_ctrl_handler hdl;
+	struct vscam01_camera_info *info;
+	const struct vscam01_size_info *frmsize;
+	struct i2c_client *client;
+	//struct v4l2_rect frame;
+	//v4l2_std_id	norm;
+	const struct vscam01_format *format;
+	int model;
+	int num_formats;
+	u32 flags;
+/* for flags */
+#define INIT_DONE	(1 << 0)
+#define PCLK_RISING	(1 << 1)
+};
+
+/************************************************************************
+			supported format
+************************************************************************/
+
+static const struct vscam01_format vscam01_cfmts[] = {
+	{
+		.code		= MEDIA_BUS_FMT_UYVY8_2X8, // V4L2_MBUS_FMT_YUYV8_2X8,
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+		.fmt		= 1,
+		.order		= 0,
+	},
+};
+
+/*
+176×144 に設定    : 0000 
+320×240 に設定    : 0001 
+352×288 に設定    : 0010 
+360×272 に設定    : 0011 
+480×272 に設定    : 0100 
+544×408 に設定    : 0101 
+640×480 に設定    : 0110
+*/
+
+static const struct vscam01_size_info vscam01_sizes[] = {
+	{
+		.name   = "VGA",
+		.width  = VGA_WIDTH,
+		.height = VGA_HEIGHT,
+	},
+	{
+		.name   = "544x408",
+		.width  = 544,
+		.height = 408,
+	},
+	{
+		.name   = "480x272",
+		.width  = 480,
+		.height = 272,
+	},
+	{
+		.name   = "360x272",
+		.width  = 360,
+		.height = 272,
+	},
+	{
+		.name   = "CIF",
+		.width  = CIF_WIDTH,
+		.height = CIF_HEIGHT,
+	},
+	{
+		.name   = "QVGA",
+		.width  = QVGA_WIDTH,
+		.height = QVGA_HEIGHT,
+	},
+	{
+		.name   = "QCIF",
+		.width  = QCIF_WIDTH,
+		.height = QCIF_HEIGHT,
+	},
+};
+
+
+/************************************************************************
+			general function
+************************************************************************/
+static struct vscam01_priv *to_vscam01(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client),
+			    struct vscam01_priv,
+			    subdev);
+}
+
+static int vscam01_reg_read(const struct i2c_client *client,
+                            u8 command, u8 data[4], u8 len)
+{
+	struct i2c_msg msg[2];
+	int ret;
+
+	msg[0].addr  = client->addr;
+	msg[0].flags = 0;
+	msg[0].len   = 1;
+	msg[0].buf   = &command;
+
+	msg[1].addr  = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len   = len;
+	msg[1].buf   = data;
+
+	/*
+	 * if return value of this function is < 0,
+	 * it mean error.
+	 * else, under 16bit is valid data.
+	 */
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0)
+		return ret;
+	
+	return ret;
+}
+
+static int vscam01_reg_write(const struct i2c_client *client,
+                             u8 command, u8 data[4], u8 len)
+{
+	struct i2c_msg msg;
+	u8 buf[4 + 1];
+	int ret;
+
+	memcpy(buf + 0, &command, 1);
+	memcpy(buf + 1, data, len);
+
+	msg.addr  = client->addr;
+	msg.flags = 0;
+	msg.len   = len + 1;
+	msg.buf   = buf;
+
+	/*
+	 * i2c_transfer return message length,
+	 * but this function should return 0 if correct case
+	 */
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret;
+}
+
+static int vscam01_set_a_frame_size(const struct i2c_client *client,
+				   u16 width,
+				   u16 height)
+{
+	u8 mdata[1], sdata[1];
+	int i, n, ret = 0;
+
+	for( i =0; i < ARRAY_SIZE(vscam01_sizes); i++ ) {
+		if( (vscam01_sizes[i].width == width) && (vscam01_sizes[i].height == height) )
+			break;
+	}
+	n = ARRAY_SIZE(vscam01_sizes) - i -1;
+	if( 0 < n ) {
+		ret = vscam01_reg_read(client, VSCAM_REG_OUTPUT_MODE, mdata, 1);
+		if(ret < 0){
+			printk("%s: Get State Error\n", __func__);
+			goto done;
+		}
+		ret = vscam01_reg_read(client, VSCAM_REG_OUTPUT_SIZE, sdata, 1);
+		if(ret < 0){
+			printk("%s: Get Output size Error\n", __func__);
+			goto done;
+		}
+		switch( mdata[0] % 3) {
+			case 0 :
+				break;
+			case 1 :
+				sdata[0] &= ~VSCAM_REG_MASK_SCALE;
+				break;
+			case 2 :
+				sdata[0] |= VSCAM_REG_MASK_C_EN;
+				break;
+			case 3 :
+				break;
+		}
+		sdata[0] = (sdata[0] & 0xf0) | n;
+		ret = vscam01_reg_write(client, VSCAM_REG_OUTPUT_SIZE, sdata, 1);
+		if(ret < 0){
+			printk("%s: Set Output size Error\n", __func__);
+			goto done;
+		}
+	}
+	
+done: 
+	return ret;
+}
+
+
+
+/************************************************************************
+			v4l2_subdev_core_ops
+************************************************************************/
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int vscam01_g_register(struct v4l2_subdev *sd,
+			      struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int                ret;
+
+	reg->size = 2;
+	vscam01_reg_read(ret, client, reg->reg);
+
+	reg->val = (__u64)ret;
+
+	return 0;
+}
+
+static int vscam01_s_register(struct v4l2_subdev *sd,
+			      const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	vscam01_reg_write(ret, client, reg->reg, reg->val);
+
+	return 0;
+}
+#endif
+
+static int vscam01_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+	struct vscam01_priv *priv = to_vscam01(client);
+
+	return soc_camera_set_power(&client->dev, ssdd, priv->clk, on);
+}
+
+static struct v4l2_subdev_core_ops vscam01_subdev_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= vscam01_g_register,
+	.s_register	= vscam01_s_register,
+#endif
+	.s_power	= vscam01_s_power,
+};
+
+
+
+static const struct vscam01_size_info *vscam01_select_size( u32 width, u32 height)
+{
+	const struct vscam01_size_info *sinfo;
+	const struct vscam01_size_info *ret = NULL;
+	__u32 diff = 0xffffffff, tmp;
+	int size, i;
+
+	sinfo = vscam01_sizes;
+	size = ARRAY_SIZE(vscam01_sizes);
+
+	for (i = 0; i < size; i++) {
+		tmp = abs(width - sinfo[i].width) +
+			abs(height - sinfo[i].height);
+		if (tmp < diff) {
+			diff = tmp;
+			ret = sinfo + i;
+		}
+	}
+	return ret;
+}
+
+/************************************************************************
+			v4l2_subdev_video_ops
+************************************************************************/
+static int vscam01_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct vscam01_priv *priv = to_vscam01(client);
+	int ret = 0;
+
+	if (!enable) {
+		/* FIXME
+		 *
+		 * If user selected large output size,
+		 * and used it long time,
+		 * vscam01 camera will be very warm.
+		 *
+		 * But current driver can not stop vscam01 camera.
+		 * So, set small size here to solve this problem.
+		 */
+		vscam01_set_a_frame_size(client, VGA_WIDTH, VGA_HEIGHT);
+		return ret;
+	}
+
+	if (!(priv->flags & INIT_DONE)) {
+		priv->flags |= INIT_DONE;
+	}
+
+
+	vscam01_set_a_frame_size(client,
+				 priv->frmsize->width,
+				 priv->frmsize->height);
+
+	dev_dbg(&client->dev, "format : %d\n", priv->format->code);
+	dev_dbg(&client->dev, "size   : %d x %d\n",
+		priv->frmsize->width,
+		priv->frmsize->height);
+
+	return ret;
+}
+
+static int vscam01_set_params(struct vscam01_priv *priv,
+			      const struct v4l2_rect *rect,
+			      __u32 code)
+{
+	int i;
+	const struct vscam01_size_info *sinfo; 
+
+	/*
+	 * get color format
+	 */
+	for (i = 0; i < priv->num_formats; i++)
+		if (vscam01_cfmts[i].code == code)
+			break;
+
+	if (i == priv->num_formats)
+		return -EINVAL;
+
+	sinfo = vscam01_select_size( rect->width, rect->height);
+
+	priv->format = vscam01_cfmts + i;
+
+	return 0;
+}
+
+static int vscam01_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)
+{
+	a->bounds.left		= 0;
+	a->bounds.top		= 0;
+	a->bounds.width		= MAX_WIDTH;
+	a->bounds.height	= MAX_HEIGHT;
+	a->defrect.left		= 0;
+	a->defrect.top		= 0;
+	a->defrect.width	= VGA_WIDTH;
+	a->defrect.height	= VGA_HEIGHT;
+	a->type				= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	a->pixelaspect.numerator	= 1;
+	a->pixelaspect.denominator	= 1;
+
+	return 0;
+}
+
+static int vscam01_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct vscam01_priv *priv = to_vscam01(client);
+
+	a->c.width	= priv->frmsize->width;
+	a->c.height	= priv->frmsize->height;
+	a->c.left	= 0;
+	a->c.top	= 0;
+	a->type	= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	return 0;
+}
+
+static int vscam01_s_crop(struct v4l2_subdev *sd, const struct v4l2_crop *a)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct vscam01_priv *priv = to_vscam01(client);
+	const struct v4l2_rect *rect = &a->c;
+
+	return vscam01_set_params(priv, rect, priv->format->code);
+}
+
+static int vscam01_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct vscam01_priv *priv = to_vscam01(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	if (!priv->frmsize) {
+		priv->frmsize = vscam01_select_size(VGA_WIDTH, VGA_HEIGHT);
+		if (!priv->frmsize)
+			return -EINVAL;
+	}
+
+	mf->width	= priv->frmsize->width;
+	mf->height	= priv->frmsize->height;
+	mf->code	= MEDIA_BUS_FMT_UYVY8_2X8;
+	mf->colorspace	= V4L2_COLORSPACE_JPEG;
+	mf->field	= V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int vscam01_s_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_mbus_framefmt *mf)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct vscam01_priv *priv = to_vscam01(client);
+	struct v4l2_rect rect = {
+		.width = mf->width,
+		.height = mf->height,
+		.left = 0,
+		.top = 0,
+	};
+	int ret;
+
+	ret = vscam01_set_params(priv, &rect, mf->code);
+
+	if (!ret)
+		mf->colorspace = priv->format->colorspace;
+
+	return ret;
+}
+
+static int vscam01_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	const struct vscam01_size_info *sinfo;
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->code = MEDIA_BUS_FMT_UYVY8_2X8;
+	mf->colorspace = V4L2_COLORSPACE_JPEG;
+
+	/*
+	 * select suitable size
+	 */
+	sinfo = vscam01_select_size(mf->width, mf->height);
+	if (!sinfo)
+		return -EINVAL;
+
+	mf->width	= sinfo->width;
+	mf->height	= sinfo->height;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		return vscam01_s_fmt(sd, mf);
+	cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int vscam01_enum_mbus_code(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_UYVY8_2X8;
+	return 0;
+}
+
+
+static int vscam01_g_mbus_config(struct v4l2_subdev *sd,
+				 struct v4l2_mbus_config *cfg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+
+	cfg->flags = V4L2_MBUS_MASTER | V4L2_MBUS_VSYNC_ACTIVE_HIGH |
+		V4L2_MBUS_HSYNC_ACTIVE_LOW | V4L2_MBUS_DATA_ACTIVE_HIGH |
+		V4L2_MBUS_PCLK_SAMPLE_RISING;
+	cfg->type = V4L2_MBUS_PARALLEL;
+	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
+
+	return 0;
+}
+
+static int vscam01_s_mbus_config(struct v4l2_subdev *sd,
+				 const struct v4l2_mbus_config *cfg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+	struct vscam01_priv *priv = to_vscam01(client);
+
+	if (soc_camera_apply_board_flags(ssdd, cfg) & V4L2_MBUS_PCLK_SAMPLE_RISING)
+		priv->flags |= PCLK_RISING;
+
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops vscam01_subdev_video_ops = {
+	.s_stream	= vscam01_s_stream,
+	.cropcap	= vscam01_cropcap,
+	.g_crop		= vscam01_g_crop,
+	.s_crop		= vscam01_s_crop,
+	.g_mbus_config	= vscam01_g_mbus_config,
+	.s_mbus_config	= vscam01_s_mbus_config,
+};
+
+
+static const struct v4l2_subdev_pad_ops vscam01_subdev_pad_ops = {
+	.enum_mbus_code = vscam01_enum_mbus_code,
+	.get_fmt	= vscam01_get_fmt,
+	.set_fmt	= vscam01_set_fmt,
+};
+
+
+/************************************************************************
+			i2c driver
+************************************************************************/
+static int gpio_pwdn = 0, gpio_reset = 0, gpio_xclk =0;
+
+
+static struct v4l2_subdev_ops vscam01_subdev_ops = {
+	.core	= &vscam01_subdev_core_ops,
+	.video	= &vscam01_subdev_video_ops,
+	.pad	= &vscam01_subdev_pad_ops,
+};
+
+
+static int vscam01_camera_probe(struct i2c_client *client)
+{
+	struct vscam01_priv *priv = to_vscam01(client);
+	int ret;
+	int res = 0;
+	u8 data[4];
+	int count;
+
+	ret = vscam01_s_power(&priv->subdev, 1);
+	if (ret < 0)
+		return -1;
+
+	/* Get Version */
+	res = -1;
+	for(count = 0; count < 5; count++) {
+		
+		ret = vscam01_reg_read(client, VSCAM_REG_FIRMWARE_VERSION, data, 1);
+		if(ret >= 0){
+			res = 0;
+			break;
+		}
+		mdelay(10);
+	}
+
+	if(res < 0) {
+		printk("%s: Get Version Error\n", __func__);
+		goto done;
+	}
+
+	printk("VS-CAM-01 : Ver%d.%d\n", (data[0] & 0xF0) >> 4,
+	                                 (data[0] & 0x0F));
+
+	/* Set UYVY */
+	data[0] = 0x00;
+	ret = vscam01_reg_write(client, VSCAM_REG_YUV_MODE, data, 1);
+	if(ret < 0) {
+		printk("%s: Set UYVY Error\n", __func__);
+		res = -1;
+		goto done;
+	}
+
+	do {
+		mdelay(10);
+
+		ret = vscam01_reg_read(client, VSCAM_REG_STATUS, data, 1);
+		if(ret < 0){
+			printk("%s: Get State Error\n", __func__);
+			res = -1;
+			goto done;
+		}
+	}while(data[0] != 0x00);
+
+	priv->model = V4L2_IDENT_VSCAM01;
+	priv->num_formats = ARRAY_SIZE(vscam01_cfmts);
+
+	//priv->norm = V4L2_STD_NTSC;
+	priv->frmsize = &vscam01_sizes[0];
+
+
+done:
+	vscam01_s_power(&priv->subdev, 0);
+	return res;
+}
+
+
+static int vscam01_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+	struct vscam01_priv *priv;
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
+	struct device_node *np;
+	struct v4l2_rect rect = {
+		.width = VGA_WIDTH,
+		.height = VGA_HEIGHT,
+		.left = (MAX_WIDTH - VGA_WIDTH) / 2,
+		.top = (MAX_HEIGHT - VGA_HEIGHT) / 2,
+	};	int ret;
+
+	if (client->dev.of_node) {
+		ssdd = devm_kzalloc(&client->dev, sizeof(*ssdd), GFP_KERNEL);
+		if (!ssdd)
+			return -ENOMEM;
+		client->dev.platform_data = ssdd;
+		np = client->dev.of_node;
+		gpio_pwdn  = of_get_named_gpio(np, "gpio_vscam_pwdn",  0);
+		gpio_reset = of_get_named_gpio(np, "gpio_vscam_reset", 0);
+		gpio_xclk  = of_get_named_gpio(np, "gpio_vscam_xclk",  0);
+
+		if( 0 < gpio_pwdn ) {
+			if( gpio_request( gpio_pwdn, "VSCAM01 PowerDown" ) == 0) {
+				gpio_direction_output( gpio_pwdn, 1 );
+				gpio_export( gpio_pwdn, false );
+				gpio_set_value(gpio_pwdn,  0);
+				printk( "%s: gpio_pwdn(  3, 30)=%d\n", __func__, gpio_pwdn );
+			} else {
+				// Already registerd at first probe
+			}
+		}
+
+		if( 0 < gpio_reset ) {
+			if( gpio_request( gpio_reset, "VSCAM01 Reset") == 0 ) {
+				gpio_direction_output( gpio_reset, 1 );
+				gpio_export( gpio_reset, false );
+				gpio_set_value(gpio_reset, 0);
+				printk( "%s: gpio_reset( 3, 31)=%d\n", __func__, gpio_reset );
+			} else {
+				// Already registerd at first probe
+			}
+		}
+
+		if( 0 < gpio_xclk ) {
+			if( gpio_request( gpio_xclk, "VSCAM01 Xclk" ) == 0 ) {
+				gpio_direction_output( gpio_xclk, 0 );
+				gpio_export( gpio_xclk, false );
+				gpio_set_value(gpio_xclk,  1);
+				printk( "%s: gpio_xclk(  3, 29)=%d\n", __func__, gpio_xclk );
+				mdelay(10);
+			} else {
+				// Already registerd at first probe
+			}
+		}
+	}
+	if (!ssdd) {
+		dev_err(&client->dev, "vscam01: driver needs platform data\n");
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {
+		dev_warn(&adapter->dev,
+			 "I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");
+		return -EIO;
+	}
+
+	priv = devm_kzalloc(&client->dev, sizeof(struct vscam01_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->info = ssdd->drv_priv;
+
+	v4l2_i2c_subdev_init(&priv->subdev, client, &vscam01_subdev_ops);
+
+	priv->clk = v4l2_clk_get(&client->dev, "mclk");
+	if (IS_ERR(priv->clk))
+		return -EPROBE_DEFER;
+
+	priv->subdev.dev = &client->dev;
+	ret = v4l2_async_register_subdev(&priv->subdev);
+	if (ret < 0)
+		goto out_hdlfree;
+
+	ret = vscam01_camera_probe(client);
+	if (ret < 0)
+		 goto out_hdlfree;
+
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	if (priv->hdl.error) {
+		ret = priv->hdl.error;
+
+		v4l2_ctrl_handler_free(&priv->hdl);
+		goto out_hdlfree;
+	}
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+
+	/* Cannot fail: using the default supported pixel code */
+	vscam01_set_params(priv, &rect, MEDIA_BUS_FMT_YUYV8_2X8 );
+
+	return 0;
+
+out_hdlfree:
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_clk_put(priv->clk);
+
+	return ret;
+}
+
+
+static int vscam01_remove(struct i2c_client *client)
+{
+	struct vscam01_priv *priv = to_vscam01(client);
+
+	if( gpio_xclk )  gpio_free(gpio_xclk);
+	if( gpio_pwdn )  gpio_free(gpio_pwdn);
+	if( gpio_reset ) gpio_free(gpio_reset);
+	v4l2_clk_put(priv->clk);
+
+	return 0;
+}
+
+/* VIN */
+
+/*
+ * VS-CAM-01 camera info
+ */
+
+static const struct of_device_id vscam01_of_match[] = {
+	{ .compatible = "apj,vscam01", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mt9m111_of_match);
+
+
+static const struct i2c_device_id vscam01_id[] = {
+	{ "vscam01", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, vscam01_id);
+
+
+static struct i2c_driver vscam01_i2c_driver = {
+	.driver = {
+		.name = "vscam01",
+		.owner = THIS_MODULE,
+		.of_match_table	= of_match_ptr(vscam01_of_match),
+	},
+	.probe    = vscam01_probe,
+	.remove   = vscam01_remove,
+	.id_table = vscam01_id,
+};
+
+module_i2c_driver(vscam01_i2c_driver);
+
+MODULE_DESCRIPTION("SoC Camera driver for vscam01");
+MODULE_AUTHOR("");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/media/platform/soc_camera/rcar_vin.c b/drivers/media/platform/soc_camera/rcar_vin.c
index d5799ff..669ad23 100644
--- a/drivers/media/platform/soc_camera/rcar_vin.c
+++ b/drivers/media/platform/soc_camera/rcar_vin.c
@@ -1251,6 +1251,10 @@ static int rcar_vin_set_bus_param(struct soc_camera_device *icd)
 	if (priv->pdata_flags & VNDMR2_YDS)
 		val |= VNDMR2_YDS;
 
+#ifdef CONFIG_SOC_CAMERA_VSCAM01
+	val |= 0x00800000;
+#endif
+
 	iowrite32(val, priv->base + VNDMR2_REG);
 	/*fixme: hardcode
 	(val == 0x60021000) ? iowrite32(0x21000, priv->base + VNDMR2_REG) : iowrite32(val, priv->base + VNDMR2_REG);*/
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index ae8396b..e7698f0 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -2211,7 +2211,17 @@ static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,
 	struct mmc_blk_data *md;
 	int devidx, ret;
 
+#ifdef CONFIG_MACH_APRZG0A
+	/* AP-RZG-0A: SD/MMC: Fix for static slot numbering Micro SD(SD2) - 0, Micro SD(SD1) - 1 */
+	if ((!strcmp(mmc_hostname(card->host), "mmc1")) && !subname)
+		devidx = 1;
+	else if (!strcmp(mmc_hostname(card->host), "mmc0"))
+		devidx = 0;
+	else
+		devidx = find_next_zero_bit(dev_use, max_devices, 2); 
+#else
 	devidx = find_first_zero_bit(dev_use, max_devices);
+#endif
 	if (devidx >= max_devices)
 		return ERR_PTR(-ENOSPC);
 	__set_bit(devidx, dev_use);
@@ -2229,7 +2239,15 @@ static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,
 	 * index anymore so we keep track of a name index.
 	 */
 	if (!subname) {
+#ifdef CONFIG_MACH_APRZG0A
+		/* AP-RZG-0A: SD/MMC: Fix for static slot numbering Micro SD(SD2) - 0, Micro SD(SD1) - 1 */
+		if (!strcmp(mmc_hostname(card->host), "mmc1"))
+			md->name_idx = 1;
+		else if (!strcmp(mmc_hostname(card->host), "mmc0"))
+			md->name_idx = 0; 
+#else
 		md->name_idx = find_first_zero_bit(name_use, max_devices);
+#endif
 		__set_bit(md->name_idx, name_use);
 	} else
 		md->name_idx = ((struct mmc_blk_data *)
diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index f9f9422..e06f5b1 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -285,5 +285,6 @@ source "drivers/net/wireless/zd1211rw/Kconfig"
 source "drivers/net/wireless/mwifiex/Kconfig"
 source "drivers/net/wireless/cw1200/Kconfig"
 source "drivers/net/wireless/rsi/Kconfig"
+source "drivers/net/wireless/wmrp0xs/Kconfig"
 
 endif # WLAN
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index 740fdd3..2699d90 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -60,3 +60,5 @@ obj-$(CONFIG_BRCMSMAC)	+= brcm80211/
 
 obj-$(CONFIG_CW1200)	+= cw1200/
 obj-$(CONFIG_RSI_91X)	+= rsi/
+obj-$(CONFIG_WMRP0X_SPI) += wmrp0xs/
+
diff --git a/drivers/net/wireless/wmrp0xs/Kconfig b/drivers/net/wireless/wmrp0xs/Kconfig
new file mode 100644
index 0000000..ed61224
--- /dev/null
+++ b/drivers/net/wireless/wmrp0xs/Kconfig
@@ -0,0 +1,10 @@
+config WMRP0X_SPI
+	bool "WM-RP-04S/05S"
+	depends on SPI
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	select CFG80211
+	help
+	  Redpine
+
+
diff --git a/drivers/net/wireless/wmrp0xs/Makefile b/drivers/net/wireless/wmrp0xs/Makefile
new file mode 100644
index 0000000..aa26b41
--- /dev/null
+++ b/drivers/net/wireless/wmrp0xs/Makefile
@@ -0,0 +1,4 @@
+
+obj-$(CONFIG_WMRP0X_SPI) += rs9110.o
+
+
diff --git a/drivers/net/wireless/wmrp0xs/rs9110.c b/drivers/net/wireless/wmrp0xs/rs9110.c
new file mode 100644
index 0000000..97bb519
--- /dev/null
+++ b/drivers/net/wireless/wmrp0xs/rs9110.c
@@ -0,0 +1,3494 @@
+//#define DEBUG 1
+
+#if !defined(CONFIG_WIRELESS_EXT)
+#define CONFIG_WIRELESS_EXT
+#endif
+
+#if !defined(CONFIG_WEXT_PRIV)
+#define CONFIG_WEXT_PRIV
+#endif
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/ieee80211.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/semaphore.h>
+#include <linux/sched.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <net/iw_handler.h>
+#include <net/cfg80211.h>
+
+#ifdef CONFIG_USE_OF
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include <linux/version.h>
+
+#include "rs9110.h"
+
+#define DEBUG	0
+
+//#define USE_TIMER 1
+#define USE_TIMER 0
+
+#define ZEROFILL 1
+
+#define RSI_FRAME_DESC_LEN 16
+#define DEBUG_SPI_RW		0
+//#define DEBUG_SPI_RW		0
+#define DEBUG_DATA_SEND		0
+#define DEBUG_DATA_RECV		0
+#define DEBUG_DESC		0
+#define DEBUG_C1C2		0
+#define DEBUG_START_TOKEN	0
+#define DEBUG_INTR		0
+#define DEBUG_BUS		0
+#define DEBUG_RS21		0
+#define DEBUG_TXRX		0
+#define DEBUG_SEM		0
+
+#define SND_MGMT_Q		1
+#define SND_DATA_Q		2
+#define SND_TA_MGMT_Q		4
+
+#define C1_INIT		0x00
+#define C1_RW		0x40
+#define C1_WRITE	0x20
+#define C1_BUS		0x10
+#define C1_SLAVE	0x08
+#define C1_16BIT_LENGTH	0x04
+#define C1_2BIT_MASK	0x03
+#define C2_32BIT	0x40
+#define C2_32BIT_GRAN	0x40
+#define C2_MISC_MASK	0x3f
+
+#define TA_SB_IM1_BASE_ADDR 0x00000000
+#define TA_SB_IM2_BASE_ADDR 0x02014010
+#define TA_SB_DM_BASE_ADDR  0x20003100
+
+#define TA_IU_IM1_BASE_ADDR 0x00000000
+#define TA_IU_IM2_BASE_ADDR 0x02000000
+#define TA_IU_DM_BASE_ADDR  0x20003100
+
+#define IU_BASE_ADDR        0x02008000
+
+#define MGMT_INIT		0x10
+#define MGMT_SCAN		0x11
+#define MGMT_JOIN		0x12
+#define MGMT_UPGRADE_FF_TAIM1	0x13
+#define MGMT_UPGRADE_FF_TAIM2	0x14
+#define MGMT_UPGRADE_FF_TADM	0x15
+#define MGMT_MAC_ADDRESS	0x16
+#define MGMT_BAND		0x18
+#define MGMT_FW_VERSION		0x1a
+
+#define MGMT_CARD_READY		0x89
+#define MGMT_INIT_RESP		0x94
+#define MGMT_SCAN_RESP		0x95
+#define MGMT_JOIN_RESP		0x96
+#define MGMT_BAND_RESP		0x97
+#define MGMT_MAC_ADDRESS_RESP	0x9f
+#define MGMT_FW_VERSION_RESP	0x9d
+
+#define RCV_LMAC_MGMT_Q		1
+#define RCV_DATA_Q		2
+#define RCV_TA_MGMT_Q		4
+
+#define SND_MGMT_Q		1
+#define SND_DATA_Q		2
+#define SND_TA_MGMT_Q		4
+
+#define RSI_DESC_LEN		16
+#define FRAME_DESC_SZ		16
+#define FIRM_VER_LEN		20
+
+typedef struct {
+	u16 type;
+	u16 length;
+	void *data;
+	int address;
+} BusCmd;
+
+typedef struct _WiFi_CNFG_Band WiFi_CNFG_Band;
+typedef struct _WiFi_CNFG_ScanInfo WiFi_CNFG_ScanInfo;
+typedef struct _WiFi_CNFG_ScanRsp WiFi_CNFG_ScanRsp;
+typedef struct _WiFi_CNFG_Scan WiFi_CNFG_Scan;
+typedef struct _WiFi_CNFG_Join WiFi_CNFG_Join;
+
+typedef enum {
+	BAND_24,
+	BAND_5,
+} BandType;
+
+typedef enum _RPS_AUTH_TYPE {
+	RPS_AUTH_OPEN,
+	RPS_AUTH_WPA1,
+	RPS_AUTH_WPA2,
+	RPS_AUTH_WEP,
+} RPS_AUTH_TYPE;
+
+struct _WiFi_CNFG_Band {
+	u8 uBandVal;
+} __attribute__((packed));
+
+struct _WiFi_CNFG_ScanInfo {
+	u8 uChannelNumber;
+	u8 uSecMode;
+	u8 rssiVal;
+	u8 aSSID[32];
+} __attribute__((packed));
+
+struct _WiFi_CNFG_ScanRsp {
+	u32 uScanCount;
+	u32 dummy;
+	WiFi_CNFG_ScanInfo stScanInfo[32];
+} __attribute__((packed));
+
+struct _WiFi_CNFG_Scan {
+	u32 uChannelNo;
+	u8 uSSID[32];
+} __attribute__((packed));
+
+struct WiFi_CNFG_BssidInfo
+{
+	u8 uChannelNumber;
+	u8 uSecMode;
+	u8 rssiVal;
+	u8 aSSID[32];
+	u8 uNetworkType;
+	u8 BSSID[6];
+} __attribute__((packed));
+
+struct WiFi_CNFG_BssidRsp
+{
+	u32 uScanCount;
+	u32 uErrorcode;
+	struct WiFi_CNFG_BssidInfo stBssidInfo[32];
+} __attribute__((packed));
+
+struct _WiFi_CNFG_Join {
+	u8 uNwType;
+	u8 uSecType;
+	u8 uDataRate;
+	u8 uPowerLevel;
+	u8 uPSK[32];
+	u8 uSSID[32];
+	u8 uIbss_mode;
+	u8 uChannel;
+	u8 uAction;
+} __attribute__((packed));
+
+typedef struct {
+	u16 desc[8];
+	union {
+		WiFi_CNFG_Band band;
+		WiFi_CNFG_Scan scan;
+		WiFi_CNFG_Join join;
+	} t;
+} MacFrame;
+
+#define RSI_SPI_SUCCESS			0x58
+#define RSI_SPI_BUSY			0x54
+#define RSI_SPI_FAIL			0x52
+#define RSI_SPI_START_TOKEN		0x55
+
+/*==============================================*/
+// Mode Value Defines
+// Band Defines
+#define RSI_BAND_2P5GHZ			0x00 // u8
+#define RSI_BAND_5GHZ			0x01 // u8
+
+// SECURITY Type Defines
+#define RSI_SECURITY_NONE		0
+// Security type NONE and OPEN are alises for each other
+#define RSI_SECURITY_OPEN		0
+#define RSI_SECURITY_WPA1		1
+#define RSI_SECURITY_WPA2		2
+#define RSI_SECURITY_WEP		3
+
+// NETWORK Type
+#define RSI_IBSS_OPEN_MODE		0
+#define RSI_INFRASTRUCTURE_MODE		1
+#define RSI_IBSS_SEC_MODE		2
+#define RSI_IBSS_JOINER			0
+#define RSI_IBSS_CREATOR		1
+
+// Power Mode Constants
+#define RSI_POWER_MODE_0	0x0000
+#define RSI_POWER_MODE_1	0x0001
+#define RSI_POWER_MODE_2	0x0002
+
+//Tx Power level
+#define RSI_POWER_LEVEL_LOW	0x0000
+#define RSI_POWER_LEVEL_MEDIUM	0x0001
+#define RSI_POWER_LEVEL_HIGH	0x0002
+
+// DATA Rates
+#define RSI_DATA_RATE_AUTO	0
+#define RSI_DATA_RATE_1		1
+#define RSI_DATA_RATE_2		2
+#define RSI_DATA_RATE_5P5	3
+#define RSI_DATA_RATE_11	4
+#define RSI_DATA_RATE_6		5
+#define RSI_DATA_RATE_9		6
+#define RSI_DATA_RATE_12	7
+
+#define RSI_MACADDRLEN		6
+#define RSI_DFRAMECMDLEN	4
+
+#define RSI_SPISSWIFI		0
+#define RSI_SPISSFLASH		1
+
+#define RSI_MODE_8BIT		0
+#define RSI_MODE_32BIT		1
+
+#define SPI_INITIALIZATION	1
+#define SPI_INTERNAL_READ	2
+#define SPI_INTERNAL_WRITE	3
+#define AHB_MASTER_READ		4
+#define AHB_MASTER_WRITE	5
+#define AHB_SLAVE_READ		6
+#define AHB_SLAVE_WRITE		7
+#define SPI_DUMMY_WRITE		8
+
+#define RS21_BUFFER_FULL	0x01
+#define RS21_BUFFER_FREE 	0x02
+#define RS21_DATA_PENDING	0x08
+
+#define RS21_BUFFER_LEN (1 << 8)
+
+#define RSI_MAX_PAYLOAD_SIZE	1500
+#define RSI_AP_SCANNED_MAX	15
+#define RSI_FRAME_CMD_RSP_LEN	56
+
+#define RSI_LOAD_SBDATA2_FROM_HOST	1
+#define RSI_63BYTE_PSK_SUPPORT		0
+#define RSI_MODULE_23_24		0
+#define RSI_LITTLE_ENDIAN		1
+
+#if RSI_63BYTE_PSK_SUPPORT
+#define RSI_PSK_LEN		63 // maximum length of PSK
+#else
+#define RSI_PSK_LEN		32 // maximum length of PSK
+#endif
+#define RSI_PSK_64_BYTE_LEN	64
+#define RSI_SSID_LEN		32	     // maximum length of SSID
+#define RSI_IP_ADD_LEN                          4
+#define RSI_MAC_ADD_LEN                         6
+#define RSI_MGMT_PKT_TYPE                       0x04
+#define RSI_DATA_PKT_TYPE                       0x02 
+
+typedef struct {
+	u8 current_mode;
+	u8 ack_pwsave;
+} rsi_powerstate;
+
+typedef struct {
+	u32 channel;
+	u8 ssid[RSI_SSID_LEN];
+} rsi_scanFrame;
+
+typedef struct {
+	u8 nwType;
+	u8 securityType;
+	u8 dataRate;
+	u8 powerLevel;
+	u8 psk[RSI_PSK_LEN]; 
+	u8 ssid[RSI_SSID_LEN];
+	u8 ibssMode;
+	u8 ibssChannel;
+#if RSI_63BYTE_PSK_SUPPORT
+	u8 padding[3];
+#else
+	u8 padding[2];
+#endif
+} rsi_joinFrame;
+
+typedef struct {
+	u8 rspCode[2];
+	u8 macAddress[6];
+	u8 errorCode[4];
+} rsi_qryMacAddress;
+
+typedef struct {
+	u8 rfChannel;
+	u8 securityMode; 
+	u8 rssiVal;
+	u8 ssid[RSI_SSID_LEN];
+} rsi_scanInfo;
+
+typedef struct {
+	u32 scanCount;
+	u32 _Reserved;
+	rsi_scanInfo strScanInfo[RSI_AP_SCANNED_MAX];
+	u8 status;
+} rsi_scanResponse;
+
+typedef struct {
+	u8 rfChannel;
+	u8 securityMode;
+	u8 rssiVal;
+	u8 ssid[RSI_SSID_LEN];
+	u8 uNetworkType;
+	u8 BSSID[6];
+} rsi_bssid_nwtypeInfo;
+
+typedef struct {
+	u32 scanCount;
+	u32 errorCode;
+	rsi_bssid_nwtypeInfo strBssid_NwtypeInfo[RSI_AP_SCANNED_MAX];
+	u8 status;
+} rsi_bssid_nwtypeFrame;
+
+typedef union {
+	u8 rspCode[2];
+	u8 buf[RSI_FRAME_CMD_RSP_LEN + RSI_MAX_PAYLOAD_SIZE];
+} rsi_uCmdRsp;
+
+#define RS9110SIWSECMODE SIOCIWFIRSTPRIV
+#define RS9110GIWSECMODE (RS9110SIWSECMODE + 1)
+
+#define RS9110_KEY_NUM 4
+struct rs21_priv {
+	struct net_device_stats stats;
+	struct spi_device *spi;
+	struct net_device *ndev;
+	spinlock_t lock;
+	spinlock_t tx_skb_lock;
+	spinlock_t irq_lock;
+	struct timer_list timer;
+	struct work_struct work;
+	struct delayed_work assoc_work;
+	struct work_struct tx_work;
+	struct semaphore spi_sem;
+	struct sk_buff *skbs[RS21_BUFFER_LEN];
+	u32 skb_rp, skb_wp;
+	wait_queue_head_t buffer_wq;
+	int spi_async;
+	rsi_powerstate pwstate;
+	struct rs9110_platform_data *pdata;
+	int buffer_full;
+	int security_mode;
+	int wpa_level;
+	int exclude_unencrypted;
+	int auth_alg;
+
+	/* wireless */
+	struct iw_statistics iwstats;
+	u32 mode;
+	int channel;
+	int txpower;
+	int bitrate;
+	u8 essid[IW_ESSID_MAX_SIZE];
+	u8 bssid[ETH_ALEN];
+	int essid_len;
+	//u8 key[32];
+	int key_len;
+	bool encode_enabled;
+	u8 keys[RS9110_KEY_NUM][IW_ENCODING_TOKEN_MAX];
+	unsigned long key_enabled;
+	unsigned int key_lens[RS9110_KEY_NUM];
+	unsigned int current_key;
+	u8 psk[IW_ENCODING_TOKEN_MAX];
+	int psk_len;
+	u16 init_sw;
+	u16 join_sw;
+	u16 scan_sw;
+	struct semaphore init_sem;
+	struct semaphore qmac_sem;
+	struct semaphore scan_sem;
+	struct semaphore join_sem;
+	struct semaphore test_sem;
+	struct completion init_comp;
+	struct completion scan_comp;
+	struct completion join_comp;
+	struct completion qmac_comp;
+	struct completion *tx_comp;
+	struct completion buff_comp;
+	struct sk_buff *tx_skb;
+	u8 *tx_data;
+	int tx_len;
+	wait_queue_head_t init_waitq;
+	wait_queue_head_t scan_waitq;
+	wait_queue_head_t join_waitq;
+	union {
+		rsi_scanResponse *scanResponse;
+		rsi_bssid_nwtypeFrame *bssid_nwtypeFrame;
+	};
+	u8 *fwversion;
+	u8 *mac;
+	u16 *rssi;
+	bool scanned;
+	bool joined;
+
+	rsi_scanResponse _scanResponse;
+	rsi_bssid_nwtypeFrame _bssid_nwtypeFrame;
+	u16 _scan_sw;
+
+	/* ieee80211 */
+	struct ieee80211_hw *hw;
+	int type;
+	int irq;
+	rsi_uCmdRsp uCmdRsp;
+
+	int gpio_reset;
+	int gpio_power;
+};
+
+#define RSI_TRUE	1
+#define RSI_FALSE	0
+
+#define RSI_POLLED	1
+
+#if DEBUG_RS21
+#define debug(...) pr_debug(__VA_ARGS__)
+#else
+#define debug(...) do {} while (0)
+#endif
+
+#define RSI_TICKS_PER_SECOND	HZ
+
+#define RSI_FWUPTIMEOUT         100 * RSI_TICKS_PER_SECOND
+/*@ bootloading timeout */
+#define RSI_BLTIMEOUT           1 * RSI_TICKS_PER_SECOND
+/*@ band timeout */
+#define RSI_BANDTIMEOUT         1 * RSI_TICKS_PER_SECOND
+/*@ Init timeout */
+#define RSI_INITTIMEOUT         1 * RSI_TICKS_PER_SECOND
+/*@ Query firmware version timeout */
+#define RSI_QFWVTIMEOUT         1 * RSI_TICKS_PER_SECOND
+/*@ Scan timeout */
+#define RSI_SCANTIMEOUT         12 * RSI_TICKS_PER_SECOND
+/*@ Join timeout */
+#define RSI_JOINTIMEOUT         12 * RSI_TICKS_PER_SECOND
+/*@ Disconnect timeout */
+#define RSI_DISCONTIMEOUT       1 * RSI_TICKS_PER_SECOND
+/*@ Query connection status timeout */
+#define RSI_QCSTIMEOUT          3 * RSI_TICKS_PER_SECOND
+/*@ powersave command timeout */
+#define RSI_PSTIMEOUT           3 * RSI_TICKS_PER_SECOND
+/*@ Query RSSI Value timeout */
+#define RSI_RSSITIMEOUT         1 * RSI_TICKS_PER_SECOND
+/*@ recv timeout */
+#define RSI_RECVTIMEOUT         1 * RSI_TICKS_PER_SECOND
+/*@ Regread timeout */
+#define RSI_REGREADTIMEOUT      1 * RSI_TICKS_PER_SECOND
+/*@ Start token timeout */
+#define RSI_START_TOKEN_TIMEOUT (10 * RSI_TICKS_PER_SECOND)
+/*@ Config Enable timeout */
+#define RSI_CETIMEOUT           1 * RSI_TICKS_PER_SECOND
+/*@ Config store timeout */
+#define RSI_CSTIMEOUT           1 * RSI_TICKS_PER_SECOND
+/*@ Config get timeout */
+#define RSI_CGTIMEOUT           1 * RSI_TICKS_PER_SECOND
+/*@ Query BSSID/NW TYPE timeout */
+#define RSI_QBSSIDNWTIMEOUT     6 * RSI_TICKS_PER_SECOND
+#define RSI_QMACADDTIMEOUT      6 * RSI_TICKS_PER_SECOND
+/*@ Query MAC ADDR timeout */
+#define RSI_WAKEUP_CMD_TIMEOUT  2 * RSI_TICKS_PER_SECOND
+/*@ WAKE UP command timeout */
+#define RSI_MODESEL_TIMEOUT     1 * RSI_TICKS_PER_SECOND
+/*@ MODE select Timeout */
+#define RSI_FEATSEL_TIMEOUT     1 * RSI_TICKS_PER_SECOND
+
+typedef u8 u8;
+typedef u16 uint16;
+typedef u32 uint32;
+typedef s8 int8;
+typedef s16 int16;
+typedef s32 int32;
+
+/*Management Commands */
+static const u8 rsi_frameCmdBand[] = {0x02, 0x18, 0x04, 0x00, 0x00};
+static const u8 rsi_frameCmdInit[] = {0x00, 0x10, 0x04, 0x00, 0x00};
+static const u8 rsi_frameCmdScan[] = {0x24, 0x11, 0x04, 0x00, 0x00};
+#if RSI_63BYTE_PSK_SUPPORT
+static const u8 rsi_frameCmdJoin[] = {0x68, 0x12, 0x04, 0x00, 0x00};
+#else
+static const u8 rsi_frameCmdJoin[] = {0x48, 0x12, 0x04, 0x00, 0x00};
+#endif
+static const u8 rsi_frameCmdPower[] = {0x02, 0x19, 0x04, 0x00, 0x00};
+static const u8 rsi_frameCmdFftaim1Upgd[] = {0x00, 0x13, 0x04, 0x00, 0x00};
+static const u8 rsi_frameCmdFftaim2Upgd[] = {0x00, 0x14, 0x04, 0x00, 0x00};
+static const u8 rsi_frameCmdFftadmUpgd[] = {0x00, 0x15, 0x04, 0x00, 0x00};
+static const u8 rsi_frameCmdBssidNwtype[] = {0x00, 0x23, 0x04, 0x44, 0x00};
+static const u8 rsi_frameCmdCfgEnable[]  = {0x02, 0x2A, 0x04, 0x00, 0x00};
+static const u8 rsi_frameCmdCfgSave[]  =  {0x00, 0x2B, 0x04, 0x00, 0x00};
+static const u8 rsi_frameCmdCfgGet[]  =  {0x00, 0x2C, 0x04, 0x00, 0x00};
+static const u8 rsi_frameCmdModeSel[] = {0x04, 0x2D, 0x04, 0x00, 0x00};
+const u8        rsi_frameCmdFeatSel[5] = {0x04, 0x24, 0x04, 0x00, 0x00};
+
+// Management Data Frames
+static const u8 rsi_dFrmBand[] = {0x18, 0x00};
+static const u8 rsi_dFrmInit[] = {0x10, 0x00};
+static const u8 rsi_dFrmPower[] = {0x00, 0x00};
+static const u8 rsi_dFrmCfgEnable[] = {0x2A, 0x00};
+static const u8 rsi_dFrmCfgSave[] = {0x2B, 0x00};
+
+/* Data-Control Commands */
+static const u8 rsi_frameCmdRssi[5] = {0x02, 0x00, 0x02, 0x44, 0x00};
+/* 4 bytes, 2 bytes command, 2 bytes padding */
+static const u8 rsi_frameCmdSend[5] = {0x00, 0x00, 0x02, 0x00, 0x00};
+static const u8 rsi_frameCmdRecv[5] = {0x00, 0x00, 0x02, 0x00, 0x00};
+static const u8 rsi_frameCmdConnStatus[5] = {0x02, 0x00, 0x02, 0x44, 0x00};
+static const u8 rsi_frameCmdDisconnect[5] = {0x02, 0x00, 0x02, 0x44, 0x00};
+static const u8 rsi_frameCmdQryFwVer[5] = {0x02, 0x00, 0x02, 0x44, 0x00};
+static const u8 rsi_frameCmdSetMacAddress[] = {0x08, 0x00, 0x02, 0x44, 0x00};
+static const u8 rsi_frameCmdQryMacAddress[] = {0x02, 0x00, 0x02, 0x44, 0x00};
+/* Data-Control Data Frames */
+/* These can be used as-is, or copied into bytes 0/1 of a larger data frame */
+static const u8 rsi_dFrmRssi[] = {0x05, 0x00};
+static const u8 rsi_dFrmConnStatus[] = {0x07, 0x00};
+static const u8 rsi_dFrmDisconnect[] = {0x08, 0x00};
+static const u8 rsi_dFrmQryFwVer[] = {0x0d, 0x00};
+static const u8 rsi_dFrmSetMacAddress[] = {0x0e, 0x00};
+static const u8 rsi_dFrmQryMacAddress[] = {0x0f, 0x00};
+/* Management Response list */
+const u8	rsi_mgmtRspList[] = {0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x64};	
+
+#define RSI_C1_INIT_CMD				0x15
+// sent to spi interface after reset/powerup to init the spi interface
+#define RSI_C1_INIT_RESP			0x55
+// response from spi interface to successful init
+#define RSI_C176_INIT				0b00111111 // and
+#define RSI_C176_RW				0b01000000 // or
+#define RSI_C15_RD				0b11011111 // and
+#define RSI_C15_WR				0b00100000 // or
+#define RSI_C14_SPISLV				0b11101111 // and
+#define RSI_C14_AHBBUS				0b00010000 // or
+#define RSI_C13_AHBMEM				0b11110111 // and
+#define RSI_C13_AHBFRM				0b00001000 // or
+#define RSI_C12_02BITXFR			0b11111011 // and
+#define RSI_C12_16BITXFR			0b00000100 // or
+#define RSI_C110_4BYTESLEN		        0b11111100
+// and	number of C bytes transferred, usually 4
+#define RSI_C110_1BYTESLEN			0b00000001
+// or/~and number of C bytes transferred
+#define RSI_C110_2BYTESLEN			0b00000010
+// or/~and number of C bytes transferred
+#define RSI_C110_3BYTESLEN			0b00000011
+// or number of C bytes transferred
+
+/*=========================================================*/
+// C2 Register Defines
+#define RSI_C276_08BIT				0b00111111 // and
+#define RSI_C276_32BIT				0b01000000 // or
+#define RSI_C250_SPIADDR			0b00111111 // and
+#define RSI_C250_DATAPACKET			0b00000010 // or
+#define RSI_C250_MGMTPACKET			0b00000100 // or
+
+/*==========================================================*/
+// C1 Register Defines
+// Internal Read
+#define RSI_C1INTREAD2BYTES			0x42
+// (((((0x00 & C176_INT) & C15_RD) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_2BYTESLEN	// 01000010
+#define RSI_C1INTREAD1BYTES			0x41
+#define RSI_C1INTWRITE1BYTES			0x61
+#define RSI_C1INTWRITE2BYTES			0x62
+
+// Memory ReadWrite (AHB Master Read/Write, Internal Legacy Name)
+// Memory read/write is normally done using 16-bit transfer length with 4 C bytes transferred
+#define RSI_C1MEMWR16BIT1BYTE			0x75
+// (((0x00 | C176_RW | C15_WR | C14_AHBBUS) & C13_AHBMEM) & C12_16BITXFR) | C110_1BYTESLEN // 01110101
+#define RSI_C1MEMRD16BIT1BYTE			0x55
+// (((0x00 | C176_RW & C15_RD | C14_AHBBUS) & C13_AHBMEM) & C12_16BITXFR) | C110_1BYTESLEN // 01010101
+
+#define RSI_C1MEMWR16BIT4BYTE			0x74
+// (((0x00 | C176_RW | C15_WR | C14_AHBBUS) & C13_AHBMEM) & C12_16BITXFR) & C110_4BYTESLEN // 01110100
+#define RSI_C1MEMRD16BIT4BYTE			0x54
+// ((((0x00 | C176_RW & C15_RD) | C14_AHBBUS) & C13_AHBMEM) & C12_16BITXFR) & C110_4BYTESLEN // 01010100
+
+// Normally, 2-bit transfer length is not used for memory read/write
+#define RSI_C1MEMWR02BIT1BYTE			0x71
+// (((0x00 | C176_RW | C15_WR | C14_AHBBUS) & C13_AHBMEM) & C12_02BITXFR) | C110_1BYTESLEN // 01110001
+#define RSI_C1MEMRD02BIT1BYTE			0x51
+// (((0x00 | C176_RW & C15_RD | C14_AHBBUS) & C13_AHBMEM) & C12_02BITXFR) | C110_1BYTESLEN // 01010001
+#define RSI_C1MEMWR02BIT4BYTE			0x70
+// (((0x00 | C176_RW | C15_WR | C14_AHBBUS) & C13_AHBMEM) & C12_02BITXFR) & C110_4BYTESLEN // 01110000
+#define RSI_C1MEMRD02BIT4BYTE			0x50
+// ((((0x00 | C176_RW & C15_RD) | C14_AHBBUS) & C13_AHBMEM) & C12_02BITXFR) & C110_4BYTESLEN // 01010000
+
+
+// Frame ReadWrite
+// Frame read/writes normally  use 16-bit transfer length
+#define RSI_C1FRMWR16BIT1BYTE			0x7d
+// ((C176_RW | C15_WR | C14_AHBBUS | C13_AHBFRM) & C12_16BITXFR) | C110_1BYTESLEN // 01111101
+#define RSI_C1FRMRD16BIT1BYTE			0x5d
+// ((C176_RW & C15_RD | C14_AHBBUS | C13_AHBFRM) & C12_16BITXFR) | C110_1BYTESLEN // 01011101
+
+#define RSI_C1FRMWR16BIT4BYTE			0x7c
+// ((C176_RW | C15_WR | C14_AHBBUS | C13_AHBFRM) & C12_16BITXFR) | C110_4BYTESLEN // 01111100
+#define RSI_C1FRMRD16BIT4BYTE			0x5c
+// ((C176_RW & C15_RD | C14_AHBBUS | C13_AHBFRM) & C12_16BITXFR) | C110_4BYTESLEN // 01011100
+
+// Frame read/writes normally do not use 2-bit transfer length
+#define RSI_C1FRMWR02BIT1BYTE			0x79
+// ((C176_RW | C15_WR | C14_AHBBUS | C13_AHBFRM) & C12_02BITXFR) | C110_1BYTESLEN // 01111001
+#define RSI_C1FRMRD02BIT1BYTE			0x59
+// ((C176_RW & C15_RD | C14_AHBBUS | C13_AHBFRM) & C12_02BITXFR) | C110_1BYTESLEN // 01011001
+
+#define RSI_C1FRMWR02BIT4BYTE			0x78
+// ((C176_RW | C15_WR | C14_AHBBUS | C13_AHBFRM) & C12_02BITXFR) | C110_4BYTESLEN // 01111000
+#define RSI_C1FRMRD02BIT4BYTE			0x58
+// ((C176_RW & C15_RD | C14_AHBBUS | C13_AHBFRM) & C12_02BITXFR) | C110_4BYTESLEN // 01011000
+
+// SPI Register ReadWrite
+#define RSI_C1SPIREGWR16BIT4BYTE		0x64
+// ((((C176_RW | C15_WR) & C14_SPISLV) & C13_AHBMEM) & C12_16BITXFR) | C110_4BYTESLEN // 01100100
+#define RSI_C1SPIREGRD16BIT4BYTE		0x44
+// ((((C176_RW & C15_RD) & C14_SPISLV) & C13_AHBMEM) & C12_16BITXFR) | C110_4BYTESLEN // 01000100
+
+#define RSI_C1SPIREGWR02BIT4BYTE		0x60
+// ((((C176_RW | C15_WR) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_4BYTESLEN // 01100000
+#define RSI_C1SPIREGRD02BIT4BYTE		0x40
+// ((((C176_RW & C15_RD) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_4BYTESLEN // 01000000
+
+#define RSI_C1SPIREGWR02BIT1BYTE		0x61
+// ((((C176_RW | C15_WR) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_1BYTESLEN // 01100001
+#define RSI_C1SPIREGRD02BIT1BYTE		0x41
+// ((((C176_RW & C15_RD) & C14_SPISLV) & C13_AHBMEM) & C12_02BITXFR) | C110_1BYTESLEN // 01000001
+
+
+
+// C2 Register Defines
+#define RSI_C2RDWR4BYTE				0x40	// 0x00 | C276_32BIT | C250_DATAPACKET
+							// 01000010
+#define RSI_C2RDWR4BYTE				0x40	// 0x00 | C276_32BIT | C250_MGMTPACKET
+							// 01000100
+
+#define RSI_C2RDWR1BYTE				0x00	// (0x00 & C276_08BIT) | C250_DATAPACKET
+							// 00000010
+#define RSI_C2RDWR1BYTE				0x00	// (0x00 & C276_08BIT) | C250_MGMTPACKET
+							// 00000100
+#define RSI_C2MGMT				0x04
+#define RSI_C2DATA				0x02
+#define RSI_C2WPS				0x08
+
+#define RSI_C2SPIADDR1BYTE			0x00	// (0x00 & C276_08BIT) | C250_SPIADDR
+							// 00xxxxxx
+#define RSI_C2MEMRDWRNOCARE			0x00	// 0x00 or ANYTHING
+							// 00000000
+#define RSI_C2SPIADDR4BYTE			0x40	// (0x00 | C276_32BIT) | C250_SPIADDR
+							// 01xxxxxx
+
+
+/*====================================================*/
+// Constant Defines
+// Sizes
+
+// SPI Status
+#define RSI_SUCCESS				0
+#define RSI_BUSY				-1
+#define RSI_FAIL				-2
+#define RSI_BUFFER_FULL				-3
+#define RSI_IN_SLEEP				-4
+
+
+// SPI Internal Register Offset
+#define RSI_SPI_INT_REG_ADDR			0x00	// register access method
+#define RSI_SPI_MODE_REG_ADDR			0x08	// register access method
+//#define RSI_SPI_INT_REG_ADDR			0x08000000	// memory access method
+//#define RSI_SPI_MODE_REG_ADDR			0x08000008	// memory access method
+
+
+// SPI Mode Register
+#define RSI_SPI_MODE_LOW			0x00
+#define RSI_SPI_MODE_HIGH			0x01
+
+// Power Mode Constants
+#define RSI_POWER_MODE_0			0x0000
+#define RSI_POWER_MODE_1			0x0001
+#define RSI_POWER_MODE_2			0x0002
+
+//Tx Power level
+#define RSI_POWER_LEVEL_LOW			0x0000
+#define RSI_POWER_LEVEL_MEDIUM			0x0001
+#define RSI_POWER_LEVEL_HIGH			0x0002
+
+// SPI Constants
+#define RSI_SPI_START_TOKEN			0x55	// SPI Start Token
+
+// Interrupt Defines
+#define RSI_INT_REG_ADDR			0x08000000
+#define RSI_INT_MSKCLR_REG_ADDR			0x22000000					
+// base address of the interrupt mask/clear register
+#define RSI_INT_MASK_REG_ADDR			0x22000008	// Interrupt mask register
+#define RSI_INT_CLR_REG_ADDR			0x22000010	// Interrupt clear register
+#define RSI_INT_MASK_OFFSET			0x08		// offset from base address of interrupt mask/clear register
+#define RSI_INT_CLR_OFFSET			0x10		// offset from base address of interrupt mask/clear register
+#define RSI_IMASK_PWR_ENABLE			0xf3		// mask power interrupt
+#define RSI_IMASK_PWR_DISABLE			0xd3		// clear power interrupt mask
+#define RSI_ICLEAR_PWR				0x20
+// bit5=1 to clear the interrupt, must use read-modify-write to preserver the other bits
+
+
+// Software Bootloader Addresses
+#define RSI_SBINST1_ADDR			0x00000000
+#define RSI_SBINST2_ADDR			0x02014010
+#define RSI_SBDATA1_ADDR			0x20003100
+#if RSI_MODULE_23_24
+#define RSI_SBDATA2_ADDR			0x0200F800
+#else
+#define RSI_SBDATA2_ADDR			0x02010000
+#endif
+
+// Image Upgrader Addresses
+#define RSI_IUINST1_ADDR			0x00000000
+#define RSI_IUINST2_ADDR			0x02000000
+#define RSI_IUDATA_ADDR				0x20003100
+
+#define RSI_FFTAIM1_ADDR			0x02008000
+#define RSI_FFTAIM2_ADDR			0x02008000
+#define RSI_FFTADM_ADDR				0x02008000
+
+
+// Soft Reset Defines
+#define RSI_RST_SOFT_ADDR			0x22000004
+#define RSI_RST_SOFT_SET			0x00000001
+#define RSI_RST_SOFT_CLR			0x00000000
+
+/*======================================================*/
+// Frame Defines
+// Management Frames (AHB Slave Read/Write)
+// Management Request Frame Codes (Type)
+#define	RSI_REQ_BAND			0x18
+#define RSI_REQ_INIT			0x10
+#define RSI_REQ_SCAN			0x11
+#define RSI_REQ_JOIN			0x12
+#define RSI_REQ_PWRMODE			0x19
+#define RSI_REQ_FFTAIM1_UPGD		0x13
+#define RSI_REQ_FFTAIM2_UPGD		0x14
+#define RSI_REQ_FFTADM_UPGD		0x15
+#define RSI_REQ_BSSID_NWTYPE		0x23
+#define RSI_REQ_CFG_ENABLE		0x2A
+#define RSI_REQ_CFG_SAVE		0x2B
+#define RSI_REQ_CFG_GET			0x2C
+#define RSI_REQ_MODE_SEL		0x2D
+#define RSI_REQ_FEAT_SEL		0x24
+
+// Management Response Frame Codes
+#define RSI_RSP_CARD_READY		0x89
+#define RSI_RSP_BAND			0x97
+#define RSI_RSP_INIT			0x94
+#define RSI_RSP_SCAN			0x95
+#define RSI_RSP_JOIN			0x96
+#define RSI_RSP_FFTAIM1_UPGD		0x91
+#define RSI_RSP_FFTAIM2_UPGD		0x92
+#define RSI_RSP_FFTADM_UPGD		0x93
+#define RSI_RSP_BSSID_NWTYPE		0xA1
+#define RSI_RSP_CFG_ENABLE		0x9A
+#define RSI_RSP_CFG_SAVE		0x9B
+#define RSI_RSP_CFG_GET			0x9C
+#define RSI_RSP_MODE_SEL		0xA3
+#define RSI_RSP_FEAT_SEL		0x9D
+#define RSI_CONTROL_CMD_TYPE		0x44
+
+
+// Control Request Frame Codes
+#define RSI_REQ_RSSI_QUERY		0x0005
+#define RSI_REQ_CONNECTION_STATUS	0x0007
+#define RSI_REQ_DISCONNECT		0x0008
+#define RSI_REQ_FWVERSION_QUERY		0x000d
+#define RSI_REQ_MACADDRESS_QUERY	0x000f
+
+// Control Response Frame Codes
+#define RSI_RSP_NULL			0x00
+#define RSI_RSP_RSSI_QUERY		0x08
+#define RSI_RSP_CONNECTION_STATUS	0x0a
+#define RSI_RSP_DISCONNECT		0x0c
+#define RSI_RSP_FWVERSION_QUERY		0x0f
+#define RSI_RSP_SET_MAC			0x10
+#define RSI_RSP_MAC_QUERY		0x12
+
+// Management Frame Responses
+#define RSI_RSP_SUCCESS				0x00
+#define RSI_RSP_ALLREADY_ASSOCIATED		0x02
+#define RSI_RSP_NO_AP				0x03
+#define RSI_RSP_PSK_NOT_CONFIG			0x04
+#define RSI_RSP_ROAM_LIST_EXCEEDED		0x05
+#define RSI_RSP_ROAM_LIST_EMPTY			0x06
+#define RSI_RSP_ROAM_SSID_NOT_FOUND		0x07
+#define RSI_RSP_SECURITY_JOIN_FAILED		0x08
+#define	RSI_RSP_ROAM_CONNECT_ERROR		0x09
+#define	RSI_RSP_INVALID_CHANNEL_NUMBER		0x0A
+#define	RSI_RSP_INVALID_COMMAND_BEFORE_SCAN	0x0B
+#define RSI_RSP_AUTHENTICATION_FAIL		0x0E
+#define RSI_RSP_UNKNOWN_ERROR			0x64
+
+
+const int MaxDelay = 1999; // < 2msec
+
+/**
+ * Enumerations
+ */
+enum RSI_INTTYPE {
+	RSI_IRQ_NONE				= 0x00,
+	RSI_IRQ_BUFFERFULL			= 0x01,
+	RSI_IRQ_BUFFEREMPTY			= 0x02,
+	RSI_IRQ_MGMTPACKET			= 0x04,
+	RSI_IRQ_DATAPACKET			= 0x08,
+	RSI_IRQ_10				= 0x10,
+	RSI_IRQ_PWRMODE				= 0x20,
+	RSI_IRQ_40				= 0x40,
+	RSI_IRQ_80				= 0x80,
+	RSI_IRQ_ANY				= 0xff
+};
+
+enum RSI_INTSOURCE {
+	RSI_FROM_MODULE,
+	RSI_FROM_CODE,
+	RSI_FROM_UNDEFINED
+};
+#if 0
+enum RSI_INTERRUPT_TYPE {
+	RSI_TXBUFFER_FULL			= 0x01,
+	RSI_TXBUFFER_EMPTY			= 0x02,
+	RSI_MGMT_PENDING			= 0x04,
+	RSI_DATA_PENDING			= 0x08,
+	RSI_PWR_MODE			 	= 0x10
+};
+#endif
+enum RSI_PROTOCOL {
+	RSI_PROTOCOL_UDP			= 0x00,
+	RSI_PROTOCOL_TCP			= 0x01,
+	RSI_PROTOCOL_UNDEFINED			= 0x02
+};
+
+enum RSI_MODULE_MODE {
+	RSI_MODE_SPI				= RSI_FALSE,
+	RSI_MODE_UART				= RSI_TRUE
+};
+
+typedef union {
+	u8 buf[RSI_FRAME_DESC_LEN];
+	u16 buf16[RSI_FRAME_DESC_LEN / sizeof (u16)];
+} rsi_uFrameDesc;
+
+typedef union {
+	struct {
+		u8 bandVal;
+		u8 padding[3];
+	} bandFrameSnd;
+	u8 uBandBuf[4];
+} rsi_uBand;
+
+typedef union {
+	struct {
+		u8 ModeSelVal;// u8, mode value to set
+		u8 padding[3];// needs to be 4 bytes long
+	} ModeSelFrameSnd;
+	u8 uModeSelBuf[4];    // byte format to send to the spi interface, 4 bytes
+} rsi_uModeSel;
+
+static int fwupgrade = 0;
+
+#if DEBUG_DATA_RECV || DEBUG_DATA_SEND
+static void hexdump(const u8 *buf, uint len);
+#endif
+
+static struct rs21_priv *rsi_priv(struct spi_device *spi)
+{
+	return dev_get_drvdata(&spi->dev);;
+}
+
+__attribute__((unused))
+static void cpto32(u8 *dst, u8 *src, int len) 
+{
+	int i;
+
+	for (i = 0; i < len; i += 4, dst += 4, src += 4) {
+		dst[0] = src[3];
+		dst[1] = src[2];
+		dst[2] = src[1];
+		dst[3] = src[0];
+	}
+}
+
+static void rs21_spi_txrx2(struct spi_device *spi, const u8 *din, u8 *dout, int len)
+{
+	static struct spi_message msg;
+	static struct spi_transfer t;
+
+	spi_message_init(&msg);
+	memset(&t, 0, sizeof t);
+	spi_message_add_tail(&t, &msg);
+	t.tx_buf = din;
+	t.rx_buf = dout;
+	t.len = len;
+	spi_sync(spi, &msg);
+#if DEBUG_DATA_SEND
+	if( 0x500 <= len ) {
+		printk( "%s: din=%p, len=%d, dump_start_offset=+0x4e0, length=32byte\n", __func__, din, len );
+		hexdump(din + 0x4e0, 32 );
+	}
+#endif
+}
+
+#if DEBUG_DATA_RECV || DEBUG_DATA_SEND
+static void hexdump(const u8 *buf, uint len)
+{
+	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1,
+		       buf, len, true);
+}
+#endif
+
+static int rsi_spiSend(struct spi_device *spi,
+		       const u8 *tx_buf, uint len, u8 *rx_buf, int mode)
+{
+#if DEBUG_SPI_RW
+	uint ti;
+
+	if (mode == RSI_MODE_32BIT) {
+		printk("S --> 32BIT <--");
+		if (len & 3) {
+			printk(" !!!!!! %d", len);
+		}
+		printk("\n");
+	}
+
+	printk("W:");
+	for (ti = 0; ti < len; ti++)
+		printk(" %02x", (u8)tx_buf[ti]);
+	printk("\n");
+#endif
+
+	rs21_spi_txrx2(spi, tx_buf, rx_buf, len);
+
+#if DEBUG_SPI_RW
+	if( rx_buf != NULL ) {
+		printk("R:");
+		for (ti = 0; ti < len; ti++)
+			printk(" %02x", rx_buf[ti]);
+		printk("\n");
+	}
+#endif
+
+	return 0;
+}
+
+static int rsi_spiRecv(struct spi_device *spi, u8 *buf, uint len, int mode)
+{
+	u8 rx_buf[len];
+
+#if DEBUG_SPI_RW
+	int ti;
+
+	if (mode == RSI_MODE_32BIT) {
+		printk("R --> 32BIT <--");
+		if (len & 3) {
+			printk(" !!!!!! %d", len);
+		}
+		printk("\n");
+	}
+#endif
+	memset(buf, 0, len);
+
+	rs21_spi_txrx2(spi, buf, rx_buf, len);
+
+	memcpy(buf, rx_buf, len);
+#if DEBUG_SPI_RW
+	printk("R:");
+	for (ti = 0; ti < len; ti++)
+		printk(" %02x", rx_buf[ti]);
+	printk("\n");
+#endif
+        return 0;
+}
+
+static int rsi_sendC1C2(struct spi_device *spi, u8 c1, u8 c2)
+{
+	unsigned long timeout = jiffies + HZ;
+	int ret = 0;
+
+#if DEBUG_C1C2
+	printk("C1C2: %02x %02x\n", c1, c2);
+#endif
+	do {
+		u8 tx_buf[2] = {c1, c2};
+		u8 rx_buf[2];
+
+		rsi_spiSend(spi, tx_buf, 2, rx_buf, RSI_MODE_8BIT);
+
+		switch (rx_buf[1]) {
+		case RSI_SPI_SUCCESS:
+			return RSI_SUCCESS;
+		case RSI_SPI_BUSY:
+#if DEBUG_C1C2
+			printk("C1C2 %02x %02x => %02x (BUSY)\n", c1, c2, RSI_SPI_BUSY);
+#endif
+			ret = RSI_BUSY;
+			break;
+		case RSI_SPI_FAIL:
+			printk("C1C2 %02x %02x => %02x (FAIL)\n", c1, c2, RSI_SPI_FAIL);
+			ret = RSI_FAIL;
+			break;
+		default:
+			printk("C1C2 %02x %02x => %02x ?\n", c1, c2, rx_buf[1]);
+		}
+	} while (time_before(jiffies, timeout));
+
+	return ret;
+}
+
+static int rsi_sendC3C4(struct spi_device *spi, u8 c3, u8 c4)
+{
+#if DEBUG_C1C2
+	printk("C3C4: %02x %02x\n", c3, c4);
+#endif
+	u8 tx_buf[2] = {c3, c4};
+	u8 rx_buf[2];
+
+	return rsi_spiSend(spi, tx_buf, 2, rx_buf, RSI_MODE_8BIT);
+}
+
+static int rsi_spiWaitStartToken(struct spi_device *spi,
+				 unsigned long timeout, int mode)
+{
+	int ret;
+	u8 ch;
+
+
+
+#if DEBUG_START_TOKEN
+	printk("+++ StartToken +++\n");
+#endif
+	timeout += jiffies;
+	do {
+		ret = rsi_spiRecv(spi, &ch, 1, mode);
+#if DEBUG_START_TOKEN
+		if (0)printk("    StartToken  %02x\n", ch);
+#endif
+		if (ch == RSI_SPI_START_TOKEN) {
+			ret = RSI_SUCCESS;
+			break;
+		}
+	} while (time_before(jiffies, timeout));
+#if DEBUG_START_TOKEN
+	printk("--- StartToken ---\n");
+#endif
+	return ret;
+}
+
+static void rsi_buildFrameDescriptor(rsi_uFrameDesc *uFrameDesc, const u8 *cmd)
+{
+	u8 *desc = uFrameDesc->buf;
+
+	memset(uFrameDesc, 0, RSI_FRAME_DESC_LEN);
+	// data or management frame type
+	desc[14] = cmd[2];		
+	desc[4] = cmd[3];		
+	// The first two bytes have different functions for management frames and
+	// control frames, but these are set in the pre-defined
+	desc[0] = cmd[0];			
+	// arrays which are the argument passed to this function, so we just set the two values
+	desc[1] = cmd[1];			
+	desc[3] = cmd[4];	
+        // for the descriptor in case of pwmode command	
+ 	 
+	return;
+}
+
+static int rsi_SpiFrameDescRd(struct spi_device *spi,
+			      rsi_uFrameDesc *uFrameDesc)
+{
+	int ret;
+	u8 c1, c2, c3, c4;
+
+	c1 = RSI_C1FRMRD16BIT4BYTE; // 0x5c
+	c2 = RSI_C2MEMRDWRNOCARE; // 0x00
+	c3 = RSI_FRAME_DESC_LEN; // command frame response descriptor
+	c4 = 0x00; // upper bye of transfer length
+	if ((ret = rsi_sendC1C2(spi, c1, c2)))
+		return ret;
+
+	ret = rsi_sendC3C4(spi, c3, c4);
+	ret = rsi_spiWaitStartToken(spi, 
+				    RSI_START_TOKEN_TIMEOUT, RSI_MODE_32BIT);
+	ret = rsi_spiRecv(spi, uFrameDesc->buf,
+			  RSI_FRAME_DESC_LEN, RSI_MODE_32BIT);
+#if DEBUG_DESC
+	{
+		int i;
+		printk("Desc R <=");
+		for (i = 0; i < RSI_FRAME_DESC_LEN/2; i++)
+			printk(" %04x", uFrameDesc->buf16[i]);
+		printk("\n");
+	}
+#endif
+	return ret;
+}
+
+static int rsi_SpiFrameDescWr(struct spi_device *spi,
+			      rsi_uFrameDesc *uFrameDesc, int type)
+{
+	int ret;
+	u8 c1, c2, c3, c4;
+
+	c1 = RSI_C1FRMWR16BIT4BYTE;
+	c2 = RSI_C2RDWR1BYTE | type;
+	c3 = RSI_FRAME_DESC_LEN;
+	c4 = 0x00;
+	if ((ret = rsi_sendC1C2(spi, c1, c2))) {
+		dev_err(&spi->dev, "%s: Data read C1C2 Failed %d\n", __func__, ret);
+		return ret;
+	}
+
+	rsi_sendC3C4(spi, c3, c4);
+#if DEBUG_DESC
+	{
+		int i;
+		printk("Desc W =>");
+		for (i = 0; i < RSI_FRAME_DESC_LEN/2; i++)
+			printk(" %04x", uFrameDesc->buf16[i]);
+		printk("\n");
+	}
+#endif
+	return rsi_spiSend(spi,
+			   uFrameDesc->buf,
+			   RSI_FRAME_DESC_LEN,
+			   NULL,
+			   RSI_MODE_32BIT);
+}
+
+static int rsi_SpiFrameDataWr(struct spi_device *spi,
+			      uint bufLen, const u8 *dBuf,
+			      uint16 tbufLen, u8 *tBuf,
+			      u8 type)
+{
+	int ret;
+	u8 c1, c2, c3, c4;
+	u16 tempbufLen;
+	tempbufLen = bufLen + tbufLen;
+	c1 = RSI_C1FRMWR16BIT4BYTE;
+	c2 = RSI_C2RDWR1BYTE | type;
+	c3 = tempbufLen & 0xff;
+	c4 = (tempbufLen >> 8) & 0xff;
+	if ((ret = rsi_sendC1C2(spi, c1, c2))) {
+		dev_err(&spi->dev, "Data read C1C2 Failed %d\n", ret);
+		return ret;
+	}
+	
+	ret = rsi_sendC3C4(spi, c3, c4);
+
+	ret = rsi_spiSend(spi, dBuf, bufLen, NULL, RSI_MODE_32BIT);
+
+	if (tbufLen) {
+		ret = rsi_spiSend(spi, tBuf, tbufLen, NULL, RSI_MODE_32BIT);
+	}
+	return ret;
+}
+
+int16 rsi_SpiFrameDataRd(struct spi_device *spi, uint16 bufLen, u8 *dBuf)
+{
+	int ret;
+	u8 c1, c2, c3, c4;
+
+	bufLen = (bufLen + 3) & ~3;
+
+	c1 = RSI_C1FRMRD16BIT4BYTE;		// 0x5c
+	c2 = RSI_C2MEMRDWRNOCARE;		// 0x00
+	c3 = (u8)(bufLen & 0x00ff);		//
+	c4 = (u8)((bufLen >> 8) & 0x00FF);	// 
+
+#if DEBUG_DATA_RECV
+	printk("%s: %d bytes\n", __func__, bufLen);
+#endif
+	if ((ret = rsi_sendC1C2(spi, c1, c2))) {
+		dev_err(&spi->dev, "Data read C1C2 Failed %d\n", ret);
+		return ret;
+	}
+
+	ret = rsi_sendC3C4(spi, c3, c4);
+	ret = rsi_spiWaitStartToken(spi,
+				    RSI_START_TOKEN_TIMEOUT, RSI_MODE_32BIT);
+
+	ret = rsi_spiRecv(spi, dBuf, bufLen, RSI_MODE_32BIT);
+
+#if DEBUG_DATA_RECV 
+	hexdump(dBuf, bufLen);
+#endif
+	return ret;
+}
+
+int rsi_memWr(struct spi_device *spi, u32 addr, u16 len, u8 *dBuf)
+{
+	u8 txCmd[4];
+	int ret;
+	u8 c1, c2, c3, c4;
+
+	c1 = RSI_C1MEMWR16BIT4BYTE;
+#ifdef RSI_BIT_32_SUPPORT
+	c2 = RSI_C2SPIADDR4BYTE;
+#else
+	c2 = RSI_C2SPIADDR1BYTE;
+#endif
+	c3 = len & 0xff;
+	c4 = (len >> 8) & 0xff;
+#ifdef RSI_LITTLE_ENDIAN
+	*(uint32 *)txCmd = addr;
+#else
+	rsi_uint32To4Bytes(txCmd, addr);
+#endif
+	ret = rsi_sendC1C2(spi, c1, c2);
+
+	if (ret) {
+		printk("MemWr C1C2 Fail, SPI Busy %d\n", ret);
+		return ret;
+	}
+
+	ret = rsi_sendC3C4(spi, c3, c4);
+	ret = rsi_spiSend(spi, txCmd, sizeof(txCmd), NULL, RSI_MODE_8BIT);
+	ret = rsi_spiSend(spi, dBuf, len, NULL, RSI_MODE_8BIT);
+
+	return ret;
+}
+
+int rsi_memRd(struct spi_device *spi, uint32 addr, uint16 len, u8 *dBuf)
+{
+	u8 c1 = RSI_C1MEMRD16BIT4BYTE;
+	u8 c2 = RSI_C2MEMRDWRNOCARE;
+	u8 c3 = len & 0xff;
+	u8 c4 = (len >> 8) & 0xff;
+	u8 txCmd[] = {
+		addr & 0xff,
+		(addr >> 8) & 0xff,
+		(addr >> 16) & 0xff,
+		(addr >> 24) & 0xff
+	};
+	int ret;
+
+	ret = rsi_sendC1C2(spi, c1, c2);
+
+	if (ret) {
+		dev_err(&spi->dev, "MemRd, C1C2 Fail, SPI Busy\n");
+		return ret;
+	}
+
+	ret = rsi_sendC3C4(spi, c3, c4);
+	ret = rsi_spiSend(spi, txCmd, sizeof(txCmd), NULL, RSI_MODE_8BIT);
+	ret = rsi_spiWaitStartToken(spi,
+				    RSI_START_TOKEN_TIMEOUT, RSI_MODE_8BIT);
+	return rsi_spiRecv(spi, dBuf, len, RSI_MODE_8BIT);
+}
+
+int rsi_regRd(struct spi_device *spi, u8 regAddr, u8 *dBuf)
+{
+	int ret;
+	u8 c1;
+	u8 c2;
+
+	c1 = RSI_C1INTREAD1BYTES;
+	c2 = 0x00;
+	c2 |= regAddr;
+	ret = rsi_sendC1C2(spi, c1, c2);
+
+	if (ret) {
+		dev_err(&spi->dev, "RegRd C1C2 Fail, SPI Busy %d\n", ret);
+		return ret;
+	}
+
+	if ((ret = rsi_spiWaitStartToken(spi,
+					 RSI_START_TOKEN_TIMEOUT,
+					 RSI_MODE_8BIT)))
+	{
+		return ret;
+	}
+
+	return rsi_spiRecv(spi, dBuf, 1, RSI_MODE_8BIT);
+}
+
+static int rsi_clear_interrupt(struct spi_device *spi, u8 interruptClear)
+{
+	int ret;
+	u8 dBuf[2] = {0,0};
+
+	// read in the register so we can set bit 5 and write back out
+	ret = rsi_memRd(spi, RSI_INT_CLR_REG_ADDR, sizeof(dBuf), dBuf);
+	// 0x74, 0x00, 0x22000010
+	// set bit 5, interrupt clear
+	dBuf[0] |= interruptClear;
+	// memory write the mask value
+	ret = rsi_memWr(spi, RSI_INT_CLR_REG_ADDR, sizeof(dBuf), dBuf);
+
+	return ret;
+}
+
+static int rsi_set_intr_mask(struct spi_device *spi, u8 interruptMask)
+{
+	u8 dBuf[2];
+
+	dBuf[0] = interruptMask;
+
+	return rsi_memWr(spi, RSI_INT_MASK_REG_ADDR, sizeof(dBuf), dBuf);
+}
+
+static int rsi_irqstatus(struct spi_device *spi)
+{
+	int ret;
+	unsigned long timeout;
+	u8 dBuf[2] = {0};
+
+	timeout = jiffies + RSI_TICKS_PER_SECOND;
+
+	while (time_before(jiffies, timeout)) {
+		ret = rsi_regRd(spi, RSI_SPI_INT_REG_ADDR, dBuf);
+
+		if (ret >= 0)
+			return dBuf[0];
+	}
+
+	return -ETIME;
+}
+
+int rsi_irqstatus2(struct spi_device *spi)
+{
+	struct rs21_priv *priv = rsi_priv(spi);
+	int stat = rsi_irqstatus(spi);
+	if (stat < 0)
+		return stat;
+
+#if DEBUG_INTR
+	if (stat)
+		printk("I:%02x\n", (u8)stat);
+#endif
+	if (0)
+	if ((priv->pwstate.current_mode == 1) && (stat & RSI_IRQ_PWRMODE)) {
+		if (priv->pwstate.ack_pwsave == 1) {
+			rsi_clear_interrupt(spi, RSI_ICLEAR_PWR);
+			rsi_set_intr_mask(spi, RSI_IMASK_PWR_DISABLE);
+
+		} else {
+			rsi_set_intr_mask(spi, RSI_IMASK_PWR_ENABLE);
+		}
+
+#ifdef RSI_INTERRUPTS
+		rsi_spiIrqClearPending();
+#endif
+	}
+	return stat;
+}
+
+int rsi_read_data(struct spi_device *spi, uint16 length)
+{
+	struct rs21_priv *priv = rsi_priv(spi);
+	struct net_device_stats *stats = &priv->stats;
+	struct sk_buff *skb;
+	int err;
+
+	skb = dev_alloc_skb(length + NET_IP_ALIGN + 3);	// #define NET_IP_ALIGN	2
+
+	rsi_SpiFrameDataRd(spi, length, skb_put(skb, length));
+
+	skb->protocol = eth_type_trans(skb, priv->ndev);
+#if DEBUG_SEM
+	printk("Recv: --UP--\n");
+#endif
+	up(&priv->spi_sem);
+
+	err = netif_rx_ni(skb);
+
+	down(&priv->spi_sem);
+
+#if DEBUG_SEM
+	printk("Recv: -DOWN-\n");
+#endif
+
+	stats->rx_packets++;
+	stats->rx_bytes += length;
+
+	return 0;
+}
+
+int rsi_read_packet(struct spi_device *spi)
+{
+	int ret = 0;
+	u16 bufLen;
+	static rsi_uFrameDesc uFrameDesc;
+	struct rs21_priv *priv = rsi_priv(spi);
+
+	memset(&uFrameDesc, 0, sizeof(uFrameDesc));
+
+	if ((ret = rsi_SpiFrameDescRd(spi, &uFrameDesc))) {
+		dev_err(&spi->dev, "DescRdError=%02x\n", (u8)ret);
+		return ret;
+	}
+
+	bufLen = uFrameDesc.buf[0] | uFrameDesc.buf[1] << 8;
+
+	if (uFrameDesc.buf[14] == RSI_DATA_PKT_TYPE) {
+		bufLen &= 0x0fff;
+		if (uFrameDesc.buf[5] == RSI_CONTROL_CMD_TYPE) {
+			ret = rsi_SpiFrameDataRd(spi, bufLen, (u8 *)&priv->uCmdRsp);
+			if (ret) {
+				dev_err(&spi->dev, "FrmDataRdError=%02x\n", (u8)ret);
+				return ret;
+			}
+
+			switch (priv->uCmdRsp.buf[0]) {
+			case RSI_RSP_RSSI_QUERY:
+				memcpy(priv->rssi, &priv->uCmdRsp.buf[2], 2);
+				complete(&priv->qmac_comp);
+				break;
+			case RSI_RSP_SET_MAC:
+				complete(&priv->qmac_comp);
+				break;
+			case RSI_RSP_FWVERSION_QUERY:
+				memcpy(priv->fwversion,
+				       &priv->uCmdRsp.buf[2],
+				       FIRM_VER_LEN);
+				complete(&priv->qmac_comp);
+				break;
+			case RSI_RSP_MAC_QUERY:
+				memcpy(priv->mac, &priv->uCmdRsp.buf[2], 6);
+				complete(&priv->qmac_comp);
+				break;
+			case RSI_RSP_DISCONNECT:
+				complete(&priv->join_comp);
+				break;
+			}
+			return ret;
+		} else {
+			rsi_read_data(spi, bufLen);
+			return bufLen; /* for data packet length */
+		}
+	} else {
+		bufLen &= 0x00ff;
+		if (uFrameDesc.buf[1] == RSI_RSP_INIT ||
+		    uFrameDesc.buf[1] == RSI_RSP_BAND ||
+		    uFrameDesc.buf[1] == RSI_RSP_MODE_SEL) {
+			complete(&priv->init_comp);
+		} else if (uFrameDesc.buf[1] == RSI_RSP_CARD_READY) {
+
+		} else if (uFrameDesc.buf[1] == RSI_RSP_JOIN) {
+			priv->join_sw = uFrameDesc.buf[2];
+			complete(&priv->join_comp);
+		} else if (uFrameDesc.buf[1] == RSI_RSP_SCAN ||
+			   uFrameDesc.buf[1] == RSI_RSP_BSSID_NWTYPE) {
+			priv->scan_sw = uFrameDesc.buf[2];
+			if (!uFrameDesc.buf[2]) {
+				if (bufLen == 0xff) {
+					bufLen = uFrameDesc.buf[9];
+					bufLen <<= 8;
+					bufLen &= 0xff00;
+					bufLen |= uFrameDesc.buf[8];
+				}
+				// Read in the scan data (results)
+				if (bufLen > 0) {
+					ret = rsi_SpiFrameDataRd(spi, bufLen, (u8 *)priv->scanResponse);
+					if (ret) {
+						dev_err(&spi->dev, "ScanFramDataRdErr %d\n", ret);
+						return ret;
+					}
+				}
+			}
+			priv->scanResponse->status = uFrameDesc.buf[2];
+			complete(&priv->scan_comp);
+			return ret;
+		}
+	}
+	return ret;
+}
+
+int rsi_send_raw_data(struct spi_device *spi, u8 *payload, u32 payloadLen);
+
+static void rs9110_process(struct rs21_priv *priv)
+{
+	struct spi_device *spi = priv->spi;
+	int status;
+
+#if DEBUG
+	printk("########## rs9110_process() ##########\n");
+#endif
+
+	down(&priv->spi_sem);
+#if DEBUG_SEM
+	printk("PI: -DOWN-\n");
+#endif
+	status = rsi_irqstatus2(spi);
+
+	priv->buffer_full = status & RSI_IRQ_BUFFERFULL;
+
+	if (status < 0) {
+		printk("%s: %d\n", __func__, status);
+		goto end;
+	}
+
+
+	if (status & RSI_IRQ_DATAPACKET)
+		rsi_read_packet(spi);
+	if (!(status & RSI_IRQ_BUFFERFULL))
+		complete(&priv->buff_comp);
+
+end:
+#if DEBUG_SEM
+	printk("PI: --UP--\n");
+#endif
+	up(&priv->spi_sem);
+}
+
+static void rsi_work(struct work_struct *work)
+{
+	struct rs21_priv *priv = container_of(work, struct rs21_priv, work);
+
+	rs9110_process(priv);
+
+#if DEBUG
+	printk( "%s: priv->ndev->irq=%d\n", __func__, priv->ndev->irq );
+#endif
+	if (priv->ndev->irq)
+		enable_irq(priv->ndev->irq);
+}
+
+static irqreturn_t rsi_interrupt(int irq, void *ptr)
+{
+	struct net_device *ndev;
+	struct rs21_priv *priv;
+
+#if DEBUG
+	printk("********** rsi_interrupt() **********\n");
+#endif
+
+	disable_irq_nosync(irq);
+
+	ndev = ptr;
+	priv = netdev_priv(ndev);
+#if DEBUG_INTR
+	if (printk_ratelimit())
+		printk("%s:\n", __func__);
+#endif
+
+	schedule_work(&priv->work);
+
+	return IRQ_HANDLED;
+}
+
+#if USE_TIMER
+static void rs9110_poll_irq(unsigned long arg)
+{
+	struct rs21_priv *priv = (struct rs21_priv *)arg;
+	struct rs9110_platform_data *pdata = priv->pdata;
+
+	schedule_work(&priv->work);
+
+	mod_timer(&priv->timer, jiffies + pdata->poll_period);
+}
+#else
+static int rs9110_thread(void *ptr)
+{
+	struct net_device *ndev = ptr;
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct rs9110_platform_data *pdata = priv->pdata;
+	int timeout = 1;
+	int tmo_max = 1 << 8;
+
+	for ( ; ; ) {
+		if (pdata->get_irq_pin_state()) {
+			schedule_work(&priv->work);
+			schedule();
+			timeout = 1;
+			continue;
+		}
+
+		if (kthread_should_stop())
+			break;
+
+		msleep(timeout);
+		timeout <<= 1;
+		if (timeout > tmo_max)
+			timeout = tmo_max;
+	}
+	return 0;
+}
+#endif
+int rsi_spi_iface_init(struct spi_device *spi)
+{
+	unsigned long timeout = jiffies + (HZ / 100) + 1;
+	u8 txCmd[2];
+	u8 localBuf[4];
+
+#if DEBUG
+	printk( "%s: Enter\n", __func__ );
+#endif
+
+	txCmd[0] = RSI_C1_INIT_CMD;
+
+	do {
+		rsi_spiSend(spi, txCmd, 2, localBuf, RSI_MODE_8BIT);
+		if (localBuf[1] == RSI_SPI_SUCCESS)
+			return RSI_SUCCESS;
+	} while (time_before(jiffies, timeout));
+
+#if DEBUG
+	printk( "%s: Exit -EBUSY\n", __func__ );
+#endif
+	return -EBUSY;
+}
+
+int rsi_send_raw_data(struct spi_device *spi, u8 *payload, u32 payloadLen)
+{
+	int ret;
+	rsi_uFrameDesc uFrameDesc;
+
+	// build the SEND frame descriptor
+	rsi_buildFrameDescriptor(&uFrameDesc, rsi_frameCmdSend);
+	uFrameDesc.buf16[0] = payloadLen & 0x7fff;
+#if RSI_LITTLE_ENDIAN == 0
+#err not implemented...
+#endif
+	// Write out the command frame descriptor
+	ret = rsi_SpiFrameDescWr(spi, &uFrameDesc, RSI_C2DATA);
+	// Init the SEND Frame Data
+	payloadLen = (payloadLen + 3) & ~3;
+	if ((ret = rsi_SpiFrameDataWr(spi, payloadLen, payload, 0, NULL,
+				      RSI_C2DATA))) {
+		dev_err(&spi->dev, "SndFrmDescErr=%02x\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+int rsi_bootloader(struct spi_device *spi)
+{
+	int ret;
+	u8 dBuf[4];
+	rsi_uFrameDesc uFrameDesc;
+
+	static u8 sbinst1[] = {
+#include "Firmware/sbinst1"
+	};
+	static u8 sbinst2[] = {
+#include "Firmware/sbinst2"
+	};
+	static u8 sbdata1[] = {
+#include "Firmware/sbdata1"
+	};
+#if RSI_LOAD_SBDATA2_FROM_HOST
+	static u8 sbdata2[] = {
+#include "Firmware/sbdata2"
+	};
+#endif
+	dev_dbg(&spi->dev, "BootLoader Start\n");
+	dev_dbg(&spi->dev, "Set Soft Reset\n");
+
+	memset(dBuf, 0, sizeof dBuf);
+
+	dBuf[0] = RSI_RST_SOFT_SET;
+
+	if ((ret = rsi_memWr(spi, RSI_RST_SOFT_ADDR, sizeof(dBuf), dBuf))) {
+		dev_err(&spi->dev, "Soft Reset FAILED %d\n", ret);
+		return ret;
+	}
+
+	dev_dbg(&spi->dev, "Loading SBINST1, is %d Bytes\n", sizeof(sbinst1));
+
+	if ((ret = rsi_memWr(spi, RSI_SBINST1_ADDR, sizeof(sbinst1), sbinst1))) {
+		dev_err(&spi->dev, "sbinst1 memory write FAILED %d\n", ret);
+		return ret;
+	}
+
+	dev_dbg(&spi->dev, "Loading SBINST2, is %d Bytes\n", sizeof(sbinst2));
+
+	if ((ret = rsi_memWr(spi, RSI_SBINST2_ADDR, sizeof(sbinst2), sbinst2))) {
+		dev_dbg(&spi->dev, "sbinst2 memory write FAILED %d\n", ret);
+		return ret;
+	}
+
+	dev_dbg(&spi->dev, "Loading SBDATA1, is %d Bytes\n", sizeof(sbdata1));
+
+	if ((ret = rsi_memWr(spi, RSI_SBDATA1_ADDR, sizeof sbdata1, sbdata1))) {
+		dev_dbg(&spi->dev, "sbdata1 memory write FAILED %d\n", ret);
+		return ret;
+	}
+
+	dev_dbg(&spi->dev, "Negate Soft Reset\n");
+
+	memset(dBuf, sizeof dBuf, 0);
+	dBuf[0] = RSI_RST_SOFT_CLR;
+	if ((ret = rsi_memWr(spi, RSI_RST_SOFT_ADDR, 0x0004, dBuf))) {
+		dev_dbg(&spi->dev, 
+			"Bring module out of reset FAILED %d\n", ret);
+		return ret;
+	}
+
+	msleep(100);
+	dev_dbg(&spi->dev, "Wait for Card Ready\n");
+	dev_dbg(&spi->dev, "Read Card Ready Response\n");
+
+	if ((ret = rsi_SpiFrameDescRd(spi, &uFrameDesc))) {
+		dev_err(&spi->dev, 
+			"Card ready frame descriptor read failed %d\n", ret);
+		return ret;
+	}
+	// read in the frame descriptor
+	if (uFrameDesc.buf[1] != RSI_RSP_CARD_READY) {
+		dev_err(&spi->dev, "Card (NOT) Ready=%02x\n", uFrameDesc.buf[1]);
+		return RSI_BUSY;
+	}
+	
+#if RSI_LOAD_SBDATA2_FROM_HOST
+	if ((ret = rsi_memWr(spi, RSI_SBDATA2_ADDR, sizeof sbdata2, sbdata2))) {
+		dev_err(&spi->dev, "sbdata2 memory write FAILED %d\n", ret);
+		return ret;
+	}
+
+#endif
+	dev_dbg(&spi->dev, "BootLoader End\n");
+	
+#ifdef RSI_INTERRUPTS
+	// Cannot initialize interrupts until the chip has booted
+	// SPI_IRQ Initialization
+# ifdef RSI_DEBUG_PRINT
+	RSI_DPRINT(RSI_PL3,"\r\nEnabling Interrupts");
+# endif
+	rsi_spiIrqStart(); // Enable the interrupt from the Wi-Fi Module
+# ifdef RSI_DEBUG_PRINT
+	RSI_DPRINT(RSI_PL3,"\r\nInterrupts Enabled");
+# endif
+#endif
+	return RSI_SUCCESS;
+}
+
+int rsi_execute_cmd(struct spi_device *spi,
+		    const u8 *descparam,
+		    const u8 *payloadparam, uint size_param)
+{
+	int ret;
+	struct rs21_priv *priv = rsi_priv(spi);
+	static rsi_uFrameDesc uFrameDesc;
+
+	memset(&uFrameDesc, 0, sizeof(uFrameDesc));
+
+	rsi_buildFrameDescriptor(&uFrameDesc, descparam);
+	down(&priv->spi_sem);
+#if DEBUG_SEM
+	printk("CMD: -DOWN-\n");
+#endif
+	if ((ret = rsi_SpiFrameDescWr(spi, &uFrameDesc, RSI_C2MGMT)))
+		goto end;
+	if (size_param) {
+		size_param = (size_param + 3) & ~3;
+		if ((ret = rsi_SpiFrameDataWr(spi,
+					      size_param,
+					      payloadparam,
+					      0,
+					      NULL,
+					      RSI_C2MGMT)))
+			goto end;
+	}
+end:
+#if DEBUG_SEM
+	printk("CMD: --UP--\n");
+#endif
+	up(&priv->spi_sem);
+
+	return ret;
+}
+
+int rsi_band(struct spi_device *spi, int band)
+{
+	struct rs21_priv *priv = rsi_priv(spi);
+	int ret;
+	rsi_uBand uBand;
+
+	down(&priv->init_sem);
+
+	uBand.bandFrameSnd.bandVal = band;
+	ret = rsi_execute_cmd(spi, rsi_frameCmdBand,
+			      (u8 *)&uBand, sizeof(uBand));
+	wait_for_completion_timeout(&priv->init_comp, HZ);
+
+	up(&priv->init_sem);
+
+	return ret;
+}
+
+int rsi_spi_mode_sel(struct spi_device *spi, int mode)
+{
+	struct rs21_priv *priv = rsi_priv(spi);
+	int ret;
+	rsi_uModeSel uModeSel;
+
+	down(&priv->init_sem);
+
+	uModeSel.ModeSelFrameSnd.ModeSelVal = mode;
+	ret =  rsi_execute_cmd(spi, rsi_frameCmdModeSel,
+			       (u8 *)&uModeSel, sizeof(uModeSel));
+	wait_for_completion_timeout(&priv->init_comp, HZ);
+
+	up(&priv->init_sem);
+
+	return ret;
+}
+
+int rsi_init(struct spi_device *spi)
+{
+	struct rs21_priv *priv = rsi_priv(spi);
+	int ret;
+
+	down(&priv->init_sem);
+
+	ret = rsi_execute_cmd(spi, rsi_frameCmdInit, NULL, 0);
+	ret = wait_for_completion_timeout(&priv->init_comp, HZ);
+
+	up(&priv->init_sem);
+
+	return ret;
+}
+
+int rsi_scan(struct spi_device *spi,
+	     const rsi_scanFrame *scanFrame,
+	     rsi_scanResponse *scanResponse,
+	     u16 *sw)
+{
+	int ret;
+	struct rs21_priv *priv = rsi_priv(spi);
+
+	down(&priv->scan_sem);
+
+	if (priv->ndev->irq)
+	{
+		struct irq_desc *desc = irq_to_desc(priv->ndev->irq);
+		if (desc->irq_data.chip->irq_enable)
+			desc->irq_data.chip->irq_enable(&desc->irq_data);
+	}
+
+	priv->scanResponse = scanResponse;
+
+	ret = rsi_execute_cmd(spi,
+			      rsi_frameCmdScan,
+			      (const u8 *)scanFrame, sizeof(*scanFrame));
+	ret = wait_for_completion_interruptible_timeout(&priv->scan_comp,
+							HZ * 10);
+
+	up(&priv->scan_sem);
+
+	if (ret == 0)
+		return -ETIMEDOUT;
+	if (ret < 0)
+		return ret;
+	if (sw)
+		*sw = priv->scan_sw;
+
+	return 0;
+}
+
+int rsi_query_bssid_nwtype(struct spi_device *spi,
+			   rsi_bssid_nwtypeFrame *frame)
+{
+	int ret;
+	struct rs21_priv *priv = rsi_priv(spi);
+
+	down(&priv->scan_sem);
+
+	priv->bssid_nwtypeFrame = frame;
+	ret = rsi_execute_cmd(spi, rsi_frameCmdBssidNwtype, NULL, 0);
+	wait_for_completion(&priv->scan_comp);
+
+	up(&priv->scan_sem);
+
+	return ret;
+}
+
+int rsi_disconnect(struct spi_device *spi);
+
+int rsi_join(struct spi_device *spi, const rsi_joinFrame *jf, u16 *sw)
+{
+	struct rs21_priv *priv = rsi_priv(spi);
+	int ret;
+
+	down(&priv->join_sem);
+
+	ret = rsi_execute_cmd(spi, rsi_frameCmdJoin,
+					      (const u8 *)jf, sizeof(*jf));
+	ret = wait_for_completion_interruptible_timeout(&priv->join_comp,
+							HZ * 30);
+
+	if (ret == 0) {
+		ret =  -ETIMEDOUT;
+		goto end;
+	}
+	if (ret < 0)
+		goto end;
+
+	ret = 0;
+
+	if (sw)
+		*sw = priv->join_sw;
+
+	if (priv->join_sw == 0)
+		priv->joined = true;
+
+end:
+	up(&priv->join_sem);
+
+	if (priv->join_sw)
+		printk("%s: sw=%04x\n", __func__, *sw);
+
+	return ret;
+}
+
+int rsi_query_rssi(struct spi_device *spi, u16 *rssi)
+{
+	int ret;
+	struct rs21_priv *priv = rsi_priv(spi);
+
+	down(&priv->qmac_sem);
+
+	priv->rssi = rssi;
+
+	ret = rsi_execute_cmd(spi,
+			      rsi_frameCmdRssi,
+			      rsi_dFrmRssi,
+			      sizeof(rsi_dFrmRssi));
+	wait_for_completion(&priv->qmac_comp);
+
+	up(&priv->qmac_sem);
+
+	*rssi *= -1;
+
+	return ret;
+}
+
+int rsi_query_macaddress(struct spi_device *spi, u8 *mac)
+{
+	int ret;
+	struct rs21_priv *priv = rsi_priv(spi);
+
+	down(&priv->qmac_sem);
+
+	priv->mac = mac;
+
+	ret = rsi_execute_cmd(spi,
+			      rsi_frameCmdQryMacAddress,
+			      rsi_dFrmQryMacAddress,
+			      sizeof(rsi_dFrmQryMacAddress));
+	ret = wait_for_completion_timeout(&priv->qmac_comp, HZ);
+
+	up(&priv->qmac_sem);
+
+	return ret;
+}
+
+int rsi_query_fwversion(struct spi_device *spi, u8 *ver)
+{
+	struct rs21_priv *priv = rsi_priv(spi);
+	int ret;
+
+	down(&priv->qmac_sem);
+
+	priv->fwversion = ver;
+	ret = rsi_execute_cmd(spi,
+			      rsi_frameCmdQryFwVer,
+			      rsi_dFrmQryFwVer,
+			      sizeof(rsi_dFrmQryFwVer));
+	ret = wait_for_completion_timeout(&priv->qmac_comp, HZ);
+
+	up(&priv->qmac_sem);
+
+	return ret;
+}
+
+int rsi_set_macaddress(struct spi_device *spi, const u8 *mac)
+{
+	struct rs21_priv *priv = rsi_priv(spi);
+	int ret;
+	u8 __mac[8];
+
+	down(&priv->qmac_sem);
+
+	ret = rsi_execute_cmd(spi,
+			      rsi_frameCmdSetMacAddress,
+			      rsi_dFrmSetMacAddress,
+			      sizeof(rsi_dFrmSetMacAddress));
+
+	memcpy(__mac, mac, 6);
+	rsi_SpiFrameDataWr(spi, 8, __mac, 0, NULL,
+			   RSI_C2DATA);
+	wait_for_completion(&priv->qmac_comp);
+
+	up(&priv->qmac_sem);
+
+	return ret;
+}
+
+int rsi_disconnect(struct spi_device *spi)
+{
+	struct rs21_priv *priv = rsi_priv(spi);
+	int ret;
+
+	down(&priv->join_sem);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,13,0)
+	reinit_completion( &(priv->join_comp) );
+#else
+	INIT_COMPLETION(priv->join_comp);
+#endif
+	ret = rsi_execute_cmd(spi,
+			      rsi_frameCmdDisconnect,
+			      rsi_dFrmDisconnect, sizeof(rsi_dFrmDisconnect));
+	ret = wait_for_completion_timeout(&priv->join_comp, HZ * 5);
+
+	priv->joined = false;
+
+	up(&priv->join_sem);
+
+	if (ret == 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static const int rs21_bitrates[] = {
+	10, 20, 55, 110,
+	60, 90, 120, 180, 240, 360, 480, 540,
+	65, 130, 195, 260, 390, 520, 585, 650,
+};
+
+static const int rs21_txpowers[] = {
+	6, 8, 9, 10, 12, 14, 15, 17
+};
+ 
+static int rs21_get_name(struct net_device *ndev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
+{
+	strcpy(wrqu->name, "IEEE 802.11n");
+	return 0;
+}
+
+static int rs21_set_mode(struct net_device *ndev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+
+	priv->mode = wrqu->mode;
+
+	return 0;
+}
+
+static int rs21_get_mode(struct net_device *ndev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	
+	wrqu->mode = priv->mode;
+
+	return 0;
+}
+
+static int rs21_set_freq(struct net_device *ndev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_freq *freq = &wrqu->freq;
+
+	priv->channel = freq->m;
+
+	return 0;
+}
+
+static int rs21_get_freq(struct net_device *ndev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_freq *freq = &wrqu->freq;
+
+	if (!priv->joined)
+		return -1;
+
+	freq->e = 0;
+	freq->m = priv->channel;
+
+	return 0;
+}
+
+static int rs21_get_range(struct net_device *ndev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
+{
+	struct iw_point *point = &wrqu->data;
+	struct iw_range *range = (struct iw_range *)extra;
+	int i;
+
+	point->length = sizeof (struct iw_range);
+	memset(range, 0, sizeof (struct iw_range));
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = WIRELESS_EXT;
+	range->scan_capa =
+		IW_SCAN_CAPA_ESSID |
+		IW_SCAN_CAPA_BSSID |
+		IW_SCAN_CAPA_CHANNEL;
+
+	IW_EVENT_CAPA_SET_KERNEL(range->event_capa);
+	IW_EVENT_CAPA_SET(range->event_capa, SIOCGIWSCAN);
+
+	range->txpower_capa = IW_TXPOW_DBM | IW_TXPOW_RANGE;
+	range->num_txpower = ARRAY_SIZE(rs21_txpowers);
+	for (i = 0; i < range->num_txpower; i++)
+		range->txpower[i] = rs21_txpowers[i];
+
+	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 | IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_4WAY_HANDSHAKE;
+	range->encoding_size[0] = 5;
+	range->encoding_size[1] = 13;
+	range->encoding_size[2] = 32;
+	range->num_encoding_sizes = 3;
+
+	for (i = 0; i < 14; i++) {
+		range->freq[i].i = i + 1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+		range->freq[i].m = ieee80211_channel_to_frequency(i + 1, NL80211_BAND_2GHZ) * 100000;
+#else
+		range->freq[i].m = ieee80211_dsss_chan_to_freq(i + 1) * 100000;
+#endif
+		range->freq[i].e = 1;
+	}
+	range->num_channels = i;
+	range->num_frequency = i;
+
+	for (i = 0; i < ARRAY_SIZE(rs21_bitrates); i++) {
+		range->bitrate[i] = rs21_bitrates[i] * 100000;
+	}
+	range->num_bitrates = i;
+
+	return 0;
+}
+
+static const rsi_bssid_nwtypeInfo *find_bssid_nwtypeInfo(const rsi_scanInfo *si,
+							 const rsi_bssid_nwtypeFrame *frame)
+{
+	int i;
+
+	for (i = 0; i < frame->scanCount; i++) {
+		const rsi_bssid_nwtypeInfo *info =
+			&frame->strBssid_NwtypeInfo[i];
+
+		if (strcmp(si->ssid, info->ssid) == 0 &&
+		    si->rfChannel == info->rfChannel)
+			return info;
+	}
+	return NULL;
+}
+
+static size_t rs9110_synthesize_ie(u8 *buf, rsi_scanInfo *scan)
+{
+#define OUI_LEN 3
+	static const u8 rsn_oui[OUI_LEN] = { 0x00, 0x0f, 0xac };
+	static const u8 wpa_oui[OUI_LEN] = { 0x00, 0x50, 0xf2 };
+	const u8 *oui_header;
+	u8 *start = buf;
+	int rsn;
+	int ccmp;
+
+	switch (scan->securityMode) {
+	case RSI_SECURITY_WPA1:
+		rsn = 0;
+		break;
+	case RSI_SECURITY_WPA2:
+		rsn = 1;
+		break;
+	default:
+		/* WEP or none.  No IE returned */
+		return 0;
+	}
+
+	if (rsn) {
+		ccmp = 1;
+	} else {
+		ccmp = 0;
+	}
+
+	if (rsn)
+		oui_header = rsn_oui;
+	else
+		oui_header = wpa_oui;
+
+	/* element id */
+	if (rsn)
+		*buf++ = WLAN_EID_RSN;
+	else
+		*buf++ = WLAN_EID_VENDOR_SPECIFIC;
+
+	/* length filed; set later */
+	buf++;
+
+	/* wpa special header */
+	if (!rsn) {
+		memcpy(buf, wpa_oui, OUI_LEN);
+		buf += OUI_LEN;
+		*buf++ = 0x01;
+	}
+
+	/* version */
+	*buf++ = 0x01; /* version 1.0 */
+	*buf++ = 0x00;
+
+	/* group cipher */
+	memcpy(buf, oui_header, OUI_LEN);
+	buf += OUI_LEN;
+
+	if (ccmp)
+		*buf++ = 0x04; /* CCMP */
+	else
+		*buf++ = 0x02; /* TKIP */
+
+	/* pairwise key count always 1 */
+	*buf++ = 0x01;
+	*buf++ = 0x00;
+
+	/* pairwise key suit */
+	memcpy(buf, oui_header, OUI_LEN);
+	buf += OUI_LEN;
+	if (ccmp)
+		*buf++ = 0x04; /* CCMP */
+	else
+		*buf++ = 0x02; /* TKIP */
+
+	/* AKM count is 1 */
+	*buf++ = 0x01;
+	*buf++ = 0x00;
+
+	/* AKM suite is assumed as PSK*/
+	memcpy(buf, oui_header, OUI_LEN);
+	buf += OUI_LEN;
+	*buf++ = 0x02; /* PSK */
+
+	/* RSN capabilities is 0 */
+	*buf++ = 0x00;
+	*buf++ = 0x00;
+
+	/* set length field */
+	start[1] = (buf - start - 2);
+
+	return buf - start;
+}
+
+static char *rsi_translate_scan(struct rs21_priv *priv, rsi_scanInfo *si,
+				struct iw_request_info *info, char *cev,
+				char *end_buf)
+{
+	struct iw_event iwe;
+	const rsi_bssid_nwtypeInfo *ni =
+		find_bssid_nwtypeInfo(si, &priv->_bssid_nwtypeFrame);
+	int len;
+	u8 buf[64];
+
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+	memset(iwe.u.ap_addr.sa_data, 0, ETH_ALEN);
+	if (ni)
+		memcpy(iwe.u.ap_addr.sa_data, ni->BSSID, sizeof (ni->BSSID));
+	cev = iwe_stream_add_event(info, cev, end_buf,
+				   &iwe, IW_EV_ADDR_LEN);
+
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.length = min(strlen(si->ssid), sizeof (si->ssid));
+	iwe.u.data.flags = 1;
+	cev = iwe_stream_add_point(info, cev, end_buf,
+				   &iwe, si->ssid);
+	iwe.cmd = SIOCGIWMODE;
+	if (ni->uNetworkType == RSI_INFRASTRUCTURE_MODE)
+		iwe.u.mode = IW_MODE_MASTER;
+	else
+		iwe.u.mode = IW_MODE_ADHOC;
+	cev = iwe_stream_add_event(info, cev, end_buf,
+				   &iwe, IW_EV_UINT_LEN);
+
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = si->rfChannel;
+	iwe.u.freq.e = 0;
+	cev = iwe_stream_add_event(info, cev, end_buf,
+				   &iwe, IW_EV_FREQ_LEN);
+	iwe.cmd = SIOCGIWENCODE;
+	iwe.u.data.length = 0;
+	if (si->securityMode > 0)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	cev = iwe_stream_add_point(info, cev, end_buf, &iwe, NULL);
+
+	iwe.cmd = IWEVQUAL;
+	iwe.u.qual.level = -si->rssiVal;
+	iwe.u.qual.updated = IW_QUAL_DBM | IW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID | IW_QUAL_LEVEL_UPDATED;
+	cev = iwe_stream_add_event(info, cev, end_buf,
+				   &iwe, IW_EV_QUAL_LEN);
+
+	/* RSN */
+	memset(&iwe, 0, sizeof(iwe));
+
+	len = rs9110_synthesize_ie(buf, si);
+	if (len) {
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = len;
+		cev = iwe_stream_add_point(info, cev, end_buf, &iwe, buf);
+	}
+
+	return cev;
+}
+
+static int rs21_set_scan(struct net_device *ndev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_scan_req *sr = (struct iw_scan_req *)extra;
+	rsi_scanFrame scanFrame = {};
+	int ret;
+
+	if (sr->essid_len) {
+		memcpy(scanFrame.ssid, sr->essid, sr->essid_len);
+		scanFrame.channel = priv->channel;
+	}
+	
+	if ((ret = rsi_scan(priv->spi, &scanFrame, &priv->_scanResponse,
+		     &priv->_scan_sw))) {
+		printk("RS21 Scan request failed\n");
+		return ret;
+	}
+
+	if ((ret = rsi_query_bssid_nwtype(priv->spi,
+					  &priv->_bssid_nwtypeFrame))) {
+		printk("RS21 Scan request[bssid] failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rs21_get_scan(struct net_device *ndev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_point *data = &wrqu->data;
+	char *cev = extra;
+	rsi_scanResponse *sr = &priv->_scanResponse;
+	int i;
+
+	if (priv->_scan_sw && priv->_scan_sw == 0x0002)
+		return 0;
+
+	for (i = 0; i < sr->scanCount; i++) {
+		cev = rsi_translate_scan(priv, &sr->strScanInfo[i],
+					 info, cev, extra + IW_SCAN_MAX_DATA);
+	}
+
+	data->length = cev - extra;
+
+	return 0;
+}
+
+static int rs9110_join(struct rs21_priv *priv, rsi_scanResponse *sr)
+{
+	static rsi_joinFrame jf = {};
+	int i;
+	int ret;
+	u16 sw;
+
+	switch (priv->mode) {
+	case IW_MODE_ADHOC:
+		jf.nwType = RSI_IBSS_OPEN_MODE;
+		break;
+	case IW_MODE_INFRA:
+	default:
+		jf.nwType = RSI_INFRASTRUCTURE_MODE;
+	}
+
+	jf.securityType	= priv->security_mode;;
+
+	if (priv->security_mode == RSI_SECURITY_OPEN) {
+		switch (priv->wpa_level) {
+		case IW_AUTH_WPA_VERSION_DISABLED:
+			if (priv->exclude_unencrypted)
+				jf.securityType = RSI_SECURITY_WEP;
+			break;
+		case IW_AUTH_WPA_VERSION_WPA:
+			jf.securityType = RSI_SECURITY_WPA1;
+			break;
+		case IW_AUTH_WPA_VERSION_WPA2:
+			jf.securityType = RSI_SECURITY_WPA2;
+			break;
+		}
+	}
+
+	if (priv->bitrate == 0)
+		jf.dataRate = RSI_DATA_RATE_AUTO;
+	else
+		jf.dataRate = priv->bitrate;
+
+	if (priv->txpower < 10)
+		jf.powerLevel = RSI_POWER_LEVEL_LOW;
+	else if (priv->txpower < 15)
+		jf.powerLevel = RSI_POWER_LEVEL_MEDIUM;
+	else
+		jf.powerLevel = RSI_POWER_LEVEL_HIGH;
+
+	memcpy(jf.ssid, priv->essid, priv->essid_len);
+
+	switch (priv->security_mode) {
+	case RSI_SECURITY_WPA1:
+	case RSI_SECURITY_WPA2:
+	case RSI_SECURITY_WEP:
+		memcpy(jf.psk,
+		       priv->keys[priv->current_key],
+		       priv->key_lens[priv->current_key]);
+		break;
+	default:
+		switch (priv->wpa_level) {
+		case IW_AUTH_WPA_VERSION_DISABLED:
+			memcpy(jf.psk,
+			       priv->keys[priv->current_key],
+			       priv->key_lens[priv->current_key]);
+			printk("%s:", __func__);
+			for (i = 0; i < priv->key_lens[priv->current_key]; ++i)
+				printk(" %02x", jf.psk[i]);
+			printk("\n");
+			break;
+		case IW_AUTH_WPA_VERSION_WPA:
+		case IW_AUTH_WPA_VERSION_WPA2:
+			memcpy(jf.psk, priv->psk, priv->psk_len);
+			printk("%s:", __func__);
+			for (i = 0; i < priv->psk_len; ++i)
+				printk(" %02x", jf.psk[i]);
+			printk("\n");
+			break;
+		}
+	}
+
+	if ((ret = rsi_join(priv->spi, &jf, &sw)))
+		return ret;
+
+	if (sw)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int rs21_set_auth(struct net_device *netdev,
+			 struct iw_request_info *info,
+			 union iwreq_data *data, char *extra)
+{
+	struct iw_param *param = &data->param;
+	struct rs21_priv *priv = netdev_priv(netdev);
+	unsigned long irqflag;
+	int ret = 0;
+
+#if DEBUG
+	printk("%s: <- %d %08x %08x\n", __func__, param->flags & IW_AUTH_INDEX, param->flags, param->value);
+#endif
+	spin_lock_irqsave(&priv->lock, irqflag);
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+		if (param->value & IW_AUTH_WPA_VERSION_DISABLED) {
+			printk("%s: NO WPA selected\n", __func__);
+			priv->wpa_level = param->value;
+		}
+		if (param->value & IW_AUTH_WPA_VERSION_WPA) {
+			printk("%s: WPA version 1 selected\n", __func__);
+			priv->wpa_level = param->value;
+		}
+		if (param->value & IW_AUTH_WPA_VERSION_WPA2) {
+			priv->wpa_level = param->value;
+		}
+		break;
+
+
+	case IW_AUTH_DROP_UNENCRYPTED:
+		priv->exclude_unencrypted = param->value ? 1 : 0;
+		break;
+	case IW_AUTH_80211_AUTH_ALG:
+		if (param->value & IW_AUTH_ALG_SHARED_KEY) {
+			printk("%s: shared key specified\n", __func__);
+			priv->auth_alg = IW_AUTH_ALG_SHARED_KEY;
+		} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+			printk("%s: open system specified\n", __func__);
+			priv->auth_alg = IW_AUTH_ALG_OPEN_SYSTEM;
+		} else
+			ret = -EINVAL;
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		if (param->value) {
+			printk("%s: WPA enabled %d\n", __func__, param->value);
+			//if (priv->wpa_level == IW_AUTH_WPA_VERSION_DISABLED)
+			priv->wpa_level = IW_AUTH_WPA_VERSION_WPA;
+		} else {
+			printk("%s: WPA disabled\n", __func__);
+			priv->wpa_level = IW_AUTH_WPA_VERSION_DISABLED;
+		}
+		break;
+	case IW_AUTH_KEY_MGMT:
+		if (param->value & IW_AUTH_KEY_MGMT_PSK)
+			break;
+		/* intentionally fall through */
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	if (!ret)
+		;//set_bit(GELIC_WL_STAT_CONFIGURED, &wl->stat);
+
+	spin_unlock_irqrestore(&priv->lock, irqflag);
+	return ret;
+}
+
+static int rs21_get_auth(struct net_device *netdev,
+			 struct iw_request_info *info,
+			 union iwreq_data *iwreq, char *extra)
+{
+	struct iw_param *param = &iwreq->param;
+	int ret = 0;
+
+	pr_debug("%s: <- %d\n", __func__, param->flags & IW_AUTH_INDEX);
+	pr_debug("%s: -> %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int rs21_set_essid(struct net_device *ndev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *essid)
+{
+	struct iw_point *data = &wrqu->data;
+	struct rs21_priv *priv = netdev_priv(ndev);
+	if (data->length > sizeof (priv->essid))
+		return -EINVAL;
+
+	priv->essid_len = data->length;	
+	memset(priv->essid, 0, sizeof (priv->essid));
+	memcpy(priv->essid, essid, priv->essid_len);
+
+	return 0;
+}
+
+static int rs21_get_essid(struct net_device *ndev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *essid)
+{
+	struct iw_point *data = &wrqu->data;
+	struct rs21_priv *priv = netdev_priv(ndev);
+
+	memcpy(essid, priv->essid, priv->essid_len);
+	data->length = priv->essid_len;
+	data->flags = 1;
+
+	return 0;
+}
+
+static int rs21_set_rate(struct net_device *ndev,
+			 struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *essid)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_param *bitrate = &wrqu->bitrate;
+	int i;
+
+	if (bitrate->value == -1 && bitrate->fixed == 0) {
+		priv->bitrate = 0;
+		return 0;
+	} else if (bitrate->fixed) {
+		for (i = 0; i < ARRAY_SIZE(rs21_bitrates); i++) {
+			if (bitrate->value == rs21_bitrates[i] * 100000) {
+				priv->bitrate = i + 1;
+				return 0;
+			}
+		}
+	} else {
+		int min_diff = -1;
+		int diff;
+
+		for (i = 0; i < ARRAY_SIZE(rs21_bitrates); i++) {
+			diff = bitrate->value - rs21_bitrates[i] * 100000;
+			if (diff >= 0)
+				min_diff = min_diff == -1 ?
+					diff : min(min_diff, diff);
+		}
+
+		if (min_diff == -1)
+			return -EINVAL;
+		for (i = 0; i < ARRAY_SIZE(rs21_bitrates); i++) {
+			if (rs21_bitrates[i] * 100000 ==
+			    bitrate->value - min_diff) {
+				priv->bitrate = i + 1;
+				return 0;
+			}
+		}
+	}
+
+	return -EINVAL;
+}
+
+static int rs21_get_rate(struct net_device *ndev,
+			 struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *essid)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_param *bitrate = &wrqu->bitrate;
+
+	if (priv->bitrate == 0) {
+		bitrate->value = 0;
+		bitrate->fixed = 0;
+	} else {
+		bitrate->value = rs21_bitrates[priv->bitrate - 1] * 100000;
+		bitrate->fixed = 1;
+	}
+	bitrate->disabled = 0;
+
+	return 0;
+}
+
+static int rs21_set_txpow(struct net_device *ndev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_param *txpower = &wrqu->txpower;
+
+	if (txpower->disabled == 1) /* off */
+		return -EINVAL;
+
+	if (txpower->value == -1) /* auto */
+		priv->txpower = 12;
+	else if (!txpower->fixed)
+		return -EINVAL;
+	else if (txpower->value < 6 || 18 <= txpower->value)
+		return -EINVAL;
+	else
+		priv->txpower = txpower->value;
+	return 0;
+}
+
+static int rs21_get_txpow(struct net_device *ndev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_param *txpower = &wrqu->txpower;
+
+	txpower->value = priv->txpower;
+	txpower->fixed = 0;
+	txpower->disabled = 0;
+	txpower->flags = IW_TXPOW_DBM;
+
+	return 0;
+}
+
+static int rs21_set_encode(struct net_device *ndev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *key)
+{
+	struct iw_point *enc = &wrqu->encoding;
+	struct rs21_priv *priv = netdev_priv(ndev);
+	unsigned long irqflag;
+	int key_index = enc->flags & IW_ENCODE_INDEX, index_specified;
+	__u16 flags = enc->flags & IW_ENCODE_FLAGS;
+	int ret = 0;
+
+	if (RS9110_KEY_NUM < key_index)
+		return -EINVAL;
+
+	spin_lock_irqsave(&priv->lock, irqflag);
+	if (key_index) {
+		index_specified = 1;
+		key_index--;
+	} else {
+		index_specified = 0;
+		key_index = priv->current_key;
+	}
+
+	if (flags & IW_ENCODE_NOKEY) {
+		/* if just IW_ENCODE_NOKEY, change current key index */
+		if (!flags && index_specified) {
+			priv->current_key = key_index;
+			goto done;
+		}
+
+		if (flags & IW_ENCODE_DISABLED) {
+			if (!index_specified) {
+				/* invalidate all key */
+				priv->key_enabled = 0;
+			} else
+				clear_bit(key_index, &priv->key_enabled);
+		}
+	} else {
+		if (IW_ENCODING_TOKEN_MAX < enc->length) {
+			ret = -EINVAL;
+			goto done;
+		}
+		priv->key_lens[key_index] = enc->length;
+		memcpy(priv->keys[key_index], key, enc->length);
+		set_bit(key_index, &priv->key_enabled);
+	}
+
+done:
+	spin_unlock_irqrestore(&priv->lock, irqflag);
+	return ret;
+}
+
+static int rs21_get_encode(struct net_device *ndev,
+			   struct iw_request_info *info,
+			   union iwreq_data *data, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_point *enc = &data->encoding;
+	unsigned int key_index = enc->flags & IW_ENCODE_INDEX, index_specified;
+	unsigned long irqflag;
+	int ret = 0;
+	
+	if (RS9110_KEY_NUM < key_index)
+		return -EINVAL;
+
+	spin_lock_irqsave(&priv->lock, irqflag);
+	if (key_index) {
+		index_specified = 1;
+		key_index--;
+	} else {
+		index_specified = 0;
+		key_index = priv->current_key;
+	}
+
+	if (test_bit(key_index, &priv->key_enabled)) {
+		if (enc->length < priv->key_lens[key_index]) {
+			ret = -EINVAL;
+			goto done;
+		}
+		enc->length = priv->key_lens[key_index];
+		memcpy(extra, priv->keys[key_index],
+		       priv->key_lens[key_index]);
+	} else {
+		enc->length = 0;
+		enc->flags |= IW_ENCODE_NOKEY;
+	}
+	enc->flags |= key_index + 1;
+done:
+	spin_unlock_irqrestore(&priv->lock, irqflag);
+	return ret;
+}
+
+static int rs21_set_encodeext(struct net_device *ndev,
+			      struct iw_request_info *info,
+			      union iwreq_data *data, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_point *enc = &data->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	__u16 alg;
+	__u16 flags;
+	unsigned long irqflag;
+	int key_index;
+	int ret = 0;
+
+	flags = enc->flags & IW_ENCODE_FLAGS;
+	alg = ext->alg;
+	key_index = enc->flags & IW_ENCODE_INDEX;
+
+	if (RS9110_KEY_NUM < key_index)
+		return -EINVAL;
+
+	spin_lock_irqsave(&priv->lock, irqflag);
+
+	if (key_index)
+		key_index--;
+	else
+		key_index = priv->current_key;
+
+	if (!enc->length && (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)) {
+		/* reques to change default key index */
+		printk("%s: request to change default key to %d\n",
+		       __func__, key_index);
+		priv->current_key = key_index;
+		goto done;
+	}
+
+	if (alg == IW_ENCODE_ALG_NONE || (flags & IW_ENCODE_DISABLED)) {
+		printk("%s: alg disabled\n", __func__);
+		priv->wpa_level = IW_AUTH_WPA_VERSION_DISABLED;
+	} else if (alg == IW_ENCODE_ALG_WEP) {
+		printk("%s: WEP requested\n", __func__);
+		if (flags & IW_ENCODE_OPEN) {
+			pr_info("%s: open key mode\n", __func__);
+		}
+		if (flags & IW_ENCODE_RESTRICTED) {
+			pr_info("%s: shared key mode\n", __func__);
+		}
+		if (IW_ENCODING_TOKEN_MAX < ext->key_len) {
+			pr_info("%s: key is too long %d\n", __func__,
+				ext->key_len);
+			ret = -EINVAL;
+			goto done;
+		}
+		/* OK, update the key */
+		priv->key_lens[key_index] = ext->key_len;
+		memset(priv->keys[key_index], 0, IW_ENCODING_TOKEN_MAX);
+		memcpy(priv->keys[key_index], ext->key, ext->key_len);
+		set_bit(key_index, &priv->key_enabled);
+	} else if (alg == IW_ENCODE_ALG_PMK) {
+
+		if (ext->key_len != 32/*WPA_PSK_LEN*/) {
+			pr_err("%s: PSK length wrong %d\n", __func__,
+			       ext->key_len);
+			ret = -EINVAL;
+			goto done;
+		}
+		memset(priv->psk, 0, sizeof(priv->psk));
+		memcpy(priv->psk, ext->key, ext->key_len);
+		priv->psk_len = ext->key_len;
+	}
+done:
+	spin_unlock_irqrestore(&priv->lock, irqflag);
+	return ret;
+}
+
+static int rs21_get_encodeext(struct net_device *ndev,
+			      struct iw_request_info *info,
+			      union iwreq_data *data, char *extra)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_point *enc = &data->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	unsigned long irqflag;
+	int key_index;
+	int ret = 0;
+	int max_key_len;
+
+	max_key_len = enc->length - sizeof(struct iw_encode_ext);
+	if (max_key_len < 0)
+		return -EINVAL;
+	key_index = enc->flags & IW_ENCODE_INDEX;
+
+	if (RS9110_KEY_NUM < key_index)
+		return -EINVAL;
+
+	spin_lock_irqsave(&priv->lock, irqflag);
+
+	if (key_index)
+		key_index--;
+	else
+		key_index = priv->current_key;
+
+	memset(ext, 0, sizeof(struct iw_encode_ext));
+	spin_unlock_irqrestore(&priv->lock, irqflag);
+	return ret;
+}
+
+static int rs21_set_power(struct net_device *ndev,
+			   struct iw_request_info *info,
+			   struct iw_param *power, char *extra)
+{
+	return 0;
+}
+
+static int rs21_get_power(struct net_device *ndev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *key)
+{
+	return 0;
+}
+
+#define IW_IOCTL(n) [(n) - SIOCIWFIRST]
+static const iw_handler rs21_iw_handlers[] = {
+	IW_HANDLER(SIOCGIWNAME, rs21_get_name),
+	IW_HANDLER(SIOCGIWRANGE, rs21_get_range),
+	IW_HANDLER(SIOCSIWMODE, rs21_set_mode),
+	IW_HANDLER(SIOCGIWMODE, rs21_get_mode),
+	IW_HANDLER(SIOCSIWFREQ, rs21_set_freq),
+	IW_HANDLER(SIOCGIWFREQ, rs21_get_freq),
+	IW_HANDLER(SIOCSIWSCAN, rs21_set_scan),
+	IW_HANDLER(SIOCGIWSCAN, rs21_get_scan),
+	IW_HANDLER(SIOCSIWAUTH, rs21_set_auth),
+	IW_HANDLER(SIOCGIWAUTH, rs21_get_auth),
+	IW_HANDLER(SIOCSIWESSID, rs21_set_essid),
+	IW_HANDLER(SIOCGIWESSID, rs21_get_essid),
+	IW_HANDLER(SIOCSIWRATE, rs21_set_rate),
+	IW_HANDLER(SIOCGIWRATE, rs21_get_rate),
+	IW_HANDLER(SIOCSIWTXPOW, rs21_set_txpow),
+	IW_HANDLER(SIOCGIWTXPOW, rs21_get_txpow),
+	IW_HANDLER(SIOCSIWENCODE, rs21_set_encode),
+	IW_HANDLER(SIOCGIWENCODE, rs21_get_encode),
+	IW_HANDLER(SIOCSIWENCODEEXT, rs21_set_encodeext),
+	IW_HANDLER(SIOCGIWENCODEEXT, rs21_get_encodeext),
+	IW_HANDLER(SIOCSIWPOWER, (iw_handler)rs21_set_power),
+	IW_HANDLER(SIOCGIWPOWER, (iw_handler)rs21_get_power),
+};
+
+static int rs21_set_security_mode(struct net_device * ndev,
+				  struct iw_request_info * info,
+				  struct iw_param * rrq, char * extra)
+{
+	struct rs21_priv * priv = netdev_priv(ndev);
+
+	priv->security_mode = rrq->value;
+
+	return 0;
+}
+
+static int rs21_get_security_mode(struct net_device * ndev,
+				  struct iw_request_info * info,
+				  struct iw_param * rrq, char * extra)
+{
+	struct rs21_priv * priv = netdev_priv(ndev);
+
+	rrq->value = priv->security_mode;
+	rrq->fixed = 1;
+	return 0;
+}
+
+static const iw_handler rs21_private_handler[] = {
+	(iw_handler)rs21_set_security_mode,	/* RS9110SIWSECMODE */
+	(iw_handler)rs21_get_security_mode,	/* RS9110GIWSECMODE */
+};
+
+static const struct iw_priv_args rs21_private_args[] = {
+	{
+		RS9110SIWSECMODE,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+		IW_PRIV_TYPE_NONE,
+		"setsecuritymode"
+	}, {
+		RS9110GIWSECMODE,
+		IW_PRIV_TYPE_NONE,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+		"getsecuritymode"
+	},
+};
+
+
+static struct iw_statistics *rs21_get_wireless_stats(struct net_device *ndev)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	struct iw_quality *qual = &priv->iwstats.qual;
+	u16 rssi;
+
+	if (priv->joined)
+	{
+		rsi_query_rssi(priv->spi, &rssi);
+		qual->level = rssi;
+		qual->updated = IW_QUAL_DBM | IW_QUAL_QUAL_INVALID | IW_QUAL_NOISE_INVALID;
+	}
+
+	return &priv->iwstats;
+}
+
+
+static const struct iw_handler_def rs21_iw_handler_def = {
+	.standard		= rs21_iw_handlers,
+	.num_standard		= ARRAY_SIZE(rs21_iw_handlers),
+	.num_private 		= ARRAY_SIZE(rs21_private_handler),
+	.num_private_args 	= ARRAY_SIZE(rs21_private_args),
+	.private 		= rs21_private_handler,
+	.private_args 		= rs21_private_args,
+	.get_wireless_stats	= rs21_get_wireless_stats,
+};
+
+static int rs21_open(struct net_device *ndev)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	rsi_scanResponse sr;
+	u16 sw;
+	rsi_scanFrame sf = {};
+	int ret;
+#if DEBUG
+	printk("********** rs21_open **********\n" );
+#endif
+
+	if ((ret = rsi_scan(priv->spi, &sf, &sr, &sw)))
+		return ret;
+
+	if (sw && sw != 0x0002)
+		return -EINVAL;
+
+	schedule_delayed_work(&priv->assoc_work, 0);
+
+	netif_start_queue(ndev);
+
+	return 0;
+}
+
+static int rs21_close(struct net_device *ndev)
+{
+	netif_stop_queue(ndev);
+
+	return 0;
+}
+
+static void rs21_tx_skb(struct rs21_priv *priv, struct sk_buff *skb)
+{
+	struct net_device *ndev = priv->ndev;
+	struct spi_device *spi = priv->spi;
+	struct net_device_stats *stats = &priv->stats;
+	char *data, short_pkt[ETH_ZLEN];
+	int len;
+	int intr_status;
+
+	len = skb->len;
+	data = skb->data;
+
+	if (len < ETH_ZLEN) {
+		memset(short_pkt, 0, sizeof (short_pkt));
+		memcpy(short_pkt, skb->data, skb->len);
+		len = sizeof (short_pkt);
+		data = short_pkt;
+	} else if (len & 3) {
+	  //skb_put(skb, 4 - (len & 3));
+	}
+
+	for ( ; ; ) {
+		down(&priv->spi_sem);
+# if DEBUG_SEM
+		printk("TX: -DOWN-\n");
+# endif
+		intr_status = rsi_irqstatus2(spi);
+# if DEBUG_SEM
+		printk("TX: --UP-- .\n");
+# endif
+		if (!(intr_status & RSI_IRQ_BUFFERFULL))
+			break;
+#if DEBUG
+		printk(KERN_DEBUG "buffer full... isr=%02x\n", (u8)intr_status);
+#endif
+		up(&priv->spi_sem);
+
+		wait_for_completion_timeout(&priv->buff_comp, HZ);
+#if DEBUG
+		printk(KERN_DEBUG "buffer free...\n");
+#endif
+	}
+
+	/* MUST BE SEM DOWN */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
+	netif_trans_update(ndev);
+#else
+	ndev->trans_start = jiffies;
+#endif
+	stats->tx_packets++;
+	stats->tx_bytes += len;
+
+	rsi_send_raw_data(spi, data, len);
+#if DEBUG_SEM
+	printk("TX: --UP--\n");
+#endif
+	up(&priv->spi_sem);
+
+	dev_kfree_skb(skb);
+}
+
+static void rs9110_process_tx(struct rs21_priv *priv)
+{
+	struct net_device *ndev = priv->ndev;
+	unsigned long flags;
+	struct sk_buff *skb;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	while (priv->skb_rp != priv->skb_wp) {
+		skb = priv->skbs[priv->skb_rp];
+		priv->skb_rp = (priv->skb_rp + 1) & (RS21_BUFFER_LEN - 1);
+
+		netif_wake_queue(ndev);
+
+		spin_unlock_irqrestore(&priv->lock, flags);
+
+		rs21_tx_skb(priv, skb);
+
+		spin_lock_irqsave(&priv->lock, flags);
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static void rs21_tx_work(struct work_struct *work)
+{
+	struct rs21_priv *priv = container_of(work, struct rs21_priv, tx_work);
+
+	rs9110_process_tx(priv);
+}
+
+static int rs21_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+	u32 skb_wp;
+
+	spin_lock(&priv->lock);
+
+	priv->skbs[priv->skb_wp] = skb;
+	skb_wp = (priv->skb_wp + 1) & (RS21_BUFFER_LEN - 1);
+	if (skb_wp == priv->skb_rp) {
+		netif_stop_queue(ndev);
+
+		spin_unlock(&priv->lock);
+
+#if DEBUG
+		printk(KERN_DEBUG "%s: RS21 SKB BUFFER FULL %d == %d !!!!\n", __func__, skb_wp, priv->skb_rp);
+#endif
+
+		return NETDEV_TX_BUSY;
+	}
+	priv->skb_wp = skb_wp;
+
+	spin_unlock(&priv->lock);
+
+	schedule_work(&priv->tx_work);
+
+	return NETDEV_TX_OK;
+}
+
+static void rs21_tx_timeout(struct net_device *ndev)
+{
+	struct rs21_priv *priv = netdev_priv(ndev);
+
+#if DEBUG
+	printk("%s: atomic=%d queue=%d\n", __func__, in_atomic(), netif_queue_stopped(ndev));
+#endif
+
+	priv->stats.tx_errors++;
+
+	netif_wake_queue(ndev);
+}
+
+static struct net_device_stats *rs21_get_stats(struct net_device *ndev)
+{
+	return &((struct rs21_priv *)netdev_priv(ndev))->stats;
+}
+
+static const struct net_device_ops rs21_netdev_ops = {
+	.ndo_open	= rs21_open,
+	.ndo_stop	= rs21_close,
+	.ndo_start_xmit	= rs21_start_xmit,
+	.ndo_tx_timeout	= rs21_tx_timeout,
+	.ndo_get_stats	= rs21_get_stats,
+};
+
+static void rsi_assoc_work(struct work_struct *work)
+{
+	int retry = 2;
+	struct rs21_priv *priv =
+		container_of((struct delayed_work *)work, struct rs21_priv, assoc_work);
+	rsi_scanFrame sf = {};
+	rsi_scanResponse sr;
+	u16 sw;
+	int ret;
+
+	if (priv->joined)
+		return;
+redo:
+	if ((ret = rsi_scan(priv->spi, &sf, &sr, &sw))) {
+		printk("%s: scan failed %d\n", __func__, ret);
+		return;
+	}
+
+	if (sw && sw != 0x0002)
+		return;
+
+	if ((ret = rs9110_join(priv, &sr))) {
+		if (priv->join_sw == 0x0002)
+			return;
+		if (retry-- > 0)
+			goto redo;
+	}
+}
+
+int rsi_sys_init(struct spi_device *spi)
+{
+	int ret;
+	struct rs21_priv *priv = rsi_priv(spi);
+
+	memset(priv, 0, sizeof (*priv));
+	priv->spi = spi;
+	priv->bitrate = 0;
+	priv->txpower = 12;
+	spin_lock_init(&priv->lock);
+	spin_lock_init(&priv->tx_skb_lock);
+	INIT_WORK(&priv->work, rsi_work);
+	INIT_DELAYED_WORK(&priv->assoc_work, rsi_assoc_work);
+	sema_init(&priv->spi_sem, 1);
+	sema_init(&priv->init_sem, 1);
+	sema_init(&priv->scan_sem, 1);
+	sema_init(&priv->join_sem, 1);
+	sema_init(&priv->qmac_sem, 1);
+	sema_init(&priv->test_sem, 1);
+	init_completion(&priv->init_comp);
+	init_completion(&priv->scan_comp);
+	init_completion(&priv->join_comp);
+	init_completion(&priv->qmac_comp);
+	init_completion(&priv->buff_comp);
+	init_waitqueue_head(&priv->buffer_wq);
+	init_waitqueue_head(&priv->init_waitq);
+	init_waitqueue_head(&priv->scan_waitq);
+	init_waitqueue_head(&priv->join_waitq);
+	priv->current_key = 0;
+	priv->key_enabled = 0;
+
+	ret = rsi_spi_iface_init(spi);
+
+	return ret;
+}
+
+static int rs21_spi_probe(struct spi_device *spi)
+{
+	int ret;
+	struct net_device *ndev;
+	struct rs21_priv *priv;
+	struct rs9110_platform_data *pdata = spi->dev.platform_data;
+	u8 fwversion[FIRM_VER_LEN + 1];
+	struct device_node *np;
+	int i;
+
+	int power_no =0, reset_no = 0;
+
+	if (spi->master->flags & SPI_MASTER_HALF_DUPLEX)
+		return -EINVAL;
+
+	spi->mode = SPI_MODE_0;
+	//spi->mode = SPI_MODE_3;
+	spi->bits_per_word = 8;
+
+	if ((ret = spi_setup(spi)))
+		return ret;
+
+	ndev = alloc_etherdev(sizeof (struct rs21_priv));
+	strcpy(ndev->name, "wlan%d");
+
+	ndev->netdev_ops = &rs21_netdev_ops;
+	ndev->watchdog_timeo = 5 * HZ;
+
+	if( of_machine_is_compatible("ap,aprzg0a") )
+	{
+	      	np = of_find_node_by_path("/spi@e6e20000/wmrp0x_spi@0");
+		if( np ) {
+	      		power_no = of_get_named_gpio(np, "gpio_power", 0);
+	      		reset_no = of_get_named_gpio(np, "gpio_reset", 0);
+	      		printk( "%s: gpio_power(GPIO2_26)=%d\n", __func__, power_no );
+	      		printk( "%s: gpio_reset(GPIO4_7)=%d\n", __func__, reset_no );
+	      		ndev->irq = irq_of_parse_and_map(np, 0);
+	      		of_node_put(np);
+	      	} else {
+	      		ndev->irq = 0;
+		      	dev_err(&spi->dev, "irq_of_parse_and_map failed\n" );
+	      	}
+		if( 0 < reset_no ) {
+			if( gpio_request( reset_no, "WiFi !Reset" ) == 0) {
+				gpio_direction_output( reset_no, 0 );
+				gpio_export( reset_no, false );
+			} else {
+				printk( "%s: gpio_request failed(WiFi Reset)\n", __func__ );
+			}
+		}
+		if( 0 < power_no ) {
+			if( gpio_request( power_no, "WiFi Power" ) == 0) {
+				gpio_direction_output( power_no, 1 );
+				gpio_export( power_no, false );
+			} else {
+				printk( "%s: gpio_request failed(WiFi Power)\n", __func__ );
+			}
+		}
+		if( 0 < reset_no ) {
+			// PowerON Rset > 20ms
+			for( i = 0; i < 20000 / MaxDelay + 1; i++ ) {
+				udelay( MaxDelay );
+			}
+			gpio_set_value( reset_no, 1 );
+		}
+	}
+	else if( of_machine_is_compatible("ap,aprzn0a")  )
+	{
+		np = of_find_node_by_path("/bus/spi@0x50005000/wmrp0x_spi@0");
+		if ( np ) {
+			power_no = of_get_named_gpio(np, "gpio_power", 0);
+			reset_no = of_get_named_gpio(np, "gpio_reset", 0);
+			of_node_put(np);
+#if DEBUG
+			printk( "%s: power_no = %d\n", __func__, power_no );
+			printk( "%s: reset_no = %d\n", __func__, reset_no );
+#endif
+		} else {
+			printk( "%s: of_find_node_by_path(\"/bus/spi@0x50005000/wmrp0x_spi@0\") failed \n", __func__ );
+		}
+		if( ndev->irq == 0 ) {
+			np = of_find_node_by_path("/bus/spi@0x50005000/wmrp0x_spi@0");
+			if( np ) {
+				ndev->irq = irq_of_parse_and_map(np, 0);
+				of_node_put(np);
+			} else {
+				ndev->irq = 0;
+				dev_err(&spi->dev, "irq_of_parse_and_map failed\n" );
+			}
+		}
+		if( 0 < reset_no ) {
+			if( gpio_request( reset_no, "WiFi !Reset" ) == 0) {
+				gpio_direction_output( reset_no, 0 );
+			gpio_export( reset_no, false );
+			} else {
+				printk( "%s: gpio_request failed(WiFi Reset)\n", __func__ );
+			}
+		}
+		if( 0 < power_no ) {
+			if( gpio_request( power_no, "WiFi Power" ) == 0) {
+				gpio_direction_output( power_no, 1 );
+				gpio_export( power_no, false );
+			} else {
+				printk( "%s: gpio_request failed(WiFi Power)\n", __func__ );
+			}
+		}
+		if( 0 < reset_no ) {
+			// PowerON Reset > 20ms
+			for( i = 0; i < 20000 / MaxDelay + 1; i++ ) {
+				udelay( MaxDelay );
+			}
+			gpio_set_value( reset_no, 1 );
+		}
+	}
+	else if( of_machine_is_compatible("apj,xg3358") || of_machine_is_compatible("apj,xg3352") )
+	{
+		if( ndev->irq == 0 ) {
+			np = of_find_node_by_path("/ocp/spi@481a0000/wmrp0x_spi@0");
+			if( np ) {
+				ndev->irq = irq_of_parse_and_map(np, 0);
+				of_node_put(np);
+			} else {
+				ndev->irq = 0;
+				dev_err(&spi->dev, "irq_of_parse_and_map failed\n" );
+			}
+		}
+	}
+	
+	printk("%s: spi_irq=%d, ndev->irq=%d\n", __func__, spi->irq, ndev->irq );
+	ndev->wireless_handlers = &rs21_iw_handler_def;
+
+	priv = netdev_priv(ndev);
+	dev_set_drvdata(&spi->dev, priv);
+
+	if ((ret = rsi_sys_init(spi))) {
+		dev_err(&spi->dev, "RS21 SPI Initialization failed %d\n", ret);
+
+		free_netdev(ndev);
+		return -ENODEV;
+	}
+
+	if ((ret = register_netdev(ndev)))
+		return ret;
+
+	priv->ndev = ndev;
+	priv->pdata = pdata;
+	priv->mode = IW_MODE_INFRA;
+	priv->gpio_power = power_no;
+	priv->gpio_reset = reset_no;
+	INIT_WORK(&priv->tx_work, rs21_tx_work);
+	if ((ret = rsi_bootloader(spi))) {
+		dev_err(&spi->dev, "rsi_bootloader failed %d\n", ret);
+		return ret;
+	}
+
+	printk("rsi_bootloader ok\n");
+	if (ndev->irq == NO_IRQ) {
+#if USE_TIMER
+		init_timer(&priv->timer);
+		priv->timer.expires = jiffies + pdata->poll_period;
+		setup_timer(&priv->timer, rs9110_poll_irq, priv);
+		add_timer(&priv->timer);
+#else
+		kthread_run(rs9110_thread, ndev, "rs9110");
+#endif
+	} else {
+		if ((ret = request_irq( ndev->irq, rsi_interrupt,
+				       IRQF_TRIGGER_HIGH,
+				       ndev->name, 
+				       ndev))) {
+			printk("request_irq(%d) failed %d\n",
+			       ndev->irq, ret);
+			return ret;
+		}
+	}
+
+	memset(fwversion, 0, sizeof(fwversion));
+
+	rsi_band(spi, 0);
+	rsi_spi_mode_sel(spi, 21);
+	rsi_init(spi);
+	rsi_query_macaddress(spi, ndev->dev_addr);
+	printk("RS9110: MAC Address: %pM\n", ndev->dev_addr);
+	rsi_query_fwversion(spi, fwversion);
+	printk("RS9110: Firmware Version: %s\n", fwversion);
+
+	return 0;
+}
+
+static int /* __devexit */ rs21_spi_remove(struct spi_device *spi)
+{
+	struct rs21_priv *priv = dev_get_drvdata(&spi->dev);
+
+	flush_scheduled_work();
+
+	unregister_netdev(priv->ndev);
+
+	free_netdev(priv->ndev);
+
+	dev_set_drvdata(&spi->dev, NULL);
+
+	if( priv->gpio_power ) gpio_free( priv->gpio_power );
+	if( priv->gpio_reset ) gpio_free( priv->gpio_reset );
+
+	return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct spi_device_id rs21_spi_idtable[] = {
+	{ "WMRP0X_SPI", 0},
+	{}
+};
+
+static const struct of_device_id rs21_spi_of_match[] = {
+         { .compatible = "apj,wmrp0x_spi" },
+         {},
+};
+
+MODULE_DEVICE_TABLE(spi, rs21_spi_idtable);
+
+#endif
+
+
+static struct spi_driver rs21_spi_driver = {
+	.driver = {
+		.name	= "wmrp0x_spi",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr( rs21_spi_of_match )
+	},
+	.probe	= rs21_spi_probe,
+	.remove	= rs21_spi_remove,
+};
+
+static int __init rs21_init(void)
+{
+	return spi_register_driver(&rs21_spi_driver);
+}
+
+static void __exit rs21_exit(void)
+{
+	spi_unregister_driver(&rs21_spi_driver);
+}
+
+static int __init rs9110_fwupgrade_setup(char *__unused)
+{
+	fwupgrade = 1;
+	return 0;
+}
+
+
+__setup("rs9110_fwupgrade", rs9110_fwupgrade_setup);
+
+module_init(rs21_init);
+module_exit(rs21_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("ALPHAPROJECT");
+
diff --git a/drivers/net/wireless/wmrp0xs/rs9110.h b/drivers/net/wireless/wmrp0xs/rs9110.h
new file mode 100644
index 0000000..113254f
--- /dev/null
+++ b/drivers/net/wireless/wmrp0xs/rs9110.h
@@ -0,0 +1,9 @@
+#ifndef __LINUX_SPI_RS9110_H
+#define __LINUX_SPI_RS9110_H
+
+struct rs9110_platform_data {
+	int (*get_irq_pin_state)(void);
+	int poll_period;
+};
+
+#endif
diff --git a/drivers/spi/spi-sh-msiof.c b/drivers/spi/spi-sh-msiof.c
index e80245a..9f6321c 100644
--- a/drivers/spi/spi-sh-msiof.c
+++ b/drivers/spi/spi-sh-msiof.c
@@ -357,6 +357,8 @@ static void sh_msiof_spi_set_pin_regs(struct sh_msiof_spi_priv *p,
 	tmp |= !cs_high << MDR1_SYNCAC_SHIFT;
 	tmp |= lsb_first << MDR1_BITLSB_SHIFT;
 	tmp |= sh_msiof_spi_get_dtdl_and_syncdl(p);
+	// The frame synchronization signal output at MSIOF_SS1.
+	tmp |= 0x04000000;
 	if (p->mode == SPI_MSIOF_MASTER)
 		sh_msiof_write(p, TMDR1, tmp | MDR1_TRMD | TMDR1_PCON);
 	else
@@ -655,6 +657,7 @@ static int sh_msiof_spi_txrx_once(struct sh_msiof_spi_priv *p,
 
 	/* setup msiof transfer mode registers */
 	sh_msiof_spi_set_mode_regs(p, tx_buf, rx_buf, bits, words);
+	sh_msiof_write(p, STR, sh_msiof_read(p, STR ) | ~(STR_TEOF | STR_REOF) );
 	sh_msiof_write(p, IER, IER_TEOFE | IER_REOFE);
 
 	/* write tx fifo */
diff --git a/drivers/usb/gadget/legacy/serial.c b/drivers/usb/gadget/legacy/serial.c
index c5d42e0..b8db1a6 100644
--- a/drivers/usb/gadget/legacy/serial.c
+++ b/drivers/usb/gadget/legacy/serial.c
@@ -35,10 +35,15 @@ USB_GADGET_COMPOSITE_OPTIONS();
 * DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
 * Instead:  allocate your own, using normal USB-IF procedures.
 */
+#ifdef CONFIG_MACH_APRZG0A
+#define GS_VENDOR_ID			0x0D91	/* AlphaProject */
+#define GS_CDC_PRODUCT_ID		0x2027	/* ... as CDC-ACM */
+#else
 #define GS_VENDOR_ID			0x0525	/* NetChip */
 #define GS_PRODUCT_ID			0xa4a6	/* Linux-USB Serial Gadget */
 #define GS_CDC_PRODUCT_ID		0xa4a7	/* ... as CDC-ACM */
 #define GS_CDC_OBEX_PRODUCT_ID		0xa4a9	/* ... as CDC-OBEX */
+#endif
 
 /* string IDs are assigned dynamically */
 
@@ -248,6 +253,13 @@ static int __init init(void)
 	/* We *could* export two configs; that'd be much cleaner...
 	 * but neither of these product IDs was defined that way.
 	 */
+#ifdef CONFIG_MACH_APRZG0A
+	serial_config_driver.label = "CDC ACM config";
+	serial_config_driver.bConfigurationValue = 2;
+	device_desc.bDeviceClass = USB_CLASS_COMM;
+	device_desc.idProduct =
+			cpu_to_le16(GS_CDC_PRODUCT_ID);
+#else
 	if (use_acm) {
 		serial_config_driver.label = "CDC ACM config";
 		serial_config_driver.bConfigurationValue = 2;
@@ -267,6 +279,7 @@ static int __init init(void)
 		device_desc.idProduct =
 				cpu_to_le16(GS_PRODUCT_ID);
 	}
+#endif
 	strings_dev[STRING_DESCRIPTION_IDX].s = serial_config_driver.label;
 
 	return usb_composite_probe(&gserial_driver);
diff --git a/include/dt-bindings/clock/r8a7745-clock.h b/include/dt-bindings/clock/r8a7745-clock.h
index 509e193..bae7158 100644
--- a/include/dt-bindings/clock/r8a7745-clock.h
+++ b/include/dt-bindings/clock/r8a7745-clock.h
@@ -30,6 +30,7 @@
 /* MSTP1 */
 #define R8A7745_CLK_VCP0		1
 #define R8A7745_CLK_VPC0		3
+#define R8A7745_CLK_ADG			6
 #define R8A7745_CLK_TMU1		11
 #define R8A7745_CLK_3DG			12
 #define R8A7745_CLK_2DDMAC		15
diff --git a/include/media/vscam01.h b/include/media/vscam01.h
new file mode 100755
index 0000000..e237128
--- /dev/null
+++ b/include/media/vscam01.h
@@ -0,0 +1,33 @@
+/* VS-CAM-01 Camera
+ *
+ * Copyright (C) 2009 Renesas Solutions Corp.
+ * Kuninori Morimoto <morimoto.kuninori@renesas.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __VSCAM01_H__
+#define __VSCAM01_H__
+
+#define VSCAM01_FLAG_PCLK_RISING_EDGE	(1 << 0)
+#define VSCAM01_FLAG_DATAWIDTH_8	(1 << 1) /* default width is 10 */
+
+#define V4L2_IDENT_VSCAM01  65000
+
+struct vscam01_pll_divider {
+	u8 m, n;
+	u8 p1, p2, p3, p4, p5, p6, p7;
+};
+
+/*
+ * VS-CAM-01 camera info
+ */
+struct vscam01_camera_info {
+	u32 flags;
+	struct vscam01_pll_divider divider;
+};
+
+#endif /* __VSCAM01_H__ */
+
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index cfdafc4..eb8e0da 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -79,6 +79,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_MAX9850 if I2C
 	select SND_SOC_MAX9768 if I2C
 	select SND_SOC_MAX9877 if I2C
+	select SND_SOC_MAX9867 if I2C
 	select SND_SOC_MC13783 if MFD_MC13XXX
 	select SND_SOC_ML26124 if I2C
 	select SND_SOC_NAU8825 if I2C
@@ -902,6 +903,9 @@ config SND_SOC_MAX9768
 config SND_SOC_MAX9877
 	tristate
 
+config SND_SOC_MAX9867
+	tristate
+
 config SND_SOC_MC13783
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index f632fc4..666bd4c 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -72,6 +72,7 @@ snd-soc-max98095-objs := max98095.o
 snd-soc-max98357a-objs := max98357a.o
 snd-soc-max98925-objs := max98925.o
 snd-soc-max9850-objs := max9850.o
+snd-soc-max9867-objs := max9867.o
 snd-soc-mc13783-objs := mc13783.o
 snd-soc-ml26124-objs := ml26124.o
 snd-soc-nau8825-objs := nau8825.o
@@ -267,6 +268,7 @@ obj-$(CONFIG_SND_SOC_MAX98095)	+= snd-soc-max98095.o
 obj-$(CONFIG_SND_SOC_MAX98357A)	+= snd-soc-max98357a.o
 obj-$(CONFIG_SND_SOC_MAX98925)	+= snd-soc-max98925.o
 obj-$(CONFIG_SND_SOC_MAX9850)	+= snd-soc-max9850.o
+obj-$(CONFIG_SND_SOC_MAX9867)	+= snd-soc-max9867.o
 obj-$(CONFIG_SND_SOC_MC13783)	+= snd-soc-mc13783.o
 obj-$(CONFIG_SND_SOC_ML26124)	+= snd-soc-ml26124.o
 obj-$(CONFIG_SND_SOC_NAU8825)   += snd-soc-nau8825.o
diff --git a/sound/soc/codecs/max9867.c b/sound/soc/codecs/max9867.c
new file mode 100644
index 0000000..1daf403
--- /dev/null
+++ b/sound/soc/codecs/max9867.c
@@ -0,0 +1,543 @@
+/*
+ * max9867.c -- max9867 ALSA SoC Audio driver
+ *
+ * Copyright 2013-15 Maxim Integrated Products
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include "max9867.h"
+
+static const char *const max9867_spmode[] = {
+	"Stereo Diff", "Mono Diff",
+	"Stereo Cap", "Mono Cap",
+	"Stereo Single", "Mono Single",
+	"Stereo Single Fast", "Mono Single Fast"
+};
+static const char *const max9867_sidetone_text[] = {
+	"None", "Left", "Right", "LeftRight", "LeftRightDiv2",
+};
+static const char *const max9867_filter_text[] = {"IIR", "FIR"};
+
+static SOC_ENUM_SINGLE_DECL(max9867_filter, MAX9867_CODECFLTR, 7,
+	max9867_filter_text);
+static SOC_ENUM_SINGLE_DECL(max9867_spkmode, MAX9867_MODECONFIG, 0,
+	max9867_spmode);
+static SOC_ENUM_SINGLE_DECL(max9867_sidetone, MAX9867_DACGAIN, 6,
+	max9867_sidetone_text);
+static DECLARE_TLV_DB_SCALE(max9860_capture_tlv, -600, 200, 0);
+static DECLARE_TLV_DB_SCALE(max9860_mic_tlv, 2000, 100, 1);
+static DECLARE_TLV_DB_SCALE(max9860_adc_left_tlv, -1200, 100, 1);
+static DECLARE_TLV_DB_SCALE(max9860_adc_right_tlv, -1200, 100, 1);
+static const unsigned int max98088_micboost_tlv[] = {
+       TLV_DB_RANGE_HEAD(2),
+       0, 1, TLV_DB_SCALE_ITEM(0, 2000, 0),
+       2, 2, TLV_DB_SCALE_ITEM(3000, 0, 0),
+};
+
+static const struct snd_kcontrol_new max9867_snd_controls[] = {
+	SOC_DOUBLE_R("Master Playback Volume", MAX9867_LEFTVOL,
+				MAX9867_RIGHTVOL, 0, 63, 1),
+	SOC_DOUBLE_R_TLV("Capture Volume", MAX9867_LEFTMICGAIN,
+			MAX9867_RIGHTMICGAIN,
+			0, 15, 1, max9860_capture_tlv),
+	SOC_DOUBLE_R_TLV("Mic Volume", MAX9867_LEFTMICGAIN,
+			MAX9867_RIGHTMICGAIN, 0, 31, 1, max9860_mic_tlv),
+	SOC_DOUBLE_R_TLV("Mic Boost Volume", MAX9867_LEFTMICGAIN,
+			MAX9867_RIGHTMICGAIN, 5, 3, 0, max98088_micboost_tlv),
+	SOC_ENUM("Digital Sidetone Src", max9867_sidetone),
+	SOC_SINGLE("Sidetone Volume", MAX9867_DACGAIN, 0, 31, 1),
+	SOC_SINGLE("DAC Volume", MAX9867_DACLEVEL, 4, 3, 0),
+	SOC_SINGLE("DAC Attenuation", MAX9867_DACLEVEL, 0, 15, 1),
+	SOC_SINGLE_TLV("ADC Left Volume", MAX9867_ADCLEVEL,
+			4, 15, 1, max9860_adc_left_tlv),
+	SOC_SINGLE_TLV("ADC Right Volume", MAX9867_ADCLEVEL,
+			0, 15, 1, max9860_adc_right_tlv),
+	SOC_ENUM("Speaker Mode", max9867_spkmode),
+	SOC_SINGLE("Volume Smoothing Switch", MAX9867_MODECONFIG, 6, 1, 0),
+	SOC_SINGLE("ZCD Switch", MAX9867_MODECONFIG, 5, 1, 0),
+	SOC_ENUM("DSP Filter", max9867_filter),
+};
+
+static const char *const max9867_mux[] = {"None", "Mic", "Line", "Mic_Line"};
+
+static SOC_ENUM_DOUBLE_DECL(max9867_mux_enum,
+	MAX9867_INPUTCONFIG, MAX9867_INPUT_SHIFT_L, MAX9867_INPUT_SHIFT_R,
+	max9867_mux);
+
+static const struct snd_kcontrol_new max9867_dapm_mux_controls =
+	SOC_DAPM_ENUM("Route", max9867_mux_enum);
+
+static const struct snd_kcontrol_new max9867_left_dapm_control =
+	SOC_DAPM_SINGLE("Switch", MAX9867_PWRMAN, 6, 1, 0);
+static const struct snd_kcontrol_new max9867_right_dapm_control =
+	SOC_DAPM_SINGLE("Switch", MAX9867_PWRMAN, 5, 1, 0);
+static const struct snd_kcontrol_new max9867_line_dapm_control =
+	SOC_DAPM_SINGLE("Switch", MAX9867_LEFTLINELVL, 6, 1, 1);
+
+static const struct snd_soc_dapm_widget max9867_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN("DAI_OUT", "HiFi Playback", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_DAC("Left DAC", NULL, MAX9867_PWRMAN, 3, 0),
+	SND_SOC_DAPM_DAC("Right DAC", NULL, MAX9867_PWRMAN, 2, 0),
+	SND_SOC_DAPM_MIXER("Output Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_OUTPUT("HPOUT"),
+
+	SND_SOC_DAPM_AIF_IN("DAI_IN", "HiFi Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_ADC("Left ADC", "HiFi Capture", MAX9867_PWRMAN, 1, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "HiFi Capture", MAX9867_PWRMAN, 0, 0),
+	SND_SOC_DAPM_MUX("Input Mux", SND_SOC_NOPM, 0, 0,
+		&max9867_dapm_mux_controls),
+
+	SND_SOC_DAPM_MIXER("Input Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_SWITCH("Left Line", MAX9867_LEFTLINELVL, 6, 1,
+		&max9867_left_dapm_control),
+	SND_SOC_DAPM_SWITCH("Right Line", MAX9867_RIGTHLINELVL, 6, 1,
+		&max9867_right_dapm_control),
+	SND_SOC_DAPM_SWITCH("Line Mixer", SND_SOC_NOPM, 0, 0,
+		&max9867_line_dapm_control),
+	SND_SOC_DAPM_INPUT("LINE_IN"),
+};
+
+static const struct snd_soc_dapm_route max9867_audio_map[] = {
+	{"Left DAC", NULL, "DAI_OUT"},
+	{"Right DAC", NULL, "DAI_OUT"},
+	{"Output Mixer", NULL, "Left DAC"},
+	{"Output Mixer", NULL, "Right DAC"},
+	{"HPOUT", NULL, "Output Mixer"},
+
+	{"Left ADC", NULL, "DAI_IN"},
+	{"Right ADC", NULL, "DAI_IN"},
+	{"Input Mixer", NULL, "Left ADC"},
+	{"Input Mixer", NULL, "Right ADC"},
+	{"Input Mux", "Line", "Input Mixer"},
+	{"Input Mux", "Mic", "Input Mixer"},
+	{"Input Mux", "Mic_Line", "Input Mixer"},
+	{"Right Line", "Switch", "Input Mux"},
+	{"Left Line", "Switch", "Input Mux"},
+	{"LINE_IN", NULL, "Left Line"},
+	{"LINE_IN", NULL, "Right Line"},
+};
+
+enum rates {
+	pcm_rate_8, pcm_rate_16, pcm_rate_24,
+	pcm_rate_32, pcm_rate_44,
+	pcm_rate_48, max_pcm_rate,
+};
+
+struct ni_div_rates {
+	u32 mclk;
+	u16 ni[max_pcm_rate];
+} ni_div[] = {
+	{11289600, {0x116A, 0x22D4, 0x343F, 0x45A9, 0x6000, 0x687D} },
+	{12000000, {0x1062, 0x20C5, 0x3127, 0x4189, 0x5A51, 0x624E} },
+	{12187500, {0x1022, 0x2044, 0x3065, 0x4087, 0x58ED, 0x60CB} },
+	{12288000, {0x1000, 0x2000, 0x3000, 0x4000, 0x5833, 0x6000} },
+	{13000000, {0x0F20, 0x1E3F, 0x2D5F, 0x3C7F, 0x535F, 0x5ABE} },
+	{19200000, {0x0A3D, 0x147B, 0x1EB8, 0x28F6, 0x3873, 0x3D71} },
+	{24000000, {0x1062, 0x20C5, 0x3127, 0x4189, 0x5A51, 0x624E} },
+	{26000000, {0x0F20, 0x1E3F, 0x2D5F, 0x3C7F, 0x535F, 0x5ABE} },
+	{27000000, {0x0E90, 0x1D21, 0x2BB1, 0x3A41, 0x5048, 0x5762} },
+};
+
+static inline int get_ni_value(int mclk, int rate)
+{
+	int i, ret = 0;
+
+	/* find the closest rate index*/
+	for (i = 0; i < ARRAY_SIZE(ni_div); i++) {
+		if (ni_div[i].mclk >= mclk)
+			break;
+	}
+	if (i == ARRAY_SIZE(ni_div))
+		return -EINVAL;
+
+	switch (rate) {
+	case 8000:
+		return ni_div[i].ni[pcm_rate_8];
+	case 16000:
+		return ni_div[i].ni[pcm_rate_16];
+	case 32000:
+		return ni_div[i].ni[pcm_rate_32];
+	case 44100:
+		return ni_div[i].ni[pcm_rate_44];
+	case 48000:
+		return ni_div[i].ni[pcm_rate_48];
+	default:
+		pr_err("%s wrong rate %d\n", __func__, rate);
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int max9867_dai_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);
+	unsigned int ni_h, ni_l;
+	int value;
+
+	value = get_ni_value(max9867->sysclk, params_rate(params));
+	if (value < 0)
+		return value;
+
+	ni_h = (0xFF00 & value) >> 8;
+	ni_l = 0x00FF & value;
+	/* set up the ni value */
+	regmap_update_bits(max9867->regmap, MAX9867_AUDIOCLKHIGH,
+		MAX9867_NI_HIGH_MASK, ni_h);
+	regmap_update_bits(max9867->regmap, MAX9867_AUDIOCLKLOW,
+		MAX9867_NI_LOW_MASK, ni_l);
+	if (!max9867->master) {
+		/*
+		 * digital pll locks on to any externally supplied LRCLK signal
+		 * and also enable rapid lock mode.
+		 */
+		regmap_update_bits(max9867->regmap, MAX9867_AUDIOCLKLOW,
+			MAX9867_RAPID_LOCK, MAX9867_RAPID_LOCK);
+		regmap_update_bits(max9867->regmap, MAX9867_AUDIOCLKHIGH,
+			MAX9867_PLL, MAX9867_PLL);
+	} else {
+		unsigned long int bclk_rate, pclk_bclk_ratio;
+		int bclk_value;
+
+		bclk_rate = params_rate(params) * 2 * snd_pcm_format_width(params_format(params));
+		pclk_bclk_ratio = max9867->pclk/bclk_rate;
+		switch (snd_pcm_format_width(params_format(params))) {
+		case 8:
+		case 16:
+			switch (pclk_bclk_ratio) {
+			case 1: case 2:
+				bclk_value = MAX9867_IFC1B_PCLK_2;
+				break;
+			case 3: case 4:
+				bclk_value = MAX9867_IFC1B_PCLK_4;
+				break;
+			case 5: case 6: case 7: case 8:
+				bclk_value = MAX9867_IFC1B_PCLK_8;
+				break;
+			default:
+				bclk_value = MAX9867_IFC1B_PCLK_16;
+				break;
+			}
+			break;
+		case 24:
+			bclk_value = MAX9867_IFC1B_24BIT;
+			break;
+		case 32:
+			bclk_value = MAX9867_IFC1B_32BIT;
+			break;
+		default:
+			dev_err(codec->dev, "unsupported sampling rate\n");
+			return -EINVAL;
+		}
+		regmap_update_bits(max9867->regmap, MAX9867_IFC1B,
+			MAX9867_IFC1B_BCLK_MASK, bclk_value);
+	}
+	return 0;
+}
+
+static int max9867_prepare(struct snd_pcm_substream *substream,
+			 struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);
+
+	regmap_update_bits(max9867->regmap, MAX9867_PWRMAN,
+		MAX9867_SHTDOWN_MASK, MAX9867_SHTDOWN_MASK);
+
+	return 0;
+}
+
+static int max9867_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);
+
+	if (mute)
+		regmap_update_bits(max9867->regmap, MAX9867_DACLEVEL,
+			MAX9867_DAC_MUTE_MASK, MAX9867_DAC_MUTE_MASK);
+	else
+		regmap_update_bits(max9867->regmap, MAX9867_DACLEVEL,
+			MAX9867_DAC_MUTE_MASK, 0);
+	return 0;
+}
+
+static int max9867_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);
+	int value = 0;
+
+	/* Set the prescaler based on the master clock frequency*/
+	if (freq >= 10000000 && freq <= 20000000) {
+		value |= MAX9867_PSCLK_10_20;
+		max9867->pclk =  freq;
+	} else if (freq >= 20000000 && freq <= 40000000) {
+		value |= MAX9867_PSCLK_20_40;
+		max9867->pclk =  freq/2;
+	} else if (freq >= 40000000 && freq <= 60000000) {
+		value |= MAX9867_PSCLK_40_60;
+		max9867->pclk =  freq/4;
+	} else {
+		pr_err("bad clock frequency %d", freq);
+		return -EINVAL;
+	}
+	value = value << MAX9867_PSCLK_SHIFT;
+	max9867->sysclk = freq;
+	/* exact integer mode is not supported */
+	value &= ~MAX9867_FREQ_MASK;
+	regmap_update_bits(max9867->regmap, MAX9867_SYSCLK,
+			MAX9867_PSCLK_MASK, value);
+	return 0;
+}
+
+static int max9867_dai_set_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);
+	u8 iface1A = 0, iface1B = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		max9867->master = 1;
+		iface1A |= MAX9867_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		max9867->master = 0;
+		iface1A &= ~MAX9867_MASTER;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* for i2s compatible mode */
+	iface1A |= MAX9867_I2S_DLY;
+	/* SDOUT goes to hiz state after all data is transferred */
+	iface1A |= MAX9867_SDOUT_HIZ;
+
+	/* Clock inversion bits, BCI and WCI */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface1A |= MAX9867_WCI_MODE | MAX9867_BCI_MODE;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface1A |= MAX9867_BCI_MODE;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface1A |= MAX9867_WCI_MODE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_write(max9867->regmap, MAX9867_IFC1A, iface1A);
+	regmap_write(max9867->regmap, MAX9867_IFC1B, iface1B);
+	return 0;
+}
+
+static struct snd_soc_dai_ops max9867_dai_ops = {
+	.set_fmt = max9867_dai_set_fmt,
+	.set_sysclk	= max9867_set_dai_sysclk,
+	.prepare	= max9867_prepare,
+	.digital_mute	= max9867_mute,
+	.hw_params = max9867_dai_hw_params,
+};
+
+#define MAX9867_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\
+	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+#define MAX9867_FORMATS (SNDRV_PCM_FMTBIT_S16_LE)
+
+static struct snd_soc_dai_driver max9867_dai[] = {
+	{
+	.name = "max9867-aif1",
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = MAX9867_RATES,
+		.formats = MAX9867_FORMATS,
+	},
+	.capture = {
+		.stream_name = "HiFi Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = MAX9867_RATES,
+		.formats = MAX9867_FORMATS,
+	},
+	.ops = &max9867_dai_ops,
+	}
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int max9867_suspend(struct device *dev)
+{
+	struct max9867_priv *max9867 = dev_get_drvdata(dev);
+
+	/* Drop down to power saving mode when system is suspended */
+	regmap_update_bits(max9867->regmap, MAX9867_PWRMAN,
+		MAX9867_SHTDOWN_MASK, ~MAX9867_SHTDOWN_MASK);
+	return 0;
+}
+
+static int max9867_resume(struct device *dev)
+{
+	struct max9867_priv *max9867 = dev_get_drvdata(dev);
+
+	regmap_update_bits(max9867->regmap, MAX9867_PWRMAN,
+		MAX9867_SHTDOWN_MASK, MAX9867_SHTDOWN_MASK);
+	return 0;
+}
+#endif
+
+static int max9867_probe(struct snd_soc_codec *codec)
+{
+	struct max9867_priv *max9867 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "max98090_probe\n");
+	max9867->codec = codec;
+	return 0;
+}
+
+static struct snd_soc_codec_driver max9867_codec = {
+	.probe				= max9867_probe,
+	.controls			= max9867_snd_controls,
+	.num_controls		= ARRAY_SIZE(max9867_snd_controls),
+	.dapm_routes		= max9867_audio_map,
+	.num_dapm_routes	= ARRAY_SIZE(max9867_audio_map),
+	.dapm_widgets		= max9867_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(max9867_dapm_widgets),
+};
+
+static bool max9867_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MAX9867_STATUS:
+	case MAX9867_JACKSTATUS:
+	case MAX9867_AUXHIGH:
+	case MAX9867_AUXLOW:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct reg_default max9867_reg[] = {
+	{ 0x04, 0x00 },
+	{ 0x05, 0x00 },
+	{ 0x06, 0x00 },
+	{ 0x07, 0x00 },
+	{ 0x08, 0x00 },
+	{ 0x09, 0x00 },
+	{ 0x0A, 0x00 },
+	{ 0x0B, 0x00 },
+	{ 0x0C, 0x00 },
+	{ 0x0D, 0x00 },
+	{ 0x0E, 0x00 },
+	{ 0x0F, 0x00 },
+	{ 0x10, 0x00 },
+	{ 0x11, 0x00 },
+	{ 0x12, 0x00 },
+	{ 0x13, 0x00 },
+	{ 0x14, 0x00 },
+	{ 0x15, 0x00 },
+	{ 0x16, 0x00 },
+	{ 0x17, 0x00 },
+};
+
+static const struct regmap_config max9867_regmap = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.max_register	= MAX9867_REVISION,
+	.reg_defaults	= max9867_reg,
+	.num_reg_defaults = ARRAY_SIZE(max9867_reg),
+	.volatile_reg	= max9867_volatile_register,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+static int max9867_i2c_probe(struct i2c_client *i2c,
+		const struct i2c_device_id *id)
+{
+	struct max9867_priv *max9867;
+	int ret = 0, reg;
+
+	max9867 = devm_kzalloc(&i2c->dev,
+			sizeof(*max9867), GFP_KERNEL);
+	if (!max9867)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, max9867);
+	max9867->regmap = devm_regmap_init_i2c(i2c, &max9867_regmap);
+	if (IS_ERR(max9867->regmap)) {
+		ret = PTR_ERR(max9867->regmap);
+		dev_err(&i2c->dev,
+				"Failed to allocate regmap: %d\n", ret);
+		return ret;
+	}
+	ret = regmap_read(max9867->regmap,
+			MAX9867_REVISION, &reg);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "Failed to read: %d\n", ret);
+		return ret;
+	}
+	dev_info(&i2c->dev, "device revision: %x\n", reg);
+	ret = snd_soc_register_codec(&i2c->dev, &max9867_codec,
+			max9867_dai, ARRAY_SIZE(max9867_dai));
+	if (ret < 0) {
+		dev_err(&i2c->dev, "Failed to register codec: %d\n", ret);
+		return ret;
+	}
+	return ret;
+}
+
+static int max9867_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	return 0;
+}
+
+static const struct i2c_device_id max9867_i2c_id[] = {
+	{ "max9867", 0 },
+	{ }
+};
+
+static const struct of_device_id max9867_of_match[] = {
+	{ .compatible = "maxim,max9867", },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, max9867_i2c_id);
+
+static const struct dev_pm_ops max9867_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(max9867_suspend, max9867_resume)
+};
+
+static struct i2c_driver max9867_i2c_driver = {
+	.driver = {
+		.name = "max9867",
+		.of_match_table = of_match_ptr(max9867_of_match),
+		.pm = &max9867_pm_ops,
+	},
+	.probe  = max9867_i2c_probe,
+	.remove = max9867_i2c_remove,
+	.id_table = max9867_i2c_id,
+};
+
+module_i2c_driver(max9867_i2c_driver);
+
+MODULE_AUTHOR("anish kumar <yesanishhere@gmail.com>");
+MODULE_DESCRIPTION("ALSA SoC MAX9867 driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/max9867.h b/sound/soc/codecs/max9867.h
new file mode 100644
index 0000000..ceb3076
--- /dev/null
+++ b/sound/soc/codecs/max9867.h
@@ -0,0 +1,84 @@
+/*
+ * max9867.h -- MAX9867 ALSA SoC Audio driver
+ *
+ * Copyright 2013-2015 Maxim Integrated Products
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _MAX9867_H
+#define _MAX9867_H
+
+/* MAX9867 register space */
+
+#define MAX9867_STATUS        0x00
+#define MAX9867_JACKSTATUS   0x01
+#define MAX9867_AUXHIGH      0x02
+#define MAX9867_AUXLOW       0x03
+#define MAX9867_INTEN        0x04
+#define MAX9867_SYSCLK       0x05
+#define MAX9867_FREQ_MASK    0xF
+#define MAX9867_PSCLK_SHIFT  0x4
+#define MAX9867_PSCLK_WIDTH  0x2
+#define MAX9867_PSCLK_MASK   (0x03<<MAX9867_PSCLK_SHIFT)
+#define MAX9867_PSCLK_10_20  0x1
+#define MAX9867_PSCLK_20_40  0x2
+#define MAX9867_PSCLK_40_60  0x3
+#define MAX9867_AUDIOCLKHIGH 0x06
+#define MAX9867_NI_HIGH_WIDTH 0x7
+#define MAX9867_NI_HIGH_MASK 0x7F
+#define MAX9867_NI_LOW_MASK 0xFF
+#define MAX9867_NI_LOW_SHIFT 0x0
+#define MAX9867_PLL     (1<<7)
+#define MAX9867_AUDIOCLKLOW  0x07
+#define MAX9867_RAPID_LOCK   0x01
+#define MAX9867_IFC1A        0x08
+#define MAX9867_MASTER       (1<<7)
+#define MAX9867_I2S_DLY      (1<<4)
+#define MAX9867_SDOUT_HIZ    (1<<3)
+#define MAX9867_TDM_MODE     (1<<2)
+#define MAX9867_WCI_MODE     (1<<6)
+#define MAX9867_BCI_MODE     (1<<5)
+#define MAX9867_IFC1B        0x09
+#define MAX9867_IFC1B_BCLK_MASK 7
+#define MAX9867_IFC1B_32BIT  0x01
+#define MAX9867_IFC1B_24BIT  0x02
+#define MAX9867_IFC1B_PCLK_2 4
+#define MAX9867_IFC1B_PCLK_4 5
+#define MAX9867_IFC1B_PCLK_8 6
+#define MAX9867_IFC1B_PCLK_16 7
+#define MAX9867_CODECFLTR    0x0a
+#define MAX9867_DACGAIN      0x0b
+#define MAX9867_DACLEVEL     0x0c
+#define MAX9867_DAC_MUTE_SHIFT 0x6
+#define MAX9867_DAC_MUTE_WIDTH 0x1
+#define MAX9867_DAC_MUTE_MASK (0x1<<MAX9867_DAC_MUTE_SHIFT)
+#define MAX9867_ADCLEVEL     0x0d
+#define MAX9867_LEFTLINELVL  0x0e
+#define MAX9867_RIGTHLINELVL 0x0f
+#define MAX9867_LEFTVOL      0x10
+#define MAX9867_RIGHTVOL     0x11
+#define MAX9867_LEFTMICGAIN  0x12
+#define MAX9867_RIGHTMICGAIN 0x13
+#define MAX9867_INPUTCONFIG  0x14
+#define MAX9867_INPUT_SHIFT_L  0x6
+#define MAX9867_INPUT_SHIFT_R  0x4
+#define MAX9867_MICCONFIG    0x15
+#define MAX9867_MODECONFIG   0x16
+#define MAX9867_PWRMAN       0x17
+#define MAX9867_SHTDOWN_MASK ((1<<7) | 0x3)
+#define MAX9867_REVISION     0xff
+
+#define MAX9867_CACHEREGNUM 10
+
+/* codec private data */
+struct max9867_priv {
+	struct regmap *regmap;
+	struct snd_soc_codec *codec;
+	unsigned int sysclk;
+	unsigned int pclk;
+	unsigned int master;
+};
+#endif
diff --git a/sound/soc/sh/rcar/adg.c b/sound/soc/sh/rcar/adg.c
index b123734..c754db3 100644
--- a/sound/soc/sh/rcar/adg.c
+++ b/sound/soc/sh/rcar/adg.c
@@ -360,11 +360,19 @@ int rsnd_adg_ssi_clk_try_start(struct rsnd_mod *mod, unsigned int rate)
 		[CLKA] = 0x1,
 		[CLKB] = 0x2,
 		[CLKC] = 0x3,
+#ifdef CONFIG_MACH_APRZG0A
+		[CLKI] = 0x10, // BGRA Output Clock
+#else
 		[CLKI] = 0x0,
+#endif
 	};
 
 	dev_dbg(dev, "request clock = %d\n", rate);
 
+#ifdef CONFIG_MACH_APRZG0A
+	data = 0x10; // BGRA Output Clock
+	goto found_clock;
+#endif
 	/*
 	 * find suitable clock from
 	 * AUDIO_CLKA/AUDIO_CLKB/AUDIO_CLKC/AUDIO_CLKI.
@@ -490,8 +498,13 @@ static void rsnd_adg_get_clkout(struct rsnd_priv *priv,
 			continue;
 
 		/* RBGA */
+#ifdef CONFIG_MACH_APRZG0A
+		if (!adg->rbga_rate_for_441khz) {
+			div = 16;
+#else
 		if (!adg->rbga_rate_for_441khz && (0 == rate % 44100)) {
 			div = 6;
+#endif
 			if (req_441kHz_rate)
 				div = rate / req_441kHz_rate;
 			rbgx = rsnd_adg_calculate_rbgx(div);
@@ -505,8 +518,13 @@ static void rsnd_adg_get_clkout(struct rsnd_priv *priv,
 		}
 
 		/* RBGB */
+#ifdef CONFIG_MACH_APRZG0A
+		if (!adg->rbgb_rate_for_48khz) {
+			div = 16;
+#else
 		if (!adg->rbgb_rate_for_48khz && (0 == rate % 48000)) {
 			div = 6;
+#endif
 			if (req_48kHz_rate)
 				div = rate / req_48kHz_rate;
 			rbgx = rsnd_adg_calculate_rbgx(div);
@@ -563,8 +581,13 @@ static void rsnd_adg_get_clkout(struct rsnd_priv *priv,
 	}
 
 	rsnd_mod_bset(adg_mod, SSICKR, 0x00FF0000, ckr);
+#ifdef CONFIG_MACH_APRZG0A
+	rsnd_mod_write(adg_mod, BRRA,  0x00000007); /* 1/16 */
+	rsnd_mod_write(adg_mod, BRRB,  0x00000007); /* 1/16 */
+#else
 	rsnd_mod_write(adg_mod, BRRA,  rbga);
 	rsnd_mod_write(adg_mod, BRRB,  rbgb);
+#endif
 
 	for_each_rsnd_clkout(clk, adg, i)
 		dev_dbg(dev, "clkout %d : %p : %ld\n", i, clk, clk_get_rate(clk));
@@ -578,6 +601,15 @@ int rsnd_adg_probe(struct platform_device *pdev,
 {
 	struct rsnd_adg *adg;
 	struct device *dev = rsnd_priv_to_dev(priv);
+#ifdef CONFIG_MACH_APRZG0A
+	static struct clk *adg_clk;
+
+	adg_clk = clk_get(NULL, "adg");
+	if (!IS_ERR(adg_clk)) {
+		clk_prepare(adg_clk);
+		clk_enable(adg_clk);
+	}
+#endif
 
 	adg = devm_kzalloc(dev, sizeof(*adg), GFP_KERNEL);
 	if (!adg) {
diff --git a/sound/soc/sh/rcar/ssi.c b/sound/soc/sh/rcar/ssi.c
index df79d7c..88cbbbe 100644
--- a/sound/soc/sh/rcar/ssi.c
+++ b/sound/soc/sh/rcar/ssi.c
@@ -160,8 +160,12 @@ static int rsnd_ssi_master_clk_start(struct rsnd_ssi *ssi,
 
 		ret = rsnd_adg_ssi_clk_try_start(mod, main_rate);
 		if (0 == ret) {
+#ifdef CONFIG_MACH_APRZG0A
+			ssi->cr_clk	= FORCE | SWL_32 | CKDV(j);
+#else
 			ssi->cr_clk	= FORCE | SWL_32 |
 				SCKD | SWSD | CKDV(j);
+#endif
 
 			dev_dbg(dev, "%s[%d] outputs %u Hz\n",
 				rsnd_mod_name(mod),
@@ -204,6 +208,11 @@ static void rsnd_ssi_hw_start(struct rsnd_ssi *ssi,
 			else
 				rsnd_ssi_master_clk_start(ssi, io);
 		}
+#ifdef CONFIG_MACH_APRZG0A
+		else {
+			rsnd_ssi_master_clk_start(ssi, io);
+		}
+#endif
 	}
 
 	if (rsnd_ssi_is_dma_mode(mod)) {
