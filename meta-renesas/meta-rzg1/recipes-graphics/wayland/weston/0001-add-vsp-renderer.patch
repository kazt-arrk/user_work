From 4ac4b662070c8de9212e80b89bb1630592dc8cc2 Mon Sep 17 00:00:00 2001
From: "Nguyen Van Linh [FGA.BU13.RZG]" <linhNV25@fsoft.com.vn>
Date: Wed, 23 May 2018 10:19:55 +0700
Subject: [PATCH 1/2] add vsp renderer

Signed-off-by: Nguyen Van Linh [FGA.BU13.RZG] <linhNV25@fsoft.com.vn>
---
 Makefile.am                         |   36 +
 compositor/main.c                   |    2 +
 configure.ac                        |   10 +
 libweston/compositor-drm.c          |  138 ++++
 libweston/compositor-drm.h          |    2 +
 libweston/v4l2-compat.h             |   68 ++
 libweston/v4l2-renderer-device.h    |  118 +++
 libweston/v4l2-renderer.c           | 1552 +++++++++++++++++++++++++++++++++++
 libweston/v4l2-renderer.h           |   41 +
 libweston/vsp-renderer.c            | 1184 ++++++++++++++++++++++++++
 10 files changed, 5642 insertions(+)
 create mode 100644 libweston/v4l2-compat.h
 create mode 100644 libweston/v4l2-renderer-device.h
 create mode 100644 libweston/v4l2-renderer.c
 create mode 100644 libweston/v4l2-renderer.h
 create mode 100644 libweston/vsp-renderer.c

diff --git a/Makefile.am b/Makefile.am
index cdf82ab..6638b86 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -326,6 +326,30 @@ gl_renderer_la_SOURCES =			\
	shared/helpers.h
 endif

+if ENABLE_V4L2
+module_LTLIBRARIES += v4l2-renderer.la
+v4l2_renderer_la_LDFLAGS = -module -avoid-version
+v4l2_renderer_la_LIBADD = $(COMPOSITOR_LIBS) $(V4L2_RENDERER_LIBS) $(LIBMEDIACTL_V4L2_LIBS)
+v4l2_renderer_la_CFLAGS =				\
+	$(COMPOSITOR_CFLAGS)			\
+	$(V4L2_RENDERER_CFLAGS) \
+	$(GCC_CFLAGS)
+v4l2_renderer_la_SOURCES =			\
+	libweston/v4l2-renderer.c			\
+	libweston/v4l2-renderer.h			\
+	libweston/v4l2-device.h
+
+module_LTLIBRARIES += v4l2-vsp-device.la
+v4l2_vsp_device_la_LDFLAGS = -module -avoid-version
+v4l2_vsp_device_la_LIBADD = $(COMPOSITOR_LIBS) $(LIBMEDIACTL_V4L2_LIBS)
+v4l2_vsp_device_la_CFLAGS =				\
+	$(COMPOSITOR_CFLAGS)			\
+	$(GCC_CFLAGS)
+v4l2_vsp_device_la_SOURCES =			\
+	libweston/vsp-renderer.c			\
+	libweston/v4l2-device.h
+endif
+
 if ENABLE_X11_COMPOSITOR
 libweston_module_LTLIBRARIES += x11-backend.la
 x11_backend_la_LDFLAGS = -module -avoid-version
diff --git a/compositor/main.c b/compositor/main.c
index 72c3cd1..938f885 100644
--- a/compositor/main.c
+++ b/compositor/main.c
@@ -566,6 +566,7 @@ usage(int error_code)
		"  --seat=SEAT\t\tThe seat that weston should run on\n"
		"  --tty=TTY\t\tThe tty to use\n"
		"  --use-pixman\t\tUse the pixman (CPU) renderer\n"
+		"  --use-v4l2\t\tUse the v4l2 renderer\n"
		"  --current-mode\tPrefer current KMS mode over EDID preferred mode\n\n");
 #endif

@@ -1227,6 +1228,7 @@ load_drm_backend(struct weston_compositor *c,
		{ WESTON_OPTION_INTEGER, "tty", 0, &config.tty },
		{ WESTON_OPTION_BOOLEAN, "current-mode", 0, &wet->drm_use_current_mode },
		{ WESTON_OPTION_BOOLEAN, "use-pixman", 0, &config.use_pixman },
+		{ WESTON_OPTION_BOOLEAN, "use-v4l2", 0, &config.use_v4l2 },
	};

	parse_options(options, ARRAY_LENGTH(options), argc, argv);
diff --git a/configure.ac b/configure.ac
index 7e84c14..e788201 100644
--- a/configure.ac
+++ b/configure.ac
@@ -138,6 +138,15 @@ if test x$enable_egl = xyes; then
	PKG_CHECK_MODULES([GL_RENDERER], [libdrm])
 fi

+AC_ARG_ENABLE(v4l2, [  --disable-v4l2],,
+              enable_v4l2=yes)
+AM_CONDITIONAL(ENABLE_V4L2, test x$enable_v4l2 = xyes)
+if test x$enable_v4l2 = xyes; then
+ AC_DEFINE([ENABLE_V4L2], [1], [Build Weston with V4L2 support])
+ PKG_CHECK_MODULES(V4L2_RENDERER, [libdrm libkms wayland-kms gbm])
+ PKG_CHECK_MODULES(LIBMEDIACTL_V4L2, [libmediactl-v4l2])
+fi
+
 AC_ARG_ENABLE(xkbcommon,
	      AS_HELP_STRING([--disable-xkbcommon], [Disable libxkbcommon
			      support: This is only useful in environments
@@ -693,6 +702,7 @@ AC_MSG_RESULT([

	Cairo Renderer			${with_cairo}
	EGL				${enable_egl}
+  V4L2        ${enable_v4l2}
	libxkbcommon			${enable_xkbcommon}
	xcb_xkb				${have_xcb_xkb}
	XWayland			${enable_xwayland}
diff --git a/libweston/compositor-drm.c b/libweston/compositor-drm.c
index 1d38f05..32ec403 100644
--- a/libweston/compositor-drm.c
+++ b/libweston/compositor-drm.c
@@ -56,6 +56,7 @@
 #include "pixman-renderer.h"
 #include "libbacklight.h"
 #include "libinput-seat.h"
+#include "v4l2-renderer.h"
 #include "launcher-util.h"
 #include "vaapi-recorder.h"
 #include "presentation-time-server-protocol.h"
@@ -113,6 +114,7 @@ struct drm_backend {

	int use_pixman;

+	int use_v4l2;
	struct udev_input input;

	int32_t cursor_width;
@@ -130,6 +132,7 @@ struct drm_fb {
	uint32_t fb_id, stride, handle, size;
	int width, height;
	int fd;
+	int dmafd;
	int is_client_buffer;
	struct weston_buffer_reference buffer_ref;

@@ -210,6 +213,7 @@ struct drm_sprite {
 };

 static struct gl_renderer_interface *gl_renderer;
+static struct v4l2_renderer_interface *v4l2_renderer;

 static const char default_seat[] = "seat0";

@@ -369,8 +373,17 @@ drm_fb_create_dumb(struct drm_backend *b, int width, int height,
	if (fb->map == MAP_FAILED)
		goto err_add_fb;

+	if (b->use_v4l2) {
+		ret = drmPrimeHandleToFD(b->drm.fd, fb->handle, DRM_CLOEXEC,
+					 &fb->dmafd);
+		if (ret)
+			goto err_export_handle;
+	}
+
	return fb;

+err_export_handle:
+	munmap(fb->map, fb->size);
 err_add_fb:
	drmModeRmFB(b->drm.fd, fb->fb_id);
 err_bo:
@@ -635,6 +648,31 @@ drm_output_render_pixman(struct drm_output *output, pixman_region32_t *damage)
 }

 static void
+drm_output_render_v4l2(struct drm_output *output, pixman_region32_t *damage)
+{
+	struct weston_compositor *ec = output->base.compositor;
+	pixman_region32_t total_damage, previous_damage;
+
+	pixman_region32_init(&total_damage);
+	pixman_region32_init(&previous_damage);
+
+	pixman_region32_copy(&previous_damage, damage);
+
+	pixman_region32_union(&total_damage, damage, &output->previous_damage);
+	pixman_region32_copy(&output->previous_damage, &previous_damage);
+
+	output->current_image ^= 1;
+
+	output->next = output->dumb[output->current_image];
+	v4l2_renderer->set_output_buffer(&output->base, output->current_image);
+
+	ec->renderer->repaint_output(&output->base, &total_damage);
+
+	pixman_region32_fini(&total_damage);
+	pixman_region32_fini(&previous_damage);
+}
+
+static void
 drm_output_render(struct drm_output *output, pixman_region32_t *damage)
 {
	struct weston_compositor *c = output->base.compositor;
@@ -642,6 +680,8 @@ drm_output_render(struct drm_output *output, pixman_region32_t *damage)

	if (b->use_pixman)
		drm_output_render_pixman(output, damage);
+	else if (b->use_v4l2)
+		drm_output_render_v4l2(output, damage);
	else
		drm_output_render_gl(output, damage);

@@ -903,6 +943,9 @@ vblank_handler(int fd, unsigned int frame, unsigned int sec, unsigned int usec,
 }

 static void
+drm_output_fini_v4l2(struct drm_output *output);
+
+static void
 drm_output_destroy(struct weston_output *base);

 static void
@@ -1429,6 +1472,8 @@ static void
 drm_output_fini_egl(struct drm_output *output);
 static int
 drm_output_init_pixman(struct drm_output *output, struct drm_backend *b);
+static int
+drm_output_init_v4l2(struct drm_output *output, struct drm_backend *b);
 static void
 drm_output_fini_pixman(struct drm_output *output);

@@ -1479,6 +1524,13 @@ drm_output_switch_mode(struct weston_output *output_base, struct weston_mode *mo
				   "new mode\n");
			return -1;
		}
+	} else if (b->use_v4l2) {
+		drm_output_fini_v4l2(output);
+		if (drm_output_init_v4l2(output, b) < 0) {
+			weston_log("failed to init output v4l2 state with "
+				   "new mode\n");
+			return -1;
+		}
	} else {
		drm_output_fini_egl(output);
		if (drm_output_init_egl(output, b) < 0) {
@@ -1654,6 +1706,16 @@ init_pixman(struct drm_backend *b)
	return pixman_renderer_init(b->compositor);
 }

+static int
+init_v4l2(struct drm_backend *b)
+{
+	v4l2_renderer = weston_load_module("v4l2-renderer.so",
+					   "v4l2_renderer_interface");
+	if (!v4l2_renderer)
+		return -1;
+
+	return v4l2_renderer->init(b->compositor, b->drm.fd, b->drm.filename);
+}
 /**
  * Add a mode to output's mode list
  *
@@ -2001,6 +2063,69 @@ drm_output_fini_pixman(struct drm_output *output)
	}
 }

+static int
+drm_output_init_v4l2(struct drm_output *output, struct drm_backend *c)
+{
+	int w = output->base.current_mode->width;
+	int h = output->base.current_mode->height;
+	uint32_t format = output->gbm_format;
+	uint32_t pixman_format;
+	unsigned int i;
+	struct v4l2_bo_state bo_state[ARRAY_LENGTH(output->dumb)];
+
+	switch (format) {
+		case GBM_FORMAT_XRGB8888:
+			pixman_format = PIXMAN_x8r8g8b8;
+			break;
+		case GBM_FORMAT_RGB565:
+			pixman_format = PIXMAN_r5g6b5;
+			break;
+		default:
+			weston_log("Unsupported pixman format 0x%x\n", format);
+			return -1;
+	}
+
+	for (i = 0; i < ARRAY_LENGTH(output->dumb); i++) {
+		output->dumb[i] = drm_fb_create_dumb(c, w, h, format);
+		if (!output->dumb[i])
+			goto err;
+		bo_state[i].dmafd = output->dumb[i]->dmafd;
+		bo_state[i].map = output->dumb[i]->map;
+		bo_state[i].stride = output->dumb[i]->stride;
+	}
+
+	if (v4l2_renderer->output_create(&output->base, bo_state, ARRAY_LENGTH(output->dumb)) < 0)
+		goto err;
+
+	pixman_region32_init_rect(&output->previous_damage,
+				  output->base.x, output->base.y, output->base.width, output->base.height);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_LENGTH(output->dumb); i++) {
+		if (output->dumb[i])
+			drm_fb_destroy_dumb(output->dumb[i]);
+
+		output->dumb[i] = NULL;
+	}
+
+	return -1;
+}
+
+static void
+drm_output_fini_v4l2(struct drm_output *output)
+{
+	unsigned int i;
+
+	v4l2_renderer->output_destroy(&output->base);
+
+	for (i = 0; i < ARRAY_LENGTH(output->dumb); i++) {
+		drm_fb_destroy_dumb(output->dumb[i]);
+		output->dumb[i] = NULL;
+	}
+}
+
 static void
 edid_parse_string(const uint8_t *data, char text[])
 {
@@ -2439,6 +2564,11 @@ drm_output_enable(struct weston_output *base)
			weston_log("Failed to init output pixman state\n");
			goto err_free;
		}
+	} else if (b->use_v4l2) {
+		if (drm_output_init_v4l2(output, b) < 0) {
+			weston_log("Failed to init output v4l2 state\n");
+			goto err_free;
+		}
	} else if (drm_output_init_egl(output, b) < 0) {
		weston_log("Failed to init output gl state\n");
		goto err_free;
@@ -2505,6 +2635,8 @@ drm_output_deinit(struct weston_output *base)

	if (b->use_pixman)
		drm_output_fini_pixman(output);
+	else if (b->use_v4l2)
+		drm_output_fini_v4l2(output);
	else
		drm_output_fini_egl(output);

@@ -3217,6 +3349,7 @@ drm_backend_create(struct weston_compositor *compositor,
	b->sprites_are_broken = 1;
	b->compositor = compositor;
	b->use_pixman = config->use_pixman;
+	b->use_v4l2 = config->use_v4l2;

	if (parse_gbm_format(config->gbm_format, GBM_FORMAT_XRGB8888, &b->gbm_format) < 0)
		goto err_compositor;
@@ -3259,6 +3392,11 @@ drm_backend_create(struct weston_compositor *compositor,
			weston_log("failed to initialize pixman renderer\n");
			goto err_udev_dev;
		}
+	} else if (b->use_v4l2) {
+		if (init_v4l2(b) < 0) {
+			weston_log("failed to initialize v4l2 renderer\n");
+			goto err_udev_dev;
+		}
	} else {
		if (init_egl(b) < 0) {
			weston_log("failed to initialize egl\n");
diff --git a/libweston/compositor-drm.h b/libweston/compositor-drm.h
index 2e2995a..160805e 100644
--- a/libweston/compositor-drm.h
+++ b/libweston/compositor-drm.h
@@ -110,6 +110,8 @@ struct weston_drm_backend_config {
	/** Whether to use the pixman renderer instead of the OpenGL ES renderer. */
	bool use_pixman;

+	/** Whether to use the v4l2 renderer insted of the OpenGL ES renderer. */
+	bool use_v4l2;
	/** The seat to be used for input and output.
	 *
	 * If NULL the default "seat0" will be used.  The backend will
diff --git a/libweston/v4l2-compat.h b/libweston/v4l2-compat.h
new file mode 100644
index 0000000..6385877
--- /dev/null
+++ b/libweston/v4l2-compat.h
@@ -0,0 +1,68 @@
+/*
+ *  videodev2.h compatible header
+ *
+ *  Copyright (C) 1999-2007 the contributors
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  Alternatively you can redistribute this file under the terms of the
+ *  BSD license as stated below:
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *  3. The names of its contributors may not be used to endorse or promote
+ *     products derived from this software without specific prior written
+ *     permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This file is based on <linux/videodev2.h>
+ */
+
+#ifndef __V4L2_COMPAT_H__
+#define __V4L2_COMPAT_H__
+
+#include <linux/videodev2.h>
+
+#ifndef V4L2_PIX_FMT_ABGR32
+#define V4L2_PIX_FMT_ABGR32  v4l2_fourcc('A', 'R', '2', '4') /* 32  BGRA-8-8-8-8  */
+#endif
+
+#ifndef V4L2_PIX_FMT_ARGB32
+#define V4L2_PIX_FMT_ARGB32  v4l2_fourcc('B', 'A', '2', '4') /* 32  ARGB-8-8-8-8  */
+#endif
+
+#ifndef V4L2_PIX_FMT_XRGB32
+#define V4L2_PIX_FMT_XRGB32  v4l2_fourcc('B', 'X', '2', '4') /* 32  XRGB-8-8-8-8  */
+#endif
+
+#ifndef V4L2_PIX_FMT_XBGR32
+#define V4L2_PIX_FMT_XBGR32  v4l2_fourcc('X', 'R', '2', '4') /* 32  BGRX-8-8-8-8  */
+#endif
+
+#endif /* !__V4L2_COMPAT_H__ */
diff --git a/libweston/v4l2-renderer-device.h b/libweston/v4l2-renderer-device.h
new file mode 100644
index 0000000..f2fe7be
--- /dev/null
+++ b/libweston/v4l2-renderer-device.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright © 2014 Renesas Electronics Corp.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *	Takanari Hayama <taki@igel.co.jp>
+ */
+
+#include "config.h"
+
+#include "compositor.h"
+
+/*
+ * Enable gl-fallback feature.
+ */
+//#define V4L2_GL_FALLBACK
+
+struct v4l2_renderer_device {
+	struct media_device *media;
+	const char *device_name;
+};
+
+struct v4l2_renderer_output {
+	int width;
+	int height;
+};
+
+struct v4l2_renderer_plane {
+	int dmafd;
+	unsigned int stride;
+};
+
+#ifdef V4L2_GL_FALLBACK
+typedef enum {
+	V4L2_SURFACE_DEFAULT,
+	V4L2_SURFACE_GL_ATTACHED
+} v4l2_surface_t;
+
+struct v4l2_view {
+	struct weston_view *view;
+	struct v4l2_surface_state *state;
+};
+#endif
+
+struct v4l2_surface_state {
+	struct weston_surface *surface;
+	struct weston_buffer_reference buffer_ref;
+
+	struct v4l2_renderer *renderer;
+
+	struct kms_bo *bo;
+	void *addr;
+	int bpp;
+	int bo_stride;
+
+	int num_planes;
+	struct v4l2_renderer_plane planes[VIDEO_MAX_PLANES];
+
+	float alpha;
+	int width;
+	int height;
+	unsigned int pixel_format;
+
+	struct v4l2_rect src_rect;
+	struct v4l2_rect dst_rect;
+
+	struct v4l2_rect opaque_src_rect;
+	struct v4l2_rect opaque_dst_rect;
+
+	struct wl_listener buffer_destroy_listener;
+	struct wl_listener surface_destroy_listener;
+	struct wl_listener renderer_destroy_listener;
+
+#ifdef V4L2_GL_FALLBACK
+	void *gl_renderer_state;
+
+	v4l2_surface_t surface_type;
+
+	struct wl_listener surface_post_destroy_listener;
+	struct wl_listener renderer_post_destroy_listener;
+#endif
+};
+
+struct v4l2_device_interface {
+	struct v4l2_renderer_device *(*init)(struct media_device *media, struct weston_config *config);
+
+	struct v4l2_renderer_output *(*create_output)(struct v4l2_renderer_device *dev, int width, int height);
+	void (*set_output_buffer)(struct v4l2_renderer_output *out, struct v4l2_bo_state *bo);
+
+	struct v4l2_surface_state *(*create_surface)(struct v4l2_renderer_device *dev);
+	int (*attach_buffer)(struct v4l2_surface_state *vs);
+
+	void (*begin_compose)(struct v4l2_renderer_device *dev, struct v4l2_renderer_output *out);
+	void (*finish_compose)(struct v4l2_renderer_device *dev);
+	int (*draw_view)(struct v4l2_renderer_device *dev, struct v4l2_surface_state *vs);
+#ifdef V4L2_GL_FALLBACK
+	int (*can_compose)(struct v4l2_view *view_list, int count);
+#endif
+
+	uint32_t (*get_capabilities)(void);
+};
diff --git a/libweston/v4l2-renderer.c b/libweston/v4l2-renderer.c
new file mode 100644
index 0000000..f020377
--- /dev/null
+++ b/libweston/v4l2-renderer.c
@@ -0,0 +1,1552 @@
+/*
+ * Copyright © 2014 Renesas Electronics Corp.
+ *
+ * Based on pixman-renderer by:
+ * Copyright © 2012 Intel Corporation
+ * Copyright © 2013 Vasily Khoruzhick <anarsoul@gmail.com>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *	Takanari Hayama <taki@igel.co.jp>
+ */
+
+#include "config.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <linux/videodev2.h>
+#include <linux/v4l2-subdev.h>
+#include "v4l2-renderer.h"
+#include "v4l2-renderer-device.h"
+
+#include <xf86drm.h>
+#include <libkms/libkms.h>
+
+#include <wayland-kms.h>
+#include <wayland-kms-server-protocol.h>
+
+#include "libmediactl-v4l2/mediactl.h"
+#include "libmediactl-v4l2/v4l2subdev.h"
+#include "libmediactl-v4l2/tools.h"
+#include "shared/helpers.h"
+
+#ifdef V4L2_GL_FALLBACK
+#include <dlfcn.h>
+#include <gbm.h>
+#include <gbm_kmsint.h>
+#include "gl-renderer.h"
+#endif
+
+#include <linux/input.h>
+
+/* Required for a short term workaround */
+#include "v4l2-compat.h"
+
+#if 0
+#define DBG(...) weston_log(__VA_ARGS__)
+#define DBGC(...) weston_log_continue(__VA_ARGS__)
+#define DEBUG
+#else
+#define DBG(...) do {} while (0)
+#define DBGC(...) do {} while (0)
+#ifdef DEBUG
+#  undef DEBUG
+#endif
+#endif
+
+struct v4l2_output_state {
+	struct v4l2_renderer_output *output;
+	uint32_t stride;
+	void *map;
+	struct v4l2_bo_state *bo;
+	int bo_count;
+	int bo_index;
+#ifdef V4L2_GL_FALLBACK
+	void *gl_renderer_state;
+	struct gbm_surface *gbm_surface;
+#endif
+};
+
+struct v4l2_renderer {
+	struct weston_renderer base;
+
+	struct kms_driver *kms;
+	struct wl_kms *wl_kms;
+
+	struct media_device *media;
+	char *device_name;
+	int drm_fd;
+
+	struct v4l2_renderer_device *device;
+
+	int repaint_debug;
+	struct weston_binding *debug_binding;
+
+	struct wl_signal destroy_signal;
+
+#ifdef V4L2_GL_FALLBACK
+	int gl_fallback;
+	struct gbm_device *gbm;
+	struct weston_renderer *gl_renderer;
+#endif
+};
+
+static struct v4l2_device_interface *device_interface = NULL;
+static struct gl_renderer_interface *gl_renderer;
+
+static inline struct v4l2_output_state *
+get_output_state(struct weston_output *output)
+{
+	return (struct v4l2_output_state *)output->renderer_state;
+}
+
+static int
+v4l2_renderer_create_surface(struct weston_surface *surface);
+
+static inline struct v4l2_surface_state *
+get_surface_state(struct weston_surface *surface)
+{
+	if (!surface->renderer_state)
+		v4l2_renderer_create_surface(surface);
+
+	return (struct v4l2_surface_state *)surface->renderer_state;
+}
+
+static inline struct v4l2_renderer *
+get_renderer(struct weston_compositor *ec)
+{
+	return (struct v4l2_renderer *)ec->renderer;
+}
+
+#ifdef V4L2_GL_FALLBACK
+static struct gbm_device *
+v4l2_create_gbm_device(int fd)
+{
+	struct gbm_device *gbm;
+
+	gl_renderer = weston_load_module("gl-renderer.so",
+					 "gl_renderer_interface");
+	if (!gl_renderer)
+		return NULL;
+
+	/* GBM will load a dri driver, but even though they need symbols from
+	 * libglapi, in some version of Mesa they are not linked to it. Since
+	 * only the gl-renderer module links to it, the call above won't make
+	 * these symbols globally available, and loading the DRI driver fails.
+	 * Workaround this by dlopen()'ing libglapi with RTLD_GLOBAL. */
+	dlopen("libglapi.so.0", RTLD_LAZY | RTLD_GLOBAL);
+
+	gbm = gbm_create_device(fd);
+
+	return gbm;
+}
+
+static void
+v4l2_destroy_gbm_device(struct gbm_device *gbm)
+{
+	if (gbm)
+		gbm_device_destroy(gbm);
+}
+
+static int
+v4l2_create_gl_renderer(struct weston_compositor *ec, struct v4l2_renderer *renderer)
+{
+	EGLint format = GBM_FORMAT_XRGB8888;
+
+	if (gl_renderer->create(ec, renderer->gbm,
+				gl_renderer->opaque_attribs, &format) < 0) {
+		return -1;
+	}
+	renderer->gl_renderer = ec->renderer;
+
+	return 0;
+}
+
+static int
+v4l2_init_gl_output(struct weston_output *output, struct v4l2_renderer *renderer)
+{
+	EGLint format = GBM_FORMAT_XRGB8888;
+	struct v4l2_output_state *state = output->renderer_state;
+	int i;
+	pixman_format_code_t read_format;
+
+	state->gbm_surface = gbm_surface_create(renderer->gbm,
+						output->current_mode->width,
+						output->current_mode->height,
+						format,
+						GBM_BO_USE_SCANOUT |
+						GBM_BO_USE_RENDERING |
+						GBM_BO_CREATE_EMPTY);
+
+	if (!state->gbm_surface) {
+		weston_log("%s: failed to create gbm surface\n", __func__);
+		return -1;
+	}
+
+	for (i = 0; i < 2; i++) {
+		int n = i % state->bo_count;
+		gbm_kms_set_bo((struct gbm_kms_surface *)state->gbm_surface,
+			       n, state->bo[n].map, state->bo[n].stride);
+	}
+
+	output->compositor->renderer = renderer->gl_renderer;
+	output->renderer_state = NULL;
+	read_format = output->compositor->read_format;
+	if (gl_renderer->output_create(output, state->gbm_surface,
+				       gl_renderer->opaque_attribs, &format) < 0) {
+		weston_log("%s: failed to create gl renderer output state\n", __func__);
+		gbm_surface_destroy(state->gbm_surface);
+		return -1;
+	}
+	output->compositor->read_format = read_format;
+	state->gl_renderer_state = output->renderer_state;
+	output->renderer_state = state;
+	output->compositor->renderer = &renderer->base;
+
+	return 0;
+}
+
+static void
+v4l2_gl_flush_damage(struct weston_surface *surface)
+{
+	struct v4l2_surface_state *vs = get_surface_state(surface);
+	struct v4l2_renderer *renderer = vs->renderer;
+
+	surface->compositor->renderer = renderer->gl_renderer;
+	surface->renderer_state = vs->gl_renderer_state;
+
+	renderer->gl_renderer->flush_damage(surface);
+
+	vs->gl_renderer_state = surface->renderer_state;
+	surface->renderer_state = vs;
+	surface->compositor->renderer = &renderer->base;
+}
+
+static void
+v4l2_gl_surface_cleanup(struct v4l2_surface_state *vs)
+{
+	wl_list_remove(&vs->surface_post_destroy_listener.link);
+	wl_list_remove(&vs->renderer_post_destroy_listener.link);
+
+	vs->surface->compositor->renderer = &vs->renderer->base;
+	vs->surface->renderer_state = NULL;
+
+	free(vs);
+}
+
+static void
+v4l2_gl_surface_post_destroy(struct wl_listener *listener, void *data)
+{
+	struct v4l2_surface_state *vs;
+	vs = container_of(listener, struct v4l2_surface_state,
+			  surface_post_destroy_listener);
+	v4l2_gl_surface_cleanup(vs);
+}
+
+static void
+v4l2_gl_renderer_post_destroy(struct wl_listener *listener, void *data)
+{
+	struct v4l2_surface_state *vs;
+	vs = container_of(listener, struct v4l2_surface_state,
+			  renderer_post_destroy_listener);
+	v4l2_gl_surface_cleanup(vs);
+}
+
+static void
+v4l2_gl_attach(struct weston_surface *surface, struct weston_buffer *buffer)
+{
+	struct v4l2_surface_state *vs = get_surface_state(surface);
+	struct v4l2_renderer *renderer = vs->renderer;
+
+	surface->compositor->renderer = renderer->gl_renderer;
+	surface->renderer_state = vs->gl_renderer_state;
+
+	renderer->gl_renderer->attach(surface, buffer);
+
+	vs->gl_renderer_state = surface->renderer_state;
+	surface->renderer_state = vs;
+	surface->compositor->renderer = &renderer->base;
+
+	if (vs->surface_type != V4L2_SURFACE_GL_ATTACHED) {
+		vs->surface_post_destroy_listener.notify = v4l2_gl_surface_post_destroy;
+		wl_signal_add(&surface->destroy_signal, &vs->surface_post_destroy_listener);
+
+		vs->renderer_post_destroy_listener.notify = v4l2_gl_renderer_post_destroy;
+		wl_signal_add(&renderer->destroy_signal, &vs->renderer_post_destroy_listener);
+
+		vs->surface_type = V4L2_SURFACE_GL_ATTACHED;
+	}
+}
+
+struct stack {
+	int stack_size;
+	int element_size;
+	void *stack;
+};
+
+#define V4L2_STACK_INIT(size) { .stack_size = 0, .element_size = (size), .stack = NULL }
+
+static int
+v4l2_stack_realloc(struct stack *stack, int target_size)
+{
+	if (target_size > stack->stack_size)
+		target_size += 8;
+	else if (target_size < stack->stack_size / 2)
+		target_size = stack->stack_size / 2 + 1;
+	else
+		target_size = 0;
+
+	if (target_size) {
+		stack->stack = realloc(stack->stack, target_size * stack->element_size);
+
+		if (!stack->stack) {
+			weston_log("can't allocate memory for a stack. can't continue.\n");
+			return -1;
+		}
+
+		stack->stack_size = target_size;
+	}
+
+	return 0;
+}
+
+static void
+v4l2_gl_repaint(struct weston_output *output,
+		pixman_region32_t *output_damage)
+{
+	struct weston_compositor *ec = output->compositor;
+	struct v4l2_renderer *renderer = get_renderer(ec);
+	struct v4l2_output_state *state = output->renderer_state;;
+	struct weston_view *ev;
+	int view_count;
+	static struct stack stacker = V4L2_STACK_INIT(sizeof(void *));
+	void **stack;
+
+	if (v4l2_stack_realloc(&stacker, wl_list_length(&ec->view_list)) < 0)
+		return;
+	stack = (void**)stacker.stack;
+
+	view_count = 0;
+	wl_list_for_each(ev, &ec->view_list, link) {
+		struct v4l2_surface_state *vs = get_surface_state(ev->surface);
+		stack[view_count++] = ev->surface->renderer_state;
+		ev->surface->renderer_state = vs->gl_renderer_state;
+	}
+
+	ec->renderer = renderer->gl_renderer;
+	output->renderer_state = state->gl_renderer_state;
+	renderer->gl_renderer->repaint_output(output, output_damage);
+	ec->renderer = &renderer->base;
+	output->renderer_state = state;
+
+	view_count = 0;
+	wl_list_for_each(ev, &ec->view_list, link) {
+		ev->surface->renderer_state = stack[view_count++];
+	}
+}
+#endif
+
+static int
+v4l2_renderer_read_pixels(struct weston_output *output,
+			 pixman_format_code_t format, void *pixels,
+			 uint32_t x, uint32_t y,
+			 uint32_t width, uint32_t height)
+{
+	struct v4l2_output_state *vo = get_output_state(output);
+	struct v4l2_bo_state *bo = &vo->bo[vo->bo_index];
+	uint32_t v, len = width * 4;
+	void *src, *dst;
+
+	switch(format) {
+	case PIXMAN_a8r8g8b8:
+		break;
+	default:
+		return -1;
+	}
+
+#ifdef V4L2_GL_FALLBACK
+	if (output->compositor->capabilities & WESTON_CAP_CAPTURE_YFLIP) {
+		src = bo->map + x * 4 + y * bo->stride;
+		dst = pixels + len * (height - 1);
+		for (v = y; v < height; v++) {
+			memcpy(dst, src, len);
+			src += bo->stride;
+			dst -= len;
+		}
+		return 0;
+	}
+#endif
+
+	if (x == 0 && y == 0 &&
+	    width == (uint32_t)output->current_mode->width &&
+	    height == (uint32_t)output->current_mode->height &&
+	    bo->stride == len) {
+		DBG("%s: copy entire buffer at once\n", __func__);
+		// TODO: we may want to optimize this using underlying
+		// V4L2 MC hardware if possible.
+		memcpy(pixels, bo->map, bo->stride * height);
+		return 0;
+	}
+
+	src = bo->map + x * 4 + y * bo->stride;
+	dst = pixels;
+	for (v = y; v < height; v++) {
+		memcpy(dst, src, len);
+		src += bo->stride;
+		dst += len;
+	}
+
+	return 0;
+}
+
+static void
+region_global_to_output(struct weston_output *output, pixman_region32_t *region)
+{
+	pixman_region32_translate(region, -output->x, -output->y);
+	weston_transformed_region(output->width, output->height,
+				  output->transform, output->current_scale,
+				  region, region);
+}
+
+#define D2F(v) pixman_double_to_fixed((double)v)
+#define F2D(v) pixman_fixed_to_double(v)
+#define F2I(v) pixman_fixed_to_int(v)
+
+
+static void
+transform_apply_viewport(pixman_transform_t *transform,
+			 struct weston_surface *surface)
+{
+	struct weston_buffer_viewport *vp = &surface->buffer_viewport;
+	double src_width, src_height;
+	double src_x, src_y;
+
+	if (vp->buffer.src_width == wl_fixed_from_int(-1)) {
+		if (vp->surface.width == -1)
+			return;
+
+		src_x = 0.0;
+		src_y = 0.0;
+		src_width = surface->width_from_buffer;
+		src_height = surface->height_from_buffer;
+	} else {
+		src_x = wl_fixed_to_double(vp->buffer.src_x);
+		src_y = wl_fixed_to_double(vp->buffer.src_y);
+		src_width = wl_fixed_to_double(vp->buffer.src_width);
+		src_height = wl_fixed_to_double(vp->buffer.src_height);
+	}
+
+	pixman_transform_scale(transform, NULL,
+			       D2F(src_width / surface->width),
+			       D2F(src_height / surface->height));
+	pixman_transform_translate(transform, NULL, D2F(src_x), D2F(src_y));
+}
+
+static void
+transform_region(pixman_transform_t *transform, pixman_region32_t *src_region,
+		 pixman_region32_t *dst_region)
+{
+	pixman_box32_t *bbox;
+	pixman_vector_t q1, q2;
+
+	pixman_region32_init(dst_region);
+	if (!pixman_region32_not_empty(src_region))
+		return;
+
+	bbox = pixman_region32_extents(src_region);
+	q1.vector[0] = pixman_int_to_fixed(bbox->x1);
+	q1.vector[1] = pixman_int_to_fixed(bbox->y1);
+	q1.vector[2] = pixman_int_to_fixed(1);
+
+	q2.vector[0] = pixman_int_to_fixed(bbox->x2);
+	q2.vector[1] = pixman_int_to_fixed(bbox->y2);
+	q2.vector[2] = pixman_int_to_fixed(1);
+
+	DBG("bbox: (%d,%d)-(%d,%d)\n", bbox->x1, bbox->y1, bbox->x2, bbox->y2);
+	DBG("q1: (%f,%f,%f)\n", F2D(q1.vector[0]), F2D(q1.vector[1]), F2D(q1.vector[2]));
+	DBG("q2: (%f,%f,%f)\n", F2D(q2.vector[0]), F2D(q2.vector[1]), F2D(q2.vector[2]));
+
+	DBG("transform: (%f,%f,%f)(%f,%f,%f)(%f,%f,%f)\n",
+	    F2D(transform->matrix[0][0]), F2D(transform->matrix[1][0]), F2D(transform->matrix[2][0]),
+	    F2D(transform->matrix[0][1]), F2D(transform->matrix[1][1]), F2D(transform->matrix[2][1]),
+	    F2D(transform->matrix[0][2]), F2D(transform->matrix[1][2]), F2D(transform->matrix[2][2])
+	);
+
+	pixman_transform_point(transform, &q1);
+	pixman_transform_point(transform, &q2);
+
+	DBG("q1': (%f,%f,%f)\n", F2D(q1.vector[0]), F2D(q1.vector[1]), F2D(q1.vector[2]));
+	DBG("q2': (%f,%f,%f)\n", F2D(q2.vector[0]), F2D(q2.vector[1]), F2D(q2.vector[2]));
+
+	pixman_region32_init_rect(dst_region,
+				  F2I((q1.vector[0] < q2.vector[0]) ? q1.vector[0] : q2.vector[0]),
+				  F2I((q1.vector[1] < q2.vector[1]) ? q1.vector[1] : q2.vector[1]),
+				  abs(F2I(pixman_fixed_ceil(q2.vector[0] - q1.vector[0]))),
+				  abs(F2I(pixman_fixed_ceil(q2.vector[1] - q1.vector[1]))));
+}
+
+static void
+calculate_transform_matrix(struct weston_view *ev, struct weston_output *output,
+			   pixman_transform_t *transform)
+{
+	struct weston_buffer_viewport *vp = &ev->surface->buffer_viewport;
+	pixman_fixed_t fw, fh;
+
+	/* Set up the source transformation based on the surface
+	   position, the output position/transform/scale and the client
+	   specified buffer transform/scale */
+	pixman_transform_init_identity(transform);
+	pixman_transform_scale(transform, NULL,
+			       pixman_double_to_fixed((double)1.0 / output->current_scale),
+			       pixman_double_to_fixed((double)1.0 / output->current_scale));
+
+	fw = pixman_int_to_fixed(output->width);
+	fh = pixman_int_to_fixed(output->height);
+	switch (output->transform) {
+	default:
+	case WL_OUTPUT_TRANSFORM_NORMAL:
+	case WL_OUTPUT_TRANSFORM_FLIPPED:
+		break;
+	case WL_OUTPUT_TRANSFORM_90:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+		pixman_transform_rotate(transform, NULL, 0, -pixman_fixed_1);
+		pixman_transform_translate(transform, NULL, 0, fh);
+		break;
+	case WL_OUTPUT_TRANSFORM_180:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+		pixman_transform_rotate(transform, NULL, -pixman_fixed_1, 0);
+		pixman_transform_translate(transform, NULL, fw, fh);
+		break;
+	case WL_OUTPUT_TRANSFORM_270:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+		pixman_transform_rotate(transform, NULL, 0, pixman_fixed_1);
+		pixman_transform_translate(transform, NULL, fw, 0);
+		break;
+	}
+
+	switch (output->transform) {
+	case WL_OUTPUT_TRANSFORM_FLIPPED:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+		pixman_transform_scale(transform, NULL,
+				       pixman_int_to_fixed(-1),
+				       pixman_int_to_fixed(1));
+		pixman_transform_translate(transform, NULL, fw, 0);
+		break;
+	}
+
+        pixman_transform_translate(transform, NULL,
+				   pixman_double_to_fixed(output->x),
+				   pixman_double_to_fixed(output->y));
+
+	if (ev->transform.enabled) {
+		/* Pixman supports only 2D transform matrix, but Weston uses 3D,
+		 * so we're omitting Z coordinate here
+		 */
+		pixman_transform_t surface_transform = {{
+				{ D2F(ev->transform.matrix.d[0]),
+				  D2F(ev->transform.matrix.d[4]),
+				  D2F(ev->transform.matrix.d[12]),
+				},
+				{ D2F(ev->transform.matrix.d[1]),
+				  D2F(ev->transform.matrix.d[5]),
+				  D2F(ev->transform.matrix.d[13]),
+				},
+				{ D2F(ev->transform.matrix.d[3]),
+				  D2F(ev->transform.matrix.d[7]),
+				  D2F(ev->transform.matrix.d[15]),
+				}
+			}};
+
+		pixman_transform_invert(&surface_transform, &surface_transform);
+		pixman_transform_multiply(transform, &surface_transform, transform);
+	} else {
+		pixman_transform_translate(transform, NULL,
+					   pixman_double_to_fixed((double)-ev->geometry.x),
+					   pixman_double_to_fixed((double)-ev->geometry.y));
+	}
+
+	transform_apply_viewport(transform, ev->surface);
+
+	fw = pixman_int_to_fixed(ev->surface->width_from_buffer);
+	fh = pixman_int_to_fixed(ev->surface->height_from_buffer);
+
+	switch (vp->buffer.transform) {
+	case WL_OUTPUT_TRANSFORM_FLIPPED:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+		pixman_transform_scale(transform, NULL,
+				       pixman_int_to_fixed(-1),
+				       pixman_int_to_fixed(1));
+		pixman_transform_translate(transform, NULL, fw, 0);
+		break;
+	}
+
+	switch (vp->buffer.transform) {
+	default:
+	case WL_OUTPUT_TRANSFORM_NORMAL:
+	case WL_OUTPUT_TRANSFORM_FLIPPED:
+		break;
+	case WL_OUTPUT_TRANSFORM_90:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+		pixman_transform_rotate(transform, NULL, 0, pixman_fixed_1);
+		pixman_transform_translate(transform, NULL, fh, 0);
+		break;
+	case WL_OUTPUT_TRANSFORM_180:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+		pixman_transform_rotate(transform, NULL, -pixman_fixed_1, 0);
+		pixman_transform_translate(transform, NULL, fw, fh);
+		break;
+	case WL_OUTPUT_TRANSFORM_270:
+	case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+		pixman_transform_rotate(transform, NULL, 0, -pixman_fixed_1);
+		pixman_transform_translate(transform, NULL, 0, fw);
+		break;
+	}
+
+	pixman_transform_scale(transform, NULL,
+			       pixman_double_to_fixed(vp->buffer.scale),
+			       pixman_double_to_fixed(vp->buffer.scale));
+
+}
+
+static void
+set_v4l2_rect(pixman_region32_t *region, struct v4l2_rect *rect)
+{
+	pixman_box32_t *bbox;
+
+	bbox = pixman_region32_extents(region);
+	rect->left   = bbox->x1;
+	rect->top    = bbox->y1;
+	rect->width  = bbox->x2 - bbox->x1;
+	rect->height = bbox->y2 - bbox->y1;
+}
+
+static void
+draw_view(struct weston_view *ev, struct weston_output *output)
+{
+	struct v4l2_renderer *renderer = (struct v4l2_renderer*)output->compositor->renderer;
+	struct v4l2_surface_state *vs = get_surface_state(ev->surface);
+	pixman_region32_t dst_region, src_region;
+	pixman_region32_t region, opaque_src_region, opaque_dst_region;
+	pixman_transform_t transform;
+
+	/* a surface in the repaint area? */
+	pixman_region32_init(&region);
+	pixman_region32_intersect(&region,
+				  &ev->transform.boundingbox,
+				  &output->region);
+	pixman_region32_subtract(&region, &region, &ev->clip);
+	if (!pixman_region32_not_empty(&region)) {
+		DBG("%s: skipping a view: not visible: view=(%d,%d)-(%d,%d), repaint=(%d,%d)-(%d,%d)\n",
+		    __func__,
+		    ev->transform.boundingbox.extents.x1, ev->transform.boundingbox.extents.y1,
+		    ev->transform.boundingbox.extents.x2, ev->transform.boundingbox.extents.y2,
+		    output->region.extents.x1, output->region.extents.y1,
+		    output->region.extents.x2, output->region.extents.y2);
+		goto out;
+	}
+
+	/* you may sometime get not-yet-attached views */
+	if (vs->planes[0].dmafd == 0)
+		goto out;
+
+	/*
+	 * Check if the surface is still valid. OpenGL/ES apps may destroy
+	 * buffers before they destroy a surface. This check works in the
+	 * serialized world only.
+	 */
+	if (fcntl(vs->planes[0].dmafd, F_GETFD) < 0)
+		goto out;
+
+	if (output->zoom.active) {
+		weston_log("v4l2 renderer does not support zoom\n");
+		goto out;
+	}
+
+	/* we have to compute a transform matrix */
+	calculate_transform_matrix(ev, output, &transform);
+
+	pixman_region32_init(&opaque_src_region);
+	pixman_region32_init(&opaque_dst_region);
+
+	if (pixman_region32_not_empty(&ev->surface->opaque)) {
+		pixman_region32_t output_region;
+		pixman_transform_t inverse;
+
+		pixman_transform_invert(&inverse, &transform);
+		transform_region(&inverse, &ev->surface->opaque, &opaque_dst_region);
+
+		pixman_region32_init_rect(&output_region, 0, 0, output->width, output->height);
+
+		pixman_region32_intersect(&opaque_dst_region, &opaque_dst_region, &output_region);
+		transform_region(&transform, &opaque_dst_region, &opaque_src_region);
+	}
+
+	/* find out the final destination in the output coordinate */
+	pixman_region32_init(&dst_region);
+	pixman_region32_copy(&dst_region, &region);
+	region_global_to_output(output, &dst_region);
+
+	transform_region(&transform, &dst_region, &src_region);
+	set_v4l2_rect(&dst_region, &vs->dst_rect);
+	set_v4l2_rect(&src_region, &vs->src_rect);
+
+	/* setup opaque region */
+	set_v4l2_rect(&opaque_dst_region, &vs->opaque_dst_rect);
+	set_v4l2_rect(&opaque_src_region, &vs->opaque_src_rect);
+
+	vs->alpha = ev->alpha;
+
+	DBG("monitor: %dx%d@(%d,%d)\n", output->width, output->height, output->x, output->y);
+	DBG("composing from %dx%d@(%d,%d) to %dx%d@(%d,%d)\n",
+	    vs->src_rect.width, vs->src_rect.height, vs->src_rect.left, vs->src_rect.top,
+	    vs->dst_rect.width, vs->dst_rect.height, vs->dst_rect.left, vs->dst_rect.top);
+	DBG("composing from %dx%d@(%d,%d) to %dx%d@(%d,%d) [opaque region]\n",
+	    vs->opaque_src_rect.width, vs->opaque_src_rect.height, vs->opaque_src_rect.left, vs->opaque_src_rect.top,
+	    vs->opaque_dst_rect.width, vs->opaque_dst_rect.height, vs->opaque_dst_rect.left, vs->opaque_dst_rect.top);
+
+	device_interface->draw_view(renderer->device, vs);
+
+	pixman_region32_fini(&dst_region);
+	pixman_region32_fini(&src_region);
+	pixman_region32_fini(&opaque_src_region);
+	pixman_region32_fini(&opaque_dst_region);
+out:
+	pixman_region32_fini(&region);
+}
+
+static void
+repaint_surfaces(struct weston_output *output, pixman_region32_t *damage)
+{
+	struct weston_compositor *compositor = output->compositor;
+	struct v4l2_output_state *vo = get_output_state(output);
+	struct v4l2_renderer *renderer = (struct v4l2_renderer*)compositor->renderer;
+	struct weston_view *view;
+
+	device_interface->begin_compose(renderer->device, vo->output);
+
+	wl_list_for_each_reverse(view, &compositor->view_list, link) {
+		if (view->plane == &compositor->primary_plane)
+			draw_view(view, output);
+	}
+
+	device_interface->finish_compose(renderer->device);
+}
+
+#ifdef V4L2_GL_FALLBACK
+static int
+can_repaint(struct weston_compositor *c, pixman_region32_t *output_region)
+{
+	struct weston_view *ev;
+	pixman_region32_t region;
+	int need_repaint, view_count;
+	static struct stack stacker = V4L2_STACK_INIT(sizeof(struct v4l2_view));
+	struct v4l2_view *view_list;
+
+	DBG("%s: checking...\n", __func__);
+
+	/* we don't bother checking, if can_compose is not defined */
+	if (!device_interface->can_compose)
+		return 1;
+
+	/* if stack realloc fails, there's not many things we can do... */
+	if (v4l2_stack_realloc(&stacker, wl_list_length(&c->view_list)) < 0)
+		return 1;
+	view_list = (struct v4l2_view *)stacker.stack;
+
+	view_count = 0;
+	wl_list_for_each(ev, &c->view_list, link) {
+		/* in the primary plane? */
+		if (ev->plane != &c->primary_plane)
+			continue;
+
+		/* a surface in the repaint area? */
+		pixman_region32_init(&region);
+		pixman_region32_intersect(&region,
+					  &ev->transform.boundingbox,
+					  output_region);
+		pixman_region32_subtract(&region, &region, &ev->clip);
+		need_repaint = pixman_region32_not_empty(&region);
+		pixman_region32_fini(&region);
+
+		if (need_repaint) {
+			struct v4l2_surface_state *vs = get_surface_state(ev->surface);
+			view_list[view_count].view = ev;
+			view_list[view_count].state = vs;
+			view_count++;
+		}
+	}
+
+	return device_interface->can_compose(view_list, view_count);
+}
+#endif
+
+static void
+v4l2_renderer_repaint_output(struct weston_output *output,
+			    pixman_region32_t *output_damage)
+{
+#ifdef V4L2_GL_FALLBACK
+	struct v4l2_output_state *vo = get_output_state(output);
+	struct weston_compositor *compositor = output->compositor;
+	struct v4l2_renderer *renderer = (struct v4l2_renderer*)compositor->renderer;
+#endif
+	DBG("%s\n", __func__);
+
+#ifdef V4L2_GL_FALLBACK
+	if ((!renderer->gl_fallback) || (can_repaint(output->compositor, &output->region))) {
+#endif
+		// render all views
+		repaint_surfaces(output, output_damage);
+
+		// remember the damaged area
+		pixman_region32_copy(&output->previous_damage, output_damage);
+
+		// emits signal
+		wl_signal_emit(&output->frame_signal, output);
+#ifdef V4L2_GL_FALLBACK
+	} else {
+		gbm_kms_set_front((struct gbm_kms_surface *)vo->gbm_surface, (!vo->bo_index));
+
+		v4l2_gl_repaint(output, output_damage);
+	}
+#endif
+
+	/* Actual flip should be done by caller */
+}
+
+static inline void
+v4l2_renderer_copy_buffer(struct v4l2_surface_state *vs, struct weston_buffer *buffer)
+{
+	void *src, *dst;
+	int y, stride, bo_stride;
+
+	src = wl_shm_buffer_get_data(buffer->shm_buffer);
+	dst = vs->addr;
+
+	stride = vs->planes[0].stride;
+	bo_stride = vs->bo_stride;
+
+	wl_shm_buffer_begin_access(buffer->shm_buffer);
+	for (y = 0; y < buffer->height; y++) {
+		memcpy(dst, src, buffer->width * vs->bpp);
+		dst += bo_stride;
+		src += stride;
+	}
+	wl_shm_buffer_end_access(buffer->shm_buffer);
+
+}
+
+static void
+v4l2_renderer_flush_damage(struct weston_surface *surface)
+{
+	struct v4l2_surface_state *vs = get_surface_state(surface);
+	struct weston_buffer *buffer = vs->buffer_ref.buffer;
+
+	DBG("%s: flushing damage..\n", __func__);
+
+	v4l2_renderer_copy_buffer(vs, buffer);
+
+	/*
+	 * TODO: We may consider use of surface->damage to
+	 * optimize updates.
+	 */
+
+#ifdef V4L2_GL_FALLBACK
+	if (vs->renderer->gl_fallback)
+		v4l2_gl_flush_damage(surface);
+#endif
+}
+
+static void
+v4l2_release_kms_bo(struct v4l2_surface_state *vs)
+{
+	int i;
+
+	if (!vs)
+		return;
+
+	if (vs->bo) {
+		for (i = 0; i < vs->num_planes; i++) {
+			if (vs->planes[i].dmafd >= 0) {
+				close(vs->planes[i].dmafd);
+				vs->planes[i].dmafd = -1;
+			}
+		}
+
+		if (kms_bo_unmap(vs->bo))
+			weston_log("kms_bo_unmap failed.\n");
+
+		kms_bo_destroy(&vs->bo);
+		vs->addr = NULL;
+	}
+}
+
+static void
+buffer_state_handle_buffer_destroy(struct wl_listener *listener, void *data)
+{
+	struct v4l2_surface_state *vs;
+
+	vs = container_of(listener, struct v4l2_surface_state,
+			  buffer_destroy_listener);
+
+	v4l2_release_kms_bo(vs);
+
+	vs->buffer_destroy_listener.notify = NULL;
+}
+
+static int
+v4l2_renderer_attach_shm(struct v4l2_surface_state *vs, struct weston_buffer *buffer,
+			 struct wl_shm_buffer *shm_buffer)
+{
+	unsigned int pixel_format;
+	int bpp;
+	int fd = vs->renderer->drm_fd;
+	unsigned attr[] = {
+		KMS_BO_TYPE, KMS_BO_TYPE_SCANOUT_X8R8G8B8,
+		KMS_WIDTH, 0,
+		KMS_HEIGHT, 0,
+		KMS_TERMINATE_PROP_LIST
+	};
+	unsigned handle, stride, bo_stride;
+
+	switch (wl_shm_buffer_get_format(shm_buffer)) {
+	case WL_SHM_FORMAT_XRGB8888:
+		pixel_format = V4L2_PIX_FMT_XBGR32;
+		bpp = 4;
+		break;
+
+	case WL_SHM_FORMAT_ARGB8888:
+		pixel_format = V4L2_PIX_FMT_ABGR32;
+		bpp = 4;
+		break;
+
+	case WL_SHM_FORMAT_RGB565:
+		pixel_format = V4L2_PIX_FMT_RGB565;
+		bpp = 2;
+		break;
+
+	case WL_SHM_FORMAT_YUYV:
+		pixel_format = V4L2_PIX_FMT_YUYV;
+		bpp = 2;
+		break;
+
+	default:
+		weston_log("Unsupported SHM buffer format\n");
+		return -1;
+	}
+
+	buffer->shm_buffer = shm_buffer;
+	buffer->width = wl_shm_buffer_get_width(shm_buffer);
+	buffer->height = wl_shm_buffer_get_height(shm_buffer);
+	stride = wl_shm_buffer_get_stride(shm_buffer);
+
+	if (vs->width == buffer->width &&
+	    vs->height == buffer->height &&
+	    vs->planes[0].stride == stride && vs->bpp == bpp) {
+	    // no need to recreate buffer
+	    return 0;
+	}
+
+	// release if there's allocated buffer
+	v4l2_release_kms_bo(vs);
+
+	// create a reference to the shm_buffer.
+	vs->width = buffer->width;
+	vs->height = buffer->height;
+	vs->pixel_format = pixel_format;
+	vs->num_planes = 1;
+	vs->planes[0].stride = stride;
+	vs->planes[0].dmafd = -1;
+	vs->bpp = bpp;
+
+	if (device_interface->attach_buffer(vs) == -1)
+		return -1;
+
+	// create gbm_bo
+	attr[3] = (buffer->width + 1) * bpp / 4;
+	attr[5] = buffer->height;
+
+	if (kms_bo_create(vs->renderer->kms, attr, &vs->bo)) {
+		weston_log("kms_bo_create failed.\n");
+		goto error;
+	}
+
+	if (kms_bo_map(vs->bo, &vs->addr)) {
+		weston_log("kms_bo_map failed.\n");
+		goto error;
+	}
+
+	if (kms_bo_get_prop(vs->bo, KMS_PITCH, &bo_stride)) {
+		weston_log("kms_bo_get_prop failed.\n");
+		goto error;
+	}
+	vs->bo_stride = stride;
+
+	if (kms_bo_get_prop(vs->bo, KMS_HANDLE, &handle)) {
+		weston_log("kms_bo_get_prop failed.\n");
+		goto error;
+	}
+	drmPrimeHandleToFD(fd, handle, DRM_CLOEXEC, &vs->planes[0].dmafd);
+
+	v4l2_renderer_copy_buffer(vs, buffer);
+
+	DBG("%s: %dx%d buffer attached (dmafd=%d).\n", __func__, buffer->width, buffer->height, vs->planes[0].dmafd);
+
+	return 0;
+
+error:
+	v4l2_release_kms_bo(vs);
+	return -1;
+}
+
+static int
+v4l2_renderer_attach_dmabuf(struct v4l2_surface_state *vs, struct weston_buffer *buffer)
+{
+	unsigned int pixel_format;
+	struct wl_kms_buffer *kbuf;
+	int bpp, i;
+
+	buffer->legacy_buffer = (struct wl_buffer *)buffer->resource;
+
+	kbuf = wayland_kms_buffer_get(buffer->resource);
+
+	switch (kbuf->format) {
+	case WL_KMS_FORMAT_XRGB8888:
+		pixel_format = V4L2_PIX_FMT_XBGR32;
+		bpp = 4;
+		break;
+
+	case WL_KMS_FORMAT_ARGB8888:
+		pixel_format = V4L2_PIX_FMT_ABGR32;
+		bpp = 4;
+		break;
+
+	case WL_KMS_FORMAT_XBGR8888:
+		pixel_format = V4L2_PIX_FMT_XRGB32;
+		bpp = 4;
+		break;
+
+	case WL_KMS_FORMAT_ABGR8888:
+		pixel_format = V4L2_PIX_FMT_ARGB32;
+		bpp = 4;
+		break;
+
+	case WL_KMS_FORMAT_RGB888:
+		pixel_format = V4L2_PIX_FMT_RGB24;
+		bpp = 3;
+		break;
+
+	case WL_KMS_FORMAT_BGR888:
+		pixel_format = V4L2_PIX_FMT_BGR24;
+		bpp = 3;
+		break;
+
+	case WL_KMS_FORMAT_RGB565:
+		pixel_format = V4L2_PIX_FMT_RGB565;
+		bpp = 2;
+		break;
+
+	case WL_KMS_FORMAT_RGB332:
+		pixel_format = V4L2_PIX_FMT_RGB332;
+		bpp = 1;
+		break;
+
+	case WL_KMS_FORMAT_YUYV:
+		pixel_format = V4L2_PIX_FMT_YUYV;
+		bpp = 2;
+		break;
+
+	case WL_KMS_FORMAT_YVYU:
+		pixel_format = V4L2_PIX_FMT_YVYU;
+		bpp = 2;
+		break;
+
+	case WL_KMS_FORMAT_UYVY:
+		pixel_format = V4L2_PIX_FMT_UYVY;
+		bpp = 2;
+		break;
+
+	case WL_KMS_FORMAT_NV12:
+		pixel_format = V4L2_PIX_FMT_NV12M;
+		bpp = 2;
+		break;
+
+	case WL_KMS_FORMAT_NV16:
+		pixel_format = V4L2_PIX_FMT_NV16M;
+		bpp = 2;
+		break;
+
+	case WL_KMS_FORMAT_NV21:
+		pixel_format = V4L2_PIX_FMT_NV21M;
+		bpp = 2;
+		break;
+
+	case WL_KMS_FORMAT_NV61:
+		pixel_format = V4L2_PIX_FMT_NV61M;
+		bpp = 2;
+		break;
+
+	case WL_KMS_FORMAT_YUV420:
+		pixel_format = V4L2_PIX_FMT_YUV420M;
+		bpp = 2;
+		break;
+
+	default:
+		weston_log("Unsupported DMABUF buffer format\n");
+		return -1;
+	}
+
+	vs->width = buffer->width = kbuf->width;
+	vs->height = buffer->height = kbuf->height;
+	vs->pixel_format = pixel_format;
+	vs->bpp = bpp;
+	vs->num_planes = kbuf->num_planes;
+	for (i = 0; i < kbuf->num_planes; i++) {
+		vs->planes[i].stride = kbuf->planes[i].stride;
+		vs->planes[i].dmafd = kbuf->planes[i].fd;
+	}
+
+	if (device_interface->attach_buffer(vs) == -1)
+		return -1;
+
+	DBG("%s: %dx%d buffer attached (dmabuf=%d, stride=%d).\n", __func__, kbuf->width, kbuf->height, kbuf->fd, kbuf->stride);
+
+	return 0;
+}
+
+static void
+v4l2_renderer_attach(struct weston_surface *es, struct weston_buffer *buffer)
+{
+	struct v4l2_surface_state *vs = get_surface_state(es);
+	struct wl_shm_buffer *shm_buffer;
+	int ret;
+
+	// refer the given weston_buffer. if there's an existing reference,
+	// release it first if not the same. if the buffer is the new one,
+	// increment the refrence counter. all done in weston_buffer_reference().
+	weston_buffer_reference(&vs->buffer_ref, buffer);
+
+	// clear the destroy listener if set.
+	if (vs->buffer_destroy_listener.notify) {
+		wl_list_remove(&vs->buffer_destroy_listener.link);
+		vs->buffer_destroy_listener.notify = NULL;
+	}
+
+	if (buffer) {
+		// for shm_buffer.
+		shm_buffer = wl_shm_buffer_get(buffer->resource);
+
+		if (shm_buffer) {
+			ret = v4l2_renderer_attach_shm(vs, buffer, shm_buffer);
+		} else {
+			ret = v4l2_renderer_attach_dmabuf(vs, buffer);
+		}
+
+		if (ret == -1) {
+			weston_buffer_reference(&vs->buffer_ref, NULL);
+			return;
+		}
+
+		// listen to the buffer destroy event.
+		vs->buffer_destroy_listener.notify =
+			buffer_state_handle_buffer_destroy;
+		wl_signal_add(&buffer->destroy_signal,
+			      &vs->buffer_destroy_listener);
+	}
+
+#ifdef V4L2_GL_FALLBACK
+	if (vs->renderer->gl_fallback)
+		v4l2_gl_attach(es, buffer);
+#endif
+}
+
+static void
+v4l2_renderer_surface_state_destroy(struct v4l2_surface_state *vs)
+{
+	wl_list_remove(&vs->surface_destroy_listener.link);
+	wl_list_remove(&vs->renderer_destroy_listener.link);
+	if (vs->buffer_destroy_listener.notify) {
+		wl_list_remove(&vs->buffer_destroy_listener.link);
+		vs->buffer_destroy_listener.notify = NULL;
+	}
+
+	// TODO: Release any resources associated to the surface here.
+
+	weston_buffer_reference(&vs->buffer_ref, NULL);
+#ifdef V4L2_GL_FALLBACK
+	if (vs->surface_type == V4L2_SURFACE_GL_ATTACHED) {
+		vs->surface->compositor->renderer = vs->renderer->gl_renderer;
+		vs->surface->renderer_state = vs->gl_renderer_state;
+	} else {
+#endif
+		vs->surface->renderer_state = NULL;
+		free(vs);
+#ifdef V4L2_GL_FALLBACK
+	}
+#endif
+}
+
+static void
+surface_state_handle_surface_destroy(struct wl_listener *listener, void *data)
+{
+	struct v4l2_surface_state *vs;
+
+	vs = container_of(listener, struct v4l2_surface_state,
+				     surface_destroy_listener);
+
+	v4l2_renderer_surface_state_destroy(vs);
+}
+
+static void
+surface_state_handle_renderer_destroy(struct wl_listener *listener, void *data)
+{
+	struct v4l2_surface_state *vs;
+
+	vs = container_of(listener, struct v4l2_surface_state,
+				     renderer_destroy_listener);
+
+	v4l2_renderer_surface_state_destroy(vs);
+}
+
+static int
+v4l2_renderer_create_surface(struct weston_surface *surface)
+{
+	struct v4l2_surface_state *vs;
+	struct v4l2_renderer *vr = get_renderer(surface->compositor);
+
+	vs = device_interface->create_surface(vr->device);
+	if (!vs)
+		return -1;
+
+	surface->renderer_state = vs;
+
+	vs->surface = surface;
+	vs->renderer = vr;
+
+	vs->surface_destroy_listener.notify =
+		surface_state_handle_surface_destroy;
+	wl_signal_add(&surface->destroy_signal,
+		      &vs->surface_destroy_listener);
+
+	vs->renderer_destroy_listener.notify =
+		surface_state_handle_renderer_destroy;
+	wl_signal_add(&vr->destroy_signal,
+		      &vs->renderer_destroy_listener);
+
+#ifdef V4L2_GL_FALLBACK
+	vs->surface_type = V4L2_SURFACE_DEFAULT;
+#endif
+	return 0;
+}
+
+static void
+v4l2_renderer_surface_set_color(struct weston_surface *es,
+				float red, float green, float blue, float alpha)
+{
+	DBG("%s\n", __func__);
+
+	// struct v4l2_surface_state *vs = get_surface_state(es);
+
+	// TODO: set solid color to the surface
+}
+
+static void
+v4l2_renderer_destroy(struct weston_compositor *ec)
+{
+	struct v4l2_renderer *vr = get_renderer(ec);
+
+	DBG("%s\n", __func__);
+
+	wl_signal_emit(&vr->destroy_signal, vr);
+	weston_binding_destroy(vr->debug_binding);
+	free(vr);
+
+	// TODO: release gl-renderer here.
+
+	ec->renderer = NULL;
+}
+
+static void
+debug_media_ctl(void *ignore, char *fmt, ...)
+{
+	char buffer[256];
+	va_list ap;
+
+	va_start(ap, fmt);
+	vsnprintf(buffer, sizeof(buffer), fmt, ap);
+	va_end(ap);
+
+	weston_log(buffer);
+}
+
+static void
+debug_binding(struct weston_seat *seat, uint32_t time, uint32_t key,
+	      void *data)
+{
+	struct weston_compositor *ec = data;
+	struct v4l2_renderer *vr = (struct v4l2_renderer *) ec->renderer;
+
+	vr->repaint_debug ^= 1;
+
+	if (vr->repaint_debug) {
+		// TODO: enable repaint debug
+
+                media_debug_set_handler(vr->media,
+					(void (*)(void *, ...))debug_media_ctl, NULL);
+
+	} else {
+		// TODO: disable repaint debug
+
+		weston_compositor_damage_all(ec);
+	}
+}
+
+static void
+v4l2_load_device_module(const char *device_name)
+{
+	char path[1024];
+
+	if (!device_name)
+		return;
+
+	snprintf(path, sizeof(path), "v4l2-%s-device.so", device_name);
+	device_interface =
+		(struct v4l2_device_interface*)weston_load_module(path, "v4l2_device_interface");
+}
+
+static char*
+v4l2_get_cname(const char *bus_info)
+{
+	char *p, *device_name;
+
+	if (!bus_info)
+		return NULL;
+
+	if ((p = strchr(bus_info, ':')))
+		device_name = strdup(p + 1);
+	else
+		device_name = strdup(bus_info);
+
+	p = strchr(device_name, '.');
+	*p = '\0';
+
+	return device_name;
+}
+
+static int
+v4l2_renderer_init(struct weston_compositor *ec, int drm_fd, char *drm_fn)
+{
+	struct v4l2_renderer *renderer;
+	char *device;
+	const char *device_name;
+	const struct media_device_info *info;
+	struct weston_config_section *section;
+
+	if (!drm_fn)
+		return -1;
+
+	renderer = calloc(1, sizeof *renderer);
+	if (renderer == NULL)
+		return -1;
+
+	renderer->wl_kms = wayland_kms_init(ec->wl_display, NULL, drm_fn, drm_fd);
+
+	/* Get V4L2 media controller device to use */
+	section = weston_config_get_section(ec->config,
+					    "media-ctl", NULL, NULL);
+	weston_config_section_get_string(section, "device", &device, "/dev/media0");
+#ifdef V4L2_GL_FALLBACK
+	weston_config_section_get_bool(section, "gl-fallback", &renderer->gl_fallback, 0);
+#endif
+
+	/* Initialize V4L2 media controller */
+	renderer->media = media_device_new(device);
+	if (!renderer->media) {
+		weston_log("Can't create a media controller.");
+		goto error;
+	}
+
+	/* Enumerate entities, pads and links */
+	if (media_device_enumerate(renderer->media)) {
+		weston_log("Can't enumerate %s.", device);
+		goto error;
+	}
+
+	/* Device info */
+	info = media_get_info(renderer->media);
+	weston_log("Media controller API version %u.%u.%u\n",
+		   (info->media_version >> 16) & 0xff,
+		   (info->media_version >>  8) & 0xff,
+		   (info->media_version)       & 0xff);
+	weston_log_continue("Media device information\n"
+			    "------------------------\n"
+			    "driver         %s\n"
+			    "model          %s\n"
+			    "serial         %s\n"
+			    "bus info       %s\n"
+			    "hw revision    0x%x\n"
+			    "driver version %u.%u.%u\n",
+			    info->driver, info->model,
+			    info->serial, info->bus_info,
+			    info->hw_revision,
+			    (info->driver_version >> 16) & 0xff,
+			    (info->driver_version >>  8) & 0xff,
+			    (info->driver_version)       & 0xff);
+
+	device_name = v4l2_get_cname(info->bus_info);
+	v4l2_load_device_module(device_name);
+	if (!device_interface)
+		goto error;
+
+	renderer->device = device_interface->init(renderer->media, ec->config);
+	if (!renderer->device)
+		goto error;
+
+	weston_log("V4L2 media controller device initialized.\n");
+
+	kms_create(drm_fd, &renderer->kms);
+
+	/* initialize renderer base */
+	renderer->drm_fd = drm_fd;
+	renderer->repaint_debug = 0;
+
+	renderer->base.read_pixels = v4l2_renderer_read_pixels;
+	renderer->base.repaint_output = v4l2_renderer_repaint_output;
+	renderer->base.flush_damage = v4l2_renderer_flush_damage;
+	renderer->base.attach = v4l2_renderer_attach;
+	renderer->base.surface_set_color = v4l2_renderer_surface_set_color;
+	renderer->base.destroy = v4l2_renderer_destroy;
+
+#ifdef V4L2_GL_FALLBACK
+	if (renderer->gl_fallback) {
+		/* we now initialize gl-renderer for fallback */
+		renderer->gbm = v4l2_create_gbm_device(drm_fd);
+		if (renderer->gbm) {
+			if (v4l2_create_gl_renderer(ec, renderer) < 0) {
+				weston_log("GL Renderer fallback failed to initialize.\n");
+				v4l2_destroy_gbm_device(renderer->gbm);
+				renderer->gbm = NULL;
+			}
+		}
+	}
+#endif
+
+	ec->renderer = &renderer->base;
+	ec->capabilities |= device_interface->get_capabilities();
+
+	ec->read_format = PIXMAN_a8r8g8b8;
+
+	renderer->debug_binding =
+		weston_compositor_add_debug_binding(ec, KEY_R,
+						    debug_binding, ec);
+
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_RGB565);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_XRGB8888);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_ARGB8888);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_YUYV);
+
+	wl_signal_init(&renderer->destroy_signal);
+
+	return 0;
+
+error:
+	free(renderer);
+	weston_log("V4L2 renderer initialization failed.\n");
+	return -1;
+}
+
+static void
+v4l2_renderer_output_set_buffer(struct weston_output *output, int bo_index)
+{
+	struct v4l2_output_state *vo = get_output_state(output);
+
+	vo->bo_index = bo_index;
+	device_interface->set_output_buffer(vo->output, &vo->bo[bo_index]);
+	return;
+}
+
+static int
+v4l2_renderer_output_create(struct weston_output *output, struct v4l2_bo_state *bo_states, int count)
+{
+	struct v4l2_renderer *renderer = (struct v4l2_renderer*)output->compositor->renderer;
+	struct v4l2_output_state *vo;
+	struct v4l2_renderer_output *outdev;
+	int i;
+
+	if (!renderer)
+		return -1;
+
+	outdev = device_interface->create_output(renderer->device,
+						 output->current_mode->width,
+						 output->current_mode->height);
+	if (!outdev)
+		return -1;
+
+	if (!(vo = calloc(1, sizeof *vo)))
+		return -1;
+
+	vo->output = outdev;
+
+	output->renderer_state = vo;
+
+	if (!(vo->bo = calloc(1, sizeof(struct v4l2_bo_state) * count))) {
+		free(vo);
+		return -1;
+	}
+
+	for (i = 0; i < count; i++)
+		vo->bo[i] = bo_states[i];
+	vo->bo_count = count;
+
+#ifdef V4L2_GL_FALLBACK
+	if ((renderer->gl_fallback) && (v4l2_init_gl_output(output, renderer) < 0)) {
+		// error...
+		weston_log("gl fallback failed...\n");
+	}
+#endif
+
+	return 0;
+}
+
+static void
+v4l2_renderer_output_destroy(struct weston_output *output)
+{
+	struct v4l2_output_state *vo = get_output_state(output);
+	if (vo->bo)
+		free(vo->bo);
+	free(vo);
+}
+
+WL_EXPORT struct v4l2_renderer_interface v4l2_renderer_interface = {
+	.init = v4l2_renderer_init,
+	.output_create = v4l2_renderer_output_create,
+	.output_destroy = v4l2_renderer_output_destroy,
+	.set_output_buffer = v4l2_renderer_output_set_buffer
+};
diff --git a/libweston/v4l2-renderer.h b/libweston/v4l2-renderer.h
new file mode 100644
index 0000000..8445bf1
--- /dev/null
+++ b/libweston/v4l2-renderer.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright © 2014 Renesas Electronics Corp.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *	Takanari Hayama <taki@igel.co.jp>
+ */
+
+#include "config.h"
+
+#include "compositor.h"
+
+struct v4l2_bo_state {
+	int dmafd;
+	void *map;
+	uint32_t stride;
+};
+
+struct v4l2_renderer_interface {
+	int (*init)(struct weston_compositor *ec, int drm_fd, char *drm_fn);
+	int (*output_create)(struct weston_output *output, struct v4l2_bo_state *bo_states, int count);
+	void (*output_destroy)(struct weston_output *output);
+	void (*set_output_buffer)(struct weston_output *output, int bo_index);
+};
diff --git a/libweston/vsp-renderer.c b/libweston/vsp-renderer.c
new file mode 100644
index 0000000..2515302
--- /dev/null
+++ b/libweston/vsp-renderer.c
@@ -0,0 +1,1184 @@
+/*
+ * Copyright © 2014 Renesas Electronics Corp.
+ *
+ * Based on pixman-renderer by:
+ * Copyright © 2012 Intel Corporation
+ * Copyright © 2013 Vasily Khoruzhick <anarsoul@gmail.com>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *	Takanari Hayama <taki@igel.co.jp>
+ */
+
+#include "config.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include <linux/videodev2.h>
+#include <linux/v4l2-subdev.h>
+#include "v4l2-renderer.h"
+#include "v4l2-renderer-device.h"
+
+#include "libmediactl-v4l2/mediactl.h"
+#include "libmediactl-v4l2/mediactl-priv.h"
+#include "libmediactl-v4l2/v4l2subdev.h"
+#include "libmediactl-v4l2/tools.h"
+
+#include <linux/input.h>
+
+/* Required for a short term workaround */
+#include "v4l2-compat.h"
+
+#if 0
+#define DBG(...) weston_log(__VA_ARGS__)
+#define DBGC(...) weston_log_continue(__VA_ARGS__)
+#else
+#define DBG(...) do {} while (0)
+#define DBGC(...) do {} while (0)
+#endif
+
+struct vsp_surface_state {
+	struct v4l2_surface_state base;
+
+	struct v4l2_format fmt;
+	enum v4l2_mbus_pixelcode mbus_code;
+};
+
+struct vsp_renderer_output {
+	struct v4l2_renderer_output base;
+	struct vsp_surface_state surface_state;
+};
+
+#define VSP_INPUT_MAX	4
+#define VSP_SCALER_MAX	1
+#define VSP_SCALER_MIN_PIXELS	4	// UDS can't take pixels smaller than this
+
+const char *vsp_input_links[] = {
+	"'%s rpf.0':1 -> '%s bru':0",
+	"'%s rpf.1':1 -> '%s bru':1",
+	"'%s rpf.2':1 -> '%s bru':2",
+	"'%s rpf.3':1 -> '%s bru':3"
+};
+
+const char *vsp_output_links[] = {
+	"'%s bru':4 -> '%s wpf.0':0",
+	"'%s wpf.0':1 -> '%s wpf.0 output':0"
+};
+
+const char *vsp_inputs[] = {
+	"%s rpf.0 input",
+	"%s rpf.1 input",
+	"%s rpf.2 input",
+	"%s rpf.3 input"
+};
+
+const char *vsp_output = {
+	"%s wpf.0 output"
+};
+
+const char *vsp_input_infmt[] = {
+	"'%s rpf.0':0",
+	"'%s rpf.1':0",
+	"'%s rpf.2':0",
+	"'%s rpf.3':0"
+};
+
+const char *vsp_input_outfmt[] = {
+	"'%s rpf.0':1",
+	"'%s rpf.1':1",
+	"'%s rpf.2':1",
+	"'%s rpf.3':1"
+};
+
+const char *vsp_input_composer[] = {
+	"'%s bru':0",
+	"'%s bru':1",
+	"'%s bru':2",
+	"'%s bru':3"
+};
+
+const char *vsp_input_subdev[] = {
+	"%s rpf.0",
+	"%s rpf.1",
+	"%s rpf.2",
+	"%s rpf.3"
+};
+
+const char *vsp_output_fmt[] = {
+	"'%s bru':4",
+	"'%s wpf.0':0",
+	"'%s wpf.0':1"
+};
+
+const char *vsp_scaler_links[] = {
+	"'%s rpf.%d':1 -> '%s uds.%d':0",
+	"'%s uds.%d':1 -> '%s bru':%d"
+};
+
+const char *vsp_scaler_infmt = "'%s uds.%d':0";
+const char *vsp_scaler_outfmt = "'%s uds.%d':1";
+
+struct vsp_media_pad {
+	struct media_pad	*infmt_pad;
+	struct media_pad	*outfmt_pad;
+	struct media_pad	*compose_pad;
+	struct media_entity	*input_entity;
+
+	struct media_link	*link;
+
+	int			fd;
+};
+
+struct vsp_scaler_template {
+	struct media_link *link0;	// rpf -> uds
+	struct media_link *link1;	// uds -> bru
+};
+
+struct vsp_scaler {
+	int input;
+
+	struct media_pad	*infmt_pad;
+	struct media_pad	*outfmt_pad;
+
+	struct vsp_scaler_template	templates[VSP_INPUT_MAX];
+};
+
+struct vsp_output {
+	struct media_pad	*pads[ARRAY_SIZE(vsp_output_fmt)];
+};
+
+typedef enum {
+	VSP_STATE_IDLE,
+	VSP_STATE_START,
+	VSP_STATE_COMPOSING,
+} vsp_state_t;
+
+struct vsp_input {
+	struct vsp_media_pad input_pads;
+	struct vsp_surface_state *input_surface_states;
+	struct vsp_scaler *use_scaler;
+	struct v4l2_rect src;
+	struct v4l2_rect dst;
+	int opaque;
+};
+
+struct vsp_device {
+	struct v4l2_renderer_device base;
+
+	vsp_state_t state;
+
+	struct vsp_media_pad output_pad;
+	struct vsp_surface_state *output_surface_state;
+
+	int input_count;
+	int input_max;
+	struct vsp_input inputs[VSP_INPUT_MAX];
+
+	int scaler_count;
+	int scaler_max;
+	struct vsp_scaler scalers[VSP_SCALER_MAX];
+
+	struct vsp_output output;
+};
+
+const char *supported_devices[] = {
+		"fe928000.vsp1", "vsp2"
+
+};
+
+#ifdef V4L2_GL_FALLBACK
+static int max_views_to_compose = -1;
+#endif
+
+static void
+video_debug_mediactl(void)
+{
+	FILE *p = popen("media-ctl -d /dev/media0 -p", "r");
+	char buf[BUFSIZ * 16];
+
+	if (!p)
+		return;
+
+	weston_log("====== output of media-ctl ======\n");
+	while(!feof(p)) {
+		fread(buf, sizeof(buf), 1, p);
+		weston_log_continue(buf);
+	}
+	weston_log_continue("\n================================\n");
+
+	pclose(p);
+}
+
+static int
+video_is_capture(__u32 cap)
+{
+	return ((cap & V4L2_CAP_VIDEO_CAPTURE) || (cap & V4L2_CAP_VIDEO_CAPTURE_MPLANE));
+}
+
+static int
+video_is_mplane(__u32 cap)
+{
+	return ((cap & V4L2_CAP_VIDEO_CAPTURE_MPLANE) || (cap & V4L2_CAP_VIDEO_OUTPUT_MPLANE));
+}
+
+static int
+video_is_streaming(__u32 cap)
+{
+	return (cap & V4L2_CAP_STREAMING);
+}
+
+static void
+vsp_check_capabiility(int fd, const char *devname)
+{
+	struct v4l2_capability cap;
+	int ret;
+
+	memset(&cap, 0, sizeof cap);
+	ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
+	if (ret < 0) {
+		weston_log("VIDIOC_QUERY_CAP on %s failed.\n", devname);
+		return;
+	}
+
+	weston_log("Device `%s'(%d) is a video %s (%s mplane and %s streaming support)\n",
+		   devname, fd,
+		   (video_is_capture(cap.device_caps) ? "capture" : "output"),
+		   (video_is_mplane(cap.device_caps) ? "w/" : "w/o"),
+		   (video_is_streaming(cap.device_caps) ? "w/" : "w/o"));
+}
+
+static struct v4l2_renderer_device*
+vsp_init(struct media_device *media, struct weston_config *config)
+{
+	struct vsp_device *vsp = NULL;
+	struct media_link *link;
+	struct media_entity *entity;
+	const struct media_device_info *info;
+	char buf[64], *p, *endp;
+	const char *device_name, *devname;
+	int i, j, res;
+	struct weston_config_section *section;
+
+	/* Get device name */
+	info = media_get_info(media);
+	if ((p = strchr(info->bus_info, ':')))
+		device_name = p + 1;
+	else
+		device_name = info->bus_info;
+
+	res = 0;
+	for(i=0; i<(sizeof(supported_devices)/sizeof(*supported_devices)); i++){
+		if (!strncmp(device_name, supported_devices[i], strlen(supported_devices[i]))) {
+			res = 1;
+			break;
+		}
+		weston_log("Dev name (%d) %s. Supported %s\n", i, device_name, supported_devices[i]);
+	}
+	if (!res)
+		goto error;
+
+	weston_log("Using the device %s\n", device_name);
+
+	vsp = calloc(1, sizeof(struct vsp_device));
+	if (!vsp)
+		goto error;
+	vsp->base.media = media;
+	vsp->base.device_name = device_name;
+	vsp->state = VSP_STATE_IDLE;
+	vsp->scaler_max = VSP_SCALER_MAX;
+
+	/* check configuration */
+	section = weston_config_get_section(config,
+					    "vsp-renderer", NULL, NULL);
+	weston_config_section_get_int(section, "max_inputs", &vsp->input_max, VSP_INPUT_MAX);
+#ifdef V4L2_GL_FALLBACK
+	weston_config_section_get_int(section, "max_views_to_compose", &max_views_to_compose, -1);
+#endif
+
+	if (vsp->input_max < 2)
+		vsp->input_max = 2;
+	if (vsp->input_max > VSP_INPUT_MAX)
+		vsp->input_max = VSP_INPUT_MAX;
+
+	/* Reset links */
+	if (media_reset_links(media)) {
+		weston_log("Reset media controller links failed.\n");
+		goto error;
+	}
+
+	/* Initialize inputs */
+	weston_log("Setting up inputs. Use %d inputs.\n", vsp->input_max);
+	for (i = 0; i < vsp->input_max; i++) {
+		struct vsp_media_pad *pads = &vsp->inputs[i].input_pads;
+
+		/* setup a link - do not enable yet */
+		snprintf(buf, sizeof(buf), vsp_input_links[i], device_name, device_name);
+		weston_log("setting up link: '%s'\n", buf);
+		link = media_parse_link(media, buf, &endp);
+		if (media_setup_link(media, link->source, link->sink, 0)) {
+			weston_log("link set up failed.\n");
+			goto error;
+		}
+		pads->link = link;
+
+		/* get a pad to configure the compositor */
+		snprintf(buf, sizeof(buf), vsp_input_infmt[i], device_name);
+		weston_log("get an input pad: '%s'\n", buf);
+		if (!(pads->infmt_pad = media_parse_pad(media, buf, NULL))) {
+			weston_log("parse pad failed.\n");
+			goto error;
+		}
+
+		snprintf(buf, sizeof(buf), vsp_input_outfmt[i], device_name);
+		weston_log("get an input sink: '%s'\n", buf);
+		if (!(pads->outfmt_pad = media_parse_pad(media, buf, NULL))) {
+			weston_log("parse pad failed.\n");
+			goto error;
+		}
+
+		snprintf(buf, sizeof(buf), vsp_input_composer[i], device_name);
+		weston_log("get a composer pad: '%s'\n", buf);
+		if (!(pads->compose_pad = media_parse_pad(media, buf, NULL))) {
+			weston_log("parse pad failed.\n");
+			goto error;
+		}
+
+		snprintf(buf, sizeof(buf), vsp_input_subdev[i], device_name);
+		weston_log("get a input subdev pad: '%s'\n", buf);
+		if (!(pads->input_entity = media_get_entity_by_name(media, buf, strlen(buf)))) {
+			weston_log("parse entity failed.\n");
+			goto error;
+		}
+
+		/* get a file descriptor for the input */
+		snprintf(buf, sizeof(buf), vsp_inputs[i], device_name);
+		entity = media_get_entity_by_name(media, buf, strlen(buf));
+		if (!entity) {
+			weston_log("error... '%s' not found.\n", buf);
+			goto error;
+		}
+
+		if (v4l2_subdev_open(entity)) {
+			weston_log("subdev '%s' open failed\n.", buf);
+			goto error;
+		}
+
+		pads->fd = entity->fd;
+		vsp_check_capabiility(pads->fd, media_entity_get_devname(entity));
+
+		/* set an input format for BRU to be ARGB (default) */
+		{
+			struct v4l2_mbus_framefmt format = {
+				.width = 256,		// a random number
+				.height = 256,		// a random number
+				.code = V4L2_MBUS_FMT_ARGB8888_1X32
+			};
+
+			if (v4l2_subdev_set_format(pads->compose_pad->entity, &format,
+						   pads->compose_pad->index,
+					           V4L2_SUBDEV_FORMAT_ACTIVE)) {
+				weston_log("setting default failed.\n");
+				goto error;
+			}
+
+			if (format.code != V4L2_MBUS_FMT_ARGB8888_1X32) {
+				weston_log("couldn't set to ARGB.\n");
+				goto error;
+			}
+		}
+	}
+
+	/* Initialize scaler */
+	weston_log("Setting up scaler(s).\n");
+	for (i = 0; i < vsp->scaler_max; i++) {
+		/* create link templates */
+		for (j = 0; j < vsp->input_max; j++) {
+			snprintf(buf, sizeof(buf), vsp_scaler_links[0], device_name, j, device_name, i);
+			weston_log("parsing link: '%s'\n", buf);
+			vsp->scalers[i].templates[j].link0 = media_parse_link(media, buf, &endp);
+
+			snprintf(buf, sizeof(buf), vsp_scaler_links[1], device_name, i, device_name, j);
+			weston_log("parsing link: '%s'\n", buf);
+			vsp->scalers[i].templates[j].link1 = media_parse_link(media, buf, &endp);
+		}
+
+		/* get pads to setup UDS */
+		snprintf(buf, sizeof(buf), vsp_scaler_infmt, device_name, i);
+		weston_log("get a scaler input pad: '%s'\n", buf);
+		if (!(vsp->scalers[i].infmt_pad = media_parse_pad(media, buf, NULL))) {
+			weston_log("parse pad failed.\n");
+			goto error;
+		}
+
+		snprintf(buf, sizeof(buf), vsp_scaler_outfmt, device_name, i);
+		weston_log("get a scaler output pad: '%s'\n", buf);
+		if (!(vsp->scalers[i].outfmt_pad = media_parse_pad(media, buf, NULL))) {
+			weston_log("parse pad failed.\n");
+			goto error;
+		}
+
+		/* initialize input */
+		vsp->scalers[i].input = -1;
+	}
+
+	/* Initialize output */
+	weston_log("Setting up an output.\n");
+
+	/* setup links for output - always on */
+	for (i = 0; i < (int)ARRAY_SIZE(vsp_output_links); i++) {
+		snprintf(buf, sizeof(buf), vsp_output_links[i], device_name, device_name);
+		weston_log("setting up link: '%s'\n", buf);
+		link = media_parse_link(media, buf, &endp);
+		if (media_setup_link(media, link->source, link->sink, 1)) {
+			weston_log("link set up failed.\n");
+			goto error;
+		}
+	}
+
+	/* get pads for output */
+	for (i = 0; i < (int)ARRAY_SIZE(vsp_output_fmt); i++) {
+		snprintf(buf, sizeof(buf), vsp_output_fmt[i], device_name);
+		weston_log("get an output pad: '%s'\n", buf);
+		if (!(vsp->output.pads[i] = media_parse_pad(media, buf, NULL))) {
+			weston_log("parse pad failed.\n");
+			goto error;
+		}
+	}
+
+	/* get a file descriptor for the output */
+	snprintf(buf, sizeof(buf), vsp_output, device_name);
+	entity = media_get_entity_by_name(media, buf, strlen(buf));
+	if (!entity) {
+		weston_log("error... '%s' not found.\n", buf);
+		goto error;
+	}
+
+	devname = media_entity_get_devname(entity);
+	weston_log("output '%s' is associated with '%s'\n", buf, devname);
+	vsp->output_pad.fd = open(devname, O_RDWR);
+	if (vsp->output_pad.fd < 0) {
+		weston_log("error... can't open '%s'.\n", devname);
+		goto error;
+	}
+	vsp_check_capabiility(vsp->output_pad.fd, devname);
+
+	return (struct v4l2_renderer_device*)vsp;
+
+error:
+	if (vsp)
+		free(vsp);
+	weston_log("VSP device init failed...\n");
+
+	return NULL;
+}
+
+static struct v4l2_surface_state*
+vsp_create_surface(struct v4l2_renderer_device *dev)
+{
+	return (struct v4l2_surface_state*)calloc(1, sizeof(struct vsp_surface_state));
+}
+
+static int
+vsp_attach_buffer(struct v4l2_surface_state *surface_state)
+{
+	struct vsp_surface_state *vs = (struct vsp_surface_state*)surface_state;
+	enum v4l2_mbus_pixelcode code;
+	int i;
+
+	if (vs->base.width > 8190 || vs->base.height > 8190)
+		return -1;
+
+	switch(vs->base.pixel_format) {
+	case V4L2_PIX_FMT_XRGB32:
+	case V4L2_PIX_FMT_ARGB32:
+	case V4L2_PIX_FMT_XBGR32:
+	case V4L2_PIX_FMT_ABGR32:
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_BGR24:
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_RGB332:
+		code = V4L2_MBUS_FMT_ARGB8888_1X32;
+		break;
+
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_NV12M:
+	case V4L2_PIX_FMT_NV21M:
+	case V4L2_PIX_FMT_NV16M:
+	case V4L2_PIX_FMT_NV61M:
+	case V4L2_PIX_FMT_YUV420M:
+		code = V4L2_MBUS_FMT_AYUV8_1X32;
+		break;
+
+	default:
+		return -1;
+	}
+
+	// create v4l2_fmt to use later
+	vs->mbus_code = code;
+	vs->fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	vs->fmt.fmt.pix_mp.width = vs->base.width;
+	vs->fmt.fmt.pix_mp.height = vs->base.height;
+	vs->fmt.fmt.pix_mp.pixelformat = vs->base.pixel_format;
+	vs->fmt.fmt.pix_mp.field = V4L2_FIELD_ANY;
+	vs->fmt.fmt.pix_mp.num_planes = vs->base.num_planes;
+
+	for (i = 0; i < vs->base.num_planes; i++)
+		vs->fmt.fmt.pix_mp.plane_fmt[i].bytesperline = vs->base.planes[i].stride;
+
+	return 0;
+}
+
+static int
+vsp_set_format(int fd, struct v4l2_format *fmt, int opaque)
+{
+	struct v4l2_format current_fmt;
+	int ret;
+	unsigned int original_pixelformat = fmt->fmt.pix_mp.pixelformat;
+
+	memset(&current_fmt, 0, sizeof(struct v4l2_format));
+	current_fmt.type = fmt->type;
+
+
+	if (ioctl(fd, VIDIOC_G_FMT, &current_fmt) == -1) {
+		weston_log("VIDIOC_G_FMT failed to %d (%s).\n", fd, strerror(errno));
+	}
+
+	DBG("Current video format: %d, %08x(%c%c%c%c) %ux%u (stride %u) field %08u buffer size %u\n",
+	    current_fmt.type,
+	    current_fmt.fmt.pix_mp.pixelformat,
+	    (current_fmt.fmt.pix_mp.pixelformat >> 24) & 0xff,
+	    (current_fmt.fmt.pix_mp.pixelformat >> 16) & 0xff,
+	    (current_fmt.fmt.pix_mp.pixelformat >>  8) & 0xff,
+	    current_fmt.fmt.pix_mp.pixelformat & 0xff,
+	    current_fmt.fmt.pix_mp.width, current_fmt.fmt.pix_mp.height, current_fmt.fmt.pix_mp.plane_fmt[0].bytesperline,
+	    current_fmt.fmt.pix_mp.field,
+	    current_fmt.fmt.pix_mp.plane_fmt[0].sizeimage);
+
+	switch (original_pixelformat) {
+	case V4L2_PIX_FMT_ABGR32:
+		if (opaque)
+			fmt->fmt.pix_mp.pixelformat = V4L2_PIX_FMT_XBGR32;
+		else
+			/* ABGR32 surfaces are premultiplied. */
+			fmt->fmt.pix_mp.flags = V4L2_PIX_FMT_FLAG_PREMUL_ALPHA;
+	}
+
+	ret = ioctl(fd, VIDIOC_S_FMT, fmt);
+
+	DBG("New video format: %d, %08x(%c%c%c%c) %ux%u (stride %u) field %08u buffer size %u\n",
+	    fmt->type,
+	    fmt->fmt.pix_mp.pixelformat,
+	    (fmt->fmt.pix_mp.pixelformat >> 24) & 0xff,
+	    (fmt->fmt.pix_mp.pixelformat >> 16) & 0xff,
+	    (fmt->fmt.pix_mp.pixelformat >>  8) & 0xff,
+	    fmt->fmt.pix_mp.pixelformat & 0xff,
+	    fmt->fmt.pix_mp.width, fmt->fmt.pix_mp.height, fmt->fmt.pix_mp.plane_fmt[0].bytesperline,
+	    fmt->fmt.pix_mp.field,
+	    fmt->fmt.pix_mp.plane_fmt[0].sizeimage);
+
+	fmt->fmt.pix_mp.pixelformat = original_pixelformat;
+
+	if (ret == -1) {
+		weston_log("VIDIOC_S_FMT failed to %d (%s).\n", fd, strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+vsp_set_output(struct vsp_device *vsp, struct vsp_renderer_output *out)
+{
+	int i;
+	struct v4l2_mbus_framefmt format;
+
+	DBG("Setting output size to %dx%d\n", out->base.width, out->base.height);
+
+	/* set WPF output size  */
+	format.width  = out->base.width;
+	format.height = out->base.height;
+	format.code   = V4L2_MBUS_FMT_ARGB8888_1X32;	// TODO: does this have to be flexible?
+
+	for (i = 0; i < (int)ARRAY_SIZE(vsp->output.pads); i++) {
+		struct media_pad *pad = vsp->output.pads[i];
+		if (v4l2_subdev_set_format(pad->entity, &format, pad->index, V4L2_SUBDEV_FORMAT_ACTIVE)) {
+			weston_log("set sbudev format for failed at index %d.\n", i);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static struct v4l2_renderer_output*
+vsp_create_output(struct v4l2_renderer_device *dev, int width, int height)
+{
+	//struct vsp_device *vsp = (struct vsp_device*)dev;
+	struct vsp_renderer_output *outdev;
+	struct v4l2_format *fmt;
+
+	outdev = calloc(1, sizeof(struct vsp_renderer_output));
+	if (!outdev)
+		return NULL;
+
+	/* set output surface state */
+	outdev->base.width = width;
+	outdev->base.height = height;
+	outdev->surface_state.mbus_code = V4L2_MBUS_FMT_ARGB8888_1X32;
+	outdev->surface_state.base.width = width;
+	outdev->surface_state.base.height = height;
+	outdev->surface_state.base.num_planes = 1;
+	outdev->surface_state.base.src_rect.width = width;
+	outdev->surface_state.base.src_rect.height = height;
+	outdev->surface_state.base.dst_rect.width = width;
+	outdev->surface_state.base.dst_rect.height = height;
+
+	/* we use this later to let output to be input for composition */
+	fmt = &outdev->surface_state.fmt;
+	fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	fmt->fmt.pix_mp.width = width;
+	fmt->fmt.pix_mp.height = height;
+	fmt->fmt.pix_mp.pixelformat = V4L2_PIX_FMT_ABGR32;
+	fmt->fmt.pix_mp.num_planes = 1;
+
+	return (struct v4l2_renderer_output*)outdev;
+}
+
+static int
+vsp_dequeue_buffer(int fd, int capture)
+{
+	struct v4l2_buffer buf;
+	struct v4l2_plane planes[VIDEO_MAX_PLANES];
+
+	memset(&buf, 0, sizeof buf);
+	buf.type = (capture) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	buf.memory = V4L2_MEMORY_DMABUF;
+	buf.index = 0;
+	buf.m.planes = planes;
+	buf.length = 1;
+	memset(planes, 0, sizeof(planes));
+
+	if (ioctl(fd, VIDIOC_DQBUF, &buf) == -1) {
+		weston_log("VIDIOC_DQBUF failed on %d (%s).\n", fd, strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+vsp_queue_buffer(int fd, int capture, struct vsp_surface_state *vs)
+{
+	struct v4l2_buffer buf;
+	struct v4l2_plane planes[VIDEO_MAX_PLANES];
+	int i;
+
+	memset(&buf, 0, sizeof buf);
+	buf.type = (capture) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	buf.memory = V4L2_MEMORY_DMABUF;
+	buf.index = 0;
+	buf.m.planes = planes;
+	buf.length = vs->base.num_planes;
+	memset(planes, 0, sizeof(planes));
+	for (i = 0; i < vs->base.num_planes; i++)
+		buf.m.planes[i].m.fd = vs->base.planes[i].dmafd;
+
+	if (ioctl(fd, VIDIOC_QBUF, &buf) == -1) {
+		weston_log("VIDIOC_QBUF failed for dmafd=%d(%d planes) on %d (%s).\n",
+			   vs->base.planes[i].dmafd, vs->base.num_planes, fd, strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+vsp_request_buffer(int fd, int capture, int count)
+{
+	struct v4l2_requestbuffers reqbuf;
+
+	memset(&reqbuf, 0, sizeof(reqbuf));
+	reqbuf.type = (capture) ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE : V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	reqbuf.memory = V4L2_MEMORY_DMABUF;
+	reqbuf.count = count;
+	if (ioctl(fd, VIDIOC_REQBUFS, &reqbuf) == -1) {
+		weston_log("clearing VIDIOC_REQBUFS failed (%s).\n", strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static void
+vsp_comp_begin(struct v4l2_renderer_device *dev, struct v4l2_renderer_output *out)
+{
+	struct vsp_device *vsp = (struct vsp_device*)dev;
+	struct vsp_renderer_output *output = (struct vsp_renderer_output*)out;
+	struct v4l2_format *fmt = &output->surface_state.fmt;
+
+	DBG("start vsp composition.\n");
+
+	vsp->state = VSP_STATE_START;
+
+	vsp_set_output(vsp, output);
+
+	// just in case
+	vsp_request_buffer(vsp->output_pad.fd, 1, 0);
+
+	fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	vsp_set_format(vsp->output_pad.fd, fmt, 0);
+	fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+
+	vsp->output_surface_state = &output->surface_state;
+
+	vsp_request_buffer(vsp->output_pad.fd, 1, 1);
+
+	DBG("output set to dmabuf=%d\n", vsp->output_surface_state->base.planes[0].dmafd);
+}
+
+static int
+vsp_set_alpha(struct media_entity *entity, float alpha)
+{
+	struct v4l2_control ctrl;
+
+	ctrl.id = V4L2_CID_ALPHA_COMPONENT;
+	ctrl.value = (__s32)(alpha * 0xff);
+
+	if (ioctl(entity->fd, VIDIOC_S_CTRL, &ctrl) == -1) {
+		weston_log("failed to set alpha value (%d)\n", ctrl.value);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+vsp_comp_setup_inputs(struct vsp_device *vsp, struct vsp_input *input, int enable)
+{
+	struct v4l2_mbus_framefmt format;
+	struct vsp_media_pad *mpad = &input->input_pads;
+	struct vsp_scaler *scaler = input->use_scaler;
+	struct vsp_surface_state *vs = input->input_surface_states;
+	struct v4l2_rect *src = &input->src;
+	struct v4l2_rect *dst = &input->dst;
+
+	// enable link associated with this pad
+	if (!scaler) {
+		if (media_setup_link(vsp->base.media, mpad->link->source, mpad->link->sink, enable)) {
+			weston_log("enabling media link setup failed.\n");
+			return -1;
+		}
+	} else {
+		struct vsp_scaler_template *temp = &scaler->templates[scaler->input];
+
+		if (enable)
+			media_setup_link(vsp->base.media, mpad->link->source, mpad->link->sink, 0);
+
+		if (media_setup_link(vsp->base.media, temp->link0->source, temp->link0->sink, enable)) {
+			weston_log("enabling scaler link0 setup failed.\n");
+			return -1;
+		}
+
+		if (media_setup_link(vsp->base.media, temp->link1->source, temp->link1->sink, enable)) {
+			weston_log("enabling scaler link1 setup failed.\n");
+			return -1;
+		}
+	}
+
+	if (!enable)
+		return 0;
+
+	// set pixel format and size
+	format.width = vs->base.width;
+	format.height = vs->base.height;
+	format.code = vs->mbus_code;	// this is input format
+	if (v4l2_subdev_set_format(mpad->infmt_pad->entity, &format, mpad->infmt_pad->index,
+				   V4L2_SUBDEV_FORMAT_ACTIVE)) {
+		weston_log("set input format via subdev failed.\n");
+		return -1;
+	}
+
+	// set an alpha
+	if (vsp_set_alpha(mpad->input_entity, vs->base.alpha)) {
+		weston_log("setting alpha (=%f) failed.", vs->base.alpha);
+		return -1;
+	}
+
+	// set a crop paramters
+	if (v4l2_subdev_set_selection(mpad->infmt_pad->entity, src, mpad->infmt_pad->index,
+				      V4L2_SEL_TGT_CROP, V4L2_SUBDEV_FORMAT_ACTIVE)) {
+		weston_log("set crop parameter failed: %dx%d@(%d,%d).\n",
+			   src->width, src->height, src->left, src->top);
+		return -1;
+	}
+	format.width = src->width;
+	format.height = src->height;
+
+	// this is an output towards BRU. this shall be consistent among all inputs.
+	format.code = V4L2_MBUS_FMT_ARGB8888_1X32;
+	if (v4l2_subdev_set_format(mpad->outfmt_pad->entity, &format, mpad->outfmt_pad->index,
+				   V4L2_SUBDEV_FORMAT_ACTIVE)) {
+		weston_log("set output format via subdev failed.\n");
+		return -1;
+	}
+
+	// if we enabled the scaler, we should set resize parameters.
+	if (scaler) {
+		// a sink of UDS should be the same as a source of RPF.
+		if (v4l2_subdev_set_format(scaler->infmt_pad->entity, &format, scaler->infmt_pad->index,
+					   V4L2_SUBDEV_FORMAT_ACTIVE)) {
+			weston_log("set input format of UDS via subdev failed.\n");
+			return -1;
+		}
+
+		// a source of UDS should be the same as a sink of BRU.
+		format.width  = dst->width;
+		format.height = dst->height;
+		if (v4l2_subdev_set_format(scaler->outfmt_pad->entity, &format, scaler->outfmt_pad->index,
+					   V4L2_SUBDEV_FORMAT_ACTIVE)) {
+			weston_log("set output format of UDS via subdev failed.\n");
+			return -1;
+		}
+	}
+
+	// so does the BRU input
+	if (v4l2_subdev_set_format(mpad->compose_pad->entity, &format, mpad->compose_pad->index,
+				   V4L2_SUBDEV_FORMAT_ACTIVE)) {
+		weston_log("set composition format via subdev failed.\n");
+		return -1;
+	}
+
+	// set a composition paramters
+	if (v4l2_subdev_set_selection(mpad->compose_pad->entity, dst, mpad->compose_pad->index,
+				      V4L2_SEL_TGT_COMPOSE, V4L2_SUBDEV_FORMAT_ACTIVE)) {
+		weston_log("set compose parameter failed: %dx%d@(%d,%d).\n",
+			   dst->width, dst->height, dst->left, dst->top);
+		return -1;
+	}
+
+	// just in case
+	if (vsp_request_buffer(mpad->fd, 0, 0) < 0)
+		return -1;
+
+	// set input format
+	if (vsp_set_format(mpad->fd, &vs->fmt, input->opaque))
+		return -1;
+
+	// request a buffer
+	if (vsp_request_buffer(mpad->fd, 0, 1) < 0)
+		return -1;
+
+	// queue buffer
+	if (vsp_queue_buffer(mpad->fd, 0, vs) < 0)
+		return -1;
+
+	return 0;
+}
+
+static int
+vsp_comp_flush(struct vsp_device *vsp)
+{
+	int i, fd;
+	int type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+
+	DBG("flush vsp composition.\n");
+
+	// enable links and queue buffer
+	for (i = 0; i < vsp->input_count; i++) {
+		if (vsp_comp_setup_inputs(vsp, &vsp->inputs[i], 1) < 0) {
+			weston_log("Setup used input failed!\n");
+			goto error;
+		}
+	}
+
+	// disable unused inputs
+	for (i = vsp->input_count; i < vsp->input_max; i++)
+		vsp_comp_setup_inputs(vsp, &vsp->inputs[i], 0);
+
+	// get an output pad
+	fd = vsp->output_pad.fd;
+
+	// queue buffer
+	if (vsp_queue_buffer(fd, 1, vsp->output_surface_state) < 0)
+		goto error;
+
+//	video_debug_mediactl();
+
+	// stream on
+	type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	for (i = 0; i < vsp->input_count; i++) {
+		if (ioctl(vsp->inputs[i].input_pads.fd, VIDIOC_STREAMON, &type) == -1) {
+			weston_log("VIDIOC_STREAMON failed for input %d. (%s)\n", i, strerror(errno));
+		}
+	}
+
+	type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	if (ioctl(fd, VIDIOC_STREAMON, &type) == -1) {
+		weston_log("VIDIOC_STREAMON failed for output (%s).\n", strerror(errno));
+		goto error;
+	}
+
+	// dequeue buffer
+	if (vsp_dequeue_buffer(fd, 1) < 0)
+		goto error;
+
+	type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	if (ioctl(fd, VIDIOC_STREAMOFF, &type) == -1) {
+		weston_log("%s: VIDIOC_STREAMOFF failed on %d (%s).\n", __func__, fd, strerror(errno));
+		goto error;
+	}
+
+	// stream off
+	type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	for (i = 0; i < vsp->input_count; i++) {
+		if (ioctl(vsp->inputs[i].input_pads.fd, VIDIOC_STREAMOFF, &type) == -1) {
+			weston_log("VIDIOC_STREAMOFF failed for input %d.\n", i);
+		}
+	}
+
+	// disable UDS if used
+	if (vsp->scaler_count) {
+		for (i = 0; i < vsp->input_count; i++) {
+			struct vsp_input *input = &vsp->inputs[i];
+			if (input->use_scaler) {
+				vsp_comp_setup_inputs(vsp, input, 0);
+				input->use_scaler->input = -1;
+				input->use_scaler = NULL;
+			}
+		}
+		vsp->scaler_count = 0;
+	}
+	vsp->input_count = 0;
+	return 0;
+
+error:
+	video_debug_mediactl();
+	vsp->input_count = 0;
+	return -1;
+}
+
+static void
+vsp_comp_finish(struct v4l2_renderer_device *dev)
+{
+	struct vsp_device *vsp = (struct vsp_device*)dev;
+
+	if (vsp->input_count > 0)
+		vsp_comp_flush(vsp);
+
+	vsp->state = VSP_STATE_IDLE;
+	DBG("complete vsp composition.\n");
+	vsp->output_surface_state = NULL;
+}
+
+#define IS_IDENTICAL_RECT(a, b) ((a)->width == (b)->width && (a)->height == (b)->height && \
+				 (a)->left  == (b)->left  && (a)->top    == (b)->top)
+
+static int
+vsp_do_draw_view(struct vsp_device *vsp, struct vsp_surface_state *vs, struct v4l2_rect *src, struct v4l2_rect *dst,
+		 int opaque)
+{
+	int should_use_scaler = 0;
+	struct vsp_input *input;
+
+	if (src->width < 1 || src->height < 1) {
+		DBG("ignoring the size of zeros < (%dx%d)\n", src->width, src->height);
+		return 0;
+	}
+
+	if (src->width > 8190 || src->height > 8190) {
+		weston_log("ignoring the size exceeding the limit (8190x8190) < (%dx%d)\n", src->width, src->height);
+		return 0;
+	}
+
+	if (dst->width != src->width || dst->height != src->height) {
+		if (src->width < VSP_SCALER_MIN_PIXELS || src->height < VSP_SCALER_MIN_PIXELS) {
+			weston_log("ignoring the size the scaler can't handle (input size=%dx%d).\n",
+				   src->width, src->height);
+			return 0;
+		}
+		should_use_scaler = 1;
+	}
+
+	if (src->left < 0) {
+		src->width += src->left;
+		src->left = 0;
+	}
+
+	if (src->top < 0) {
+		src->height += src->top;
+		src->top = 0;
+	}
+
+	DBG("set input %d (dmafd=%d): %dx%d@(%d,%d)->%dx%d@(%d,%d). alpha=%f\n",
+	    vsp->input_count,
+	    vs->base.planes[0].dmafd,
+	    src->width, src->height, src->left, src->top,
+	    dst->width, dst->height, dst->left, dst->top,
+	    vs->base.alpha);
+
+	switch(vsp->state) {
+	case VSP_STATE_START:
+		DBG("VSP_STATE_START -> COMPSOING\n");
+		vsp->state = VSP_STATE_COMPOSING;
+		break;
+
+	case VSP_STATE_COMPOSING:
+		if (vsp->input_count == 0) {
+			DBG("VSP_STATE_COMPOSING -> START (compose with output)\n");
+			vsp->state = VSP_STATE_START;
+			if (vsp_do_draw_view(vsp, vsp->output_surface_state,
+					     &vsp->output_surface_state->base.src_rect,
+					     &vsp->output_surface_state->base.dst_rect, 0) < 0)
+				return -1;
+		}
+		break;
+
+	default:
+		weston_log("unknown state... %d\n", vsp->state);
+		return -1;
+	}
+
+	input = &vsp->inputs[vsp->input_count];
+
+	/* check if we need to use a scaler */
+	if (should_use_scaler) {
+		DBG("We need to use a scaler. (%dx%d)->(%dx%d)\n",
+		    src->width, src->height, dst->width, dst->height);
+
+		// if all scalers are oocupied, flush and then retry.
+		if (vsp->scaler_count == vsp->scaler_max) {
+			vsp_comp_flush(vsp);
+			return vsp_do_draw_view(vsp, vs, src, dst, opaque);
+		}
+
+		vsp->scalers[vsp->scaler_count].input = vsp->input_count;
+		input->use_scaler = &vsp->scalers[vsp->scaler_count];
+		vsp->scaler_count++;
+	}
+
+	// get an available input pad
+	input->input_surface_states = vs;
+	input->src = *src;
+	input->dst = *dst;
+	input->opaque = opaque;
+
+	// check if we should flush now
+	vsp->input_count++;
+	if (vsp->input_count == vsp->input_max)
+		vsp_comp_flush(vsp);
+
+	return 0;
+}
+
+static int
+vsp_comp_draw_view(struct v4l2_renderer_device *dev, struct v4l2_surface_state *surface_state)
+{
+	struct vsp_device *vsp = (struct vsp_device*)dev;
+	struct vsp_surface_state *vs = (struct vsp_surface_state*)surface_state;
+
+	DBG("start rendering a view.\n");
+	if (!IS_IDENTICAL_RECT(&surface_state->dst_rect, &surface_state->opaque_dst_rect)) {
+		DBG("rendering non-opaque region.\n");
+		if (vsp_do_draw_view(vsp, vs, &surface_state->src_rect, &surface_state->dst_rect, 0) < 0)
+			return -1;
+	}
+
+	DBG("rendering opaque region if available.\n");
+	if (vsp_do_draw_view(vsp, vs, &surface_state->opaque_src_rect, &surface_state->opaque_dst_rect, 1) < 0)
+		return -1;
+
+	return 0;
+}
+
+static void
+vsp_set_output_buffer(struct v4l2_renderer_output *out, struct v4l2_bo_state *bo)
+{
+	struct vsp_renderer_output *output = (struct vsp_renderer_output*)out;
+	DBG("set output dmafd to %d\n", bo->dmafd);
+	output->surface_state.base.planes[0].dmafd = bo->dmafd;
+	output->surface_state.fmt.fmt.pix_mp.plane_fmt[0].bytesperline = bo->stride;
+}
+
+#ifdef V4L2_GL_FALLBACK
+static int
+vsp_can_compose(struct v4l2_view *view_list, int count)
+{
+	pixman_region32_t surface_blend;
+	int i, can_compose = 1;
+
+	if (max_views_to_compose > 0 && max_views_to_compose < count) {
+		can_compose = 0;
+		goto out;
+	}
+
+	for (i = 0; (can_compose) && (i < count); i++) {
+		struct weston_view *ev = view_list[i].view;
+		struct v4l2_surface_state *vs = view_list[i].state;
+
+		if (vs->pixel_format == V4L2_PIX_FMT_ABGR32 && ev->alpha != 1.0) {
+			pixman_region32_init_rect(&surface_blend, 0, 0,
+						  ev->surface->width, ev->surface->height);
+			pixman_region32_subtract(&surface_blend, &surface_blend, &ev->surface->opaque);
+
+			if (pixman_region32_not_empty(&surface_blend))
+				can_compose = 0;
+
+			pixman_region32_fini(&surface_blend);
+		}
+	}
+
+out:
+	return can_compose;
+}
+#endif
+
+static uint32_t
+vsp_get_capabilities(void)
+{
+	return 0;
+}
+
+WL_EXPORT struct v4l2_device_interface v4l2_device_interface = {
+	.init = vsp_init,
+
+	.create_output = vsp_create_output,
+	.set_output_buffer = vsp_set_output_buffer,
+
+	.create_surface = vsp_create_surface,
+	.attach_buffer = vsp_attach_buffer,
+
+	.begin_compose = vsp_comp_begin,
+	.finish_compose = vsp_comp_finish,
+	.draw_view = vsp_comp_draw_view,
+
+#ifdef V4L2_GL_FALLBACK
+	.can_compose = vsp_can_compose,
+#endif
+
+	.get_capabilities = vsp_get_capabilities,
+};
--
1.9.1
